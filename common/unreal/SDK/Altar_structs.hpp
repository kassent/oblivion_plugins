#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Altar

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "UE5AltarPairing_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "InputCore_structs.hpp"
#include "SlateCore_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Enum Altar.EVFadeTransitionType
// NumValues: 0x0004
enum class EVFadeTransitionType : uint32
{
	Interior                                 = 0,
	Seamless                                 = 1,
	FastTransiton                            = 2,
	EVFadeTransitionType_MAX                 = 3,
};

// Enum Altar.EVActorValues
// NumValues: 0x004B
enum class EVActorValues : uint8
{
	STRENGTH                                 = 0,
	INTELLIGENCE                             = 1,
	WILLPOWER                                = 2,
	AGILITY                                  = 3,
	SPEED                                    = 4,
	ENDURANCE                                = 5,
	PERSONALITY                              = 6,
	LUCK                                     = 7,
	HEALTH                                   = 8,
	MAGICKA                                  = 9,
	FATIGUE                                  = 10,
	ENCUMBRANCE                              = 11,
	ARMORER                                  = 12,
	ATHLETICS                                = 13,
	BLADE                                    = 14,
	BLOCK                                    = 15,
	BLUNT                                    = 16,
	HANDTOHAND                               = 17,
	HEAVYARMOR                               = 18,
	ALCHEMY                                  = 19,
	ALTERATION                               = 20,
	CONJURATION                              = 21,
	DESTRUCTION                              = 22,
	ILLUSION                                 = 23,
	MYSTICISM                                = 24,
	RESTORATION                              = 25,
	ACROBATICS                               = 26,
	LIGHTARMOR                               = 27,
	MARKSMAN                                 = 28,
	MERCANTILE                               = 29,
	SECURITY                                 = 30,
	SNEAK                                    = 31,
	SPEECHCRAFT                              = 32,
	AGGRESSION                               = 33,
	CONFIDENCE                               = 34,
	ENERGY                                   = 35,
	RESPONSIBILITY                           = 36,
	BOUNTY                                   = 37,
	FAME                                     = 38,
	INFAMY                                   = 39,
	MAGICKA_MULTIPLIER                       = 40,
	NIGHT_EYE_BONUS                          = 41,
	ATTACK_BONUS                             = 42,
	DEFEND_BONUS                             = 43,
	CASTING_PENALTY                          = 44,
	BLINDNESS                                = 45,
	CHAMELEON                                = 46,
	INVISIBILITY                             = 47,
	PARALYSIS                                = 48,
	SILENCE                                  = 49,
	CONFUSION                                = 50,
	DETECT_RANGE                             = 51,
	ABSORB_CHANCE                            = 52,
	REFLECT_CHANCE                           = 53,
	SWIM_SPEED_MULT                          = 54,
	WATER_BREATHING                          = 55,
	WATER_WALKING                            = 56,
	STUNTED_MAGICKA                          = 57,
	DETECT_LIFE_RANGE                        = 58,
	REFLECT_DAMAGE                           = 59,
	TELEKINESIS                              = 60,
	RESIST_FIRE                              = 61,
	RESIST_FROST                             = 62,
	RESIST_DISEASE                           = 63,
	RESIST_MAGIC                             = 64,
	RESIST_NORMAL_WEAPONS                    = 65,
	RESIST_PARALYSIS                         = 66,
	RESIST_POISON                            = 67,
	RESIST_SHOCK                             = 68,
	VAMPIRISM                                = 69,
	DARKNESS                                 = 70,
	RESIST_WATER_DAMAGE                      = 71,
	ACTOR_VALUE_COUNT                        = 72,
	ACTOR_VALUE_START                        = 0,
	EVActorValues_MAX                        = 73,
};

// Enum Altar.EOblivionAnimSection
// NumValues: 0x000A
enum class EOblivionAnimSection : uint8
{
	ANIM_SECTION_NONE                        = 0,
	ANIM_SECTION_LOWER_BODY                  = 1,
	ANIM_SECTION_LEFT_ARM                    = 2,
	ANIM_SECTION_LEFT_HAND                   = 3,
	ANIM_SECTION_RIGHT_ARM                   = 4,
	ANIM_SECTION_SPECIAL_IDLE                = 5,
	ANIM_SECTION_WHOLE_BODY                  = 6,
	ANIM_SECTION_UPPER_BODY                  = 7,
	ANIM_SECTION_TOTAL_COUNT                 = 8,
	ANIM_SECTION_MAX                         = 9,
};

// Enum Altar.EOblivionAnimGroup
// NumValues: 0x002D
enum class EOblivionAnimGroup : uint8
{
	IDLE                                     = 0,
	DYNAMIC_IDLE                             = 1,
	SPECIAL_IDLE                             = 2,
	MOVE_FORWARD                             = 3,
	MOVE_BACK                                = 4,
	MOVE_LEFT                                = 5,
	MOVE_RIGHT                               = 6,
	FAST_FORWARD                             = 7,
	FAST_BACK                                = 8,
	FAST_LEFT                                = 9,
	FAST_RIGHT                               = 10,
	DODGE_FORWARD                            = 11,
	DODGE_BACK                               = 12,
	DODGE_LEFT                               = 13,
	DODGE_RIGHT                              = 14,
	TURN_LEFT                                = 15,
	TURN_RIGHT                               = 16,
	EQUIP                                    = 17,
	UNEQUIP                                  = 18,
	ATTACK_BOW                               = 19,
	ATTACK_LEFT                              = 20,
	ATTACK_RIGHT                             = 21,
	ATTACK_NORMAL_POWER                      = 22,
	ATTACK_FORWARD_POWER                     = 23,
	ATTACK_BACK_POWER                        = 24,
	ATTACK_LEFT_POWER                        = 25,
	ATTACK_RIGHT_POWER                       = 26,
	BLOCK_IDLE                               = 27,
	BLOCK_HIT                                = 28,
	BLOCK_ATTACK                             = 29,
	RECOIL                                   = 30,
	STAGGER                                  = 31,
	DEATH                                    = 32,
	TORCH_IDLE                               = 33,
	CAST_SELF                                = 34,
	CAST_TOUCH                               = 35,
	CAST_TARGET                              = 36,
	CAST_SELF_ALT                            = 37,
	CAST_TOUCH_ALT                           = 38,
	CAST_TARGET_ALT                          = 39,
	JUMP_START                               = 40,
	JUMP_LOOP                                = 41,
	JUMP_LAND                                = 42,
	NONE                                     = 255,
	EOblivionAnimGroup_MAX                   = 256,
};

// Enum Altar.EVHUDBloodDropScreenPosition
// NumValues: 0x0005
enum class EVHUDBloodDropScreenPosition : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Top                                      = 2,
	Bottom                                   = 3,
	EVHUDBloodDropScreenPosition_MAX         = 4,
};

// Enum Altar.ENavigationInputAction
// NumValues: 0x0008
enum class ENavigationInputAction : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	Select                                   = 5,
	Cancel                                   = 6,
	ENavigationInputAction_MAX               = 7,
};

// Enum Altar.EVSenescenceModifiers
// NumValues: 0x0006
enum class EVSenescenceModifiers : uint32
{
	Sick                                     = 18446744073709551615,
	Healthy                                  = 0,
	Vampire_01                               = 1,
	Vampire_02                               = 2,
	Vampire_03                               = 3,
	EVSenescenceModifiers_MAX                = 4,
};

// Enum Altar.EVCharacterPhenotypeDataFilter
// NumValues: 0x0008
enum class EVCharacterPhenotypeDataFilter : uint8
{
	None                                     = 0,
	MorphTarget                              = 1,
	HairPiece                                = 2,
	Senescence                               = 4,
	SkinParameter                            = 8,
	ProceduralHead                           = 11,
	All                                      = 15,
	EVCharacterPhenotypeDataFilter_MAX       = 16,
};

// Enum Altar.EBipedModularBodySlot
// NumValues: 0x000C
enum class EBipedModularBodySlot : uint8
{
	Helmet                                   = 0,
	Head                                     = 1,
	UpperBody                                = 2,
	LowerBody                                = 3,
	Hands                                    = 4,
	Feet                                     = 5,
	Tail                                     = 6,
	RightRing                                = 7,
	LeftRing                                 = 8,
	Amulet                                   = 9,
	Count                                    = 10,
	EBipedModularBodySlot_MAX                = 11,
};

// Enum Altar.ELegacyInventoryMenuPage
// NumValues: 0x0006
enum class ELegacyInventoryMenuPage : uint8
{
	Weapon                                   = 0,
	Armor                                    = 1,
	Alchemy                                  = 2,
	Misc                                     = 3,
	All                                      = 4,
	ELegacyInventoryMenuPage_MAX             = 5,
};

// Enum Altar.ELegacyInventoryMenuItemType
// NumValues: 0x000B
enum class ELegacyInventoryMenuItemType : uint8
{
	Weapons                                  = 0,
	Apparel                                  = 1,
	Apparatuses                              = 2,
	Potions                                  = 3,
	Ingredients                              = 4,
	Books                                    = 5,
	Keys                                     = 6,
	Stones                                   = 7,
	Misc                                     = 8,
	None                                     = 9,
	ELegacyInventoryMenuItemType_MAX         = 10,
};

// Enum Altar.EOriginalInventoryMenuSortType
// NumValues: 0x000A
enum class EOriginalInventoryMenuSortType : uint8
{
	Name                                     = 0,
	Price                                    = 1,
	Weight                                   = 2,
	WeaponDamage                             = 3,
	ArmorRating                              = 4,
	ItemHealth                               = 5,
	ItemCharge                               = 6,
	SpellCost                                = 7,
	SpellPrice                               = 8,
	EOriginalInventoryMenuSortType_MAX       = 9,
};

// Enum Altar.ELegacyContainerMenuTab
// NumValues: 0x0003
enum class ELegacyContainerMenuTab : uint8
{
	GiveSell                                 = 0,
	TakeBuy                                  = 1,
	ELegacyContainerMenuTab_MAX              = 2,
};

// Enum Altar.ELegacyContainerMenuType
// NumValues: 0x0003
enum class ELegacyContainerMenuType : uint8
{
	Merchant                                 = 0,
	Container                                = 1,
	ELegacyContainerMenuType_MAX             = 2,
};

// Enum Altar.EModernEnchantmentMenuPage
// NumValues: 0x0004
enum class EModernEnchantmentMenuPage : uint8
{
	Gear                                     = 0,
	SoulGem                                  = 1,
	Effect                                   = 2,
	EModernEnchantmentMenuPage_MAX           = 3,
};

// Enum Altar.EModernEnchantmentMenuItemType
// NumValues: 0x0004
enum class EModernEnchantmentMenuItemType : uint8
{
	Gear                                     = 0,
	SoulGem                                  = 1,
	Effect                                   = 2,
	EModernEnchantmentMenuItemType_MAX       = 3,
};

// Enum Altar.EDialogueEmotion
// NumValues: 0x0009
enum class EDialogueEmotion : uint8
{
	Neutral                                  = 0,
	Anger                                    = 1,
	Disgust                                  = 2,
	Fear                                     = 3,
	Sad                                      = 4,
	Happy                                    = 5,
	Surprise                                 = 6,
	DIALOGUE_EMOTION_COUNT                   = 7,
	EDialogueEmotion_MAX                     = 8,
};

// Enum Altar.EVFacialHairType
// NumValues: 0x0006
enum class EVFacialHairType : uint8
{
	Hair                                     = 0,
	Beard                                    = 1,
	Mustache                                 = 2,
	Eyebrows                                 = 3,
	FACIAL_HAIR_COUNT                        = 4,
	EVFacialHairType_MAX                     = 5,
};

// Enum Altar.FLegacyControlsDevice
// NumValues: 0x0005
enum class EFLegacyControlsDevice : uint8
{
	Keyboard                                 = 0,
	Mouse                                    = 1,
	Joystick                                 = 2,
	Controller                               = 3,
	FLegacyControlsDevice_MAX                = 4,
};

// Enum Altar.EHUDVisibility
// NumValues: 0x0009
enum class EHUDVisibility : uint8
{
	None                                     = 0,
	Main                                     = 1,
	Info                                     = 2,
	Reticle                                  = 4,
	Subtitle                                 = 8,
	Breath                                   = 16,
	MapPage                                  = 32,
	QuickKeys                                = 64,
	EHUDVisibility_MAX                       = 65,
};

// Enum Altar.ELegacyLockpickMenuHandleType
// NumValues: 0x0003
enum class ELegacyLockpickMenuHandleType : uint8
{
	Normal                                   = 0,
	Skeleton                                 = 1,
	ELegacyLockpickMenuHandleType_MAX        = 2,
};

// Enum Altar.ELegacyLockpickMenuPickMovement
// NumValues: 0x0005
enum class ELegacyLockpickMenuPickMovement : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Up                                       = 3,
	ELegacyLockpickMenuPickMovement_MAX      = 4,
};

// Enum Altar.ELegacyStatsMenuPage1Items
// NumValues: 0x0008
enum class ELegacyStatsMenuPage1Items : uint8
{
	Race                                     = 0,
	Birthsign                                = 1,
	Class                                    = 2,
	Level                                    = 3,
	Health                                   = 4,
	Magicka                                  = 5,
	Fatigue                                  = 6,
	ELegacyStatsMenuPage1Items_MAX           = 7,
};

// Enum Altar.ELegacyStatsMenuPage2Items
// NumValues: 0x0009
enum class ELegacyStatsMenuPage2Items : uint8
{
	Strength                                 = 0,
	Intelligence                             = 1,
	Willpower                                = 2,
	Agility                                  = 3,
	Speed                                    = 4,
	Endurance                                = 5,
	Personality                              = 6,
	Luck                                     = 7,
	ELegacyStatsMenuPage2Items_MAX           = 8,
};

// Enum Altar.FLegacyVideoSettingsEnum
// NumValues: 0x001D
enum class EFLegacyVideoSettingsEnum : uint8
{
	Resolution                               = 0,
	TextureSize                              = 1,
	ShadowFiltering                          = 2,
	WaterDetail                              = 3,
	BloodDecal                               = 4,
	AntiAliasing                             = 5,
	LandLODActive                            = 6,
	BuildingLODActive                        = 7,
	TreeLODActive                            = 8,
	SelfShadows                              = 9,
	GrassShadows                             = 10,
	TreeShadows                              = 11,
	HDRLighting                              = 12,
	BloomLighting                            = 13,
	WaterReflections                         = 14,
	WaterDisplacement                        = 15,
	WindowReflections                        = 16,
	HairDetail                               = 17,
	Gamma                                    = 18,
	TreeLOD                                  = 19,
	ActorLOD                                 = 20,
	ItemLOD                                  = 21,
	ObjectLOD                                = 22,
	GrassLOD                                 = 23,
	ViewLOD                                  = 24,
	InternalShadows                          = 25,
	ExternalShadows                          = 26,
	SpecularLighting                         = 27,
	FLegacyVideoSettingsEnum_MAX             = 28,
};

// Enum Altar.ELegacyMagicMenuPage
// NumValues: 0x0006
enum class ELegacyMagicMenuPage : uint8
{
	Self                                     = 0,
	Touch                                    = 1,
	Target                                   = 2,
	All                                      = 3,
	Active                                   = 4,
	ELegacyMagicMenuPage_MAX                 = 5,
};

// Enum Altar.EModernMagicMenuActiveEffectValue
// NumValues: 0x0004
enum class EModernMagicMenuActiveEffectValue : uint8
{
	Positive                                 = 0,
	Neutral                                  = 1,
	Negative                                 = 2,
	EModernMagicMenuActiveEffectValue_MAX    = 3,
};

// Enum Altar.EModernMagicMenuItemSchool
// NumValues: 0x0007
enum class EModernMagicMenuItemSchool : uint8
{
	Alteration                               = 0,
	Conjuration                              = 1,
	Destruction                              = 2,
	Illusion                                 = 3,
	Mysticism                                = 4,
	Restoration                              = 5,
	EModernMagicMenuItemSchool_MAX           = 6,
};

// Enum Altar.ELegacyMagicMenuItemType
// NumValues: 0x0006
enum class ELegacyMagicMenuItemType : uint8
{
	None                                     = 0,
	Target                                   = 1,
	Touch                                    = 2,
	OnSelf                                   = 4,
	Active                                   = 8,
	ELegacyMagicMenuItemType_MAX             = 9,
};

// Enum Altar.ELegacyMagicMenuItemCategory
// NumValues: 0x000E
enum class ELegacyMagicMenuItemCategory : uint8
{
	Greater                                  = 1,
	Lesser                                   = 2,
	Spell                                    = 4,
	Scroll                                   = 8,
	Special                                  = 16,
	Disease                                  = 17,
	Ability                                  = 18,
	Poison                                   = 19,
	Enchantment                              = 20,
	Potion                                   = 21,
	Wortcraft                                = 22,
	Leveled_Spell                            = 23,
	None                                     = 0,
	ELegacyMagicMenuItemCategory_MAX         = 24,
};

// Enum Altar.ELegacyMagicMenuSortType
// NumValues: 0x0008
enum class ELegacyMagicMenuSortType : uint8
{
	Name                                     = 0,
	EffectValue                              = 1,
	School                                   = 2,
	Magnitude                                = 3,
	ItemCategory                             = 4,
	Favorite                                 = 5,
	Cost                                     = 6,
	ELegacyMagicMenuSortType_MAX             = 7,
};

// Enum Altar.FLegacyMainMenuButtonVisibility
// NumValues: 0x0004
enum class EFLegacyMainMenuButtonVisibility : uint8
{
	None                                     = 0,
	PressStart                               = 1,
	Buttons                                  = 2,
	FLegacyMainMenuButtonVisibility_MAX      = 3,
};

// Enum Altar.EModernLockpickMenuPickMovement
// NumValues: 0x0005
enum class EModernLockpickMenuPickMovement : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Up                                       = 3,
	EModernLockpickMenuPickMovement_MAX      = 4,
};

// Enum Altar.EModernLockpickMenuHandleType
// NumValues: 0x0003
enum class EModernLockpickMenuHandleType : uint8
{
	Normal                                   = 0,
	Skeleton                                 = 1,
	EModernLockpickMenuHandleType_MAX        = 2,
};

// Enum Altar.EPersuasionMiniGamePlayState
// NumValues: 0x0004
enum class EPersuasionMiniGamePlayState : uint8
{
	CanPlay                                  = 0,
	CannotPlay                               = 1,
	Playing                                  = 2,
	EPersuasionMiniGamePlayState_MAX         = 3,
};

// Enum Altar.EPersuade
// NumValues: 0x0009
enum class EPersuade : uint8
{
	Admire                                   = 0,
	Joke                                     = 1,
	Bully                                    = 2,
	Boast                                    = 3,
	Count                                    = 4,
	Bribe                                    = 5,
	Enter                                    = 6,
	None                                     = 7,
	EPersuade_MAX                            = 8,
};

// Enum Altar.EReaction
// NumValues: 0x0006
enum class EReaction : uint8
{
	None                                     = 0,
	Love                                     = 1,
	Like                                     = 2,
	Dislike                                  = 3,
	Hate                                     = 4,
	EReaction_MAX                            = 5,
};

// Enum Altar.ELegacyPlayerMenuPage
// NumValues: 0x0008
enum class ELegacyPlayerMenuPage : uint8
{
	Stats                                    = 0,
	Inventory                                = 1,
	Magic                                    = 2,
	Map                                      = 3,
	Quest                                    = 4,
	Codex                                    = 5,
	Settings                                 = 6,
	MAX                                      = 7,
};

// Enum Altar.ELegacyRechargeMenuPage
// NumValues: 0x0003
enum class ELegacyRechargeMenuPage : uint8
{
	Gold                                     = 0,
	Soul                                     = 1,
	ELegacyRechargeMenuPage_MAX              = 2,
};

// Enum Altar.ELegacyRepairMenuType
// NumValues: 0x0008
enum class ELegacyRepairMenuType : uint8
{
	Repair                                   = 1,
	Repair_Buy                               = 2,
	Alchemy_Select                           = 3,
	Enchantement_Select                      = 4,
	Soulgem_Select                           = 5,
	Sigilstone_Select                        = 6,
	None                                     = 0,
	ELegacyRepairMenuType_MAX                = 7,
};

// Enum Altar.EModernSpellType
// NumValues: 0x000C
enum class EModernSpellType : uint8
{
	Spell                                    = 0,
	Disease                                  = 1,
	Power                                    = 2,
	Lesser_Power                             = 3,
	Ability                                  = 4,
	Poison                                   = 5,
	Enchantment                              = 6,
	Potion                                   = 7,
	Wortcraft                                = 8,
	Leveled_Spell                            = 9,
	None                                     = 10,
	EModernSpellType_MAX                     = 11,
};

// Enum Altar.EModernMagnitudeType
// NumValues: 0x0005
enum class EModernMagnitudeType : uint8
{
	Percent                                  = 0,
	Level                                    = 1,
	Feet                                     = 2,
	Raw                                      = 3,
	EModernMagnitudeType_MAX                 = 4,
};

// Enum Altar.EModernEffectItemRange
// NumValues: 0x0005
enum class EModernEffectItemRange : uint8
{
	Self                                     = 0,
	Touch                                    = 1,
	Target                                   = 2,
	Strike                                   = 3,
	EModernEffectItemRange_MAX               = 4,
};

// Enum Altar.EVOutputType
// NumValues: 0x0007
enum class EVOutputType : uint8
{
	System_Mono                              = 0,
	System_Stereo                            = 1,
	System_Stereo_Headphones                 = 2,
	System_Stereo_Surround_5_1               = 4,
	System_Stereo_TvSpeakers                 = 8,
	None                                     = 16,
	EVOutputType_MAX                         = 17,
};

// Enum Altar.EVBassManagement
// NumValues: 0x0005
enum class EVBassManagement : uint8
{
	Default                                  = 0,
	LowFrequencyBoost                        = 1,
	NightMode                                = 2,
	None                                     = 4,
	EVBassManagement_MAX                     = 5,
};

// Enum Altar.EVVolumeSettings
// NumValues: 0x0009
enum class EVVolumeSettings : uint8
{
	AmbienceVolume                           = 0,
	DialogueVolume                           = 1,
	FootstepsVolume                          = 2,
	InterfaceVolume                          = 4,
	MasterVolume                             = 8,
	MusicVolume                              = 16,
	SfxVolume                                = 32,
	None                                     = 64,
	EVVolumeSettings_MAX                     = 65,
};

// Enum Altar.EPerformanceMode
// NumValues: 0x0004
enum class EPerformanceMode : uint8
{
	PERFORMANCEMODE_DEFAULT                  = 0,
	PERFORMANCEMODE_QUALITY                  = 1,
	PERFORMANCEMODE_PERFORMANCE              = 2,
	PERFORMANCEMODE_MAX                      = 3,
};

// Enum Altar.ERebindSaveSlot
// NumValues: 0x0004
enum class ERebindSaveSlot : uint8
{
	PrimaryKeyboard                          = 0,
	SecondaryKeyboard                        = 1,
	PrimaryGamepad                           = 2,
	ERebindSaveSlot_MAX                      = 3,
};

// Enum Altar.EBSXFlags
// NumValues: 0x0008
enum class EBSXFlags : uint8
{
	NONE                                     = 0,
	ANIMATED                                 = 1,
	HAVOK                                    = 2,
	RAGDOLL                                  = 4,
	COMPLEX                                  = 8,
	FLAME                                    = 16,
	EDITORMARKER                             = 32,
	EBSXFlags_MAX                            = 33,
};

// Enum Altar.ELightRigState
// NumValues: 0x0005
enum class ELightRigState : uint8
{
	DISABLE                                  = 0,
	TICKABLE                                 = 1,
	FADEOUT                                  = 2,
	COMPLETED                                = 3,
	ELightRigState_MAX                       = 4,
};

// Enum Altar.ELightRigSourceType
// NumValues: 0x0003
enum class ELightRigSourceType : uint8
{
	GLOBAL_LIGHTING                          = 0,
	TRIGGER_VOLUME                           = 1,
	ELightRigSourceType_MAX                  = 2,
};

// Enum Altar.EVInstanceReplacementType
// NumValues: 0x0005
enum class EVInstanceReplacementType : uint8
{
	Remove                                   = 0,
	Keep                                     = 1,
	Mesh                                     = 2,
	Material                                 = 3,
	EVInstanceReplacementType_MAX            = 4,
};

// Enum Altar.EHitReactionKeyframeType
// NumValues: 0x000B
enum class EHitReactionKeyframeType : uint8
{
	NONE                                     = 0,
	Heavy                                    = 1,
	Light                                    = 2,
	UpperBody                                = 4,
	LowerBody                                = 8,
	SpellArrow                               = 16,
	LightUpperBody                           = 6,
	HeavyUpperBody                           = 5,
	LightLowerBody                           = 10,
	HeavyLowerBody                           = 9,
	EHitReactionKeyframeType_MAX             = 17,
};

// Enum Altar.LandscapeLayerName
// NumValues: 0x002B
enum class ELandscapeLayerName : uint8
{
	Error                                    = 0,
	Burned                                   = 1,
	Dirt                                     = 2,
	Dirt_Road                                = 3,
	Grass                                    = 4,
	Ice                                      = 5,
	Lava                                     = 6,
	Mud                                      = 7,
	Pavement                                 = 8,
	Rock                                     = 9,
	Rock_Lava                                = 10,
	Rocky                                    = 11,
	Rubble                                   = 12,
	Sand                                     = 13,
	Snow                                     = 14,
	Snow_Grass                               = 15,
	Snow_Rock                                = 16,
	Stone_Road                               = 17,
	Stone_Street                             = 18,
	Burned_FoliageA                          = 19,
	Dirt_Road_FoliageA                       = 20,
	Dirt_FoliageA                            = 21,
	Grass_FoliageA                           = 22,
	Mud_FoliageA                             = 23,
	Mud_FoliageB                             = 24,
	Rock_Lava_FoliageA                       = 25,
	Rocky_FoliageA                           = 26,
	Sand_FoliageA                            = 27,
	Snow_Grass_FoliageA                      = 28,
	Dementia_Grass                           = 29,
	Mania_Grass                              = 30,
	Dementia_Rock                            = 31,
	Mania_Rock                               = 32,
	Ordered_Rock                             = 33,
	Dementia_Sand                            = 34,
	Mania_Sand                               = 35,
	Dementia_Stone_Street                    = 36,
	Mania_Stone_Street                       = 37,
	Dementia_Stone_Road                      = 38,
	Mania_Stone_Road                         = 39,
	Vines                                    = 40,
	Ash                                      = 41,
	LandscapeLayerName_MAX                   = 42,
};

// Enum Altar.EVCastType
// NumValues: 0x0005
enum class EVCastType : uint8
{
	Self                                     = 0,
	Touch                                    = 1,
	Target                                   = 2,
	Unknown                                  = 3,
	EVCastType_MAX                           = 4,
};

// Enum Altar.EVSpellLevel
// NumValues: 0x0006
enum class EVSpellLevel : uint8
{
	NOVICE                                   = 0,
	APPRENTICE                               = 1,
	JOURNEYMAN                               = 2,
	EXPERT                                   = 3,
	MASTER                                   = 4,
	EVSpellLevel_MAX                         = 5,
};

// Enum Altar.EndianType
// NumValues: 0x0003
enum class EndianType : uint8
{
	ENDIAN_BIG                               = 0,
	ENDIAN_LITTLE                            = 1,
	ENDIAN_MAX                               = 2,
};

// Enum Altar.OblivionHavokMaterial
// NumValues: 0x0021
enum class EOblivionHavokMaterial : uint32
{
	OB_HAV_MAT_STONE                         = 0,
	OB_HAV_MAT_CLOTH                         = 1,
	OB_HAV_MAT_DIRT                          = 2,
	OB_HAV_MAT_GLASS                         = 3,
	OB_HAV_MAT_GRASS                         = 4,
	OB_HAV_MAT_METAL                         = 5,
	OB_HAV_MAT_ORGANIC                       = 6,
	OB_HAV_MAT_SKIN                          = 7,
	OB_HAV_MAT_WATER                         = 8,
	OB_HAV_MAT_WOOD                          = 9,
	OB_HAV_MAT_HEAVY_STONE                   = 10,
	OB_HAV_MAT_HEAVY_METAL                   = 11,
	OB_HAV_MAT_HEAVY_WOOD                    = 12,
	OB_HAV_MAT_CHAIN                         = 13,
	OB_HAV_MAT_SNOW                          = 14,
	OB_HAV_MAT_STONE_STAIRS                  = 15,
	OB_HAV_MAT_CLOTH_STAIRS                  = 16,
	OB_HAV_MAT_DIRT_STAIRS                   = 17,
	OB_HAV_MAT_GLASS_STAIRS                  = 18,
	OB_HAV_MAT_GRASS_STAIRS                  = 19,
	OB_HAV_MAT_METAL_STAIRS                  = 20,
	OB_HAV_MAT_ORGANIC_STAIRS                = 21,
	OB_HAV_MAT_SKIN_STAIRS                   = 22,
	OB_HAV_MAT_WATER_STAIRS                  = 23,
	OB_HAV_MAT_WOOD_STAIRS                   = 24,
	OB_HAV_MAT_HEAVY_STONE_STAIRS            = 25,
	OB_HAV_MAT_HEAVY_METAL_STAIRS            = 26,
	OB_HAV_MAT_HEAVY_WOOD_STAIRS             = 27,
	OB_HAV_MAT_CHAIN_STAIRS                  = 28,
	OB_HAV_MAT_SNOW_STAIRS                   = 29,
	OB_HAV_MAT_ELEVATOR                      = 30,
	OB_HAV_MAT_RUBBER                        = 31,
	OB_HAV_MAT_MAX                           = 32,
};

// Enum Altar.OblivionLayer
// NumValues: 0x003B
enum class EOblivionLayer : uint8
{
	OL_UNIDENTIFIED                          = 0,
	OL_STATIC                                = 1,
	OL_ANIM_STATIC                           = 2,
	OL_TRANSPARENT                           = 3,
	OL_CLUTTER                               = 4,
	OL_WEAPON                                = 5,
	OL_PROJECTILE                            = 6,
	OL_SPELL                                 = 7,
	OL_BIPED                                 = 8,
	OL_TREES                                 = 9,
	OL_PROPS                                 = 10,
	OL_WATER                                 = 11,
	OL_TRIGGER                               = 12,
	OL_TERRAIN                               = 13,
	OL_TRAP                                  = 14,
	OL_NONCOLLIDABLE                         = 15,
	OL_CLOUD_TRAP                            = 16,
	OL_GROUND                                = 17,
	OL_PORTAL                                = 18,
	OL_STAIRS                                = 19,
	OL_CHAR_CONTROLLER                       = 20,
	OL_AVOID_BOX                             = 21,
	OL_UNKNOWN1                              = 22,
	OL_UNKNOWN2                              = 23,
	OL_CAMERA_PICK                           = 24,
	OL_ITEM_PICK                             = 25,
	OL_LINE_OF_SIGHT                         = 26,
	OL_PATH_PICK                             = 27,
	OL_CUSTOM_PICK_1                         = 28,
	OL_CUSTOM_PICK_2                         = 29,
	OL_SPELL_EXPLOSION                       = 30,
	OL_DROPPING_PICK                         = 31,
	OL_OTHER                                 = 32,
	OL_HEAD                                  = 33,
	OL_BODY                                  = 34,
	OL_SPINE1                                = 35,
	OL_SPINE2                                = 36,
	OL_L_UPPER_ARM                           = 37,
	OL_L_FOREARM                             = 38,
	OL_L_HAND                                = 39,
	OL_L_THIGH                               = 40,
	OL_L_CALF                                = 41,
	OL_L_FOOT                                = 42,
	OL_R_UPPER_ARM                           = 43,
	OL_R_FOREARM                             = 44,
	OL_R_HAND                                = 45,
	OL_R_THIGH                               = 46,
	OL_R_CALF                                = 47,
	OL_R_FOOT                                = 48,
	OL_TAIL                                  = 49,
	OL_SIDE_WEAPON                           = 50,
	OL_SHIELD                                = 51,
	OL_QUIVER                                = 52,
	OL_BACK_WEAPON                           = 53,
	OL_BACK_WEAPON2                          = 54,
	OL_PONYTAIL                              = 55,
	OL_WING                                  = 56,
	OL_NULL                                  = 57,
	OL_MAX                                   = 58,
};

// Enum Altar.hkMoppCodeBuildType
// NumValues: 0x0004
enum class EhkMoppCodeBuildType : uint8
{
	BUILT_WITH_CHUNK_SUBDIVISION             = 0,
	BUILT_WITHOUT_CHUNK_SUBDIVISION          = 1,
	BUILD_NOT_SET                            = 2,
	hkMoppCodeBuildType_MAX                  = 3,
};

// Enum Altar.BroadPhaseType
// NumValues: 0x0005
enum class EBroadPhaseType : uint8
{
	BROAD_PHASE_INVALID                      = 0,
	BROAD_PHASE_ENTITY                       = 1,
	BROAD_PHASE_PHANTOM                      = 2,
	BROAD_PHASE_BORDER                       = 3,
	BROAD_PHASE_MAX                          = 4,
};

// Enum Altar.hkResponseType
// NumValues: 0x0005
enum class EhkResponseType : uint8
{
	RESPONSE_INVALID                         = 0,
	RESPONSE_SIMPLE_CONTACT                  = 1,
	RESPONSE_REPORTING                       = 2,
	RESPONSE_NONE                            = 3,
	RESPONSE_MAX                             = 4,
};

// Enum Altar.hkMotionType
// NumValues: 0x000B
enum class EhkMotionType : uint8
{
	MO_SYS_INVALID                           = 0,
	MO_SYS_DYNAMIC                           = 1,
	MO_SYS_SPHERE_INERTIA                    = 2,
	MO_SYS_SPHERE_STABILIZED                 = 3,
	MO_SYS_BOX_INERTIA                       = 4,
	MO_SYS_BOX_STABILIZED                    = 5,
	MO_SYS_KEYFRAMED                         = 6,
	MO_SYS_FIXED                             = 7,
	MO_SYS_THIN_BOX                          = 8,
	MO_SYS_CHARACTER                         = 9,
	MO_SYS_MAX                               = 10,
};

// Enum Altar.hkDeactivatorType
// NumValues: 0x0004
enum class EhkDeactivatorType : uint8
{
	DEACTIVATOR_INVALID                      = 0,
	DEACTIVATOR_NEVER                        = 1,
	DEACTIVATOR_SPATIAL                      = 2,
	DEACTIVATOR_MAX                          = 3,
};

// Enum Altar.hkSolverDeactivation
// NumValues: 0x0006
enum class EhkSolverDeactivation : uint8
{
	SOLVER_DEACTIVATION_INVALID              = 0,
	SOLVER_DEACTIVATION_OFF                  = 1,
	SOLVER_DEACTIVATION_LOW                  = 2,
	SOLVER_DEACTIVATION_MEDIUM               = 3,
	SOLVER_DEACTIVATION_HIGH                 = 4,
	SOLVER_DEACTIVATION_MAX                  = 5,
};

// Enum Altar.hkQualityType
// NumValues: 0x000B
enum class EhkQualityType : uint8
{
	MO_QUAL_INVALID                          = 0,
	MO_QUAL_FIXED                            = 1,
	MO_QUAL_KEYFRAMED                        = 2,
	MO_QUAL_DEBRIS                           = 3,
	MO_QUAL_MOVING                           = 4,
	MO_QUAL_CRITICAL                         = 5,
	MO_QUAL_BULLET                           = 6,
	MO_QUAL_USER                             = 7,
	MO_QUAL_CHARACTER                        = 8,
	MO_QUAL_KEYFRAMED_REPORT                 = 9,
	MO_QUAL_MAX                              = 10,
};

// Enum Altar.bhkCOFlags
// NumValues: 0x000D
enum class EbhkCOFlags : uint16
{
	ACTIVE                                   = 1,
	RESET_TRANS                              = 2,
	NOTIFY                                   = 4,
	SET_LOCAL                                = 8,
	DBG_DISPLAY                              = 16,
	USE_VEL                                  = 32,
	RESET                                    = 64,
	SYNC_ON_UPDATE                           = 128,
	BLEND_POS                                = 256,
	ALWAYS_BLEND                             = 512,
	ANIM_TARGETED                            = 1024,
	DISMEMBERED_LIMB                         = 2048,
	bhkCOFlags_MAX                           = 2049,
};

// Enum Altar.ShaderFlags
// NumValues: 0x0003
enum class EShaderFlags : uint8
{
	SHADING_HARD                             = 0,
	SHADING_SMOOTH                           = 1,
	SHADING_MAX                              = 2,
};

// Enum Altar.BSShaderType
// NumValues: 0x0009
enum class EBSShaderType : uint32
{
	SHADER_TALL_GRASS                        = 0,
	SHADER_DEFAULT                           = 1,
	SHADER_SKY                               = 10,
	SHADER_SKIN                              = 14,
	SHADER_WATER                             = 17,
	SHADER_LIGHTING30                        = 29,
	SHADER_TILE                              = 32,
	SHADER_NOLIGHTING                        = 33,
	SHADER_MAX                               = 34,
};

// Enum Altar.BSShaderFlags1
// NumValues: 0x0021
enum class EBSShaderFlags1 : uint32
{
	Specular                                 = 1,
	Skinned                                  = 2,
	LowDetail                                = 4,
	Vertex_Alpha                             = 8,
	Unknown_1                                = 16,
	Single_Pass                              = 32,
	Empty                                    = 64,
	Environment_Mapping                      = 128,
	Alpha_Texture                            = 256,
	Unknown_2                                = 512,
	FaceGen                                  = 1024,
	Parallax_Shader_Index_15                 = 2048,
	Unknown_3                                = 4096,
	Non_Projective_Shadows                   = 8192,
	Unknown_4                                = 16384,
	Refraction                               = 32768,
	Fire_Refraction                          = 65536,
	Eye_Environment_Mapping                  = 131072,
	Hair                                     = 262144,
	Dynamic_Alpha                            = 524288,
	Localmap_Hide_Secret                     = 1048576,
	Window_Environment_Mapping               = 2097152,
	Tree_Billboard                           = 4194304,
	Shadow_Frustum                           = 8388608,
	Multiple_Textures                        = 16777216,
	Remappable_Textures                      = 33554432,
	Decal_Single_Pass                        = 67108864,
	Dynamic_Decal_Single_Pass                = 134217728,
	Parallax_Occulsion                       = 268435456,
	External_Emittance                       = 536870912,
	Shadow_Map                               = 1073741824,
	ZBuffer_Test                             = 2147483648,
	BSShaderFlags1_MAX                       = 2147483649,
};

// Enum Altar.BSShaderFlags2
// NumValues: 0x0021
enum class EBSShaderFlags2 : uint32
{
	ZBuffer_Write                            = 1,
	LOD_Landscape                            = 2,
	LOD_Building                             = 4,
	No_Fade                                  = 8,
	Refraction_Tint                          = 16,
	Vertex_Colors                            = 32,
	Unknown1                                 = 64,
	First_Light_is_Point_Light               = 128,
	Second_Light                             = 256,
	Third_Light                              = 512,
	Vertex_Lighting                          = 1024,
	Uniform_Scale                            = 2048,
	Fit_Slope                                = 4096,
	Billboard_and_Envmap_Light_Fade          = 8192,
	No_LOD_Land_Blend                        = 16384,
	Envmap_Light_Fade                        = 32768,
	Wireframe                                = 65536,
	VATS_Selection                           = 131072,
	Show_in_Local_Map                        = 262144,
	Premult_Alpha                            = 524288,
	Skip_Normal_Maps                         = 1048576,
	Alpha_Decal                              = 2097152,
	No_Transparecny_Multisampling            = 4194304,
	Unknown2                                 = 8388608,
	Unknown3                                 = 16777216,
	Unknown4                                 = 33554432,
	Unknown5                                 = 67108864,
	Unknown6                                 = 134217728,
	Unknown7                                 = 268435456,
	Unknown8                                 = 536870912,
	Unknown9                                 = 1073741824,
	Unknown10                                = 2147483648,
	BSShaderFlags2_MAX                       = 2147483649,
};

// Enum Altar.SourceVertexMode
// NumValues: 0x0004
enum class ESourceVertexMode : uint32
{
	VERT_MODE_SRC_IGNORE                     = 0,
	VERT_MODE_SRC_EMISSIVE                   = 1,
	VERT_MODE_SRC_AMB_DIF                    = 2,
	VERT_MODE_SRC_MAX                        = 3,
};

// Enum Altar.LightingMode
// NumValues: 0x0003
enum class ELightingMode : uint32
{
	LIGHT_MODE_EMISSIVE                      = 0,
	LIGHT_MODE_EMI_AMB_DIF                   = 1,
	LIGHT_MODE_MAX                           = 2,
};

// Enum Altar.StencilTestFunc
// NumValues: 0x0009
enum class EStencilTestFunc : uint32
{
	TEST_NEVER                               = 0,
	TEST_LESS                                = 1,
	TEST_EQUAL                               = 2,
	TEST_LESS_EQUAL                          = 3,
	TEST_GREATER                             = 4,
	TEST_NOT_EQUAL                           = 5,
	TEST_GREATER_EQUAL                       = 6,
	TEST_ALWAYS                              = 7,
	TEST_MAX                                 = 8,
};

// Enum Altar.StencilAction
// NumValues: 0x0007
enum class EStencilAction : uint32
{
	ACTION_KEEP                              = 0,
	ACTION_ZERO                              = 1,
	ACTION_REPLACE                           = 2,
	ACTION_INCREMENT                         = 3,
	ACTION_DECREMENT                         = 4,
	ACTION_INVERT                            = 5,
	ACTION_MAX                               = 6,
};

// Enum Altar.StencilDrawMode
// NumValues: 0x0005
enum class EStencilDrawMode : uint32
{
	DRAW_CCW_OR_BOTH                         = 0,
	DRAW_CCW                                 = 1,
	DRAW_CW                                  = 2,
	DRAW_BOTH                                = 3,
	DRAW_MAX                                 = 4,
};

// Enum Altar.SpecularFlags
// NumValues: 0x0003
enum class ESpecularFlags : uint16
{
	SPECULAR_DISABLED                        = 0,
	SPECULAR_ENABLED                         = 1,
	SPECULAR_MAX                             = 2,
};

// Enum Altar.PixelLayout
// NumValues: 0x0012
enum class EPixelLayout : uint32
{
	LAY_PALETTIZED_8                         = 0,
	LAY_HIGH_COLOR_16                        = 1,
	LAY_TRUE_COLOR_32                        = 2,
	LAY_COMPRESSED                           = 3,
	LAY_BUMPMAP                              = 4,
	LAY_PALETTIZED_4                         = 5,
	LAY_DEFAULT                              = 6,
	LAY_SINGLE_COLOR_8                       = 7,
	LAY_SINGLE_COLOR_16                      = 8,
	LAY_SINGLE_COLOR_32                      = 9,
	LAY_DOUBLE_COLOR_32                      = 10,
	LAY_DOUBLE_COLOR_64                      = 11,
	LAY_FLOAT_COLOR_32                       = 12,
	LAY_FLOAT_COLOR_64                       = 13,
	LAY_FLOAT_COLOR_128                      = 14,
	LAY_SINGLE_COLOR_4                       = 15,
	LAY_DEPTH_24_X8                          = 16,
	LAY_MAX                                  = 17,
};

// Enum Altar.MipMapFormat
// NumValues: 0x0004
enum class EMipMapFormat : uint32
{
	MIP_FMT_NO                               = 0,
	MIP_FMT_YES                              = 1,
	MIP_FMT_DEFAULT                          = 2,
	MIP_FMT_MAX                              = 3,
};

// Enum Altar.AlphaFormat
// NumValues: 0x0005
enum class EAlphaFormat : uint32
{
	ALPHA_NONE                               = 0,
	ALPHA_BINARY                             = 1,
	ALPHA_SMOOTH                             = 2,
	ALPHA_DEFAULT                            = 3,
	ALPHA_MAX                                = 4,
};

// Enum Altar.ImageType
// NumValues: 0x0003
enum class EImageType : uint32
{
	RGB                                      = 1,
	RGBA                                     = 2,
	ImageType_MAX                            = 3,
};

// Enum Altar.ApplyMode
// NumValues: 0x0006
enum class EApplyMode : uint32
{
	APPLY_REPLACE                            = 0,
	APPLY_DECAL                              = 1,
	APPLY_MODULATE                           = 2,
	APPLY_HILIGHT                            = 3,
	APPLY_HILIGHT2                           = 4,
	APPLY_MAX                                = 5,
};

// Enum Altar.TexClampMode
// NumValues: 0x0005
enum class ETexClampMode : uint32
{
	CLAMP_S_CLAMP_T                          = 0,
	CLAMP_S_WRAP_T                           = 1,
	WRAP_S_CLAMP_T                           = 2,
	WRAP_S_WRAP_T                            = 3,
	TexClampMode_MAX                         = 4,
};

// Enum Altar.TexFilterMode
// NumValues: 0x0007
enum class ETexFilterMode : uint32
{
	FILTER_NEAREST                           = 0,
	FILTER_BILERP                            = 1,
	FILTER_TRILERP                           = 2,
	FILTER_NEAREST_MIPLERP                   = 4,
	FILTER_BILERP_MIPNEAREST                 = 5,
	FILTER_ANISOTROPIC                       = 6,
	FILTER_MAX                               = 7,
};

// Enum Altar.TransformMethod
// NumValues: 0x0003
enum class ETransformMethod : uint32
{
	Maya_Deprecated                          = 0,
	Max                                      = 1,
	Maya                                     = 2,
};

// Enum Altar.KeyType
// NumValues: 0x0006
enum class EKeyType : uint32
{
	LINEAR_KEY                               = 1,
	QUADRATIC_KEY                            = 2,
	TBC_KEY                                  = 3,
	XYZ_ROTATION_KEY                         = 4,
	CONST_KEY                                = 5,
	KeyType_MAX                              = 6,
};

// Enum Altar.InterpBlendFlags
// NumValues: 0x0002
enum class EInterpBlendFlags : uint8
{
	MANAGER_CONTROLLED                       = 1,
	MANAGER_MAX                              = 2,
};

// Enum Altar.CycleType
// NumValues: 0x0004
enum class ECycleType : uint32
{
	CYCLE_LOOP                               = 0,
	CYCLE_REVERSE                            = 1,
	CYCLE_CLAMP                              = 2,
	CYCLE_MAX                                = 3,
};

// Enum Altar.AccumFlags
// NumValues: 0x000B
enum class EAccumFlags : uint32
{
	ACCUM_X_TRANS                            = 1,
	ACCUM_Y_TRANS                            = 2,
	ACCUM_Z_TRANS                            = 4,
	ACCUM_X_ROT                              = 8,
	ACCUM_Y_ROT                              = 16,
	ACCUM_Z_ROT                              = 32,
	ACCUM_X_FRONT                            = 64,
	ACCUM_Y_FRONT                            = 128,
	ACCUM_Z_FRONT                            = 256,
	ACCUM_NEG_FRONT                          = 512,
	ACCUM_MAX                                = 513,
};

// Enum Altar.AnimNoteType
// NumValues: 0x0004
enum class EAnimNoteType : uint32
{
	ANT_INVALID                              = 0,
	ANT_GRABIK                               = 1,
	ANT_LOOKIK                               = 2,
	ANT_MAX                                  = 3,
};

// Enum Altar.PixelComponent
// NumValues: 0x0015
enum class EPixelComponent : uint32
{
	COMP_RED                                 = 0,
	COMP_GREEN                               = 1,
	COMP_BLUE                                = 2,
	COMP_ALPHA                               = 3,
	COMP_COMPRESSED                          = 4,
	COMP_OFFSET_U                            = 5,
	COMP_OFFSET_V                            = 6,
	COMP_OFFSET_W                            = 7,
	COMP_OFFSET_Q                            = 8,
	COMP_LUMA                                = 9,
	COMP_HEIGHT                              = 10,
	COMP_VECTOR_X                            = 11,
	COMP_VECTOR_Y                            = 12,
	COMP_VECTOR_Z                            = 13,
	COMP_PADDING                             = 14,
	COMP_INTENSITY                           = 15,
	COMP_INDEX                               = 16,
	COMP_DEPTH                               = 17,
	COMP_STENCIL                             = 18,
	COMP_EMPTY                               = 19,
	COMP_MAX                                 = 20,
};

// Enum Altar.PixelRepresentation
// NumValues: 0x0008
enum class EPixelRepresentation : uint32
{
	REP_NORM_INT                             = 0,
	REP_HALF                                 = 1,
	REP_FLOAT                                = 2,
	REP_INDEX                                = 3,
	REP_COMPRESSED                           = 4,
	REP_UNKNOWN                              = 5,
	REP_INT                                  = 6,
	REP_MAX                                  = 7,
};

// Enum Altar.PixelFormat
// NumValues: 0x0012
enum class Altar::EPixelFormat : uint32
{
	FMT_RGB                                  = 0,
	FMT_RGBA                                 = 1,
	FMT_PAL                                  = 2,
	FMT_PALA                                 = 3,
	FMT_DXT1                                 = 4,
	FMT_DXT3                                 = 5,
	FMT_DXT5                                 = 6,
	FMT_RGB24NONINT                          = 7,
	FMT_BUMP                                 = 8,
	FMT_BUMPLUMA                             = 9,
	FMT_RENDERSPEC                           = 10,
	FMT_1CH                                  = 11,
	FMT_2CH                                  = 12,
	FMT_3CH                                  = 13,
	FMT_4CH                                  = 14,
	FMT_DEPTH_STENCIL                        = 15,
	FMT_UNKNOWN                              = 16,
	FMT_MAX                                  = 17,
};

// Enum Altar.PixelTiling
// NumValues: 0x0005
enum class EPixelTiling : uint32
{
	TILE_NONE                                = 0,
	TILE_XENON                               = 1,
	TILE_WII                                 = 2,
	TILE_NV_SWIZZLED                         = 3,
	TILE_MAX                                 = 4,
};

// Enum Altar.EZBufferTestFunction
// NumValues: 0x000A
enum class EZBufferTestFunction : uint32
{
	TEST_ALWAYS                              = 0,
	TEST_LESS                                = 1,
	TEST_EQUAL                               = 2,
	TEST_LESSEQUAL                           = 3,
	TEST_GREATER                             = 4,
	TEST_NOTEQUAL                            = 5,
	TEST_GREATEREQUAL                        = 6,
	TEST_NEVER                               = 7,
	TEST_MAX_MODES                           = 8,
	TEST_MAX                                 = 9,
};

// Enum Altar.hkMotorType
// NumValues: 0x0005
enum class EhkMotorType : uint8
{
	MOTOR_NONE                               = 0,
	MOTOR_POSITION                           = 1,
	MOTOR_VELOCITY                           = 2,
	MOTOR_SPRING                             = 3,
	MOTOR_MAX                                = 4,
};

// Enum Altar.ConstraintPriority
// NumValues: 0x0004
enum class EConstraintPriority : uint32
{
	PRIORITY_INVALID                         = 0,
	PRIORITY_PSI                             = 1,
	PRIORITY_TOI                             = 3,
	PRIORITY_MAX                             = 4,
};

// Enum Altar.EAspectFlags
// NumValues: 0x0004
enum class EAspectFlags : uint16
{
	VELOCITY_ORIENTATION                     = 1,
	INITIAL_ROTATION_FROM_VELOCITY           = 2,
	SPEED_TO_ASPECT_ENABLED                  = 256,
	EAspectFlags_MAX                         = 257,
};

// Enum Altar.ENiPSysModifierOrder
// NumValues: 0x000E
enum class ENiPSysModifierOrder : uint32
{
	ORDER_KILLOLDPARTICLES                   = 0,
	ORDER_BSLOD                              = 1,
	ORDER_EMITTER                            = 1000,
	ORDER_SPAWN                              = 2000,
	ORDER_FO3_BSSTRIPUPDATE                  = 2500,
	ORDER_GENERAL                            = 3000,
	ORDER_FORCE                              = 4000,
	ORDER_COLLIDER                           = 5000,
	ORDER_POS_UPDATE                         = 6000,
	ORDER_POSTPOS_UPDATE                     = 6500,
	ORDER_WORLDSHIFT_PARTSPAWN               = 6600,
	ORDER_BOUND_UPDATE                       = 7000,
	ORDER_SK_BSSTRIPUPDATE                   = 8000,
	ORDER_MAX                                = 8001,
};

// Enum Altar.EVelocityType
// NumValues: 0x0004
enum class EVelocityType : uint32
{
	VELOCITY_USE_NORMALS                     = 0,
	VELOCITY_USE_RANDOM                      = 1,
	VELOCITY_USE_DIRECTION                   = 2,
	VELOCITY_USE_MAX                         = 3,
};

// Enum Altar.EEmitFrom
// NumValues: 0x0006
enum class EEmitFrom : uint32
{
	EMIT_FROM_VERTICES                       = 0,
	EMIT_FROM_FACE_CENTER                    = 1,
	EMIT_FROM_EDGE_CENTER                    = 2,
	EMIT_FROM_FACE_SURFACE                   = 3,
	EMIT_FROM_EDGE_SURFACE                   = 4,
	EMIT_FROM_MAX                            = 5,
};

// Enum Altar.EBillboardMode
// NumValues: 0x0008
enum class EBillboardMode : uint16
{
	ALWAYS_FACE_CAMERA                       = 0,
	ROTATE_ABOUT_UP                          = 1,
	RIGID_FACE_CAMERA                        = 2,
	ALWAYS_FACE_CENTER                       = 3,
	RIGID_FACE_CENTER                        = 4,
	BSROTATE_ABOUT_UP                        = 5,
	ROTATE_ABOUT_UP2                         = 9,
	EBillboardMode_MAX                       = 10,
};

// Enum Altar.ETexType
// NumValues: 0x000D
enum class ETexType : uint32
{
	BASE_MAP                                 = 0,
	DARK_MAP                                 = 1,
	DETAIL_MAP                               = 2,
	GLOSS_MAP                                = 3,
	GLOW_MAP                                 = 4,
	BUMP_MAP                                 = 5,
	NORMAL_MAP                               = 6,
	PARALLAX_MAP                             = 7,
	DECAL_0_MAP                              = 8,
	DECAL_1_MAP                              = 9,
	DECAL_2_MAP                              = 10,
	DECAL_3_MAP                              = 11,
	ETexType_MAX                             = 12,
};

// Enum Altar.ETransformMember
// NumValues: 0x0006
enum class ETransformMember : uint32
{
	TT_TRANSLATE_U                           = 0,
	TT_TRANSLATE_V                           = 1,
	TT_ROTATE                                = 2,
	TT_SCALE_U                               = 3,
	TT_SCALE_V                               = 4,
	TT_MAX                                   = 5,
};

// Enum Altar.EForceType
// NumValues: 0x0004
enum class EForceType : uint32
{
	FORCE_PLANAR                             = 0,
	FORCE_SPHERICAL                          = 1,
	FORCE_UNKNOWN                            = 2,
	FORCE_MAX                                = 3,
};

// Enum Altar.EDitherFlags
// NumValues: 0x0003
enum class EDitherFlags : uint16
{
	DITHER_DISABLED                          = 0,
	DITHER_ENABLED                           = 1,
	DITHER_MAX                               = 2,
};

// Enum Altar.EPathFlags
// NumValues: 0x0008
enum class EPathFlags : uint16
{
	CVDataNeedsUpdate                        = 1,
	CurveTypeOpen                            = 2,
	AllowFlip                                = 4,
	Bank                                     = 8,
	ConstantVelocity                         = 16,
	Follow                                   = 32,
	Flip                                     = 64,
	EPathFlags_MAX                           = 65,
};

// Enum Altar.EDecayType
// NumValues: 0x0004
enum class EDecayType : uint32
{
	DECAY_NONE                               = 0,
	DECAY_LINEAR                             = 1,
	DECAY_EXPONENTIAL                        = 2,
	DECAY_MAX                                = 3,
};

// Enum Altar.ESymmetryType
// NumValues: 0x0004
enum class ESymmetryType : uint32
{
	SPHERICAL_SYMMETRY                       = 0,
	CYLINDRICAL_SYMMETRY                     = 1,
	PLANAR_SYMMETRY                          = 2,
	ESymmetryType_MAX                        = 3,
};

// Enum Altar.EMaterialColor
// NumValues: 0x0005
enum class EMaterialColor : uint16
{
	TC_AMBIENT                               = 0,
	TC_DIFFUSE                               = 1,
	TC_SPECULAR                              = 2,
	TC_SELF_ILLUM                            = 3,
	TC_MAX                                   = 4,
};

// Enum Altar.FurnitureEntryPoints
// NumValues: 0x0006
enum class EFurnitureEntryPoints : uint8
{
	Front                                    = 1,
	Behind                                   = 2,
	Right                                    = 4,
	Left                                     = 8,
	Up                                       = 16,
	FurnitureEntryPoints_MAX                 = 17,
};

// Enum Altar.EBHKConstraintType
// NumValues: 0x0007
enum class EBHKConstraintType : uint32
{
	BALL_AND_SOCKET                          = 0,
	HINGE                                    = 1,
	LIMITED_HINGE                            = 2,
	PRISMATIC                                = 6,
	RAGDOLL                                  = 7,
	STIFF_SPRING                             = 8,
	EBHKConstraintType_MAX                   = 9,
};

// Enum Altar.AnimationType
// NumValues: 0x0004
enum class EAnimationType : uint8
{
	Sit                                      = 1,
	Sleep                                    = 2,
	Lean                                     = 4,
	AnimationType_MAX                        = 5,
};

// Enum Altar.WireframeFlags
// NumValues: 0x0003
enum class EWireframeFlags : uint16
{
	WIREFRAME_DISABLED                       = 0,
	WIREFRAME_ENABLED                        = 1,
	WIREFRAME_MAX                            = 2,
};

// Enum Altar.EVSpawnedActorType
// NumValues: 0x0005
enum class EVSpawnedActorType : uint8
{
	Unknown                                  = 0,
	Dropped                                  = 1,
	Equipped                                 = 2,
	Ammo                                     = 3,
	EVSpawnedActorType_MAX                   = 4,
};

// Enum Altar.EAlchemyFlags
// NumValues: 0x0003
enum class EAlchemyFlags : uint8
{
	CostOverride                             = 1,
	FoodItem                                 = 2,
	EAlchemyFlags_MAX                        = 3,
};

// Enum Altar.EAmmoFlags
// NumValues: 0x0002
enum class EAmmoFlags : uint8
{
	IgnoreResist                             = 1,
	EAmmoFlags_MAX                           = 2,
};

// Enum Altar.EObjectEquipSlot
// NumValues: 0x0012
enum class EObjectEquipSlot : uint8
{
	Head                                     = 0,
	Hair                                     = 1,
	UpperBody                                = 2,
	LowerBody                                = 3,
	Hand                                     = 4,
	Foot                                     = 5,
	RightRing                                = 6,
	LeftRing                                 = 7,
	Amulet                                   = 8,
	Weapon                                   = 9,
	BackWeapon                               = 10,
	SideWeapon                               = 11,
	Quiver                                   = 12,
	Shield                                   = 13,
	Torch                                    = 14,
	Tail                                     = 15,
	Count                                    = 16,
	EObjectEquipSlot_MAX                     = 17,
};

// Enum Altar.EBipedModelFlags
// NumValues: 0x0003
enum class EBipedModelFlags : uint8
{
	NonPlayable                              = 64,
	Heavy                                    = 128,
	EBipedModelFlags_MAX                     = 129,
};

// Enum Altar.ESkills
// NumValues: 0x0017
enum class ESkills : uint64
{
	None                                     = 18446744073709551615,
	Armorer                                  = 0,
	Atheltics                                = 1,
	Blade                                    = 2,
	Block                                    = 3,
	Blunt                                    = 4,
	HandToHand                               = 5,
	HeavyArmor                               = 6,
	Alchemy                                  = 7,
	Alteration                               = 8,
	Conjuration                              = 9,
	Destruction                              = 10,
	Illusion                                 = 11,
	Mysticism                                = 12,
	Restoration                              = 13,
	Acrobatics                               = 14,
	LightArmor                               = 15,
	Maskman                                  = 16,
	Mercantile                               = 17,
	Security                                 = 18,
	Sneak                                    = 19,
	Speechcraft                              = 20,
	ESkills_MAX                              = 21,
};

// Enum Altar.EWeaponType
// NumValues: 0x0008
enum class EWeaponType : uint8
{
	BladeOneHand                             = 0,
	BladeTwoHand                             = 1,
	BluntOneHand                             = 2,
	BluntTwoHand                             = 3,
	Staff                                    = 4,
	Marksman_Bow                             = 5,
	Type_Count                               = 6,
	EWeaponType_MAX                          = 7,
};

// Enum Altar.EEffectID
// NumValues: 0x00AA
enum class EEffectID : uint64
{
	NoEffect                                 = 0,
	WaterBreathing                           = 1380073815,
	WaterWalking                             = 1096237399,
	Shield                                   = 1145849939,
	FireShield                               = 1213417798,
	LightningShield                          = 1213417804,
	FrostShield                              = 1213420102,
	Burden                                   = 1313100354,
	Feather                                  = 1380471878,
	Lock                                     = 1262702412,
	Open                                     = 1313165391,
	FireDamage                               = 1195657542,
	ShockDamage                              = 1195657299,
	FrostDamage                              = 1195659846,
	DamageAttribute                          = 1413564228,
	DamageSpellPoints                        = 1347635012,
	DamageFatigue                            = 1095124804,
	DrainAttribute                           = 1413567044,
	DrainHealth                              = 1162367556,
	DamageHealth                             = 1162364740,
	DrainSpellPoints                         = 1347637828,
	DrainFatigue                             = 1095127620,
	DrainSkill                               = 1263751748,
	PoisonInfo                               = 1314082640,
	Disease_INFO                             = 1163086148,
	WeaknessToFire                           = 1229343575,
	WeaknessToFrost                          = 1380338519,
	WeaknessToShock                          = 1213418327,
	WeaknessToMagic                          = 1095584599,
	WeaknessToDisease                        = 1229212503,
	WeaknessToPoison                         = 1330662231,
	WeaknessToNormalWeapons                  = 1464748887,
	DisintegrateWeapon                       = 1163348292,
	DisintegrateArmor                        = 1380010308,
	Vampirism                                = 1347240278,
	SunDamage                                = 1195660627,
	StuntedMagicka                           = 1095586899,
	MehrunesDagonCustom                      = 1498240324,
	Invisibility                             = 1230392905,
	Chameleon                                = 1280133187,
	Paralyze                                 = 1095909712,
	Silence                                  = 1129204819,
	Charm                                    = 1297238083,
	Demoralize                               = 1330464068,
	Rally                                    = 1498169682,
	Frenzy                                   = 1515082310,
	Calm                                     = 1296843075,
	Night_eye                                = 1163478350,
	Light                                    = 1414022988,
	Darkness                                 = 1263681860,
	Confusion                                = 1430670915,
	Dispel                                   = 1280332612,
	SoulTrap                                 = 1347572819,
	Telekinesis                              = 1162626388,
	SigilStoneActivation                     = 1128354643,
	SigilStoneDeactivation                   = 1162105683,
	Recall                                   = 1094927698,
	DetectLife                               = 1413698628,
	SpellAbsorption                          = 1396851027,
	Reflect                                  = 1129072210,
	Intervention                             = 1448365641,
	ReflectDamage                            = 1195656530,
	MysticVision                             = 1397315149,
	RestoreAttribute                         = 1413563730,
	RestoreHealth                            = 1162364242,
	RestoreSpellPoints                       = 1347634514,
	RestoreFatigue                           = 1095124306,
	FortifyAttribute                         = 1413566278,
	FortifyHealth                            = 1162366790,
	FortifySpellPoints                       = 1347637062,
	FortifyFatigue                           = 1095126854,
	FortifySkill                             = 1263750982,
	FortifyMagickaMultiplier                 = 1296912198,
	FortifyAttackBonus                       = 1111576390,
	AbsorbAttribute                          = 1413562945,
	AbsorbHealth                             = 1162363457,
	AbsorbSpellPoints                        = 1347633729,
	AbsorbFatigue                            = 1095123521,
	AbsorbSkill                              = 1263747649,
	ResistFire                               = 1229345618,
	ResistFrost                              = 1380340562,
	ResistShock                              = 1213420370,
	ResistMagic                              = 1095586642,
	ResistDisease                            = 1229214546,
	ResistPoison                             = 1330664274,
	ResistParalysis                          = 1095783250,
	ResistNormalWeapons                      = 1464750930,
	CureDisease                              = 1229215043,
	CurePoison                               = 1330664771,
	CureParalysis                            = 1095783747,
	ResistWaterDamage                        = 1146573650,
	SummonGhost                              = 1330136922,
	SummonLich                               = 1128877146,
	SummonSkeleton                           = 1162564442,
	SummonSkeletonArcher                     = 1095455578,
	SummonSkeletonChampion                   = 1129010010,
	SummonSkeletonHero                       = 1212896090,
	SummonWraith                             = 1095915354,
	SummonWraithLord                         = 1280464730,
	SummonZombie                             = 1297046106,
	SummonHeadlessZombie                     = 1514424410,
	SummonFireAtronach                       = 1095321178,
	SummonFrostAtronach                      = 1095911002,
	SummonStormAtronach                      = 1096045402,
	SummonDaedroth                           = 1161905242,
	SummonDremora                            = 1163019354,
	SummonScamp                              = 1094931290,
	SummonClannfear                          = 1095517018,
	SummonDremoraLord                        = 1280459866,
	SummonSpiderDaedra                       = 1146114906,
	SummonXivilai                            = 1447647322,
	SummonExtra01                            = 825241690,
	SummonExtra02                            = 842018906,
	SummonExtra03                            = 858796122,
	SummonExtra04                            = 875573338,
	SummonExtra05                            = 892350554,
	SummonExtra06                            = 909127770,
	SummonExtra07                            = 925904986,
	SummonExtra08                            = 942682202,
	SummonExtra09                            = 959459418,
	SummonExtra10                            = 808530010,
	SummonExtra11                            = 825307226,
	SummonExtra12                            = 842084442,
	SummonExtra13                            = 858861658,
	SummonExtra14                            = 875638874,
	SummonExtra15                            = 892416090,
	SummonExtra16                            = 909193306,
	SummonExtra17                            = 925970522,
	SummonExtra18                            = 942747738,
	SummonExtra19                            = 959524954,
	SummonExtra20                            = 808595546,
	CommandCreature                          = 1380142915,
	CommandHumanoid                          = 1430802243,
	BoundBoots                               = 1329742146,
	BoundCuirass                             = 1430470978,
	BoundGauntlets                           = 1095188802,
	BoundGreaves                             = 1380401474,
	BoundHelmet                              = 1162363202,
	BoundShield                              = 1213415746,
	BoundAxe                                 = 1480677186,
	BoundBow                                 = 1329747778,
	BoundDagger                              = 1094997826,
	BoundMace                                = 1095587650,
	BoundSword                               = 1465079618,
	Reanimate                                = 1312900434,
	TurnUndead                               = 1314018644,
	MythicDawnArmor                          = 1213487437,
	MythicDawnHelm                           = 1279809869,
	BoundaExtra01                            = 825246018,
	BoundaExtra02                            = 842023234,
	BoundaExtra03                            = 858800450,
	BoundaExtra04                            = 875577666,
	BoundaExtra05                            = 892354882,
	BoundaExtra06                            = 909132098,
	BoundaExtra07                            = 925909314,
	BoundaExtra08                            = 942686530,
	BoundaExtra09                            = 959463746,
	BoundaExtra10                            = 808534338,
	BoundwExtra01                            = 825251650,
	BoundwExtra02                            = 842028866,
	BoundwExtra03                            = 858806082,
	BoundwExtra04                            = 875583298,
	BoundwExtra05                            = 892360514,
	BoundwExtra06                            = 909137730,
	BoundwExtra07                            = 925914946,
	BoundwExtra08                            = 942692162,
	BoundwExtra09                            = 959469378,
	BoundwExtra10                            = 808539970,
	ScriptEffect                             = 1179010387,
	EEffectID_MAX                            = 1515082311,
};

// Enum Altar.ERange
// NumValues: 0x0004
enum class ERange : uint8
{
	Self                                     = 0,
	Touch                                    = 1,
	Target                                   = 2,
	ERange_MAX                               = 3,
};

// Enum Altar.EMagicSchool
// NumValues: 0x0007
enum class EMagicSchool : uint8
{
	Alteration                               = 0,
	Conjuration                              = 1,
	Destruction                              = 2,
	Illusion                                 = 3,
	Mysticism                                = 4,
	Restoration                              = 5,
	EMagicSchool_MAX                         = 6,
};

// Enum Altar.ECastingType
// NumValues: 0x0005
enum class ECastingType : uint8
{
	Scrolls                                  = 0,
	Staffs                                   = 1,
	Weapons                                  = 2,
	Apparel                                  = 3,
	ECastingType_MAX                         = 4,
};

// Enum Altar.ESpellType
// NumValues: 0x000B
enum class ESpellType : uint8
{
	Spell                                    = 0,
	Disease                                  = 1,
	Power                                    = 2,
	LesserPower                              = 3,
	Ability                                  = 4,
	Poison                                   = 5,
	Enchantment                              = 6,
	Potion                                   = 7,
	Wortcraft                                = 8,
	LeveledSpell                             = 9,
	ESpellType_MAX                           = 10,
};

// Enum Altar.EActorValue
// NumValues: 0x004A
enum class EActorValue : uint64
{
	None                                     = 18446744073709551615,
	Strength                                 = 0,
	Intelligence                             = 1,
	Willpower                                = 2,
	Agility                                  = 3,
	Speed                                    = 4,
	Endurance                                = 5,
	Personality                              = 6,
	Luck                                     = 7,
	Health                                   = 8,
	Magicka                                  = 9,
	Fatigue                                  = 10,
	Encumbrance                              = 11,
	Armorer                                  = 12,
	Athletics                                = 13,
	Blade                                    = 14,
	Block                                    = 15,
	Blunt                                    = 16,
	HandToHand                               = 17,
	HeavyArmor                               = 18,
	Alchemy                                  = 19,
	Alteration                               = 20,
	Conjuration                              = 21,
	Destruction                              = 22,
	Illusion                                 = 23,
	Mysticism                                = 24,
	Restoration                              = 25,
	Acrobatics                               = 26,
	Lightarmor                               = 27,
	Marksman                                 = 28,
	Mercantile                               = 29,
	Security                                 = 30,
	Sneak                                    = 31,
	Speechcraft                              = 32,
	Aggression                               = 33,
	Confidence                               = 34,
	Energy                                   = 35,
	Responsibility                           = 36,
	Bounty                                   = 37,
	Fame                                     = 38,
	Infamy                                   = 39,
	MagickaMultiplier                        = 40,
	NightEyeBonus                            = 41,
	AttackBonus                              = 42,
	DefendBonus                              = 43,
	CastingPenalty                           = 44,
	Blindness                                = 45,
	Chameleon                                = 46,
	Invisibility                             = 47,
	Paralysis                                = 48,
	Silence                                  = 49,
	Confusion                                = 50,
	DetectRange                              = 51,
	AbsorbChance                             = 52,
	ReflectChance                            = 53,
	SwimSpeedMult                            = 54,
	WaterBreathing                           = 55,
	WaterWalking                             = 56,
	StuntedMagicka                           = 57,
	DetectLifeRange                          = 58,
	ReflectDamage                            = 59,
	Telekinesis                              = 60,
	ResistFire                               = 61,
	ResistFrost                              = 62,
	ResistDisease                            = 63,
	ResistMagic                              = 64,
	ResistNormalWeapons                      = 65,
	ResistParalysis                          = 66,
	ResistPoison                             = 67,
	ResistShock                              = 68,
	Vampirism                                = 69,
	Darkness                                 = 70,
	ResistWaterDamage                        = 71,
	EActorValue_MAX                          = 72,
};

// Enum Altar.ELeveledObjectFlags
// NumValues: 0x0003
enum class ELeveledObjectFlags : uint8
{
	CalculateAllBelowLevel                   = 1,
	CalculateForAllInCount                   = 2,
	ELeveledObjectFlags_MAX                  = 3,
};

// Enum Altar.ELeveledSpellFlags
// NumValues: 0x0004
enum class ELeveledSpellFlags : uint8
{
	CalculateAllBelowLevel                   = 1,
	CalculateForAllInCount                   = 2,
	UseAllSpells                             = 4,
	ELeveledSpellFlags_MAX                   = 5,
};

// Enum Altar.EOblivionPackageFlags
// NumValues: 0x001A
enum class EOblivionPackageFlags : uint32
{
	Services                                 = 1,
	MustReachLocation                        = 2,
	MustComplete                             = 4,
	LockStart                                = 8,
	LockEnd                                  = 16,
	LockAtLoc                                = 32,
	UnlockStart                              = 64,
	UnlockEnd                                = 128,
	UnlockAtLoc                              = 256,
	PCContinue                               = 512,
	OncePerDay                               = 1024,
	IsCreated                                = 2048,
	SkipFallout                              = 4096,
	AlwaysRun                                = 8192,
	Script                                   = 16384,
	NeverRun                                 = 32768,
	Waiting                                  = 65536,
	AlwaysSneak                              = 131072,
	AllowSwim                                = 262144,
	AllowFalls                               = 524288,
	NoArmor                                  = 1048576,
	NoWeapon                                 = 2097152,
	Defensive                                = 4194304,
	Horse                                    = 8388608,
	NoIdles                                  = 16777216,
	EOblivionPackageFlags_MAX                = 16777217,
};

// Enum Altar.EPackageType
// NumValues: 0x000F
enum class EPackageType : uint64
{
	NONE                                     = 18446744073709551615,
	EXPLORE                                  = 0,
	FOLLOW                                   = 1,
	ESCORT                                   = 2,
	EAT                                      = 3,
	SLEEP                                    = 4,
	WANDER                                   = 5,
	TRAVEL                                   = 6,
	ACCOMPANY                                = 7,
	USEITEMAT                                = 8,
	AMBUSH                                   = 9,
	FLEE_NON_COMBAT                          = 10,
	CAST_MAGIC                               = 11,
	COUNT                                    = 12,
	EPackageType_MAX                         = 13,
};

// Enum Altar.EPackageObjectType
// NumValues: 0x0026
enum class EPackageObjectType : uint8
{
	NONE                                     = 0,
	ACTI                                     = 1,
	APPA                                     = 2,
	ARMO                                     = 3,
	BOOK                                     = 4,
	CLOT                                     = 5,
	CONT                                     = 6,
	DOOR                                     = 7,
	INGR                                     = 8,
	LIGH                                     = 9,
	MISC                                     = 10,
	FLOR                                     = 11,
	FURN                                     = 12,
	WEAP                                     = 13,
	AMMO                                     = 14,
	NPC                                      = 15,
	CREA                                     = 16,
	SLGM                                     = 17,
	KEYM                                     = 18,
	ALCH                                     = 19,
	FOOD                                     = 20,
	COMBATWEAR                               = 21,
	WEAR                                     = 22,
	WEAP_NONE                                = 23,
	WEAP_MELEE                               = 24,
	WEAP_RANGED                              = 25,
	SPELL                                    = 26,
	SPELL_RANGED                             = 27,
	SPELL_TOUCH                              = 28,
	SPELL_SELF                               = 29,
	SPELL_ALTERATION                         = 30,
	SPELL_CONJURATION                        = 31,
	SPELL_DESTRUCTION                        = 32,
	SPELL_ILLUSION                           = 33,
	SPELL_MYSTICISM                          = 34,
	SPELL_RESTORATION                        = 35,
	COUNT                                    = 36,
	EPackageObjectType_MAX                   = 37,
};

// Enum Altar.EPackageLocationType
// NumValues: 0x0008
enum class EPackageLocationType : uint8
{
	NONE                                     = 18446744073709551615,
	REFERENCE                                = 0,
	CELL                                     = 1,
	CURRLOC                                  = 2,
	EDITORLOC                                = 3,
	OBJECT                                   = 4,
	TYPE                                     = 5,
	EPackageLocationType_MAX                 = 6,
};

// Enum Altar.EPackageTargetType
// NumValues: 0x0005
enum class EPackageTargetType : uint8
{
	NONE                                     = 18446744073709551615,
	REFERENCE                                = 0,
	OBJECT                                   = 1,
	TYPE                                     = 2,
	EPackageTargetType_MAX                   = 3,
};

// Enum Altar.EPackageScheduleMonth
// NumValues: 0x0013
enum class EPackageScheduleMonth : uint8
{
	NONE                                     = 18446744073709551615,
	MORNINGSTAR                              = 0,
	SUNSDAWN                                 = 1,
	FIRSTSEED                                = 2,
	RAINSHAND                                = 3,
	SECONDSEED                               = 4,
	MIDYEAR                                  = 5,
	SUNSHEIGHT                               = 6,
	LASTSEED                                 = 7,
	HEARTFIRE                                = 8,
	FROSTFALL                                = 9,
	SUNSDUSK                                 = 10,
	EVENINGSTAR                              = 11,
	SPRING                                   = 12,
	SUMMER                                   = 13,
	FALL                                     = 14,
	WINTER                                   = 15,
	COUNT                                    = 16,
	EPackageScheduleMonth_MAX                = 17,
};

// Enum Altar.EPackageScheduleDayOfWeek
// NumValues: 0x000E
enum class EPackageScheduleDayOfWeek : uint8
{
	NONE                                     = 18446744073709551615,
	SUNDAY                                   = 0,
	MONDAY                                   = 1,
	TUESDAY                                  = 2,
	WEDNESDAY                                = 3,
	THURSDAY                                 = 4,
	FRIDAY                                   = 5,
	SATURDAY                                 = 6,
	WEEKDAY                                  = 7,
	WEEKEND                                  = 8,
	MWF                                      = 9,
	TT                                       = 10,
	COUNT                                    = 11,
	EPackageScheduleDayOfWeek_MAX            = 12,
};

// Enum Altar.EVBodyTextureEffectColors
// NumValues: 0x0009
enum class EVBodyTextureEffectColors : uint8
{
	None                                     = 0,
	MainColor                                = 1,
	BackgroundColor                          = 2,
	FresnelColor                             = 3,
	MainAndBackgroundColors                  = 4,
	MainAndFresnelColors                     = 5,
	BackgroundAndFresnelColors               = 6,
	AllColors                                = 7,
	EVBodyTextureEffectColors_MAX            = 8,
};

// Enum Altar.EEyesFlags
// NumValues: 0x0003
enum class EEyesFlags : uint8
{
	None                                     = 0,
	Playable                                 = 1,
	EEyesFlags_MAX                           = 2,
};

// Enum Altar.ESavedFormFlags
// NumValues: 0x000A
enum class ESavedFormFlags : uint32
{
	Deleted                                  = 32,
	Disabled                                 = 2048,
	QuestItem                                = 1024,
	DistantReference                         = 32768,
	CastShadows                              = 512,
	FireOff                                  = 128,
	BorderRegion                             = 64,
	Dangerous                                = 131072,
	CantWait                                 = 524288,
	ESavedFormFlags_MAX                      = 524289,
};

// Enum Altar.EAllFormFlags
// NumValues: 0x0024
enum class EAllFormFlags : uint32
{
	Master                                   = 1,
	Altered                                  = 2,
	Transfer                                 = 4,
	Init                                     = 8,
	NoCollision                              = 16,
	Delete                                   = 32,
	ActorHasSpokenTo                         = 64,
	BorderRegion                             = 64,
	FireOff                                  = 128,
	Droppped                                 = 256,
	CastShadows                              = 512,
	Quest                                    = 1024,
	Persistent                               = 1024,
	Disabled                                 = 2048,
	Ignore                                   = 4096,
	MenuNotify                               = 4096,
	Empty                                    = 8192,
	Destroyed                                = 8192,
	HasResults                               = 8192,
	Temporary                                = 16384,
	PartialData                              = 16384,
	Distant                                  = 32768,
	HavokDeath                               = 65536,
	NeedChangeProcess                        = 131072,
	Dangerous                                = 131072,
	OffLimit                                 = 131072,
	Compressed                               = 262144,
	Targeted                                 = 262144,
	CantWait                                 = 524288,
	StartsDead                               = 524288,
	Temp3D                                   = 524288,
	IgnoreFriendHits                         = 1048576,
	CenterOnCreation                         = 1048576,
	StillLoading                             = 2097152,
	NewPCDrop                                = 4194304,
	EAllFormFlags_MAX                        = 4194305,
};

// Enum Altar.ECrimeTypeEnum
// NumValues: 0x0009
enum class ECrimeTypeEnum : uint64
{
	NONE                                     = 18446744073709551615,
	STEAL                                    = 0,
	PICKPOCKET                               = 1,
	TRESPASS                                 = 2,
	ATTACK                                   = 3,
	MURDER                                   = 4,
	STEAL_HORSE                              = 5,
	CRIME_COUNT                              = 6,
	ECrimeTypeEnum_MAX                       = 7,
};

// Enum Altar.EActorValueIndexEnum
// NumValues: 0x004A
enum class EActorValueIndexEnum : uint8
{
	STRENGTH                                 = 0,
	INTELLIGENCE                             = 1,
	WILLPOWER                                = 2,
	AGILITY                                  = 3,
	SPEED                                    = 4,
	ENDURANCE                                = 5,
	PERSONALITY                              = 6,
	LUCK                                     = 7,
	HEALTH                                   = 8,
	MAGICKA                                  = 9,
	FATIGUE                                  = 10,
	ENCUMBRANCE                              = 11,
	ARMORER                                  = 12,
	ATHLETICS                                = 13,
	BLADE                                    = 14,
	BLOCK                                    = 15,
	BLUNT                                    = 16,
	HANDTOHAND                               = 17,
	HEAVYARMOR                               = 18,
	ALCHEMY                                  = 19,
	ALTERATION                               = 20,
	CONJURATION                              = 21,
	DESTRUCTION                              = 22,
	ILLUSION                                 = 23,
	MYSTICISM                                = 24,
	RESTORATION                              = 25,
	ACROBATICS                               = 26,
	LIGHTARMOR                               = 27,
	MARKSMAN                                 = 28,
	MERCANTILE                               = 29,
	SECURITY                                 = 30,
	SNEAK                                    = 31,
	SPEECHCRAFT                              = 32,
	AGGRESSION                               = 33,
	CONFIDENCE                               = 34,
	ENERGY                                   = 35,
	RESPONSIBILITY                           = 36,
	BOUNTY                                   = 37,
	FAME                                     = 38,
	INFAMY                                   = 39,
	MAGICKA_MULTIPLIER                       = 40,
	NIGHT_EYE_BONUS                          = 41,
	ATTACK_BONUS                             = 42,
	DEFEND_BONUS                             = 43,
	CASTING_PENALTY                          = 44,
	BLINDNESS                                = 45,
	CHAMELEON                                = 46,
	INVISIBILITY                             = 47,
	PARALYSIS                                = 48,
	SILENCE                                  = 49,
	CONFUSION                                = 50,
	DETECT_RANGE                             = 51,
	ABSORB_CHANCE                            = 52,
	REFLECT_CHANCE                           = 53,
	SWIM_SPEED_MULT                          = 54,
	WATER_BREATHING                          = 55,
	WATER_WALKING                            = 56,
	STUNTED_MAGICKA                          = 57,
	DETECT_LIFE_RANGE                        = 58,
	REFLECT_DAMAGE                           = 59,
	TELEKINESIS                              = 60,
	RESIST_FIRE                              = 61,
	RESIST_FROST                             = 62,
	RESIST_DISEASE                           = 63,
	RESIST_MAGIC                             = 64,
	RESIST_NORMAL_WEAPONS                    = 65,
	RESIST_PARALYSIS                         = 66,
	RESIST_POISON                            = 67,
	RESIST_SHOCK                             = 68,
	VAMPIRISM                                = 69,
	DARKNESS                                 = 70,
	RESIST_WATER_DAMAGE                      = 71,
	ACTOR_VALUE_COUNT                        = 72,
	EActorValueIndexEnum_MAX                 = 73,
};

// Enum Altar.EAnimGroupEnum
// NumValues: 0x0036
enum class EAnimGroupEnum : uint8
{
	ANIM_GROUP_NONE                          = 255,
	ANIM_GROUP_IDLE                          = 0,
	ANIM_GROUP_DYNAMIC_IDLE                  = 1,
	ANIM_GROUP_SPECIAL_IDLE                  = 2,
	ANIM_GROUP_MOVE_FORWARD                  = 3,
	ANIM_GROUP_BEGIN_MOVEMENT                = 3,
	ANIM_GROUP_MOVE_BACK                     = 4,
	ANIM_GROUP_MOVE_LEFT                     = 5,
	ANIM_GROUP_MOVE_RIGHT                    = 6,
	ANIM_GROUP_FAST_FORWARD                  = 7,
	ANIM_GROUP_FAST_BACK                     = 8,
	ANIM_GROUP_FAST_LEFT                     = 9,
	ANIM_GROUP_FAST_RIGHT                    = 10,
	ANIM_GROUP_DODGE_FORWARD                 = 11,
	ANIM_GROUP_DODGE_BACK                    = 12,
	ANIM_GROUP_DODGE_LEFT                    = 13,
	ANIM_GROUP_DODGE_RIGHT                   = 14,
	ANIM_GROUP_TURN_LEFT                     = 15,
	ANIM_GROUP_TURN_RIGHT                    = 16,
	ANIM_GROUP_END_MOVEMENT                  = 16,
	ANIM_GROUP_EQUIP                         = 17,
	ANIM_GROUP_WEAPONS_START                 = 17,
	ANIM_GROUP_UNEQUIP                       = 18,
	ANIM_GROUP_ATTACK_BOW                    = 19,
	ANIM_GROUP_ATTACK_LEFT                   = 20,
	ANIM_GROUP_ATTACK_RIGHT                  = 21,
	ANIM_GROUP_ATTACK_NORMAL_POWER           = 22,
	ANIM_GROUP_ATTACK_FORWARD_POWER          = 23,
	ANIM_GROUP_ATTACK_BACK_POWER             = 24,
	ANIM_GROUP_ATTACK_LEFT_POWER             = 25,
	ANIM_GROUP_ATTACK_RIGHT_POWER            = 26,
	ANIM_GROUP_WEAPONS_STOP                  = 26,
	ANIM_GROUP_BLOCK_IDLE                    = 27,
	ANIM_GROUP_BLOCK_HIT                     = 28,
	ANIM_GROUP_BLOCK_ATTACK                  = 29,
	ANIM_GROUP_RECOIL                        = 30,
	ANIM_GROUP_STAGGER                       = 31,
	ANIM_GROUP_DEATH                         = 32,
	ANIM_GROUP_TORCH_IDLE                    = 33,
	ANIM_GROUP_CAST_SELF                     = 34,
	ANIM_GROUP_CAST_START                    = 34,
	ANIM_GROUP_CAST_TOUCH                    = 35,
	ANIM_GROUP_CAST_TARGET                   = 36,
	ANIM_GROUP_CAST_SELF_ALT                 = 37,
	ANIM_GROUP_CAST_TOUCH_ALT                = 38,
	ANIM_GROUP_CAST_TARGET_ALT               = 39,
	ANIM_GROUP_CAST_STOP                     = 39,
	ANIM_GROUP_JUMP_START                    = 40,
	ANIM_GROUP_JUMP_LOOP                     = 41,
	ANIM_GROUP_JUMP_LAND                     = 42,
	ANIM_GROUP_COUNT                         = 43,
	ANIM_GROUP_POWERATTACK_START             = 22,
	ANIM_GROUP_POWERATTACK_COUNT             = 5,
	ANIM_GROUP_MAX                           = 256,
};

// Enum Altar.ChunkID
// NumValues: 0x00E2
enum class EChunkID : uint32
{
	NO_CHUNK                                 = 0,
	HEDR_ID                                  = 1380205896,
	MAST_ID                                  = 1414742349,
	DELE_ID                                  = 1162626372,
	SCRD_ID                                  = 1146241875,
	SCRS_ID                                  = 1397900115,
	NAME_ID                                  = 1162690894,
	MODL_ID                                  = 1279545165,
	MOD2_ID                                  = 843337549,
	MOD3_ID                                  = 860114765,
	MOD4_ID                                  = 876891981,
	MODB_ID                                  = 1111773005,
	MO2B_ID                                  = 1110593357,
	MO3B_ID                                  = 1110658893,
	MO4B_ID                                  = 1110724429,
	MODT_ID                                  = 1413762893,
	MO2T_ID                                  = 1412583245,
	MO3T_ID                                  = 1412648781,
	MO4T_ID                                  = 1412714317,
	KFFZ_ID                                  = 1514554955,
	NIFZ_ID                                  = 1514555726,
	NIFT_ID                                  = 1413892430,
	ANAM_ID                                  = 1296125505,
	BNAM_ID                                  = 1296125506,
	CNAM_ID                                  = 1296125507,
	DNAM_ID                                  = 1296125508,
	ENAM_ID                                  = 1296125509,
	FNAM_ID                                  = 1296125510,
	GNAM_ID                                  = 1296125511,
	HNAM_ID                                  = 1296125512,
	INAM_ID                                  = 1296125513,
	JNAM_ID                                  = 1296125514,
	KNAM_ID                                  = 1296125515,
	LNAM_ID                                  = 1296125516,
	MNAM_ID                                  = 1296125517,
	NNAM_ID                                  = 1296125518,
	ONAM_ID                                  = 1296125519,
	PNAM_ID                                  = 1296125520,
	CLNM_ID                                  = 1296125521,
	RNAM_ID                                  = 1296125522,
	SNAM_ID                                  = 1296125523,
	TNAM_ID                                  = 1296125524,
	UNAM_ID                                  = 1296125525,
	VNAM_ID                                  = 1296125526,
	WNAM_ID                                  = 1296125527,
	XNAM_ID                                  = 1296125528,
	YNAM_ID                                  = 1296125529,
	ZNAM_ID                                  = 1296125530,
	NAM1_ID                                  = 827146574,
	NAM2_ID                                  = 843923790,
	NAM3_ID                                  = 860701006,
	NAM4_ID                                  = 877478222,
	NAM5_ID                                  = 894255438,
	NAM6_ID                                  = 911032654,
	NAM7_ID                                  = 927809870,
	NAM8_ID                                  = 944587086,
	NAM9_ID                                  = 961364302,
	NAM0_ID                                  = 810369358,
	RCLR_ID                                  = 1380729682,
	RPLD_ID                                  = 1145851986,
	RPLI_ID                                  = 1229738066,
	RDAT_ID                                  = 1413563474,
	RDOB_ID                                  = 1112491090,
	RDOJ_ID                                  = 1246708818,
	RDOT_ID                                  = 1414480978,
	RDWT_ID                                  = 1415005266,
	RDMP_ID                                  = 1347241042,
	RDLN_ID                                  = 1313621074,
	RDGS_ID                                  = 1397179474,
	RDMD_ID                                  = 1145914450,
	RDSD_ID                                  = 1146307666,
	XIDX_ID                                  = 1480870232,
	XACT_ID                                  = 1413693784,
	XOWN_ID                                  = 1314344792,
	XGLB_ID                                  = 1112295256,
	XRNK_ID                                  = 1263424088,
	XHLT_ID                                  = 1414285400,
	XUSE_ID                                  = 1163089240,
	XTIM_ID                                  = 1296651352,
	XCNT_ID                                  = 1414415192,
	XCHG_ID                                  = 1195918168,
	XSOL_ID                                  = 1280267096,
	XSCL_ID                                  = 1279480664,
	XLOC_ID                                  = 1129270360,
	XTEL_ID                                  = 1279611992,
	XMRK_ID                                  = 1263684952,
	XEDL_ID                                  = 1279542616,
	XPSL_ID                                  = 1280528472,
	XSED_ID                                  = 1145394008,
	XPCI_ID                                  = 1229148248,
	XRGD_ID                                  = 1145524824,
	XLOD_ID                                  = 1146047576,
	XESP_ID                                  = 1347634520,
	XRTM_ID                                  = 1297371736,
	XMRC_ID                                  = 1129467224,
	XHRS_ID                                  = 1397901400,
	XPSN_ID                                  = 1314082904,
	XTRG_ID                                  = 1196577880,
	XLCM_ID                                  = 1296256088,
	XCLC_ID                                  = 1129071448,
	XCLL_ID                                  = 1280066392,
	XCLW_ID                                  = 1464615768,
	XCWT_ID                                  = 1415005016,
	XCLR_ID                                  = 1380729688,
	XCLM_ID                                  = 1296843608,
	XCMT_ID                                  = 1414349656,
	XCCM_ID                                  = 1296253784,
	ACTN_ID                                  = 1314145089,
	STPR_ID                                  = 1380996179,
	SOUL_ID                                  = 1280659283,
	SLCP_ID                                  = 1346587731,
	CIDT_ID                                  = 1413764163,
	CIDA_ID                                  = 1094997059,
	TRDT_ID                                  = 1413763668,
	TCLT_ID                                  = 1414284116,
	TCLF_ID                                  = 1179403092,
	ESCE_ID                                  = 1162040133,
	ESCS_ID                                  = 1396921157,
	ESBS_ID                                  = 1396855621,
	ESHS_ID                                  = 1397248837,
	ESAS_ID                                  = 1396790085,
	WIDX_ID                                  = 1480870231,
	MODQ_ID                                  = 1363431245,
	DATA_ID                                  = 1096040772,
	ATDM_ID                                  = 1296323649,
	ACBS_ID                                  = 1396851521,
	ATTR_ID                                  = 1381258305,
	DESC_ID                                  = 1129530692,
	INDX_ID                                  = 1480871497,
	STRV_ID                                  = 1448236115,
	INTV_ID                                  = 1448365641,
	FLTV_ID                                  = 1448365126,
	DODT_ID                                  = 1413762884,
	NPAC_ID                                  = 1128353870,
	ND3D_ID                                  = 1144210510,
	ANIS_ID                                  = 1397313089,
	CNTO_ID                                  = 1330925123,
	SPLO_ID                                  = 1330401363,
	LVLO_ID                                  = 1330402892,
	LVLD_ID                                  = 1145853516,
	LVLF_ID                                  = 1179407948,
	EFID_ID                                  = 1145652805,
	EFIT_ID                                  = 1414088261,
	AVIT_ID                                  = 1414092353,
	SCIT_ID                                  = 1414087507,
	SPIT_ID                                  = 1414090835,
	ENIT_ID                                  = 1414090309,
	PKID_ID                                  = 1145654096,
	PKDT_ID                                  = 1413761872,
	PLDT_ID                                  = 1413762128,
	PSDT_ID                                  = 1413763920,
	PTDT_ID                                  = 1413764176,
	BIDX_ID                                  = 1480870210,
	BPTM_ID                                  = 1297371202,
	BPTF_ID                                  = 1179930690,
	BMDT_ID                                  = 1413762370,
	PFIG_ID                                  = 1195984464,
	PFPC_ID                                  = 1129334352,
	MVRF_ID                                  = 1179801165,
	AGTY_ID                                  = 1498695489,
	AGFD_ID                                  = 1145456449,
	AGSC_ID                                  = 1129531201,
	AGSX_ID                                  = 1481852737,
	ICON_ID                                  = 1313817417,
	ICO2_ID                                  = 844055369,
	SCRI_ID                                  = 1230127955,
	SCHR_ID                                  = 1380467539,
	SCVR_ID                                  = 1381385043,
	SCTX_ID                                  = 1481917267,
	SCDA_ID                                  = 1094992723,
	SCRO_ID                                  = 1330791251,
	SCRV_ID                                  = 1448231763,
	SLCS_ID                                  = 1396919379,
	SLSD_ID                                  = 1146309715,
	SLLD_ID                                  = 1145850963,
	SLFD_ID                                  = 1145457747,
	SLUD_ID                                  = 1146440787,
	VHGT_ID                                  = 1413957718,
	VNML_ID                                  = 1280134742,
	VCLR_ID                                  = 1380729686,
	BTXT_ID                                  = 1415074882,
	ATXT_ID                                  = 1415074881,
	VTXT_ID                                  = 1415074902,
	MPCD_ID                                  = 1145262157,
	AIDT_ID                                  = 1413761345,
	PGRP_ID                                  = 1347569488,
	PGRC_ID                                  = 1381123920,
	PGRI_ID                                  = 1230128976,
	PGRL_ID                                  = 1280460624,
	PGAG_ID                                  = 1195460432,
	LVCR_ID                                  = 1380144716,
	GMDT_ID                                  = 1413762375,
	QSTI_ID                                  = 1230263121,
	QSDT_ID                                  = 1413763921,
	QSTA_ID                                  = 1096045393,
	TPIC_ID                                  = 1128878164,
	QSTR_ID                                  = 1381258065,
	WHGT_ID                                  = 1413957719,
	EDID_ID                                  = 1145652293,
	FULL_ID                                  = 1280070982,
	LODH_ID                                  = 1212436300,
	LODV_ID                                  = 1447317324,
	LODS_ID                                  = 1396985676,
	LODT_ID                                  = 1413762892,
	LODC_ID                                  = 1128550220,
	LODN_ID                                  = 1313099596,
	FGGS_ID                                  = 1397180230,
	FGGA_ID                                  = 1095190342,
	FGTS_ID                                  = 1398032198,
	HCLR_ID                                  = 1380729672,
	OFST_ID                                  = 1414743631,
	SNDD_ID                                  = 1145327187,
	SNDX_ID                                  = 1480871507,
	CSCR_ID                                  = 1380143939,
	CSDT_ID                                  = 1413763907,
	CSDF_ID                                  = 1178882883,
	CSDI_ID                                  = 1229214531,
	CSDC_ID                                  = 1128551235,
	CSTD_ID                                  = 1146377027,
	CSAD_ID                                  = 1145131843,
	WLST_ID                                  = 1414745175,
	LVSR_ID                                  = 1347638860,
	EFSD_ID                                  = 1146308165,
	DMTL_ID                                  = 1280593220,
	XXXX_ID                                  = 1482184792,
	ChunkID_MAX                              = 1514555727,
};

// Enum Altar.FormID
// NumValues: 0x0048
enum class EFormID : uint8
{
	NO_FORM                                  = 0,
	TES4_ID                                  = 1,
	GRUP_ID                                  = 2,
	GMST_ID                                  = 3,
	GLOB_ID                                  = 4,
	CLAS_ID                                  = 5,
	FACT_ID                                  = 6,
	HAIR_ID                                  = 7,
	EYES_ID                                  = 8,
	RACE_ID                                  = 9,
	SOUN_ID                                  = 10,
	SKIL_ID                                  = 11,
	MGEF_ID                                  = 12,
	SCPT_ID                                  = 13,
	LTEX_ID                                  = 14,
	ENCH_ID                                  = 15,
	SPEL_ID                                  = 16,
	BSGN_ID                                  = 17,
	ACTI_ID                                  = 18,
	APPA_ID                                  = 19,
	ARMO_ID                                  = 20,
	BOOK_ID                                  = 21,
	CLOT_ID                                  = 22,
	CONT_ID                                  = 23,
	DOOR_ID                                  = 24,
	INGR_ID                                  = 25,
	LIGH_ID                                  = 26,
	MISC_ID                                  = 27,
	STAT_ID                                  = 28,
	GRAS_ID                                  = 29,
	TREE_ID                                  = 30,
	FLOR_ID                                  = 31,
	FURN_ID                                  = 32,
	WEAP_ID                                  = 33,
	AMMO_ID                                  = 34,
	NPC__ID                                  = 35,
	CREA_ID                                  = 36,
	LVLC_ID                                  = 37,
	SLGM_ID                                  = 38,
	KEYM_ID                                  = 39,
	ALCH_ID                                  = 40,
	SBSP_ID                                  = 41,
	SGST_ID                                  = 42,
	LVLI_ID                                  = 43,
	SNDG_ID                                  = 44,
	WTHR_ID                                  = 45,
	CLMT_ID                                  = 46,
	REGN_ID                                  = 47,
	CELL_ID                                  = 48,
	REFR_ID                                  = 49,
	ACHR_ID                                  = 50,
	ACRE_ID                                  = 51,
	PGRD_ID                                  = 52,
	WRLD_ID                                  = 53,
	LAND_ID                                  = 54,
	TLOD_ID                                  = 55,
	ROAD_ID                                  = 56,
	DIAL_ID                                  = 57,
	INFO_ID                                  = 58,
	QUST_ID                                  = 59,
	IDLE_ID                                  = 60,
	PACK_ID                                  = 61,
	CSTY_ID                                  = 62,
	LSCR_ID                                  = 63,
	LVSP_ID                                  = 64,
	ANIO_ID                                  = 65,
	WATR_ID                                  = 66,
	EFSH_ID                                  = 67,
	TOFT_ID                                  = 68,
	LVRG_ID                                  = 69,
	FORM_ID_COUNT                            = 70,
	FormID_MAX                               = 71,
};

// Enum Altar.FormGroupType
// NumValues: 0x000C
enum class EFormGroupType : uint8
{
	FGT_TYPE                                 = 0,
	FGT_WORLDCHILD                           = 1,
	FGT_INTCELLBLOCK                         = 2,
	FGT_INTCELLSUBBLOCK                      = 3,
	FGT_EXTCELLBLOCK                         = 4,
	FGT_EXTCELLSUBBLOCK                      = 5,
	FGT_CELLCHILD                            = 6,
	FGT_TOPICCHILD                           = 7,
	FGT_PERSISTENTCHILD                      = 8,
	FGT_TEMPCHILD                            = 9,
	FGT_DISTANTCHILD                         = 10,
	FGT_MAX                                  = 11,
};

// Enum Altar.EFurnitureFlags
// NumValues: 0x0003
enum class EFurnitureFlags : uint8
{
	CanSit                                   = 1,
	CanSleep                                 = 2,
	EFurnitureFlags_MAX                      = 3,
};

// Enum Altar.GrassWaterState
// NumValues: 0x000A
enum class EGrassWaterState : uint32
{
	GWS_ABOVE_ONLY_ATLEAST                   = 0,
	GWS_ABOVE_ONLY_ATMOST                    = 1,
	GWS_BELOW_ONLY_ATLEAST                   = 2,
	GWS_BELOW_ONLY_ATMOST                    = 3,
	GWS_BOTH_ATLEAST                         = 4,
	GWS_BOTH_ATMOST                          = 5,
	GWS_BOTH_ATMOST_ABOVE                    = 6,
	GWS_BOTH_ATMOST_BELOW                    = 7,
	GWS_COUNT                                = 8,
	GWS_MAX                                  = 9,
};

// Enum Altar.EHairFlags
// NumValues: 0x0006
enum class EHairFlags : uint8
{
	None                                     = 0,
	Playable                                 = 1,
	NoMale                                   = 2,
	NoFemale                                 = 4,
	FixedColor                               = 8,
	EHairFlags_MAX                           = 9,
};

// Enum Altar.EIngredientFlags
// NumValues: 0x0003
enum class EIngredientFlags : uint8
{
	CostOverride                             = 1,
	FoodItem                                 = 2,
	EIngredientFlags_MAX                     = 3,
};

// Enum Altar.EApparatusType
// NumValues: 0x0005
enum class EApparatusType : uint8
{
	APPARATUS_MORTAR_PESTLE                  = 0,
	APPARATUS_ALEMBIC                        = 1,
	APPARATUS_CALCINATOR                     = 2,
	APPARATUS_RETORT                         = 3,
	APPARATUS_MAX                            = 4,
};

// Enum Altar.EBookFlags
// NumValues: 0x0003
enum class EBookFlags : uint8
{
	Scroll                                   = 1,
	CantTake                                 = 2,
	EBookFlags_MAX                           = 3,
};

// Enum Altar.EContainerFlags
// NumValues: 0x0002
enum class EContainerFlags : uint8
{
	Respawn                                  = 2,
	EContainerFlags_MAX                      = 3,
};

// Enum Altar.EDoorFlags
// NumValues: 0x0005
enum class EDoorFlags : uint8
{
	OblivionGate                             = 1,
	Automatic                                = 2,
	Hidden                                   = 4,
	MinimalUse                               = 8,
	EDoorFlags_MAX                           = 9,
};

// Enum Altar.EWeaponFlags
// NumValues: 0x0002
enum class EWeaponFlags : uint8
{
	IgnoreResist                             = 1,
	EWeaponFlags_MAX                         = 2,
};

// Enum Altar.EOblivionWeaponType
// NumValues: 0x0008
enum class EOblivionWeaponType : uint8
{
	NONE                                     = 0,
	BLADE_ONE_HAND                           = 1,
	BLADE_TWO_HAND                           = 2,
	BLUNT_ONE_HAND                           = 3,
	BLUNT_TWO_HAND                           = 4,
	STAFF                                    = 5,
	MARKSMAN_BOW                             = 6,
	EOblivionWeaponType_MAX                  = 7,
};

// Enum Altar.EScriptType
// NumValues: 0x0004
enum class EScriptType : uint8
{
	Object                                   = 0,
	Quest                                    = 1,
	MagicEffect                              = 2,
	EScriptType_MAX                          = 3,
};

// Enum Altar.ESoulLevel
// NumValues: 0x0007
enum class ESoulLevel : uint8
{
	None                                     = 0,
	Petty                                    = 1,
	Lesser                                   = 2,
	Common                                   = 3,
	Greater                                  = 4,
	Grand                                    = 5,
	ESoulLevel_MAX                           = 6,
};

// Enum Altar.EAttackActionType
// NumValues: 0x0004
enum class EAttackActionType : uint8
{
	NORMAL_ATTACK                            = 0,
	POWER_ATTACK                             = 1,
	ATTACK_ACTION_COUNT                      = 2,
	EAttackActionType_MAX                    = 3,
};

// Enum Altar.EDIALOGUE_EMOTION
// NumValues: 0x0009
enum class EDIALOGUE_EMOTION : uint8
{
	DE_NEUTRAL                               = 0,
	DE_ANGER                                 = 1,
	DE_DISGUST                               = 2,
	DE_FEAR                                  = 3,
	DE_SAD                                   = 4,
	DE_HAPPY                                 = 5,
	DE_SURPRISE                              = 6,
	DIALOGUE_EMOTION_COUNT                   = 7,
	EDIALOGUE_MAX                            = 8,
};

// Enum Altar.EGroundMaterialType
// NumValues: 0x0023
enum class EGroundMaterialType : uint8
{
	MT_STONE                                 = 0,
	MT_CLOTH                                 = 1,
	MT_DIRT                                  = 2,
	MT_GLASS                                 = 3,
	MT_GRASS                                 = 4,
	MT_METAL                                 = 5,
	MT_ORGANIC                               = 6,
	MT_SKIN                                  = 7,
	MT_WATER                                 = 8,
	MT_WOOD                                  = 9,
	MT_HEAVYSTONE                            = 10,
	MT_HEAVYMETAL                            = 11,
	MT_HEAVYWOOD                             = 12,
	MT_CHAIN                                 = 13,
	MT_SNOW                                  = 14,
	MT_STAIRS                                = 15,
	MT_STONESTAIRS                           = 15,
	MT_CLOTHSTAIRS                           = 16,
	MT_DIRTSTAIRS                            = 17,
	MT_GLASSSTAIRS                           = 18,
	MT_GRASSSTAIRS                           = 19,
	MT_METALSTAIRS                           = 20,
	MT_ORGANICSTAIRS                         = 21,
	MT_SKINSTAIRS                            = 22,
	MT_WATERSTAIRS                           = 23,
	MT_WOODSTAIRS                            = 24,
	MT_HEAVYSTONESTAIRS                      = 25,
	MT_HEAVYMETALSTAIRS                      = 26,
	MT_HEAVYWOODSTAIRS                       = 27,
	MT_CHAINSTAIRS                           = 28,
	MT_SNOWSTAIRS                            = 29,
	MT_ELEVATOR                              = 30,
	MT_TOTAL                                 = 31,
	MT_INVALID                               = 31,
	MT_MAX                                   = 32,
};

// Enum Altar.EMenuMode
// NumValues: 0x0007
enum class EMenuMode : uint8
{
	MENU_MODE_DISABLED                       = 0,
	MENU_MODE_OFF                            = 1,
	MENU_MODE_ON                             = 2,
	MENU_MODE_ENTERING                       = 3,
	MENU_MODE_LEAVING                        = 4,
	MENU_MODE_FIRST_PASS                     = 5,
	MENU_MODE_MAX                            = 6,
};

// Enum Altar.EMenus
// NumValues: 0x0036
enum class EMenus : uint16
{
	NO_MENU                                  = 0,
	MAIN_FOUR                                = 1,
	OTHER_ROOT                               = 2,
	CONSOLE_MENU                             = 3,
	MESSAGE_MENU                             = 1001,
	INVENTORY_MENU                           = 1002,
	STATS_MENU                               = 1003,
	HUD_MAIN_MENU                            = 1004,
	HUD_INFO_MENU                            = 1005,
	HUD_RETICLE                              = 1006,
	LOADING_MENU                             = 1007,
	CONTAINER_MENU                           = 1008,
	DIALOG_MENU                              = 1009,
	HUD_SUBTITLE_MENU                        = 1010,
	GENERIC_MENU                             = 1011,
	SLEEP_WAIT_MENU                          = 1012,
	PAUSE_MENU                               = 1013,
	LOCK_PICK_MENU                           = 1014,
	OPTION_MENU                              = 1015,
	QUANTITY_MENU                            = 1016,
	AUDIO_MENU                               = 1017,
	VIDEO_MENU                               = 1018,
	VIDEO_DISPLAY_MENU                       = 1019,
	GAMEPLAY_MENU                            = 1020,
	CONTROLS_MENU                            = 1021,
	MAGIC_MENU                               = 1022,
	MAP_MENU                                 = 1023,
	MAGIC_POPUP_MENU                         = 1024,
	NEGOTIATE_MENU                           = 1025,
	BOOK_MENU                                = 1026,
	LEVEL_UP_MENU                            = 1027,
	TRAINING_MENU                            = 1028,
	BIRTH_SIGN_MENU                          = 1029,
	CLASS_MENU                               = 1030,
	SKILL_MENU                               = 1032,
	PERSUASION_MENU                          = 1034,
	REPAIR_MENU                              = 1035,
	RACE_SEXE_MENU                           = 1036,
	SPELL_PURCHASE_MENU                      = 1037,
	LOAD_MENU                                = 1038,
	SAVE_MENU                                = 1039,
	ALCHEMY_MENU                             = 1040,
	SPELL_MAKING_MENU                        = 1041,
	ENCHANTMENT_MENU                         = 1042,
	EFFECT_SETTING_MENU                      = 1043,
	MAIN_MENU                                = 1044,
	BREATH_MENU                              = 1045,
	QUICK_KEYS_MENU                          = 1046,
	CREDITS_MENU                             = 1047,
	SIGIL_STONE_MENU                         = 1048,
	RECHARGE_MENU                            = 1049,
	DOWNLOAD_MENU                            = 1050,
	TEXT_EDIT_MENU                           = 1051,
	EMenus_MAX                               = 1052,
};

// Enum Altar.EVActorBehaviorState
// NumValues: 0x0006
enum class EVActorBehaviorState : uint8
{
	WAITING                                  = 0,
	STARTED                                  = 1,
	ONGOING                                  = 2,
	INTERRUPTED                              = 3,
	ENDED                                    = 4,
	EVActorBehaviorState_MAX                 = 5,
};

// Enum Altar.EEquipmentSocketID
// NumValues: 0x000D
enum class EEquipmentSocketID : uint64
{
	EQUIP_SOCKET_ID_NONE                     = 18446744073709551615,
	EQUIP_SOCKET_ID_TORCH                    = 0,
	EQUIP_SOCKET_ID_WEAPON                   = 1,
	EQUIP_SOCKET_ID_BACKWEAPON               = 2,
	EQUIP_SOCKET_ID_QUIVER                   = 3,
	EQUIP_SOCKET_ID_MAGIC                    = 4,
	EQUIP_SOCKET_ID_SIDEWEAPON               = 5,
	EQUIP_SOCKET_ID_SHIELD                   = 6,
	EQUIP_SOCKET_ID_ARROW                    = 7,
	EQUIP_SOCKET_ID_BACKWEAPON_BOW           = 8,
	EQUIP_SOCKET_ID_MIN                      = 0,
	EQUIP_SOCKET_ID_MAX                      = 8,
	EQUIP_SOCKET_ID_COUNT                    = 9,
};

// Enum Altar.EComposedWeaponPart
// NumValues: 0x0004
enum class EComposedWeaponPart : uint8
{
	COMPOSED_WEAPON_ALL                      = 0,
	COMPOSED_WEAPON_CONTAINER                = 1,
	COMPOSED_WEAPON_NUDE                     = 2,
	COMPOSED_WEAPON_MAX                      = 3,
};

// Enum Altar.EVAttribute
// NumValues: 0x0009
enum class EVAttribute : uint8
{
	Strength                                 = 0,
	Intelligence                             = 1,
	Willpower                                = 2,
	Agility                                  = 3,
	Speed                                    = 4,
	Endurance                                = 5,
	Personality                              = 6,
	Luck                                     = 7,
	EVAttribute_MAX                          = 8,
};

// Enum Altar.EVSkillLevel
// NumValues: 0x0007
enum class EVSkillLevel : uint8
{
	Novice                                   = 0,
	Apprentice                               = 1,
	Journeyman                               = 2,
	Expert                                   = 3,
	Master                                   = 4,
	SkillLevelCount                          = 5,
	EVSkillLevel_MAX                         = 6,
};

// Enum Altar.EVSkill
// NumValues: 0x0017
enum class EVSkill : uint8
{
	DEFAULT                                  = 0,
	Armorer                                  = 12,
	Athletics                                = 13,
	Blade                                    = 14,
	Block                                    = 15,
	Blunt                                    = 16,
	Handtohand                               = 17,
	Heavyarmor                               = 18,
	Alchemy                                  = 19,
	Alteration                               = 20,
	Conjuration                              = 21,
	Destruction                              = 22,
	Illusion                                 = 23,
	Mysticism                                = 24,
	Restoration                              = 25,
	Acrobatics                               = 26,
	Lightarmor                               = 27,
	Marksman                                 = 28,
	Mercantile                               = 29,
	Security                                 = 30,
	Sneak                                    = 31,
	Speechcraft                              = 32,
	EVSkill_MAX                              = 33,
};

// Enum Altar.EVApparatusType
// NumValues: 0x0005
enum class EVApparatusType : uint8
{
	APPARATUS_Mortar                         = 0,
	APPARATUS_Alembic                        = 1,
	APPARATUS_Retort                         = 2,
	APPARATUS_Calcinator                     = 3,
	APPARATUS_MAX                            = 4,
};

// Enum Altar.EVAltarAchievement
// NumValues: 0x0040
enum class EVAltarAchievement : uint8
{
	INVALID                                  = 0,
	Main_EscapedTheImperialSewers            = 1,
	Main_ClosedAnOblivionGate                = 2,
	Main_LocatedTheShrineOfDragon            = 3,
	Main_DeliveredDaedricArtifact            = 4,
	Main_DestroyedTheGreatGate               = 5,
	Main_ChampionOfCyrodiil                  = 6,
	Brother_Murderer                         = 7,
	Brother_Slayer                           = 8,
	Brother_Eliminator                       = 9,
	Brother_Assassin                         = 10,
	Brother_Silencer                         = 11,
	Brother_Speaker                          = 12,
	Brother_Listener                         = 13,
	Arena_PitDog                             = 14,
	Arena_Brawler                            = 15,
	Arena_Bloodletter                        = 16,
	Arena_Myrmidon                           = 17,
	Arena_Warrior                            = 18,
	Arena_Gladiator                          = 19,
	Arena_Hero                               = 20,
	Arena_Champion                           = 21,
	Arena_GrandChampion                      = 22,
	Thief_Pickpocket                         = 23,
	Thief_Footpad                            = 24,
	Thief_Bandit                             = 25,
	Thief_Prowler                            = 26,
	Thief_CatBurglar                         = 27,
	Thief_Shadowfoot                         = 28,
	Thief_MasterThief                        = 29,
	Thief_Guildmaster                        = 30,
	Mage_Associate                           = 31,
	Mage_Apprentice                          = 32,
	Mage_Journeyman                          = 33,
	Mage_Evoker                              = 34,
	Mage_Conjurer                            = 35,
	Mage_Magician                            = 36,
	Mage_Warlock                             = 37,
	Mage_Wizard                              = 38,
	Mage_MasterWizard                        = 39,
	Mage_ArchMage                            = 40,
	Fighter_Associate                        = 41,
	Fighter_Apprentice                       = 42,
	Fighter_Journeyman                       = 43,
	Fighter_Swordsman                        = 44,
	Fighter_Protector                        = 45,
	Fighter_Defender                         = 46,
	Fighter_Warder                           = 47,
	Fighter_Guardian                         = 48,
	Fighter_Champion                         = 49,
	Fighter_Master                           = 50,
	Isles_Tourist                            = 51,
	Isles_Aspirant                           = 52,
	Isles_Citizen                            = 53,
	Isles_Madman                             = 54,
	Isles_HonoredMadman                      = 55,
	Isles_DukeDementia                       = 56,
	Isles_DukeMania                          = 57,
	Isles_Regent                             = 58,
	Isles_Defender                           = 59,
	Isles_Madgod                             = 60,
	LAST_OBLIVION_ACHIEVEMENT                = 60,
	COUNT                                    = 61,
	EVAltarAchievement_MAX                   = 62,
};

// Enum Altar.EGPUType
// NumValues: 0x0005
enum class EGPUType : uint8
{
	OTHER                                    = 0,
	NVIDIA                                   = 1,
	AMD                                      = 2,
	INTEL                                    = 3,
	EGPUType_MAX                             = 4,
};

// Enum Altar.EExecBranch
// NumValues: 0x0003
enum class EExecBranch : uint8
{
	No                                       = 0,
	Yes                                      = 1,
	EExecBranch_MAX                          = 2,
};

// Enum Altar.EUserInputTextValidityCode
// NumValues: 0x0008
enum class EUserInputTextValidityCode : uint8
{
	Valid                                    = 0,
	ContainsDigit                            = 1,
	ContainsSpecialCharacter                 = 2,
	IsEmpty                                  = 3,
	ContainsOnlyWhiteSpace                   = 4,
	TooLong                                  = 5,
	None                                     = 6,
	EUserInputTextValidityCode_MAX           = 7,
};

// Enum Altar.EUpscalingMethod
// NumValues: 0x0005
enum class EUpscalingMethod : uint8
{
	UPSCALER_NONE                            = 0,
	UPSCALER_DLSS                            = 1,
	UPSCALER_FSR3                            = 2,
	UPSCALER_XESS                            = 3,
	UPSCALER_MAX                             = 4,
};

// Enum Altar.EVSyncOption
// NumValues: 0x0006
enum class EVSyncOption : uint8
{
	VSYNC_OFF                                = 0,
	VSYNC_MATCHING_REFRESH_RATE              = 1,
	VSYNC_HALF_SCREEN_REFRESH_RATE           = 2,
	VSYNC_ONE_THIRD_SCREEN_REFRESH_RATE      = 3,
	VSYNC_QUARTER_SCREEN_REFRESH_RATE        = 4,
	VSYNC_MAX                                = 5,
};

// Enum Altar.EMoonPhase
// NumValues: 0x000A
enum class EMoonPhase : uint8
{
	PH_FULL                                  = 0,
	PH_3Q_WAN                                = 1,
	PH_HALF_WAN                              = 2,
	PH_1Q_WAN                                = 3,
	PH_NEW                                   = 4,
	PH_1Q_WAX                                = 5,
	PH_HALF_WAX                              = 6,
	PH_3Q_WAX                                = 7,
	NUM_PHASES                               = 8,
	EMoonPhase_MAX                           = 9,
};

// Enum Altar.EVPlayerPOVType
// NumValues: 0x0005
enum class EVPlayerPOVType : uint8
{
	FirstPerson                              = 0,
	ThirdPersonClose                         = 1,
	ThirdPersonFar                           = 2,
	Customization                            = 3,
	EVPlayerPOVType_MAX                      = 4,
};

// Enum Altar.EVModernRichTextBlockFontSizeChannel
// NumValues: 0x0004
enum class EVModernRichTextBlockFontSizeChannel : uint8
{
	General                                  = 0,
	Subtitle                                 = 1,
	None                                     = 2,
	EVModernRichTextBlockFontSizeChannel_MAX = 3,
};

// Enum Altar.EVAltarCompressionMethod
// NumValues: 0x0006
enum class EVAltarCompressionMethod : uint32
{
	None                                     = 0,
	Zlib                                     = 257,
	Gzip                                     = 258,
	LZ4                                      = 259,
	Oodle                                    = 261,
	EVAltarCompressionMethod_MAX             = 262,
};

// Enum Altar.EVSaveType
// NumValues: 0x0004
enum class EVSaveType : uint32
{
	Manual                                   = 0,
	Auto                                     = 1,
	Quick                                    = 2,
	EVSaveType_MAX                           = 3,
};

// Enum Altar.EVGetOblivionSaveDataResult
// NumValues: 0x0005
enum class EVGetOblivionSaveDataResult : uint8
{
	SaveSystemIsBusy                         = 0,
	Success                                  = 1,
	PlayerNeedToDownload                     = 2,
	ErrorSaveDeletedOrCorrupted              = 3,
	EVGetOblivionSaveDataResult_MAX          = 4,
};

// Enum Altar.EVSaveSystemError
// NumValues: 0x0006
enum class EVSaveSystemError : uint8
{
	Unknown                                  = 0,
	SaveSystemBusy                           = 1,
	SaveNotFound                             = 2,
	SaveCorrupted                            = 3,
	NotEnoughDiskSpace                       = 4,
	EVSaveSystemError_MAX                    = 5,
};

// Enum Altar.EVSaveSystemStatus
// NumValues: 0x0006
enum class EVSaveSystemStatus : uint8
{
	SavingGame                               = 0,
	SavingMetaData                           = 1,
	WaitingForOblivionSaveGameLoad           = 2,
	Loading                                  = 3,
	Done                                     = 4,
	EVSaveSystemStatus_MAX                   = 5,
};

// Enum Altar.EVAltarBIHardwarePlatform
// NumValues: 0x0006
enum class EVAltarBIHardwarePlatform : uint8
{
	Desktop                                  = 0,
	XSX                                      = 1,
	XSS                                      = 2,
	PS5                                      = 3,
	PS5_Pro                                  = 4,
	EVAltarBIHardwarePlatform_MAX            = 5,
};

// Enum Altar.EVAltarBIGraphicsQuality
// NumValues: 0x000C
enum class EVAltarBIGraphicsQuality : uint64
{
	Invalid                                  = 18446744073709551615,
	Unknown                                  = 18446744073709551615,
	Custom                                   = 0,
	Cinematic                                = 1,
	Ultra                                    = 2,
	High                                     = 3,
	Medium                                   = 4,
	Low                                      = 5,
	Console_Quality                          = 6,
	Console_Performance                      = 7,
	Console_XSS_Locked                       = 8,
	EVAltarBIGraphicsQuality_MAX             = 9,
};

// Enum Altar.EVAltarPerformanceContextFlags
// NumValues: 0x0006
enum class EVAltarPerformanceContextFlags : uint8
{
	Startup                                  = 1,
	LoadingScreen                            = 2,
	PlayerLoadGame                           = 4,
	PlayerSaveGame                           = 8,
	UiMenuVisiblePaused                      = 16,
	EVAltarPerformanceContextFlags_MAX       = 17,
};

// Enum Altar.EVModernTextBlockFontSizeChannel
// NumValues: 0x0004
enum class EVModernTextBlockFontSizeChannel : uint8
{
	General                                  = 0,
	Subtitle                                 = 1,
	None                                     = 2,
	EVModernTextBlockFontSizeChannel_MAX     = 3,
};

// Enum Altar.EMoonOblivion
// NumValues: 0x0003
enum class EMoonOblivion : uint8
{
	MOON_MASSER                              = 0,
	MOON_SECUNDA                             = 1,
	MOON_MAX                                 = 2,
};

// Enum Altar.EVCountryGroup
// NumValues: 0x0006
enum class EVCountryGroup : uint8
{
	SIEA                                     = 0,
	SIEE                                     = 1,
	SIEJA_Asia                               = 2,
	SIEJA_Japan                              = 3,
	None                                     = 4,
	EVCountryGroup_MAX                       = 5,
};

// Enum Altar.EAmbientDelimiterStatus
// NumValues: 0x0004
enum class EAmbientDelimiterStatus : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EAmbientDelimiterStatus_MAX              = 3,
};

// Enum Altar.EOblivionAnimAction
// NumValues: 0x0010
enum class EOblivionAnimAction : uint8
{
	ANIM_ACTION_NONE                         = 0,
	ANIM_ACTION_EQUIP_WEAPON                 = 1,
	ANIM_ACTION_UNEQUIP_WEAPON               = 2,
	ANIM_ACTION_ATTACK                       = 3,
	ANIM_ACTION_ATTACK_FOLLOW_THROUGH        = 4,
	ANIM_ACTION_ATTACK_BOW                   = 5,
	ANIM_ACTION_ATTACK_BOW_ARROW_ATTACHED    = 6,
	ANIM_ACTION_BLOCK                        = 7,
	ANIM_ACTION_RECOIL                       = 8,
	ANIM_ACTION_STAGGER                      = 9,
	ANIM_ACTION_DODGE                        = 10,
	ANIM_ACTION_WAIT_FOR_LOWER_BODY_ANIM     = 11,
	ANIM_ACTION_WAIT_FOR_SPECIAL_IDLE        = 12,
	ANIM_ACTION_FORCE_SCRIPT_ANIM            = 13,
	ANIM_ACTION_COUNT                        = 14,
	ANIM_ACTION_MAX                          = 15,
};

// Enum Altar.EOblivionMovementType
// NumValues: 0x000A
enum class EOblivionMovementType : uint8
{
	NONE                                     = 0,
	WALKING                                  = 1,
	RUNNING                                  = 2,
	SNEAKING                                 = 4,
	SWIMMING                                 = 8,
	JUMPING                                  = 16,
	FLYING                                   = 32,
	FALLING                                  = 64,
	SLIDING                                  = 128,
	EOblivionMovementType_MAX                = 129,
};

// Enum Altar.EOblivionMovementDirection
// NumValues: 0x0008
enum class EOblivionMovementDirection : uint8
{
	NONE                                     = 0,
	DIRECTION_FORWARD                        = 1,
	DIRECTION_BACKWARD                       = 2,
	DIRECTION_LEFT                           = 4,
	DIRECTION_RIGHT                          = 8,
	TURN_LEFT                                = 16,
	TURN_RIGHT                               = 32,
	EOblivionMovementDirection_MAX           = 33,
};

// Enum Altar.EVEquipAction
// NumValues: 0x0003
enum class EVEquipAction : uint8
{
	Equip                                    = 0,
	Unequip                                  = 1,
	EVEquipAction_MAX                        = 2,
};

// Enum Altar.EVOpenCloseAction
// NumValues: 0x0003
enum class EVOpenCloseAction : uint8
{
	Open                                     = 0,
	Close                                    = 1,
	EVOpenCloseAction_MAX                    = 2,
};

// Enum Altar.EVBloodColor
// NumValues: 0x0006
enum class EVBloodColor : uint8
{
	Red                                      = 0,
	Green                                    = 1,
	Blue                                     = 2,
	Black                                    = 3,
	Gold                                     = 4,
	EVBloodColor_MAX                         = 5,
};

// Enum Altar.ELegacyBookTagType
// NumValues: 0x0004
enum class ELegacyBookTagType : uint8
{
	Font                                     = 0,
	Color                                    = 1,
	Alignment                                = 2,
	ELegacyBookTagType_MAX                   = 3,
};

// Enum Altar.ELegacyBookStylizedTextAlignment
// NumValues: 0x0004
enum class ELegacyBookStylizedTextAlignment : uint8
{
	Left                                     = 0,
	Center                                   = 1,
	Right                                    = 2,
	ELegacyBookStylizedTextAlignment_MAX     = 3,
};

// Enum Altar.EVBossCategory
// NumValues: 0x0005
enum class EVBossCategory : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Quest                                    = 2,
	Dungeon                                  = 3,
	EVBossCategory_MAX                       = 4,
};

// Enum Altar.ECharacterType
// NumValues: 0x0030
enum class ECharacterType : uint8
{
	HUMANOID                                 = 0,
	ATRONACH                                 = 1,
	BALIWOG                                  = 2,
	BEAR                                     = 3,
	BOAR                                     = 4,
	CLANN_FEAR                               = 5,
	DAEDROTH                                 = 6,
	DEER                                     = 7,
	DOG                                      = 8,
	ELYTRA                                   = 9,
	FLAME_ATRONACH                           = 10,
	FLESH_ATRONACH                           = 11,
	FROST_ATRONACH                           = 12,
	GATE_KEEPER                              = 13,
	GHOST                                    = 14,
	GNARL                                    = 15,
	GOBLIN                                   = 16,
	GRUMMITE                                 = 17,
	HORSE                                    = 18,
	HUNGER                                   = 19,
	IMP                                      = 20,
	JYGGALAG                                 = 21,
	LAND_DREUGH                              = 22,
	LICH                                     = 23,
	MEHRUNES_DAGON                           = 24,
	MINOTAUR                                 = 25,
	MOUNTAIN_LION                            = 26,
	MUDCRAB                                  = 27,
	MURK_DWELLER                             = 28,
	OGRE                                     = 29,
	RAT                                      = 30,
	SCAMP                                    = 31,
	SHAMBLES                                 = 32,
	SHEEP                                    = 33,
	SIEGE_CRAWLER                            = 34,
	SKELETON                                 = 35,
	SKINNED_HOUND                            = 36,
	SLAUGHTERFISH                            = 37,
	SPIDER_DAEDRA                            = 38,
	SPRIGGAN                                 = 39,
	STORM_ATRONACH                           = 40,
	TROLL                                    = 41,
	WILL_O_THE_WISP                          = 42,
	WOLF                                     = 43,
	WRAITH                                   = 44,
	XIVILAI                                  = 45,
	ZOMBIE                                   = 46,
	ECharacterType_MAX                       = 47,
};

// Enum Altar.ECharacterCombatMoveset
// NumValues: 0x0006
enum class ECharacterCombatMoveset : uint8
{
	HAND_TO_HAND                             = 0,
	ONE_HANDED                               = 1,
	TWO_HANDED                               = 2,
	STAFF                                    = 3,
	BOW                                      = 4,
	ECharacterCombatMoveset_MAX              = 5,
};

// Enum Altar.ECharacterAttackMove
// NumValues: 0x0008
enum class ECharacterAttackMove : uint8
{
	LEFT                                     = 0,
	RIGHT                                    = 1,
	NORMAL_POWER                             = 2,
	FORWARD_POWER                            = 3,
	BACKWARD_POWER                           = 4,
	LEFT_POWER                               = 5,
	RIGHT_POWER                              = 6,
	ECharacterAttackMove_MAX                 = 7,
};

// Enum Altar.ECharacterSex
// NumValues: 0x0003
enum class ECharacterSex : uint8
{
	MALE                                     = 0,
	FEMALE                                   = 1,
	ECharacterSex_MAX                        = 2,
};

// Enum Altar.EVCharacterParameterType
// NumValues: 0x0003
enum class EVCharacterParameterType : uint32
{
	Simple                                   = 0,
	Color                                    = 1,
	EVCharacterParameterType_MAX             = 2,
};

// Enum Altar.ECharacterFadeState
// NumValues: 0x0004
enum class ECharacterFadeState : uint32
{
	FadeNone                                 = 0,
	FadeIn                                   = 1,
	FadeOut                                  = 2,
	ECharacterFadeState_MAX                  = 3,
};

// Enum Altar.EVCinematicType
// NumValues: 0x0004
enum class EVCinematicType : uint32
{
	EmperorAssassination                     = 0,
	EndGameFight                             = 1,
	Count                                    = 2,
	EVCinematicType_MAX                      = 3,
};

// Enum Altar.EVDetectionLightingObstructionTracesType
// NumValues: 0x0004
enum class EVDetectionLightingObstructionTracesType : uint8
{
	CentersOnly                              = 0,
	LightsCenterToPlayerShoulders            = 1,
	LightEdgesToPlayerFourPoints             = 2,
	EVDetectionLightingObstructionTracesType_MAX = 3,
};

// Enum Altar.EVDetectionLightTag
// NumValues: 0x0004
enum class EVDetectionLightTag : uint8
{
	None                                     = 0,
	Fake                                     = 1,
	Skip                                     = 2,
	EVDetectionLightTag_MAX                  = 3,
};

// Enum Altar.EVDetectionLightingLineTracePosition
// NumValues: 0x0006
enum class EVDetectionLightingLineTracePosition : uint8
{
	Center                                   = 0,
	Top                                      = 1,
	Left                                     = 2,
	Right                                    = 3,
	Bottom                                   = 4,
	EVDetectionLightingLineTracePosition_MAX = 5,
};

// Enum Altar.LegacyDialogButton
// NumValues: 0x0008
enum class ELegacyDialogButton : uint8
{
	Persuasion                               = 0,
	Barter                                   = 1,
	SpellBarter                              = 2,
	Repairing                                = 3,
	Training                                 = 4,
	Recharging                               = 5,
	Goodbye                                  = 6,
	LegacyDialogButton_MAX                   = 7,
};

// Enum Altar.ESitSleepState
// NumValues: 0x000D
enum class ESitSleepState : uint8
{
	NORMAL                                   = 0,
	LOAD_SIT_IDLE                            = 1,
	WANT_TO_SIT                              = 2,
	WAITING_FOR_SIT_ANIM                     = 3,
	IS_SITTING                               = 4,
	WANT_TO_STAND                            = 5,
	LOAD_SLEEP_IDLE                          = 6,
	WANT_TO_SLEEP                            = 7,
	WAITING_FOR_SLEEP_ANIM                   = 8,
	IS_SLEEPING                              = 9,
	WANT_TO_WAKE                             = 10,
	COUNT                                    = 11,
	ESitSleepState_MAX                       = 12,
};

// Enum Altar.EDodgeDirection
// NumValues: 0x000A
enum class EDodgeDirection : uint8
{
	NONE                                     = 10,
	Right                                    = 0,
	BackRight                                = 1,
	Back                                     = 2,
	BackLeft                                 = 3,
	Left                                     = 4,
	ForwardLeft                              = 5,
	Forward                                  = 6,
	ForwardRight                             = 7,
	EDodgeDirection_MAX                      = 11,
};

// Enum Altar.EMordernLockLevel
// NumValues: 0x0007
enum class EMordernLockLevel : uint8
{
	VeryEasy                                 = 0,
	Easy                                     = 1,
	Average                                  = 2,
	Hard                                     = 3,
	VeryHard                                 = 4,
	Impossible                               = 5,
	EMordernLockLevel_MAX                    = 6,
};

// Enum Altar.ELegacyEffectEntryType
// NumValues: 0x0009
enum class ELegacyEffectEntryType : uint8
{
	Magnitude                                = 0,
	Area                                     = 1,
	Duration                                 = 2,
	Range                                    = 3,
	Attribute                                = 4,
	Skill                                    = 5,
	Lock                                     = 6,
	None                                     = 7,
	ELegacyEffectEntryType_MAX               = 8,
};

// Enum Altar.EFacialPoseType
// NumValues: 0x0003
enum class EFacialPoseType : uint8
{
	Attack                                   = 0,
	HitReaction                              = 1,
	EFacialPoseType_MAX                      = 2,
};

// Enum Altar.EVLocomotionType
// NumValues: 0x0006
enum class EVLocomotionType : uint8
{
	Walking                                  = 0,
	Running                                  = 1,
	SneakingWalking                          = 2,
	SneakingRunning                          = 3,
	Landing                                  = 4,
	EVLocomotionType_MAX                     = 5,
};

// Enum Altar.EVFreezeSubsystemMode
// NumValues: 0x0003
enum class EVFreezeSubsystemMode : uint8
{
	Normal                                   = 0,
	Loading                                  = 1,
	EVFreezeSubsystemMode_MAX                = 2,
};

// Enum Altar.ELegacyGameplayMenuIDs
// NumValues: 0x000C
enum class ELegacyGameplayMenuIDs : uint8
{
	None                                     = 0,
	DifficultyScrollBar                      = 1,
	DifficultyScrollBarMarker                = 2,
	GeneralSubtitlesButton                   = 3,
	DialogueSubtitlesButton                  = 4,
	CrossHairButton                          = 5,
	SaveRestButton                           = 6,
	SaveWaitButton                           = 7,
	SaveTravelButton                         = 8,
	DefaultsButton                           = 9,
	ReturnButton                             = 10,
	ELegacyGameplayMenuIDs_MAX               = 11,
};

// Enum Altar.EVGrabState
// NumValues: 0x0004
enum class EVGrabState : uint8
{
	None                                     = 0,
	HandGrabbed                              = 1,
	TelekinesisGrabbed                       = 2,
	EVGrabState_MAX                          = 3,
};

// Enum Altar.EVTriggerFlags
// NumValues: 0x0005
enum class EVTriggerFlags : uint8
{
	None                                     = 0,
	VFX                                      = 1,
	Gameplay                                 = 2,
	All                                      = 3,
	EVTriggerFlags_MAX                       = 4,
};

// Enum Altar.EVGameplayHitboxBehaviour
// NumValues: 0x0004
enum class EVGameplayHitboxBehaviour : uint32
{
	Default                                  = 0,
	Trap                                     = 1,
	Trigger                                  = 2,
	EVGameplayHitboxBehaviour_MAX            = 3,
};

// Enum Altar.EHitReactionState
// NumValues: 0x0004
enum class EHitReactionState : uint8
{
	Default                                  = 0,
	Reaction                                 = 1,
	Recovery                                 = 2,
	EHitReactionState_MAX                    = 3,
};

// Enum Altar.ELegacyHudInfoIcon
// NumValues: 0x000B
enum class ELegacyHudInfoIcon : uint8
{
	Uses                                     = 0,
	Weight                                   = 1,
	Action                                   = 2,
	Quality                                  = 3,
	Armor                                    = 4,
	Damage                                   = 5,
	Lock                                     = 6,
	Value                                    = 7,
	Health                                   = 8,
	NumIcons                                 = 9,
	ELegacyHudInfoIcon_MAX                   = 10,
};

// Enum Altar.EModernMarkerType
// NumValues: 0x000E
enum class EModernMarkerType : uint8
{
	None                                     = 0,
	Camp                                     = 1,
	Cave                                     = 2,
	City                                     = 3,
	Elvenruin                                = 4,
	Fortruin                                 = 5,
	Mine                                     = 6,
	Mountain                                 = 7,
	Tavern                                   = 8,
	Settlement                               = 9,
	DaedrickShrine                           = 10,
	OblivionGate                             = 11,
	Door                                     = 12,
	EModernMarkerType_MAX                    = 13,
};

// Enum Altar.EModernReticleWeaponBehavior
// NumValues: 0x0004
enum class EModernReticleWeaponBehavior : uint8
{
	Default                                  = 0,
	Range                                    = 1,
	Melee                                    = 2,
	EModernReticleWeaponBehavior_MAX         = 3,
};

// Enum Altar.ELegacyHudReticleIcon
// NumValues: 0x000E
enum class ELegacyHudReticleIcon : uint8
{
	None                                     = 0,
	Take                                     = 1,
	Open                                     = 2,
	Sit                                      = 3,
	Activate                                 = 4,
	Sleep                                    = 5,
	Read                                     = 6,
	Talk                                     = 7,
	OpenDoor                                 = 8,
	Horse                                    = 9,
	Crown                                    = 10,
	Vampire                                  = 11,
	COUNT                                    = 12,
	ELegacyHudReticleIcon_MAX                = 13,
};

// Enum Altar.EVHitSourceMaterial
// NumValues: 0x0005
enum class EVHitSourceMaterial : uint8
{
	Metal                                    = 0,
	Wood                                     = 1,
	Flesh                                    = 2,
	Magical                                  = 3,
	EVHitSourceMaterial_MAX                  = 4,
};

// Enum Altar.EVHitSourceType
// NumValues: 0x0005
enum class EVHitSourceType : uint8
{
	LightAttack                              = 0,
	PowerAttack                              = 1,
	Arrow                                    = 2,
	Other                                    = 3,
	EVHitSourceType_MAX                      = 4,
};

// Enum Altar.EVHitSourceWeaponType
// NumValues: 0x0005
enum class EVHitSourceWeaponType : uint8
{
	Slashing                                 = 0,
	Contending                               = 1,
	Piercing                                 = 2,
	Other                                    = 3,
	EVHitSourceWeaponType_MAX                = 4,
};

// Enum Altar.ECharacterCombatIdles
// NumValues: 0x0006
enum class ECharacterCombatIdles : uint8
{
	HAND_TO_HAND                             = 0,
	ONE_HANDED                               = 1,
	TWO_HANDED                               = 2,
	STAFF                                    = 3,
	BOW                                      = 4,
	ECharacterCombatIdles_MAX                = 5,
};

// Enum Altar.EOriginalInventoryMenuItemStatus
// NumValues: 0x0011
enum class EOriginalInventoryMenuItemStatus : uint8
{
	Stolen                                   = 1,
	Enchanted                                = 2,
	Poisoned                                 = 4,
	Broken                                   = 8,
	Stolen_Enchanted                         = 3,
	Stolen_Poisoned                          = 5,
	Enchanted_Poisoned                       = 6,
	Stolen_Enchanted_Poisoned                = 7,
	Stolen_Broken                            = 9,
	Enchanted_Broken                         = 10,
	Stolen_Enchanted_Broken                  = 11,
	Poisoned_Broken                          = 12,
	Stolen_Poisoned_Broken                   = 13,
	Enchanted_Poisoned_Broken                = 14,
	All                                      = 15,
	None                                     = 0,
	EOriginalInventoryMenuItemStatus_MAX     = 16,
};

// Enum Altar.EOriginalInventoryMenuWeaponSkillAndSize
// NumValues: 0x0007
enum class EOriginalInventoryMenuWeaponSkillAndSize : uint8
{
	Blade_One_Hand                           = 0,
	Blade_Two_Hand                           = 1,
	Blunt_One_Hand                           = 2,
	Blunt_Two_Hand                           = 3,
	Staff                                    = 4,
	Bow                                      = 5,
	EOriginalInventoryMenuWeaponSkillAndSize_MAX = 6,
};

// Enum Altar.EOriginalInventoryMenuArmorClothPart
// NumValues: 0x000C
enum class EOriginalInventoryMenuArmorClothPart : uint8
{
	Head                                     = 0,
	Upper                                    = 2,
	Lower                                    = 3,
	Hand                                     = 4,
	Foot                                     = 5,
	Right_Ring                               = 6,
	Left_Ring                                = 7,
	Amulet                                   = 8,
	Shield                                   = 13,
	Upper_And_Lower                          = 17,
	None                                     = 18,
	EOriginalInventoryMenuArmorClothPart_MAX = 19,
};

// Enum Altar.EOriginalInventoryMenuPotionType
// NumValues: 0x0005
enum class EOriginalInventoryMenuPotionType : uint8
{
	Potion                                   = 0,
	Poison                                   = 1,
	Beverage                                 = 2,
	None                                     = 3,
	EOriginalInventoryMenuPotionType_MAX     = 4,
};

// Enum Altar.EOriginalInventoryMenuBookType
// NumValues: 0x0006
enum class EOriginalInventoryMenuBookType : uint8
{
	Book                                     = 0,
	Scroll                                   = 1,
	Skill_Book                               = 2,
	Spell_Scroll                             = 3,
	None                                     = 4,
	EOriginalInventoryMenuBookType_MAX       = 5,
};

// Enum Altar.ELegacyMapMenuPage
// NumValues: 0x0006
enum class ELegacyMapMenuPage : uint8
{
	LocalMap                                 = 0,
	WorldMap                                 = 1,
	ActiveQuest                              = 2,
	CurrentQuests                            = 3,
	CompletedQuests                          = 4,
	ELegacyMapMenuPage_MAX                   = 5,
};

// Enum Altar.EVSaveNotificationType
// NumValues: 0x0005
enum class EVSaveNotificationType : uint8
{
	EManualSaveSucceeded                     = 0,
	EAutosavingSucceeded                     = 1,
	EQuicksavingSucceeded                    = 2,
	ESaveErrorDiskFull                       = 3,
	EVSaveNotificationType_MAX               = 4,
};

// Enum Altar.ELegacyVideoMenuOptionType
// NumValues: 0x0009
enum class ELegacyVideoMenuOptionType : uint8
{
	None                                     = 0,
	Resolution                               = 1,
	DefaultButton                            = 2,
	TextureSize                              = 3,
	ShadowFiltering                          = 4,
	WaterDetail                              = 5,
	BloodDecal                               = 6,
	AntiAliasing                             = 7,
	ELegacyVideoMenuOptionType_MAX           = 8,
};

// Enum Altar.ELegacyXboxFloatingHintButton
// NumValues: 0x000E
enum class ELegacyXboxFloatingHintButton : uint8
{
	Start                                    = 0,
	Back                                     = 1,
	LeftThumbstick                           = 2,
	RightThumbstick                          = 3,
	A                                        = 4,
	B                                        = 5,
	X                                        = 6,
	Y                                        = 7,
	RightShoulder                            = 8,
	LeftShoulder                             = 9,
	LeftTrigger                              = 10,
	RightTrigger                             = 11,
	None                                     = 12,
	ELegacyXboxFloatingHintButton_MAX        = 13,
};

// Enum Altar.ELoadingScreenType
// NumValues: 0x0005
enum class ELoadingScreenType : uint8
{
	FromLoadingGame                          = 0,
	FromLevelChange                          = 1,
	FromNewGame                              = 2,
	Count                                    = 3,
	ELoadingScreenType_MAX                   = 4,
};

// Enum Altar.ELegacyLockpickMenuDifficulty
// NumValues: 0x0007
enum class ELegacyLockpickMenuDifficulty : uint8
{
	VeryEasy                                 = 0,
	Easy                                     = 1,
	Average                                  = 2,
	Hard                                     = 3,
	VeryHard                                 = 4,
	Impossible                               = 5,
	ELegacyLockpickMenuDifficulty_MAX        = 6,
};

// Enum Altar.EAttemptSuccess
// NumValues: 0x0004
enum class EAttemptSuccess : uint8
{
	NoAttempt                                = 0,
	WasNotSuccessful                         = 1,
	WasSuccessful                            = 2,
	EAttemptSuccess_MAX                      = 3,
};

// Enum Altar.EVVFXType
// NumValues: 0x0005
enum class EVVFXType : uint32
{
	Casting                                  = 0,
	Projectile                               = 1,
	AreaEffect                               = 2,
	HitEffect                                = 3,
	EVVFXType_MAX                            = 4,
};

// Enum Altar.FLegacyMainMenuLogo
// NumValues: 0x0004
enum class EFLegacyMainMenuLogo : uint8
{
	None                                     = 0,
	Blink                                    = 1,
	Final                                    = 2,
	FLegacyMainMenuLogo_MAX                  = 3,
};

// Enum Altar.ELegacyMapMenuIcon
// NumValues: 0x0012
enum class ELegacyMapMenuIcon : uint8
{
	Empty                                    = 0,
	Camp                                     = 1,
	Cave                                     = 2,
	City                                     = 3,
	ElvenRuin                                = 4,
	FortRuin                                 = 5,
	Mine                                     = 6,
	MountainPeak                             = 7,
	Tavern                                   = 8,
	Settlement                               = 9,
	DaedricShrine                            = 10,
	OblivionGate                             = 11,
	Door                                     = 12,
	Quest                                    = 13,
	Player                                   = 14,
	PlayerMarker                             = 15,
	All                                      = 16,
	ELegacyMapMenuIcon_MAX                   = 17,
};

// Enum Altar.EModalMenuLayoutType
// NumValues: 0x000B
enum class EModalMenuLayoutType : uint8
{
	Default                                  = 0,
	QuestAdded                               = 1,
	QuestUpdated                             = 2,
	SkillIncreased                           = 3,
	OutOfPrison                              = 4,
	SellBuy                                  = 5,
	LoadSave                                 = 6,
	RaceSex                                  = 7,
	Recharge                                 = 8,
	Repair                                   = 9,
	EModalMenuLayoutType_MAX                 = 10,
};

// Enum Altar.EVPersuasionButtons
// NumValues: 0x0005
enum class EVPersuasionButtons : uint8
{
	EmptyAction                              = 0,
	Start                                    = 1,
	Bribe                                    = 2,
	Back                                     = 3,
	EVPersuasionButtons_MAX                  = 4,
};

// Enum Altar.EVPersuasionMenuState
// NumValues: 0x0003
enum class EVPersuasionMenuState : uint8
{
	Actions                                  = 0,
	MiniGame                                 = 1,
	EVPersuasionMenuState_MAX                = 2,
};

// Enum Altar.EVPersuasionMiniGameButtons
// NumValues: 0x0006
enum class EVPersuasionMiniGameButtons : uint8
{
	Admire                                   = 0,
	Joke                                     = 1,
	Coerce                                   = 2,
	Boast                                    = 3,
	EmptyMiniGameAction                      = 4,
	EVPersuasionMiniGameButtons_MAX          = 5,
};

// Enum Altar.EVRebindIndex
// NumValues: 0x0004
enum class EVRebindIndex : uint8
{
	KeyboardPrimary                          = 0,
	KeyboardSecondary                        = 1,
	GamepadPrimary                           = 2,
	EVRebindIndex_MAX                        = 3,
};

// Enum Altar.FModernSettingsPageType
// NumValues: 0x0004
enum class EFModernSettingsPageType : uint8
{
	Settings                                 = 0,
	Rebind                                   = 1,
	Override                                 = 2,
	FModernSettingsPageType_MAX              = 3,
};

// Enum Altar.EVModernSettingsPagePlatormFlag
// NumValues: 0x0008
enum class EVModernSettingsPagePlatormFlag : uint8
{
	NONE                                     = 0,
	PC                                       = 1,
	XSS                                      = 2,
	XSX                                      = 4,
	PlayStation                              = 8,
	WinGDK                                   = 16,
	SteamDeck                                = 32,
	EVModernSettingsPagePlatormFlag_MAX      = 33,
};

// Enum Altar.EVModernRebindType
// NumValues: 0x0004
enum class EVModernRebindType : uint8
{
	Separator                                = 0,
	Keyboard                                 = 1,
	Gamepad                                  = 2,
	EVModernRebindType_MAX                   = 3,
};

// Enum Altar.EVModernRebindCategory
// NumValues: 0x0003
enum class EVModernRebindCategory : uint8
{
	General                                  = 0,
	UI_Navigation                            = 1,
	EVModernRebindCategory_MAX               = 2,
};

// Enum Altar.ESettingCommandOuput
// NumValues: 0x0004
enum class ESettingCommandOuput : uint8
{
	HasChange                                = 0,
	IsSame                                   = 1,
	Invalid                                  = 2,
	ESettingCommandOuput_MAX                 = 3,
};

// Enum Altar.EModernSettingWidgetType
// NumValues: 0x0007
enum class EModernSettingWidgetType : uint8
{
	Button                                   = 0,
	Step                                     = 1,
	Slider                                   = 2,
	ComboBox                                 = 3,
	Preset                                   = 4,
	Custom                                   = 5,
	EModernSettingWidgetType_MAX             = 6,
};

// Enum Altar.EModernSettingWidgetSubType
// NumValues: 0x0012
enum class EModernSettingWidgetSubType : uint8
{
	NONE                                     = 0,
	Resolution                               = 1,
	Upscaler                                 = 2,
	RayTracing                               = 3,
	Quality                                  = 4,
	HDR                                      = 5,
	HDROptions                               = 6,
	Language                                 = 7,
	SDROptions                               = 8,
	Monitors                                 = 9,
	AdaptiveTriggerToggle                    = 10,
	VibrationToggle                          = 11,
	VibrationStrength                        = 12,
	AimAssistToggle                          = 13,
	AimAssistSensitivity                     = 14,
	NoLocaToggle                             = 15,
	GenericGamepadSettings                   = 16,
	EModernSettingWidgetSubType_MAX          = 17,
};

// Enum Altar.EModernCategoryPlatormFlag
// NumValues: 0x0008
enum class EModernCategoryPlatormFlag : uint8
{
	NONE                                     = 0,
	PC                                       = 1,
	XSS                                      = 2,
	XSX                                      = 4,
	PlayStation                              = 8,
	WinGDK                                   = 16,
	SteamDeck                                = 32,
	EModernCategoryPlatormFlag_MAX           = 33,
};

// Enum Altar.EModernSettingWidgetState
// NumValues: 0x0004
enum class EModernSettingWidgetState : uint8
{
	Default                                  = 0,
	Hover                                    = 1,
	Disable                                  = 2,
	EModernSettingWidgetState_MAX            = 3,
};

// Enum Altar.ESliderInputType
// NumValues: 0x0004
enum class ESliderInputType : uint8
{
	MouseWheel                               = 0,
	SliderArrows                             = 1,
	ControllerTriggers                       = 2,
	ESliderInputType_MAX                     = 3,
};

// Enum Altar.EModularBodySection
// NumValues: 0x0019
enum class EModularBodySection : uint32
{
	Feet                                     = 16777216,
	Calf                                     = 33554432,
	Knees                                    = 67108864,
	Thigh                                    = 134217728,
	BustRear                                 = 268435456,
	Stomach                                  = 536870912,
	ChestCenter                              = 1073741824,
	ChestSide                                = 2147483648,
	BackTop                                  = 65536,
	Shoulder                                 = 131072,
	Biceps                                   = 262144,
	Forearms                                 = 524288,
	Heels                                    = 1048576,
	Hands                                    = 2097152,
	Bra                                      = 4194304,
	LoinCloth                                = 8388608,
	Tail                                     = 256,
	Collar                                   = 512,
	Neck                                     = 1024,
	Head                                     = 2048,
	CollarCenter                             = 4096,
	EarsTip                                  = 8192,
	Ankle                                    = 16384,
	FeetBase                                 = 32768,
	EModularBodySection_MAX                  = 2147483649,
};

// Enum Altar.EVMusicType
// NumValues: 0x000A
enum class EVMusicType : uint8
{
	Explore                                  = 0,
	Public                                   = 1,
	Dungeon                                  = 2,
	Battle                                   = 4,
	Special                                  = 8,
	Death                                    = 16,
	Success                                  = 32,
	Title                                    = 64,
	None                                     = 128,
	EVMusicType_MAX                          = 129,
};

// Enum Altar.EVGlobalMusicState
// NumValues: 0x0003
enum class EVGlobalMusicState : uint8
{
	Normal                                   = 0,
	None                                     = 1,
	EVGlobalMusicState_MAX                   = 2,
};

// Enum Altar.EOblivionCombatMoveset
// NumValues: 0x0007
enum class EOblivionCombatMoveset : uint8
{
	HAND_TO_HAND                             = 0,
	DAGGER                                   = 1,
	ONE_HANDED_SWORD                         = 2,
	TWO_HANDED_SWORD                         = 3,
	ONE_HANDED_MACE                          = 4,
	TWO_HANDED_MACE                          = 5,
	EOblivionCombatMoveset_MAX               = 6,
};

// Enum Altar.EGameplayCameraContext
// NumValues: 0x0003
enum class EGameplayCameraContext : uint8
{
	Default                                  = 0,
	Dialogue                                 = 1,
	EGameplayCameraContext_MAX               = 2,
};

// Enum Altar.EOriginalInventoryFilterBackgrounds
// NumValues: 0x0007
enum class EOriginalInventoryFilterBackgrounds : uint8
{
	OneTab                                   = 0,
	TwoTabs                                  = 1,
	ThreeTabs                                = 2,
	FourTabs                                 = 3,
	FiveTabs                                 = 4,
	SixTabs                                  = 5,
	EOriginalInventoryFilterBackgrounds_MAX  = 6,
};

// Enum Altar.EVPreloadPriority
// NumValues: 0x0007
enum class EVPreloadPriority : uint8
{
	Low                                      = 0,
	Normal                                   = 1,
	High                                     = 2,
	Critical                                 = 3,
	Default                                  = 1,
	Min                                      = 0,
	Max                                      = 3,
};

// Enum Altar.EVAssetWeight
// NumValues: 0x0006
enum class EVAssetWeight : uint8
{
	Light                                    = 0,
	Medium                                   = 1,
	Heavy                                    = 2,
	Default                                  = 0,
	Min                                      = 0,
	Max                                      = 2,
};

// Enum Altar.EVCharacterRefreshSelector
// NumValues: 0x0007
enum class EVCharacterRefreshSelector : uint8
{
	None                                     = 0,
	BodySection                              = 1,
	BodyPart                                 = 2,
	Phenotype                                = 4,
	Weapons                                  = 8,
	All                                      = 15,
	EVCharacterRefreshSelector_MAX           = 16,
};

// Enum Altar.EVAvoidanceMask
// NumValues: 0x0004
enum class EVAvoidanceMask : uint8
{
	None                                     = 0,
	Ragdoll                                  = 1,
	Pawn                                     = 2,
	EVAvoidanceMask_MAX                      = 3,
};

// Enum Altar.EVActionType
// NumValues: 0x0016
enum class EVActionType : uint8
{
	PowerAttack                              = 0,
	RightAttack                              = 1,
	LeftAttack                               = 2,
	PowerAttackForward                       = 3,
	PowerAttackBack                          = 4,
	PowerAttackRight                         = 5,
	PowerAttackLeft                          = 6,
	BowDraw                                  = 7,
	BowShoot                                 = 8,
	DrawWeapon                               = 9,
	PrepareAttack                            = 10,
	Block                                    = 11,
	Jump                                     = 12,
	BlockHit                                 = 13,
	Recoil                                   = 14,
	Stagger                                  = 15,
	SpellCasting                             = 16,
	DodgeForward                             = 17,
	DodgeBack                                = 18,
	DodgeRight                               = 19,
	DodgeLeft                                = 20,
	EVActionType_MAX                         = 21,
};

// Enum Altar.EVVisiblePart
// NumValues: 0x0005
enum class EVVisiblePart : uint8
{
	Bottom                                   = 0,
	Middle                                   = 1,
	Top                                      = 2,
	None                                     = 3,
	EVVisiblePart_MAX                        = 4,
};

// Enum Altar.EVLifeState
// NumValues: 0x0007
enum class EVLifeState : uint8
{
	Alive_FromSpawn                          = 0,
	Alive_FromResurrection                   = 1,
	Alive_FromUnconscious                    = 2,
	Dead_FromSpawn                           = 3,
	Dead_FromKilled                          = 4,
	Unconscious                              = 5,
	EVLifeState_MAX                          = 6,
};

// Enum Altar.EVRagdollSetup
// NumValues: 0x0005
enum class EVRagdollSetup : uint8
{
	None                                     = 0,
	Paralyzed                                = 1,
	KO                                       = 2,
	Dead                                     = 3,
	EVRagdollSetup_MAX                       = 4,
};

// Enum Altar.EVAnimAction
// NumValues: 0x0010
enum class EVAnimAction : uint8
{
	ANIM_ACTION_NONE                         = 0,
	ANIM_ACTION_EQUIP_WEAPON                 = 1,
	ANIM_ACTION_UNEQUIP_WEAPON               = 2,
	ANIM_ACTION_ATTACK                       = 3,
	ANIM_ACTION_ATTACK_FOLLOW_THROUGH        = 4,
	ANIM_ACTION_ATTACK_BOW                   = 5,
	ANIM_ACTION_ATTACK_BOW_ARROW_ATTACHED    = 6,
	ANIM_ACTION_BLOCK                        = 7,
	ANIM_ACTION_RECOIL                       = 8,
	ANIM_ACTION_STAGGER                      = 9,
	ANIM_ACTION_DODGE                        = 10,
	ANIM_ACTION_WAIT_FOR_LOWER_BODY_ANIM     = 11,
	ANIM_ACTION_WAIT_FOR_SPECIAL_IDLE        = 12,
	ANIM_ACTION_FORCE_SCRIPT_ANIM            = 13,
	ANIM_ACTION_COUNT                        = 14,
	ANIM_ACTION_MAX                          = 15,
};

// Enum Altar.EVAnimGroupSection
// NumValues: 0x0008
enum class EVAnimGroupSection : uint8
{
	AGS_NONE                                 = 0,
	AGS_LOWER_BODY                           = 1,
	AGS_LEFT_ARM                             = 2,
	AGS_LEFT_HAND                            = 3,
	AGS_RIGHT_ARM                            = 4,
	AGS_SPECIAL_IDLE                         = 5,
	ANIM_GROUP_SECTION_COUNT                 = 6,
	EVAnimGroupSection_MAX                   = 7,
};

// Enum Altar.EVAnimGroupAction
// NumValues: 0x001B
enum class EVAnimGroupAction : uint8
{
	NONE                                     = 0,
	START                                    = 1,
	STOP                                     = 2,
	ATTACK_START                             = 1,
	ATTACK_HIT                               = 2,
	ATTACK_SWITCH                            = 3,
	ATTACK_POWER_STOP                        = 3,
	ATTACK_STOP                              = 4,
	BOW_START                                = 1,
	BOW_ATTACH                               = 2,
	BOW_HOLD                                 = 3,
	BOW_RELEASE                              = 4,
	BOW_STOP                                 = 5,
	GROUP_ACTION_COUNT                       = 6,
	BLOCK_START                              = 1,
	BLOCK_ATTACK                             = 2,
	BLOCK_STOP                               = 3,
	EQUIP_START                              = 1,
	EQUIP_ATTACH                             = 2,
	EQUIP_STOP                               = 3,
	UNEQUIP_START                            = 1,
	UNEQUIP_DETACH                           = 2,
	UNEQUIP_STOP                             = 3,
	CAST_START                               = 1,
	CAST_HIT                                 = 2,
	CAST_STOP                                = 3,
	EVAnimGroupAction_MAX                    = 7,
};

// Enum Altar.EVAnimGroup
// NumValues: 0x0036
enum class EVAnimGroup : uint8
{
	NONE                                     = 255,
	IDLE                                     = 0,
	DYNAMIC_IDLE                             = 1,
	SPECIAL_IDLE                             = 2,
	MOVE_FORWARD                             = 3,
	BEGIN_MOVEMENT                           = 3,
	MOVE_BACK                                = 4,
	MOVE_LEFT                                = 5,
	MOVE_RIGHT                               = 6,
	FAST_FORWARD                             = 7,
	FAST_BACK                                = 8,
	FAST_LEFT                                = 9,
	FAST_RIGHT                               = 10,
	DODGE_FORWARD                            = 11,
	DODGE_BACK                               = 12,
	DODGE_LEFT                               = 13,
	DODGE_RIGHT                              = 14,
	TURN_LEFT                                = 15,
	TURN_RIGHT                               = 16,
	END_MOVEMENT                             = 16,
	EQUIP                                    = 17,
	WEAPONS_START                            = 17,
	UNEQUIP                                  = 18,
	ATTACK_BOW                               = 19,
	ATTACK_LEFT                              = 20,
	ATTACK_RIGHT                             = 21,
	ATTACK_NORMAL_POWER                      = 22,
	ATTACK_FORWARD_POWER                     = 23,
	ATTACK_BACK_POWER                        = 24,
	ATTACK_LEFT_POWER                        = 25,
	ATTACK_RIGHT_POWER                       = 26,
	WEAPONS_STOP                             = 26,
	BLOCK_IDLE                               = 27,
	BLOCK_HIT                                = 28,
	BLOCK_ATTACK                             = 29,
	RECOIL                                   = 30,
	STAGGER                                  = 31,
	DEATH                                    = 32,
	TORCH_IDLE                               = 33,
	CAST_SELF                                = 34,
	CAST_START                               = 34,
	CAST_TOUCH                               = 35,
	CAST_TARGET                              = 36,
	CAST_SELF_ALT                            = 37,
	CAST_TOUCH_ALT                           = 38,
	CAST_TARGET_ALT                          = 39,
	CAST_STOP                                = 39,
	JUMP_START                               = 40,
	JUMP_LOOP                                = 41,
	JUMP_LAND                                = 42,
	COUNT                                    = 43,
	POWERATTACK_START                        = 22,
	POWERATTACK_COUNT                        = 5,
	EVAnimGroup_MAX                          = 256,
};

// Enum Altar.EVSkinType
// NumValues: 0x0004
enum class EVSkinType : uint8
{
	BONE                                     = 0,
	FUR                                      = 1,
	FLESH                                    = 2,
	EVSkinType_MAX                           = 3,
};

// Enum Altar.EVWeightCategory
// NumValues: 0x0004
enum class EVWeightCategory : uint8
{
	LIGHT                                    = 0,
	HEAVY                                    = 1,
	NONE                                     = 2,
	EVWeightCategory_MAX                     = 3,
};

// Enum Altar.EVPriorityTypeOnPawn
// NumValues: 0x0005
enum class EVPriorityTypeOnPawn : uint8
{
	LastArrivedIsPlayed                      = 0,
	HighPriority                             = 1,
	EnchantmentEffect                        = 2,
	NotAPawnEffect                           = 3,
	EVPriorityTypeOnPawn_MAX                 = 4,
};

// Enum Altar.EVItemUsageType
// NumValues: 0x0026
enum class EVItemUsageType : uint8
{
	NONE                                     = 0,
	ACTI                                     = 1,
	APPA                                     = 2,
	ARMO                                     = 3,
	BOOK                                     = 4,
	CLOT                                     = 5,
	CONT                                     = 6,
	DOOR                                     = 7,
	INGR                                     = 8,
	LIGH                                     = 9,
	MISC                                     = 10,
	FLOR                                     = 11,
	FURN                                     = 12,
	WEAP                                     = 13,
	AMMO                                     = 14,
	NPC                                      = 15,
	CREA                                     = 16,
	SLGM                                     = 17,
	KEYM                                     = 18,
	ALCH                                     = 19,
	FOOD                                     = 20,
	COMBATWEAR                               = 21,
	WEAR                                     = 22,
	WEAP_NONE                                = 23,
	WEAP_MELEE                               = 24,
	WEAP_RANGED                              = 25,
	SPELL                                    = 26,
	SPELL_RANGED                             = 27,
	SPELL_TOUCH                              = 28,
	SPELL_SELF                               = 29,
	SPELL_ALTERATION                         = 30,
	SPELL_CONJURATION                        = 31,
	SPELL_DESTRUCTION                        = 32,
	SPELL_ILLUSION                           = 33,
	SPELL_MYSTICISM                          = 34,
	SPELL_RESTORATION                        = 35,
	COUNT                                    = 36,
	EVItemUsageType_MAX                      = 37,
};

// Enum Altar.EVOblivionStrategy
// NumValues: 0x000F
enum class EVOblivionStrategy : uint8
{
	HANDTOHAND                               = 0,
	MELEE_WEAPON                             = 1,
	RANGED_WEAPON                            = 2,
	MELEE_MAGIC                              = 3,
	RANGED_MAGIC                             = 4,
	YIELD                                    = 5,
	POST_YIELD                               = 6,
	FLEE                                     = 7,
	BUFF                                     = 8,
	RESTORE                                  = 9,
	SWITCH                                   = 10,
	CALMED                                   = 11,
	SWIM_FLEE                                = 12,
	NONE                                     = 13,
	EVOblivionStrategy_MAX                   = 14,
};

// Enum Altar.EVOblivionManeuver
// NumValues: 0x0012
enum class EVOblivionManeuver : uint8
{
	ENGAGE                                   = 0,
	IDLE                                     = 1,
	DODGE                                    = 2,
	CLOSE                                    = 3,
	ADVANCE                                  = 4,
	WITHDRAW                                 = 5,
	TAKE_COVER                               = 6,
	ACQUIRE                                  = 7,
	RUN_AWAY                                 = 8,
	DISMOUNT                                 = 9,
	RANGED_ALERT                             = 10,
	ON_STATION                               = 11,
	REPOSITION                               = 12,
	DISARMED                                 = 13,
	STANDOFF                                 = 14,
	MELEE_ALERT                              = 15,
	STANDOFF_BACKUP                          = 16,
	EVOblivionManeuver_MAX                   = 17,
};

// Enum Altar.EVOblivionCombatState
// NumValues: 0x0005
enum class EVOblivionCombatState : uint8
{
	ATTACK                                   = 0,
	BLOCK                                    = 1,
	HOLD                                     = 2,
	DONE                                     = 3,
	EVOblivionCombatState_MAX                = 4,
};

// Enum Altar.EVOblivionAIPackageType
// NumValues: 0x002A
enum class EVOblivionAIPackageType : uint8
{
	NONE                                     = 0,
	EXPLORE_TRAVEL                           = 1,
	EXPLORE_WANDER                           = 2,
	EXPLORE_ACTIVATE                         = 3,
	EXPLORE_AQUIRE                           = 4,
	SLEEP                                    = 5,
	EAT                                      = 6,
	FOLLOW_WITH_ESCORT                       = 7,
	FOLLOW_WITHOUT_ESCORT                    = 8,
	ESCORT_ACTOR                             = 9,
	ESCORT_OBJECT                            = 10,
	DIALOGUE                                 = 11,
	ALARM                                    = 12,
	COMBAT                                   = 13,
	ACTIVATE                                 = 14,
	GREET                                    = 15,
	OBSERVE_COMBAT                           = 16,
	OBSERVE_DIALOGUE                         = 17,
	TALK_TO_DEAD                             = 18,
	COMBAT_NOT_IN_HIGH                       = 19,
	FLEE                                     = 20,
	TRESPASS                                 = 21,
	GET_UP                                   = 22,
	EXPLORE_NPC                              = 23,
	MOUNT_HORSE                              = 24,
	DISMOUNT_HORSE                           = 25,
	DO_NOTHING                               = 26,
	EXPLORE_AQUIRE_GENERIC                   = 27,
	CAST_TARGET_SPELL                        = 28,
	CAST_TOUCH_SPELL                         = 29,
	ACCOMPANY                                = 30,
	USEITEMAT                                = 31,
	FEED                                     = 32,
	AMBUSH                                   = 33,
	SURFACE                                  = 34,
	CASTING                                  = 35,
	FLEE_NON_COMBAT                          = 36,
	SEARCH                                   = 37,
	CLEAR_MOUNT_POSITION                     = 38,
	SUMMON_CREATURE_DEFEND                   = 39,
	MOVEMENT_BLOCKED                         = 40,
	EVOblivionAIPackageType_MAX              = 41,
};

// Enum Altar.EVOblivionAIProcedureType
// NumValues: 0x002F
enum class EVOblivionAIProcedureType : uint8
{
	NONE                                     = 0,
	TRAVEL                                   = 1,
	WANDER                                   = 2,
	ACTIVATE                                 = 3,
	AQUIRE                                   = 4,
	SLEEP                                    = 5,
	EAT                                      = 6,
	FOLLOW                                   = 7,
	ESCORT                                   = 8,
	ALARM                                    = 9,
	COMBAT                                   = 10,
	FLEE                                     = 11,
	YIELD                                    = 12,
	DIALOGUE                                 = 13,
	WAIT                                     = 14,
	TRAVEL_TARGET                            = 15,
	PURSUE                                   = 16,
	GREET                                    = 17,
	CREATE_FOLLOW                            = 18,
	OBSERVE_COMBAT                           = 19,
	OBSERVE_DIALOGUE                         = 20,
	GREET_DEAD                               = 21,
	WARN                                     = 22,
	GET_UP                                   = 23,
	MOUNT_HORSE                              = 24,
	DISMOUNT_HORSE                           = 25,
	DO_NOTHING                               = 26,
	CAST_SPELL                               = 27,
	AIM                                      = 28,
	NOTIFY                                   = 29,
	ACCOMPANY                                = 30,
	USE_ITEM_AT                              = 31,
	FEED                                     = 32,
	WAIT_AMBUSH                              = 33,
	SURFACE                                  = 34,
	WAIT_FOR_SPELL                           = 35,
	CHOOSE_CAST                              = 36,
	FLEE_NON_COMBAT                          = 37,
	REMOVE_WORN_ITEMS                        = 38,
	SEARCH                                   = 39,
	CLEAR_MOUNT_POSITION                     = 40,
	SUMMON_DEFEND                            = 41,
	MOVEMENT_BLOCKED_WAIT                    = 42,
	UNEQUIP_ARMOR                            = 43,
	TAKE_BACK_ITEM                           = 44,
	DONE                                     = 45,
	EVOblivionAIProcedureType_MAX            = 46,
};

// Enum Altar.EVMoveDirection
// NumValues: 0x0007
enum class EVMoveDirection : uint8
{
	NONE                                     = 0,
	FORWARD                                  = 1,
	BACKWARD                                 = 2,
	LEFT                                     = 4,
	RIGHT                                    = 8,
	ALL                                      = 15,
	EVMoveDirection_MAX                      = 16,
};

// Enum Altar.ELegacyPauseButtonsIDs
// NumValues: 0x0007
enum class ELegacyPauseButtonsIDs : uint8
{
	Default                                  = 0,
	Return                                   = 3,
	Save                                     = 4,
	Load                                     = 5,
	Options                                  = 7,
	Quit                                     = 8,
	ELegacyPauseButtonsIDs_MAX               = 9,
};

// Enum Altar.EVVoiceType
// NumValues: 0x0004
enum class EVVoiceType : uint8
{
	LEGACY                                   = 0,
	ALTVOICE                                 = 1,
	BEGGAR                                   = 2,
	EVVoiceType_MAX                          = 3,
};

// Enum Altar.EVPhysicsSettingsAuthority
// NumValues: 0x0004
enum class EVPhysicsSettingsAuthority : uint8
{
	FROM_INI_FILE                            = 0,
	FROM_BLUEPRINT                           = 1,
	DRIVEN_BY_CODE                           = 2,
	EVPhysicsSettingsAuthority_MAX           = 3,
};

// Enum Altar.EVConstrainingMode
// NumValues: 0x0004
enum class EVConstrainingMode : uint8
{
	Free                                     = 0,
	LockOnlyLeaves                           = 1,
	LockAllBodies                            = 2,
	EVConstrainingMode_MAX                   = 3,
};

// Enum Altar.EPreviewDefaultObjectType
// NumValues: 0x0006
enum class EPreviewDefaultObjectType : uint8
{
	ActorTypeClass                           = 0,
	StaticMesh                               = 1,
	SkeletalMesh                             = 2,
	Count                                    = 3,
	Invalid                                  = 3,
	EPreviewDefaultObjectType_MAX            = 4,
};

// Enum Altar.EModernCharacterCreationGenderRequirement
// NumValues: 0x0004
enum class EModernCharacterCreationGenderRequirement : uint8
{
	BodyA                                    = 0,
	BodyB                                    = 1,
	NONE                                     = 2,
	EModernCharacterCreationGenderRequirement_MAX = 3,
};

// Enum Altar.ELegacyRaceSexMenuPage
// NumValues: 0x0017
enum class ELegacyRaceSexMenuPage : uint8
{
	Main                                     = 0,
	Race                                     = 1,
	Face                                     = 2,
	Face_Shape                               = 3,
	Face_Tone                                = 4,
	Shape_Face                               = 5,
	Shape_Brow                               = 6,
	Shape_Checks                             = 7,
	Shape_Chin                               = 8,
	Shape_Eyes                               = 9,
	Shape_Forehead                           = 10,
	Shape_Jaw                                = 11,
	Shape_Mouth                              = 12,
	Shape_Nose                               = 13,
	Tone_Skin                                = 14,
	Tone_Beard                               = 15,
	Tone_Eyes                                = 16,
	Tone_EyeBrows                            = 17,
	Tone_Lips                                = 18,
	Tone_Nose                                = 19,
	Hair                                     = 20,
	None                                     = 21,
	ELegacyRaceSexMenuPage_MAX               = 22,
};

// Enum Altar.EModernRaceSexPage
// NumValues: 0x0006
enum class EModernRaceSexPage : uint8
{
	Shape                                    = 0,
	Tone                                     = 1,
	Style                                    = 2,
	Color                                    = 3,
	None                                     = 4,
	EModernRaceSexPage_MAX                   = 5,
};

// Enum Altar.ELegacyRaceSexMenuWidgetType
// NumValues: 0x0007
enum class ELegacyRaceSexMenuWidgetType : uint8
{
	Button                                   = 0,
	Toggle                                   = 1,
	Slider                                   = 2,
	Text                                     = 3,
	ColorPicker                              = 4,
	EyebrowColorPicker                       = 5,
	ELegacyRaceSexMenuWidgetType_MAX         = 6,
};

// Enum Altar.ELegacyRaceSexMenuButtonType
// NumValues: 0x0004
enum class ELegacyRaceSexMenuButtonType : uint8
{
	Redirect                                 = 0,
	Reset                                    = 1,
	Random                                   = 2,
	ELegacyRaceSexMenuButtonType_MAX         = 3,
};

// Enum Altar.ELegacyRaceSexMenuToggleType
// NumValues: 0x000C
enum class ELegacyRaceSexMenuToggleType : uint8
{
	EyeColour                                = 0,
	Gender                                   = 1,
	Archetype                                = 2,
	Race                                     = 3,
	HairStyle                                = 4,
	BeardStyle                               = 5,
	MustacheStyle                            = 6,
	EyebrowsStyle                            = 7,
	HairColour                               = 8,
	KhajitFurPattern                         = 9,
	None                                     = 10,
	ELegacyRaceSexMenuToggleType_MAX         = 11,
};

// Enum Altar.ELegacyRaceSexMenuSliderType
// NumValues: 0x0004
enum class ELegacyRaceSexMenuSliderType : uint8
{
	Morph                                    = 0,
	Texture                                  = 1,
	Phenotype                                = 2,
	ELegacyRaceSexMenuSliderType_MAX         = 3,
};

// Enum Altar.EPlayerNameValidityCode
// NumValues: 0x0007
enum class EPlayerNameValidityCode : uint8
{
	Valid                                    = 0,
	ContainsDigit                            = 1,
	ContainsSpecialCharacter                 = 2,
	IsEmpty                                  = 3,
	ContainsOnlyWhiteSpace                   = 4,
	TooLong                                  = 5,
	EPlayerNameValidityCode_MAX              = 6,
};

// Enum Altar.EStatGroupType
// NumValues: 0x0004
enum class EStatGroupType : uint8
{
	Attribute                                = 0,
	Skill                                    = 1,
	Resist                                   = 2,
	EStatGroupType_MAX                       = 3,
};

// Enum Altar.EAttributeStat
// NumValues: 0x000A
enum class EAttributeStat : uint8
{
	STRENGTH                                 = 0,
	INTELLIGENCE                             = 1,
	WILLPOWER                                = 2,
	AGILITY                                  = 3,
	SPEED                                    = 4,
	ENDURANCE                                = 5,
	PERSONALITY                              = 6,
	LUCK                                     = 7,
	MAGICKA                                  = 9,
	EAttributeStat_MAX                       = 10,
};

// Enum Altar.ESkillStat
// NumValues: 0x0017
enum class ESkillStat : uint8
{
	DO_NOT_USE                               = 0,
	ARMORER                                  = 12,
	ATHLETICS                                = 13,
	BLADE                                    = 14,
	BLOCK                                    = 15,
	BLUNT                                    = 16,
	HANDTOHAND                               = 17,
	HEAVYARMOR                               = 18,
	ALCHEMY                                  = 19,
	ALTERATION                               = 20,
	CONJURATION                              = 21,
	DESTRUCTION                              = 22,
	ILLUSION                                 = 23,
	MYSTICISM                                = 24,
	RESTORATION                              = 25,
	ACROBATICS                               = 26,
	LIGHTARMOR                               = 27,
	MARKSMAN                                 = 28,
	MERCANTILE                               = 29,
	SECURITY                                 = 30,
	SNEAK                                    = 31,
	SPEECHCRAFT                              = 32,
	ESkillStat_MAX                           = 33,
};

// Enum Altar.EResistStat
// NumValues: 0x0008
enum class EResistStat : uint8
{
	DO_NOT_USE                               = 0,
	RESIST_FIRE                              = 61,
	RESIST_FROST                             = 62,
	RESIST_DISEASE                           = 63,
	RESIST_MAGIC                             = 64,
	RESIST_POISON                            = 67,
	RESIST_SHOCK                             = 68,
	EResistStat_MAX                          = 69,
};

// Enum Altar.ESaveLoadMenuOpeningSource
// NumValues: 0x0005
enum class ESaveLoadMenuOpeningSource : uint8
{
	Unknown                                  = 0,
	FromMainMenu                             = 1,
	FromInGame                               = 2,
	FromDeath                                = 3,
	ESaveLoadMenuOpeningSource_MAX           = 4,
};

// Enum Altar.EVSenescencePhenotypeBehaviour
// NumValues: 0x0003
enum class EVSenescencePhenotypeBehaviour : uint32
{
	Add                                      = 0,
	Override                                 = 1,
	EVSenescencePhenotypeBehaviour_MAX       = 2,
};

// Enum Altar.ELegacySettingsMenuIDs
// NumValues: 0x0007
enum class ELegacySettingsMenuIDs : uint8
{
	None                                     = 0,
	ReturnButton                             = 2,
	GamePlayButton                           = 5,
	VideoButton                              = 6,
	AudioButton                              = 7,
	ControlsButton                           = 8,
	ELegacySettingsMenuIDs_MAX               = 9,
};

// Enum Altar.ESkillAndClassSpecialization
// NumValues: 0x0005
enum class ESkillAndClassSpecialization : uint8
{
	Combat                                   = 0,
	Magic                                    = 1,
	Stealth                                  = 2,
	None                                     = 3,
	ESkillAndClassSpecialization_MAX         = 4,
};

// Enum Altar.ESkillMenuType
// NumValues: 0x0006
enum class ESkillMenuType : uint8
{
	Skills                                   = 0,
	Attributes                               = 1,
	Specialisation                           = 2,
	BirthSign                                = 3,
	Overview                                 = 4,
	ESkillMenuType_MAX                       = 5,
};

// Enum Altar.ESpellMakingEnchantingMenus
// NumValues: 0x0004
enum class ESpellMakingEnchantingMenus : uint8
{
	EnchantmentMenu                          = 0,
	SigilStoneMenu                           = 1,
	SpellMakingMenu                          = 2,
	ESpellMakingEnchantingMenus_MAX          = 3,
};

// Enum Altar.ELegacySpellPurchaseMenuItemCategory
// NumValues: 0x0007
enum class ELegacySpellPurchaseMenuItemCategory : uint8
{
	None                                     = 0,
	Greater                                  = 1,
	Lesser                                   = 2,
	Spell                                    = 3,
	Scroll                                   = 4,
	Special                                  = 5,
	ELegacySpellPurchaseMenuItemCategory_MAX = 6,
};

// Enum Altar.ELegacySpellPurchaseMenuItemType
// NumValues: 0x0006
enum class ELegacySpellPurchaseMenuItemType : uint8
{
	None                                     = 0,
	Target                                   = 1,
	Touch                                    = 2,
	Self                                     = 4,
	Active                                   = 8,
	ELegacySpellPurchaseMenuItemType_MAX     = 9,
};

// Enum Altar.ELegacySpellPurchaseMenuSortType
// NumValues: 0x0005
enum class ELegacySpellPurchaseMenuSortType : uint8
{
	None                                     = 0,
	Name                                     = 1,
	SpellCost                                = 2,
	GoldCost                                 = 3,
	ELegacySpellPurchaseMenuSortType_MAX     = 4,
};

// Enum Altar.ELegacySpellPurchaseMenuSpellSchool
// NumValues: 0x0007
enum class ELegacySpellPurchaseMenuSpellSchool : uint8
{
	Alteration                               = 0,
	Conjuration                              = 1,
	Destruction                              = 2,
	Illusion                                 = 3,
	Mysticism                                = 4,
	Restoration                              = 5,
	ELegacySpellPurchaseMenuSpellSchool_MAX  = 6,
};

// Enum Altar.ELegacyStatsMenuPage
// NumValues: 0x0006
enum class ELegacyStatsMenuPage : uint8
{
	Attributes                               = 0,
	Character                                = 1,
	Skill                                    = 2,
	Factions                                 = 3,
	Misc                                     = 4,
	ELegacyStatsMenuPage_MAX                 = 5,
};

// Enum Altar.EMeshType
// NumValues: 0x0003
enum class EMeshType : uint8
{
	StaticMesh                               = 0,
	SkeletalMesh                             = 1,
	EMeshType_MAX                            = 2,
};

// Enum Altar.EVForwardTransformPairingStep
// NumValues: 0x0006
enum class EVForwardTransformPairingStep : uint8
{
	RawData                                  = 0,
	Conversion                               = 1,
	LevelOffset                              = 2,
	ActorOffset                              = 3,
	Adjustment                               = 4,
	EVForwardTransformPairingStep_MAX        = 5,
};

// Enum Altar.ELegacyVideoMenuIDs
// NumValues: 0x0003
enum class ELegacyVideoMenuIDs : uint8
{
	None                                     = 0,
	Return                                   = 1,
	ELegacyVideoMenuIDs_MAX                  = 2,
};

// Enum Altar.ESpeedCategory
// NumValues: 0x0005
enum class ESpeedCategory : uint8
{
	NONE                                     = 0,
	FAST                                     = 1,
	NORMAL                                   = 2,
	SLOW                                     = 3,
	ESpeedCategory_MAX                       = 4,
};

// Enum Altar.EVWeatherTexture
// NumValues: 0x0005
enum class EVWeatherTexture : uint8
{
	City                                     = 0,
	Foliage                                  = 1,
	Open                                     = 2,
	None                                     = 4,
	EVWeatherTexture_MAX                     = 5,
};

// ScriptStruct Altar.FooterInputActionVisibility
// 0x0010 (0x0010 - 0x0000)
struct FFooterInputActionVisibility final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFooterInputActionVisibility) == 0x000008, "Wrong alignment on FFooterInputActionVisibility");
static_assert(sizeof(FFooterInputActionVisibility) == 0x000010, "Wrong size on FFooterInputActionVisibility");
static_assert(offsetof(FFooterInputActionVisibility, InputAction) == 0x000000, "Member 'FFooterInputActionVisibility::InputAction' has a wrong offset!");
static_assert(offsetof(FFooterInputActionVisibility, bIsVisible) == 0x000008, "Member 'FFooterInputActionVisibility::bIsVisible' has a wrong offset!");

// ScriptStruct Altar.CutParameter
// 0x0030 (0x0030 - 0x0000)
struct FCutParameter final
{
public:
	class FString                                 StaticMeshComponentName;                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialSlotIndex;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CutHeight;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CutAngle;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCutParameter) == 0x000008, "Wrong alignment on FCutParameter");
static_assert(sizeof(FCutParameter) == 0x000030, "Wrong size on FCutParameter");
static_assert(offsetof(FCutParameter, StaticMeshComponentName) == 0x000000, "Member 'FCutParameter::StaticMeshComponentName' has a wrong offset!");
static_assert(offsetof(FCutParameter, MaterialSlotIndex) == 0x000010, "Member 'FCutParameter::MaterialSlotIndex' has a wrong offset!");
static_assert(offsetof(FCutParameter, CutHeight) == 0x000014, "Member 'FCutParameter::CutHeight' has a wrong offset!");
static_assert(offsetof(FCutParameter, CutAngle) == 0x000018, "Member 'FCutParameter::CutAngle' has a wrong offset!");

// ScriptStruct Altar.HintData
// 0x0018 (0x0018 - 0x0000)
struct FHintData final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHintData) == 0x000008, "Wrong alignment on FHintData");
static_assert(sizeof(FHintData) == 0x000018, "Wrong size on FHintData");
static_assert(offsetof(FHintData, Description) == 0x000000, "Member 'FHintData::Description' has a wrong offset!");

// ScriptStruct Altar.BribeData
// 0x0008 (0x0008 - 0x0000)
struct FBribeData final
{
public:
	int32                                         BribeGold;                                         // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BribeDisposition;                                  // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBribeData) == 0x000004, "Wrong alignment on FBribeData");
static_assert(sizeof(FBribeData) == 0x000008, "Wrong size on FBribeData");
static_assert(offsetof(FBribeData, BribeGold) == 0x000000, "Member 'FBribeData::BribeGold' has a wrong offset!");
static_assert(offsetof(FBribeData, BribeDisposition) == 0x000004, "Member 'FBribeData::BribeDisposition' has a wrong offset!");

// ScriptStruct Altar.VBaseCharacterAnimInstanceProxy
// 0x0000 (0x0700 - 0x0700)
struct FVBaseCharacterAnimInstanceProxy : public FAnimInstanceProxy
{
};
static_assert(alignof(FVBaseCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVBaseCharacterAnimInstanceProxy");
static_assert(sizeof(FVBaseCharacterAnimInstanceProxy) == 0x000700, "Wrong size on FVBaseCharacterAnimInstanceProxy");

// ScriptStruct Altar.VShieldHandPoseCharacterAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVShieldHandPoseCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVShieldHandPoseCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVShieldHandPoseCharacterAnimInstanceProxy");
static_assert(sizeof(FVShieldHandPoseCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVShieldHandPoseCharacterAnimInstanceProxy");

// ScriptStruct Altar.VSaveLoadingContext
// 0x0020 (0x0020 - 0x0000)
struct FVSaveLoadingContext final
{
public:
	TArray<class FString>                         SlotNames;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UVAltarSaveGame*                        SaveGame;                                          // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveGame*                              SaveContainer;                                     // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSaveLoadingContext) == 0x000008, "Wrong alignment on FVSaveLoadingContext");
static_assert(sizeof(FVSaveLoadingContext) == 0x000020, "Wrong size on FVSaveLoadingContext");
static_assert(offsetof(FVSaveLoadingContext, SlotNames) == 0x000000, "Member 'FVSaveLoadingContext::SlotNames' has a wrong offset!");
static_assert(offsetof(FVSaveLoadingContext, SaveGame) == 0x000010, "Member 'FVSaveLoadingContext::SaveGame' has a wrong offset!");
static_assert(offsetof(FVSaveLoadingContext, SaveContainer) == 0x000018, "Member 'FVSaveLoadingContext::SaveContainer' has a wrong offset!");

// ScriptStruct Altar.AlphaFlags
// 0x0002 (0x0002 - 0x0000)
struct alignas(0x02) FAlphaFlags final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAlphaFlags) == 0x000002, "Wrong alignment on FAlphaFlags");
static_assert(sizeof(FAlphaFlags) == 0x000002, "Wrong size on FAlphaFlags");

// ScriptStruct Altar.SaveGameObjectIdentifier
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSaveGameObjectIdentifier final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveGameObjectIdentifier) == 0x000008, "Wrong alignment on FSaveGameObjectIdentifier");
static_assert(sizeof(FSaveGameObjectIdentifier) == 0x000018, "Wrong size on FSaveGameObjectIdentifier");

// ScriptStruct Altar.OblivionSourcedCharacterAnimationState
// 0x001C (0x001C - 0x0000)
struct FOblivionSourcedCharacterAnimationState final
{
public:
	EOblivionAnimGroup                            UpperBodyAnimGroup;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOblivionAnimGroup                            LowerBodyAnimGroup;                                // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOblivionAnimGroup                            LeftArmAnimGroup;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOblivionAnimGroup                            RightArmAnimGroup;                                 // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOblivionAnimGroup                            LeftHandAnimGroup;                                 // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOblivionAnimGroup                            SpecialIdleAnimGroup;                              // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MovementType;                                      // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MovementDirection;                                 // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimAction;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperBodySequenceIdx;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LowerBodySequenceIdx;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftArmSequenceIdx;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RightArmSequenceIdx;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOblivionSourcedCharacterAnimationState) == 0x000004, "Wrong alignment on FOblivionSourcedCharacterAnimationState");
static_assert(sizeof(FOblivionSourcedCharacterAnimationState) == 0x00001C, "Wrong size on FOblivionSourcedCharacterAnimationState");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, UpperBodyAnimGroup) == 0x000000, "Member 'FOblivionSourcedCharacterAnimationState::UpperBodyAnimGroup' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, LowerBodyAnimGroup) == 0x000001, "Member 'FOblivionSourcedCharacterAnimationState::LowerBodyAnimGroup' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, LeftArmAnimGroup) == 0x000002, "Member 'FOblivionSourcedCharacterAnimationState::LeftArmAnimGroup' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, RightArmAnimGroup) == 0x000003, "Member 'FOblivionSourcedCharacterAnimationState::RightArmAnimGroup' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, LeftHandAnimGroup) == 0x000004, "Member 'FOblivionSourcedCharacterAnimationState::LeftHandAnimGroup' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, SpecialIdleAnimGroup) == 0x000005, "Member 'FOblivionSourcedCharacterAnimationState::SpecialIdleAnimGroup' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, MovementType) == 0x000006, "Member 'FOblivionSourcedCharacterAnimationState::MovementType' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, MovementDirection) == 0x000007, "Member 'FOblivionSourcedCharacterAnimationState::MovementDirection' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, AnimAction) == 0x000008, "Member 'FOblivionSourcedCharacterAnimationState::AnimAction' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, UpperBodySequenceIdx) == 0x00000C, "Member 'FOblivionSourcedCharacterAnimationState::UpperBodySequenceIdx' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, LowerBodySequenceIdx) == 0x000010, "Member 'FOblivionSourcedCharacterAnimationState::LowerBodySequenceIdx' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, LeftArmSequenceIdx) == 0x000014, "Member 'FOblivionSourcedCharacterAnimationState::LeftArmSequenceIdx' has a wrong offset!");
static_assert(offsetof(FOblivionSourcedCharacterAnimationState, RightArmSequenceIdx) == 0x000018, "Member 'FOblivionSourcedCharacterAnimationState::RightArmSequenceIdx' has a wrong offset!");

// ScriptStruct Altar.BodyProperties
// 0x0050 (0x0050 - 0x0000)
struct FBodyProperties final
{
public:
	TMap<class FName, float>                      BoneScalingMap;                                    // 0x0000(0x0050)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBodyProperties) == 0x000008, "Wrong alignment on FBodyProperties");
static_assert(sizeof(FBodyProperties) == 0x000050, "Wrong size on FBodyProperties");
static_assert(offsetof(FBodyProperties, BoneScalingMap) == 0x000000, "Member 'FBodyProperties::BoneScalingMap' has a wrong offset!");

// ScriptStruct Altar.PairedOblivionHitEvent
// 0x0038 (0x0038 - 0x0000)
struct FPairedOblivionHitEvent final
{
public:
	class AVPairedPawn*                           Attacker;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVPairedPawn*                           Target;                                            // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDamage;                                      // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FatigueDamage;                                     // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockedPercentage;                                 // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBowAttack;                                      // 0x001C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpellAttack;                                    // 0x001D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  Projectile;                                        // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesTargetBlockHit;                               // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesTargetPerformBlockAttack;                     // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetStaggered;                                // 0x002A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetKnockedDown;                              // 0x002B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesAttackerRecoil;                               // 0x002C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetAliveAfterAttack;                         // 0x002D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSneakAttack;                                    // 0x002E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnockbackForce;                                    // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPairedOblivionHitEvent) == 0x000008, "Wrong alignment on FPairedOblivionHitEvent");
static_assert(sizeof(FPairedOblivionHitEvent) == 0x000038, "Wrong size on FPairedOblivionHitEvent");
static_assert(offsetof(FPairedOblivionHitEvent, Attacker) == 0x000000, "Member 'FPairedOblivionHitEvent::Attacker' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, Target) == 0x000008, "Member 'FPairedOblivionHitEvent::Target' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, HealthDamage) == 0x000010, "Member 'FPairedOblivionHitEvent::HealthDamage' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, FatigueDamage) == 0x000014, "Member 'FPairedOblivionHitEvent::FatigueDamage' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, BlockedPercentage) == 0x000018, "Member 'FPairedOblivionHitEvent::BlockedPercentage' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, bIsBowAttack) == 0x00001C, "Member 'FPairedOblivionHitEvent::bIsBowAttack' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, bIsSpellAttack) == 0x00001D, "Member 'FPairedOblivionHitEvent::bIsSpellAttack' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, Projectile) == 0x000020, "Member 'FPairedOblivionHitEvent::Projectile' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, bDoesTargetBlockHit) == 0x000028, "Member 'FPairedOblivionHitEvent::bDoesTargetBlockHit' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, bDoesTargetPerformBlockAttack) == 0x000029, "Member 'FPairedOblivionHitEvent::bDoesTargetPerformBlockAttack' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, bIsTargetStaggered) == 0x00002A, "Member 'FPairedOblivionHitEvent::bIsTargetStaggered' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, bIsTargetKnockedDown) == 0x00002B, "Member 'FPairedOblivionHitEvent::bIsTargetKnockedDown' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, bDoesAttackerRecoil) == 0x00002C, "Member 'FPairedOblivionHitEvent::bDoesAttackerRecoil' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, bIsTargetAliveAfterAttack) == 0x00002D, "Member 'FPairedOblivionHitEvent::bIsTargetAliveAfterAttack' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, bIsSneakAttack) == 0x00002E, "Member 'FPairedOblivionHitEvent::bIsSneakAttack' has a wrong offset!");
static_assert(offsetof(FPairedOblivionHitEvent, KnockbackForce) == 0x000030, "Member 'FPairedOblivionHitEvent::KnockbackForce' has a wrong offset!");

// ScriptStruct Altar.NpcDisposition
// 0x0008 (0x0008 - 0x0000)
struct FNpcDisposition final
{
public:
	int32                                         DispositionValue;                                  // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTimerUpdate;                                    // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcDisposition) == 0x000004, "Wrong alignment on FNpcDisposition");
static_assert(sizeof(FNpcDisposition) == 0x000008, "Wrong size on FNpcDisposition");
static_assert(offsetof(FNpcDisposition, DispositionValue) == 0x000000, "Member 'FNpcDisposition::DispositionValue' has a wrong offset!");
static_assert(offsetof(FNpcDisposition, bIsTimerUpdate) == 0x000004, "Member 'FNpcDisposition::bIsTimerUpdate' has a wrong offset!");

// ScriptStruct Altar.BSVertexDesc
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FBSVertexDesc final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBSVertexDesc) == 0x000008, "Wrong alignment on FBSVertexDesc");
static_assert(sizeof(FBSVertexDesc) == 0x000008, "Wrong size on FBSVertexDesc");

// ScriptStruct Altar.TESGrassData
// 0x0020 (0x0020 - 0x0000)
struct FTESGrassData final
{
public:
	uint8                                         Density;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MinSlopeDegrees;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxSlopeDegrees;                                   // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DistanceFromWaterLevel;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGrassWaterState                              Underwater;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionRange;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightRange;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorRange;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WavePeriod;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Flags;                                             // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTESGrassData) == 0x000004, "Wrong alignment on FTESGrassData");
static_assert(sizeof(FTESGrassData) == 0x000020, "Wrong size on FTESGrassData");
static_assert(offsetof(FTESGrassData, Density) == 0x000000, "Member 'FTESGrassData::Density' has a wrong offset!");
static_assert(offsetof(FTESGrassData, MinSlopeDegrees) == 0x000001, "Member 'FTESGrassData::MinSlopeDegrees' has a wrong offset!");
static_assert(offsetof(FTESGrassData, MaxSlopeDegrees) == 0x000002, "Member 'FTESGrassData::MaxSlopeDegrees' has a wrong offset!");
static_assert(offsetof(FTESGrassData, DistanceFromWaterLevel) == 0x000004, "Member 'FTESGrassData::DistanceFromWaterLevel' has a wrong offset!");
static_assert(offsetof(FTESGrassData, Underwater) == 0x000008, "Member 'FTESGrassData::Underwater' has a wrong offset!");
static_assert(offsetof(FTESGrassData, PositionRange) == 0x00000C, "Member 'FTESGrassData::PositionRange' has a wrong offset!");
static_assert(offsetof(FTESGrassData, HeightRange) == 0x000010, "Member 'FTESGrassData::HeightRange' has a wrong offset!");
static_assert(offsetof(FTESGrassData, ColorRange) == 0x000014, "Member 'FTESGrassData::ColorRange' has a wrong offset!");
static_assert(offsetof(FTESGrassData, WavePeriod) == 0x000018, "Member 'FTESGrassData::WavePeriod' has a wrong offset!");
static_assert(offsetof(FTESGrassData, Flags) == 0x00001C, "Member 'FTESGrassData::Flags' has a wrong offset!");

// ScriptStruct Altar.ColorProperty
// 0x0008 (0x0008 - 0x0000)
struct FColorProperty final
{
public:
	struct FColor                                 Color;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInRandomization;                             // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmptyColor;                                     // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FColorProperty) == 0x000004, "Wrong alignment on FColorProperty");
static_assert(sizeof(FColorProperty) == 0x000008, "Wrong size on FColorProperty");
static_assert(offsetof(FColorProperty, Color) == 0x000000, "Member 'FColorProperty::Color' has a wrong offset!");
static_assert(offsetof(FColorProperty, bAllowInRandomization) == 0x000004, "Member 'FColorProperty::bAllowInRandomization' has a wrong offset!");
static_assert(offsetof(FColorProperty, bIsEmptyColor) == 0x000005, "Member 'FColorProperty::bIsEmptyColor' has a wrong offset!");

// ScriptStruct Altar.ModernRaceSexMenuColorProperties
// 0x0020 (0x0020 - 0x0000)
struct FModernRaceSexMenuColorProperties final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionIndex;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FColorProperty>                 Options;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernRaceSexMenuColorProperties) == 0x000008, "Wrong alignment on FModernRaceSexMenuColorProperties");
static_assert(sizeof(FModernRaceSexMenuColorProperties) == 0x000020, "Wrong size on FModernRaceSexMenuColorProperties");
static_assert(offsetof(FModernRaceSexMenuColorProperties, Key) == 0x000000, "Member 'FModernRaceSexMenuColorProperties::Key' has a wrong offset!");
static_assert(offsetof(FModernRaceSexMenuColorProperties, OptionIndex) == 0x000008, "Member 'FModernRaceSexMenuColorProperties::OptionIndex' has a wrong offset!");
static_assert(offsetof(FModernRaceSexMenuColorProperties, Options) == 0x000010, "Member 'FModernRaceSexMenuColorProperties::Options' has a wrong offset!");

// ScriptStruct Altar.ModernEffectItemData
// 0x0060 (0x0060 - 0x0000)
struct FModernEffectItemData final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectID;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EffectName;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   AdditionalEffectName;                              // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EModernEffectItemRange                        Range;                                             // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MagickaCost;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magnitude;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModernMagnitudeType                          MagnitudeType;                                     // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AreaOfEffect;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Duration;                                          // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Image;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModernSpellType                              MagicType;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActiveEffect;                                   // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernEffectItemData) == 0x000008, "Wrong alignment on FModernEffectItemData");
static_assert(sizeof(FModernEffectItemData) == 0x000060, "Wrong size on FModernEffectItemData");
static_assert(offsetof(FModernEffectItemData, Index) == 0x000000, "Member 'FModernEffectItemData::Index' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, EffectID) == 0x000004, "Member 'FModernEffectItemData::EffectID' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, EffectName) == 0x000008, "Member 'FModernEffectItemData::EffectName' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, AdditionalEffectName) == 0x000020, "Member 'FModernEffectItemData::AdditionalEffectName' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, Range) == 0x000038, "Member 'FModernEffectItemData::Range' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, MagickaCost) == 0x00003C, "Member 'FModernEffectItemData::MagickaCost' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, Magnitude) == 0x000040, "Member 'FModernEffectItemData::Magnitude' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, MagnitudeType) == 0x000044, "Member 'FModernEffectItemData::MagnitudeType' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, AreaOfEffect) == 0x000048, "Member 'FModernEffectItemData::AreaOfEffect' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, Duration) == 0x00004C, "Member 'FModernEffectItemData::Duration' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, Image) == 0x000050, "Member 'FModernEffectItemData::Image' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, MagicType) == 0x000058, "Member 'FModernEffectItemData::MagicType' has a wrong offset!");
static_assert(offsetof(FModernEffectItemData, bIsActiveEffect) == 0x000059, "Member 'FModernEffectItemData::bIsActiveEffect' has a wrong offset!");

// ScriptStruct Altar.FooterInputActionDescription
// 0x0020 (0x0020 - 0x0000)
struct FFooterInputActionDescription final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFooterInputActionDescription) == 0x000008, "Wrong alignment on FFooterInputActionDescription");
static_assert(sizeof(FFooterInputActionDescription) == 0x000020, "Wrong size on FFooterInputActionDescription");
static_assert(offsetof(FFooterInputActionDescription, InputAction) == 0x000000, "Member 'FFooterInputActionDescription::InputAction' has a wrong offset!");
static_assert(offsetof(FFooterInputActionDescription, Description) == 0x000008, "Member 'FFooterInputActionDescription::Description' has a wrong offset!");

// ScriptStruct Altar.VAltarSettings
// 0x0020 (0x0020 - 0x0000)
struct FVAltarSettings final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVAltarSettings) == 0x000008, "Wrong alignment on FVAltarSettings");
static_assert(sizeof(FVAltarSettings) == 0x000020, "Wrong size on FVAltarSettings");
static_assert(offsetof(FVAltarSettings, Command) == 0x000000, "Member 'FVAltarSettings::Command' has a wrong offset!");
static_assert(offsetof(FVAltarSettings, Value) == 0x000010, "Member 'FVAltarSettings::Value' has a wrong offset!");

// ScriptStruct Altar.PlayerNamePair
// 0x0028 (0x0028 - 0x0000)
struct FPlayerNamePair final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Value;                                             // 0x0010(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerNamePair) == 0x000008, "Wrong alignment on FPlayerNamePair");
static_assert(sizeof(FPlayerNamePair) == 0x000028, "Wrong size on FPlayerNamePair");
static_assert(offsetof(FPlayerNamePair, Key) == 0x000000, "Member 'FPlayerNamePair::Key' has a wrong offset!");
static_assert(offsetof(FPlayerNamePair, Value) == 0x000010, "Member 'FPlayerNamePair::Value' has a wrong offset!");

// ScriptStruct Altar.VAltarRebind
// 0x0010 (0x0010 - 0x0000)
struct FVAltarRebind final
{
public:
	TArray<struct FKey>                           Slots;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVAltarRebind) == 0x000008, "Wrong alignment on FVAltarRebind");
static_assert(sizeof(FVAltarRebind) == 0x000010, "Wrong size on FVAltarRebind");
static_assert(offsetof(FVAltarRebind, Slots) == 0x000000, "Member 'FVAltarRebind::Slots' has a wrong offset!");

// ScriptStruct Altar.LoadScreenPlayerData
// 0x0020 (0x0020 - 0x0000)
struct FLoadScreenPlayerData final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         CurrentLevel;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanLevelUp;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadScreenPlayerData) == 0x000008, "Wrong alignment on FLoadScreenPlayerData");
static_assert(sizeof(FLoadScreenPlayerData) == 0x000020, "Wrong size on FLoadScreenPlayerData");
static_assert(offsetof(FLoadScreenPlayerData, Name) == 0x000000, "Member 'FLoadScreenPlayerData::Name' has a wrong offset!");
static_assert(offsetof(FLoadScreenPlayerData, CurrentLevel) == 0x000018, "Member 'FLoadScreenPlayerData::CurrentLevel' has a wrong offset!");
static_assert(offsetof(FLoadScreenPlayerData, bCanLevelUp) == 0x00001C, "Member 'FLoadScreenPlayerData::bCanLevelUp' has a wrong offset!");

// ScriptStruct Altar.StandSneakBowAttackAnimSet
// 0x0038 (0x0038 - 0x0000)
struct FStandSneakBowAttackAnimSet final
{
public:
	class UAnimSequenceBase*                      Start;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Loop;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Release;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Sneak_Start;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Sneak_Loop;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Sneak_Release;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            AimOffsetBlendSpace;                               // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandSneakBowAttackAnimSet) == 0x000008, "Wrong alignment on FStandSneakBowAttackAnimSet");
static_assert(sizeof(FStandSneakBowAttackAnimSet) == 0x000038, "Wrong size on FStandSneakBowAttackAnimSet");
static_assert(offsetof(FStandSneakBowAttackAnimSet, Start) == 0x000000, "Member 'FStandSneakBowAttackAnimSet::Start' has a wrong offset!");
static_assert(offsetof(FStandSneakBowAttackAnimSet, Loop) == 0x000008, "Member 'FStandSneakBowAttackAnimSet::Loop' has a wrong offset!");
static_assert(offsetof(FStandSneakBowAttackAnimSet, Release) == 0x000010, "Member 'FStandSneakBowAttackAnimSet::Release' has a wrong offset!");
static_assert(offsetof(FStandSneakBowAttackAnimSet, Sneak_Start) == 0x000018, "Member 'FStandSneakBowAttackAnimSet::Sneak_Start' has a wrong offset!");
static_assert(offsetof(FStandSneakBowAttackAnimSet, Sneak_Loop) == 0x000020, "Member 'FStandSneakBowAttackAnimSet::Sneak_Loop' has a wrong offset!");
static_assert(offsetof(FStandSneakBowAttackAnimSet, Sneak_Release) == 0x000028, "Member 'FStandSneakBowAttackAnimSet::Sneak_Release' has a wrong offset!");
static_assert(offsetof(FStandSneakBowAttackAnimSet, AimOffsetBlendSpace) == 0x000030, "Member 'FStandSneakBowAttackAnimSet::AimOffsetBlendSpace' has a wrong offset!");

// ScriptStruct Altar.MenuNavigationElements
// 0x0028 (0x0028 - 0x0000)
struct FMenuNavigationElements final
{
public:
	TScriptInterface<class INavigationUIElement>  Current;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class INavigationUIElement>  Default;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarMenu*                            Menu;                                              // 0x0020(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuNavigationElements) == 0x000008, "Wrong alignment on FMenuNavigationElements");
static_assert(sizeof(FMenuNavigationElements) == 0x000028, "Wrong size on FMenuNavigationElements");
static_assert(offsetof(FMenuNavigationElements, Current) == 0x000000, "Member 'FMenuNavigationElements::Current' has a wrong offset!");
static_assert(offsetof(FMenuNavigationElements, Default) == 0x000010, "Member 'FMenuNavigationElements::Default' has a wrong offset!");
static_assert(offsetof(FMenuNavigationElements, Menu) == 0x000020, "Member 'FMenuNavigationElements::Menu' has a wrong offset!");

// ScriptStruct Altar.ModernTutorialDisplayTime
// 0x0008 (0x0010 - 0x0008)
struct FModernTutorialDisplayTime final : public FTableRowBase
{
public:
	float                                         Time;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernTutorialDisplayTime) == 0x000008, "Wrong alignment on FModernTutorialDisplayTime");
static_assert(sizeof(FModernTutorialDisplayTime) == 0x000010, "Wrong size on FModernTutorialDisplayTime");
static_assert(offsetof(FModernTutorialDisplayTime, Time) == 0x000008, "Member 'FModernTutorialDisplayTime::Time' has a wrong offset!");

// ScriptStruct Altar.VCharacterBodyPartProperties
// 0x0028 (0x0028 - 0x0000)
struct FVCharacterBodyPartProperties final
{
public:
	bool                                          bIsCovered;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTESForm*                               EquipmentForm;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVModularBodyPartBase>      EquippedClass;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVCharacterBodyPartProperties) == 0x000008, "Wrong alignment on FVCharacterBodyPartProperties");
static_assert(sizeof(FVCharacterBodyPartProperties) == 0x000028, "Wrong size on FVCharacterBodyPartProperties");
static_assert(offsetof(FVCharacterBodyPartProperties, bIsCovered) == 0x000000, "Member 'FVCharacterBodyPartProperties::bIsCovered' has a wrong offset!");
static_assert(offsetof(FVCharacterBodyPartProperties, EquipmentForm) == 0x000008, "Member 'FVCharacterBodyPartProperties::EquipmentForm' has a wrong offset!");
static_assert(offsetof(FVCharacterBodyPartProperties, EquippedClass) == 0x000010, "Member 'FVCharacterBodyPartProperties::EquippedClass' has a wrong offset!");

// ScriptStruct Altar.VAltarRebindMap
// 0x0050 (0x0050 - 0x0000)
struct FVAltarRebindMap final
{
public:
	TMap<class FString, struct FVAltarRebind>     AltarRebindMap;                                    // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FVAltarRebindMap) == 0x000008, "Wrong alignment on FVAltarRebindMap");
static_assert(sizeof(FVAltarRebindMap) == 0x000050, "Wrong size on FVAltarRebindMap");
static_assert(offsetof(FVAltarRebindMap, AltarRebindMap) == 0x000000, "Member 'FVAltarRebindMap::AltarRebindMap' has a wrong offset!");

// ScriptStruct Altar.HitReactionData
// 0x0040 (0x0040 - 0x0000)
struct FHitReactionData final
{
public:
	float                                         HitReactForceLight;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactForceHeavy;                                // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactForceProjectile;                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactForceSpell;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactDuration;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverDuration;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGravity;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PelvisBoneName;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultBoneName;                                   // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ValidBoneNames;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitReactionData) == 0x000008, "Wrong alignment on FHitReactionData");
static_assert(sizeof(FHitReactionData) == 0x000040, "Wrong size on FHitReactionData");
static_assert(offsetof(FHitReactionData, HitReactForceLight) == 0x000000, "Member 'FHitReactionData::HitReactForceLight' has a wrong offset!");
static_assert(offsetof(FHitReactionData, HitReactForceHeavy) == 0x000004, "Member 'FHitReactionData::HitReactForceHeavy' has a wrong offset!");
static_assert(offsetof(FHitReactionData, HitReactForceProjectile) == 0x000008, "Member 'FHitReactionData::HitReactForceProjectile' has a wrong offset!");
static_assert(offsetof(FHitReactionData, HitReactForceSpell) == 0x00000C, "Member 'FHitReactionData::HitReactForceSpell' has a wrong offset!");
static_assert(offsetof(FHitReactionData, ReactDuration) == 0x000010, "Member 'FHitReactionData::ReactDuration' has a wrong offset!");
static_assert(offsetof(FHitReactionData, RecoverDuration) == 0x000014, "Member 'FHitReactionData::RecoverDuration' has a wrong offset!");
static_assert(offsetof(FHitReactionData, bUseGravity) == 0x000018, "Member 'FHitReactionData::bUseGravity' has a wrong offset!");
static_assert(offsetof(FHitReactionData, PelvisBoneName) == 0x00001C, "Member 'FHitReactionData::PelvisBoneName' has a wrong offset!");
static_assert(offsetof(FHitReactionData, DefaultBoneName) == 0x000024, "Member 'FHitReactionData::DefaultBoneName' has a wrong offset!");
static_assert(offsetof(FHitReactionData, ValidBoneNames) == 0x000030, "Member 'FHitReactionData::ValidBoneNames' has a wrong offset!");

// ScriptStruct Altar.VInventoryPreviewPositionOverride
// 0x0048 (0x0048 - 0x0000)
struct FVInventoryPreviewPositionOverride final
{
public:
	struct FVector                                DefaultLocationOffset;                             // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DefaultRotationOverride;                           // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MultiplicativeScaleOffset;                         // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVInventoryPreviewPositionOverride) == 0x000008, "Wrong alignment on FVInventoryPreviewPositionOverride");
static_assert(sizeof(FVInventoryPreviewPositionOverride) == 0x000048, "Wrong size on FVInventoryPreviewPositionOverride");
static_assert(offsetof(FVInventoryPreviewPositionOverride, DefaultLocationOffset) == 0x000000, "Member 'FVInventoryPreviewPositionOverride::DefaultLocationOffset' has a wrong offset!");
static_assert(offsetof(FVInventoryPreviewPositionOverride, DefaultRotationOverride) == 0x000018, "Member 'FVInventoryPreviewPositionOverride::DefaultRotationOverride' has a wrong offset!");
static_assert(offsetof(FVInventoryPreviewPositionOverride, MultiplicativeScaleOffset) == 0x000030, "Member 'FVInventoryPreviewPositionOverride::MultiplicativeScaleOffset' has a wrong offset!");

// ScriptStruct Altar.VPreviewDefaultLocationRotationTableRow
// 0x0050 (0x0058 - 0x0008)
struct FVPreviewDefaultLocationRotationTableRow final : public FTableRowBase
{
public:
	EFormID                                       FormType;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVInventoryPreviewPositionOverride     DefaultParameters;                                 // 0x0010(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVPreviewDefaultLocationRotationTableRow) == 0x000008, "Wrong alignment on FVPreviewDefaultLocationRotationTableRow");
static_assert(sizeof(FVPreviewDefaultLocationRotationTableRow) == 0x000058, "Wrong size on FVPreviewDefaultLocationRotationTableRow");
static_assert(offsetof(FVPreviewDefaultLocationRotationTableRow, FormType) == 0x000008, "Member 'FVPreviewDefaultLocationRotationTableRow::FormType' has a wrong offset!");
static_assert(offsetof(FVPreviewDefaultLocationRotationTableRow, DefaultParameters) == 0x000010, "Member 'FVPreviewDefaultLocationRotationTableRow::DefaultParameters' has a wrong offset!");

// ScriptStruct Altar.VProjectilePenetrationSettings
// 0x0014 (0x0014 - 0x0000)
struct FVProjectilePenetrationSettings final
{
public:
	bool                                          bIsPenetrationAllowed;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinPenetrationDepth;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPenetrationDepth;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocityThreshold;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocityThreshold;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVProjectilePenetrationSettings) == 0x000004, "Wrong alignment on FVProjectilePenetrationSettings");
static_assert(sizeof(FVProjectilePenetrationSettings) == 0x000014, "Wrong size on FVProjectilePenetrationSettings");
static_assert(offsetof(FVProjectilePenetrationSettings, bIsPenetrationAllowed) == 0x000000, "Member 'FVProjectilePenetrationSettings::bIsPenetrationAllowed' has a wrong offset!");
static_assert(offsetof(FVProjectilePenetrationSettings, MinPenetrationDepth) == 0x000004, "Member 'FVProjectilePenetrationSettings::MinPenetrationDepth' has a wrong offset!");
static_assert(offsetof(FVProjectilePenetrationSettings, MaxPenetrationDepth) == 0x000008, "Member 'FVProjectilePenetrationSettings::MaxPenetrationDepth' has a wrong offset!");
static_assert(offsetof(FVProjectilePenetrationSettings, MinVelocityThreshold) == 0x00000C, "Member 'FVProjectilePenetrationSettings::MinVelocityThreshold' has a wrong offset!");
static_assert(offsetof(FVProjectilePenetrationSettings, MaxVelocityThreshold) == 0x000010, "Member 'FVProjectilePenetrationSettings::MaxVelocityThreshold' has a wrong offset!");

// ScriptStruct Altar.ImpactSystemRowBase
// 0x00A0 (0x00A8 - 0x0008)
struct FImpactSystemRowBase final : public FTableRowBase
{
public:
	EPhysicalSurface                              TargetMaterial;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ImpactSystemBlueprintClass;                        // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WwiseSwitchType;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FootStepVFXBlueprintClass;                         // 0x0040(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVProjectilePenetrationSettings        ProjectilePenetrationSettings;                     // 0x0068(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PawnSparkBlueprintClass;                           // 0x0080(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactSystemRowBase) == 0x000008, "Wrong alignment on FImpactSystemRowBase");
static_assert(sizeof(FImpactSystemRowBase) == 0x0000A8, "Wrong size on FImpactSystemRowBase");
static_assert(offsetof(FImpactSystemRowBase, TargetMaterial) == 0x000008, "Member 'FImpactSystemRowBase::TargetMaterial' has a wrong offset!");
static_assert(offsetof(FImpactSystemRowBase, ImpactSystemBlueprintClass) == 0x000010, "Member 'FImpactSystemRowBase::ImpactSystemBlueprintClass' has a wrong offset!");
static_assert(offsetof(FImpactSystemRowBase, WwiseSwitchType) == 0x000038, "Member 'FImpactSystemRowBase::WwiseSwitchType' has a wrong offset!");
static_assert(offsetof(FImpactSystemRowBase, FootStepVFXBlueprintClass) == 0x000040, "Member 'FImpactSystemRowBase::FootStepVFXBlueprintClass' has a wrong offset!");
static_assert(offsetof(FImpactSystemRowBase, ProjectilePenetrationSettings) == 0x000068, "Member 'FImpactSystemRowBase::ProjectilePenetrationSettings' has a wrong offset!");
static_assert(offsetof(FImpactSystemRowBase, PawnSparkBlueprintClass) == 0x000080, "Member 'FImpactSystemRowBase::PawnSparkBlueprintClass' has a wrong offset!");

// ScriptStruct Altar.VModularBody
// 0x0040 (0x0040 - 0x0000)
struct FVModularBody final
{
public:
	TSubclassOf<class AVHelmetModularBodyPart>    Helmet;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVRingModularBodyPart>      RightRing;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVRingModularBodyPart>      LeftRing;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVAmuletModularBodyPart>    Amulet;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVUpperBodyModularBodyPart> UpperBody;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVHandsModularBodyPart>     Hands;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVLowerBodyModularBodyPart> LowerBody;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVFeetModularBodyPart>      Feet;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVModularBody) == 0x000008, "Wrong alignment on FVModularBody");
static_assert(sizeof(FVModularBody) == 0x000040, "Wrong size on FVModularBody");
static_assert(offsetof(FVModularBody, Helmet) == 0x000000, "Member 'FVModularBody::Helmet' has a wrong offset!");
static_assert(offsetof(FVModularBody, RightRing) == 0x000008, "Member 'FVModularBody::RightRing' has a wrong offset!");
static_assert(offsetof(FVModularBody, LeftRing) == 0x000010, "Member 'FVModularBody::LeftRing' has a wrong offset!");
static_assert(offsetof(FVModularBody, Amulet) == 0x000018, "Member 'FVModularBody::Amulet' has a wrong offset!");
static_assert(offsetof(FVModularBody, UpperBody) == 0x000020, "Member 'FVModularBody::UpperBody' has a wrong offset!");
static_assert(offsetof(FVModularBody, Hands) == 0x000028, "Member 'FVModularBody::Hands' has a wrong offset!");
static_assert(offsetof(FVModularBody, LowerBody) == 0x000030, "Member 'FVModularBody::LowerBody' has a wrong offset!");
static_assert(offsetof(FVModularBody, Feet) == 0x000038, "Member 'FVModularBody::Feet' has a wrong offset!");

// ScriptStruct Altar.ReplacementMaterial
// 0x0010 (0x0010 - 0x0000)
struct FReplacementMaterial final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSlot;                                      // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplacementMaterial) == 0x000008, "Wrong alignment on FReplacementMaterial");
static_assert(sizeof(FReplacementMaterial) == 0x000010, "Wrong size on FReplacementMaterial");
static_assert(offsetof(FReplacementMaterial, Index) == 0x000000, "Member 'FReplacementMaterial::Index' has a wrong offset!");
static_assert(offsetof(FReplacementMaterial, bDisableSlot) == 0x000004, "Member 'FReplacementMaterial::bDisableSlot' has a wrong offset!");
static_assert(offsetof(FReplacementMaterial, Material) == 0x000008, "Member 'FReplacementMaterial::Material' has a wrong offset!");

// ScriptStruct Altar.VInstanceMeshReplacement
// 0x0020 (0x0020 - 0x0000)
struct FVInstanceMeshReplacement final
{
public:
	EVInstanceReplacementType                     ReplacementType;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            StaticMesh;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FReplacementMaterial>           Materials;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVInstanceMeshReplacement) == 0x000008, "Wrong alignment on FVInstanceMeshReplacement");
static_assert(sizeof(FVInstanceMeshReplacement) == 0x000020, "Wrong size on FVInstanceMeshReplacement");
static_assert(offsetof(FVInstanceMeshReplacement, ReplacementType) == 0x000000, "Member 'FVInstanceMeshReplacement::ReplacementType' has a wrong offset!");
static_assert(offsetof(FVInstanceMeshReplacement, StaticMesh) == 0x000008, "Member 'FVInstanceMeshReplacement::StaticMesh' has a wrong offset!");
static_assert(offsetof(FVInstanceMeshReplacement, Materials) == 0x000010, "Member 'FVInstanceMeshReplacement::Materials' has a wrong offset!");

// ScriptStruct Altar.RaceSexMenuPhenotypeData
// 0x0100 (0x0100 - 0x0000)
struct FRaceSexMenuPhenotypeData final
{
public:
	class UTESRace*                               Race;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterSex                                 Gender;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      MorphTargets;                                      // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              ColorTargets;                                      // 0x0060(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<ELegacyRaceSexMenuToggleType, int32>     CustomisationTargets;                              // 0x00B0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRaceSexMenuPhenotypeData) == 0x000008, "Wrong alignment on FRaceSexMenuPhenotypeData");
static_assert(sizeof(FRaceSexMenuPhenotypeData) == 0x000100, "Wrong size on FRaceSexMenuPhenotypeData");
static_assert(offsetof(FRaceSexMenuPhenotypeData, Race) == 0x000000, "Member 'FRaceSexMenuPhenotypeData::Race' has a wrong offset!");
static_assert(offsetof(FRaceSexMenuPhenotypeData, Gender) == 0x000008, "Member 'FRaceSexMenuPhenotypeData::Gender' has a wrong offset!");
static_assert(offsetof(FRaceSexMenuPhenotypeData, MorphTargets) == 0x000010, "Member 'FRaceSexMenuPhenotypeData::MorphTargets' has a wrong offset!");
static_assert(offsetof(FRaceSexMenuPhenotypeData, ColorTargets) == 0x000060, "Member 'FRaceSexMenuPhenotypeData::ColorTargets' has a wrong offset!");
static_assert(offsetof(FRaceSexMenuPhenotypeData, CustomisationTargets) == 0x0000B0, "Member 'FRaceSexMenuPhenotypeData::CustomisationTargets' has a wrong offset!");

// ScriptStruct Altar.VHorseLocomotionData
// 0x0050 (0x0050 - 0x0000)
struct FVHorseLocomotionData final
{
public:
	class UAnimSequenceBase*                      Idle;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            WalkBlendSpace;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            TrotBlendSpace;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CanterGallopBlendSpace;                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            WalkBackward;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StartBlendSpace;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StopBlendSpace;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              SpecialIdles;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UBlendSpace*                            UndockedMovingBlendSpace;                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVHorseLocomotionData) == 0x000008, "Wrong alignment on FVHorseLocomotionData");
static_assert(sizeof(FVHorseLocomotionData) == 0x000050, "Wrong size on FVHorseLocomotionData");
static_assert(offsetof(FVHorseLocomotionData, Idle) == 0x000000, "Member 'FVHorseLocomotionData::Idle' has a wrong offset!");
static_assert(offsetof(FVHorseLocomotionData, WalkBlendSpace) == 0x000008, "Member 'FVHorseLocomotionData::WalkBlendSpace' has a wrong offset!");
static_assert(offsetof(FVHorseLocomotionData, TrotBlendSpace) == 0x000010, "Member 'FVHorseLocomotionData::TrotBlendSpace' has a wrong offset!");
static_assert(offsetof(FVHorseLocomotionData, CanterGallopBlendSpace) == 0x000018, "Member 'FVHorseLocomotionData::CanterGallopBlendSpace' has a wrong offset!");
static_assert(offsetof(FVHorseLocomotionData, WalkBackward) == 0x000020, "Member 'FVHorseLocomotionData::WalkBackward' has a wrong offset!");
static_assert(offsetof(FVHorseLocomotionData, StartBlendSpace) == 0x000028, "Member 'FVHorseLocomotionData::StartBlendSpace' has a wrong offset!");
static_assert(offsetof(FVHorseLocomotionData, StopBlendSpace) == 0x000030, "Member 'FVHorseLocomotionData::StopBlendSpace' has a wrong offset!");
static_assert(offsetof(FVHorseLocomotionData, SpecialIdles) == 0x000038, "Member 'FVHorseLocomotionData::SpecialIdles' has a wrong offset!");
static_assert(offsetof(FVHorseLocomotionData, UndockedMovingBlendSpace) == 0x000048, "Member 'FVHorseLocomotionData::UndockedMovingBlendSpace' has a wrong offset!");

// ScriptStruct Altar.ItemToEnchantInfo
// 0x0020 (0x0020 - 0x0000)
struct FItemToEnchantInfo final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemToEnchantInfo) == 0x000008, "Wrong alignment on FItemToEnchantInfo");
static_assert(sizeof(FItemToEnchantInfo) == 0x000020, "Wrong size on FItemToEnchantInfo");
static_assert(offsetof(FItemToEnchantInfo, Name) == 0x000000, "Member 'FItemToEnchantInfo::Name' has a wrong offset!");
static_assert(offsetof(FItemToEnchantInfo, Icon) == 0x000018, "Member 'FItemToEnchantInfo::Icon' has a wrong offset!");

// ScriptStruct Altar.InputText
// 0x0030 (0x0030 - 0x0000)
struct FInputText final
{
public:
	class FText                                   ControllerText;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   KeyboardText;                                      // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputText) == 0x000008, "Wrong alignment on FInputText");
static_assert(sizeof(FInputText) == 0x000030, "Wrong size on FInputText");
static_assert(offsetof(FInputText, ControllerText) == 0x000000, "Member 'FInputText::ControllerText' has a wrong offset!");
static_assert(offsetof(FInputText, KeyboardText) == 0x000018, "Member 'FInputText::KeyboardText' has a wrong offset!");

// ScriptStruct Altar.VATMRecordingFrameMoon
// 0x0014 (0x0014 - 0x0000)
struct FVATMRecordingFrameMoon final
{
public:
	bool                                          bUpdated;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateRevolution;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateAxisAltitude;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Phase;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseProgress;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVATMRecordingFrameMoon) == 0x000004, "Wrong alignment on FVATMRecordingFrameMoon");
static_assert(sizeof(FVATMRecordingFrameMoon) == 0x000014, "Wrong size on FVATMRecordingFrameMoon");
static_assert(offsetof(FVATMRecordingFrameMoon, bUpdated) == 0x000000, "Member 'FVATMRecordingFrameMoon::bUpdated' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameMoon, RotateRevolution) == 0x000004, "Member 'FVATMRecordingFrameMoon::RotateRevolution' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameMoon, RotateAxisAltitude) == 0x000008, "Member 'FVATMRecordingFrameMoon::RotateAxisAltitude' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameMoon, Phase) == 0x00000C, "Member 'FVATMRecordingFrameMoon::Phase' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameMoon, PhaseProgress) == 0x000010, "Member 'FVATMRecordingFrameMoon::PhaseProgress' has a wrong offset!");

// ScriptStruct Altar.OriginalInventoryMenuItemProperties
// 0x0050 (0x0050 - 0x0000)
struct FOriginalInventoryMenuItemProperties final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Price;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponDamage;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorRating;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELegacyInventoryMenuItemType                  Type;                                              // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquiped;                                        // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFavorite;                                       // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InventoryIndex;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESForm*                               form;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatusFlags;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInventoryItem;                                  // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInContainerMenu;                                // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOriginalInventoryMenuItemProperties) == 0x000008, "Wrong alignment on FOriginalInventoryMenuItemProperties");
static_assert(sizeof(FOriginalInventoryMenuItemProperties) == 0x000050, "Wrong size on FOriginalInventoryMenuItemProperties");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, Name) == 0x000000, "Member 'FOriginalInventoryMenuItemProperties::Name' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, Price) == 0x000018, "Member 'FOriginalInventoryMenuItemProperties::Price' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, Weight) == 0x00001C, "Member 'FOriginalInventoryMenuItemProperties::Weight' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, WeaponDamage) == 0x000020, "Member 'FOriginalInventoryMenuItemProperties::WeaponDamage' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, ArmorRating) == 0x000024, "Member 'FOriginalInventoryMenuItemProperties::ArmorRating' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, Health) == 0x000028, "Member 'FOriginalInventoryMenuItemProperties::Health' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, Count) == 0x00002C, "Member 'FOriginalInventoryMenuItemProperties::Count' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, Icon) == 0x000030, "Member 'FOriginalInventoryMenuItemProperties::Icon' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, Type) == 0x000038, "Member 'FOriginalInventoryMenuItemProperties::Type' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, bIsEquiped) == 0x000039, "Member 'FOriginalInventoryMenuItemProperties::bIsEquiped' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, bIsFavorite) == 0x00003A, "Member 'FOriginalInventoryMenuItemProperties::bIsFavorite' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, InventoryIndex) == 0x00003C, "Member 'FOriginalInventoryMenuItemProperties::InventoryIndex' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, form) == 0x000040, "Member 'FOriginalInventoryMenuItemProperties::form' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, StatusFlags) == 0x000048, "Member 'FOriginalInventoryMenuItemProperties::StatusFlags' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, bIsInventoryItem) == 0x00004C, "Member 'FOriginalInventoryMenuItemProperties::bIsInventoryItem' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemProperties, bIsInContainerMenu) == 0x00004D, "Member 'FOriginalInventoryMenuItemProperties::bIsInContainerMenu' has a wrong offset!");

// ScriptStruct Altar.ModernHelpMenuEntry
// 0x00B0 (0x00B8 - 0x0008)
struct FModernHelpMenuEntry final : public FTableRowBase
{
public:
	class FText                                   EntryName;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   EntryCategory;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CardTitle;                                         // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CardText;                                          // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CardControllerText;                                // 0x0068(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CardDescription;                                   // 0x0080(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             CardTexture;                                       // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VideoPath;                                         // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             EntryIcon;                                         // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernHelpMenuEntry) == 0x000008, "Wrong alignment on FModernHelpMenuEntry");
static_assert(sizeof(FModernHelpMenuEntry) == 0x0000B8, "Wrong size on FModernHelpMenuEntry");
static_assert(offsetof(FModernHelpMenuEntry, EntryName) == 0x000008, "Member 'FModernHelpMenuEntry::EntryName' has a wrong offset!");
static_assert(offsetof(FModernHelpMenuEntry, EntryCategory) == 0x000020, "Member 'FModernHelpMenuEntry::EntryCategory' has a wrong offset!");
static_assert(offsetof(FModernHelpMenuEntry, CardTitle) == 0x000038, "Member 'FModernHelpMenuEntry::CardTitle' has a wrong offset!");
static_assert(offsetof(FModernHelpMenuEntry, CardText) == 0x000050, "Member 'FModernHelpMenuEntry::CardText' has a wrong offset!");
static_assert(offsetof(FModernHelpMenuEntry, CardControllerText) == 0x000068, "Member 'FModernHelpMenuEntry::CardControllerText' has a wrong offset!");
static_assert(offsetof(FModernHelpMenuEntry, CardDescription) == 0x000080, "Member 'FModernHelpMenuEntry::CardDescription' has a wrong offset!");
static_assert(offsetof(FModernHelpMenuEntry, CardTexture) == 0x000098, "Member 'FModernHelpMenuEntry::CardTexture' has a wrong offset!");
static_assert(offsetof(FModernHelpMenuEntry, VideoPath) == 0x0000A0, "Member 'FModernHelpMenuEntry::VideoPath' has a wrong offset!");
static_assert(offsetof(FModernHelpMenuEntry, EntryIcon) == 0x0000B0, "Member 'FModernHelpMenuEntry::EntryIcon' has a wrong offset!");

// ScriptStruct Altar.HelpEntryCategoryData
// 0x0050 (0x0050 - 0x0000)
struct FHelpEntryCategoryData final
{
public:
	TMap<class FName, struct FModernHelpMenuEntry> Data;                                             // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHelpEntryCategoryData) == 0x000008, "Wrong alignment on FHelpEntryCategoryData");
static_assert(sizeof(FHelpEntryCategoryData) == 0x000050, "Wrong size on FHelpEntryCategoryData");
static_assert(offsetof(FHelpEntryCategoryData, Data) == 0x000000, "Member 'FHelpEntryCategoryData::Data' has a wrong offset!");

// ScriptStruct Altar.LegacyInventoryMenuExtraData
// 0x0028 (0x0028 - 0x0000)
struct FLegacyInventoryMenuExtraData final
{
public:
	float                                         CurrentEncumberance;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxEncumberance;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorRating;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoldAmount;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PlayerName;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyInventoryMenuExtraData) == 0x000008, "Wrong alignment on FLegacyInventoryMenuExtraData");
static_assert(sizeof(FLegacyInventoryMenuExtraData) == 0x000028, "Wrong size on FLegacyInventoryMenuExtraData");
static_assert(offsetof(FLegacyInventoryMenuExtraData, CurrentEncumberance) == 0x000000, "Member 'FLegacyInventoryMenuExtraData::CurrentEncumberance' has a wrong offset!");
static_assert(offsetof(FLegacyInventoryMenuExtraData, MaxEncumberance) == 0x000004, "Member 'FLegacyInventoryMenuExtraData::MaxEncumberance' has a wrong offset!");
static_assert(offsetof(FLegacyInventoryMenuExtraData, ArmorRating) == 0x000008, "Member 'FLegacyInventoryMenuExtraData::ArmorRating' has a wrong offset!");
static_assert(offsetof(FLegacyInventoryMenuExtraData, GoldAmount) == 0x00000C, "Member 'FLegacyInventoryMenuExtraData::GoldAmount' has a wrong offset!");
static_assert(offsetof(FLegacyInventoryMenuExtraData, PlayerName) == 0x000010, "Member 'FLegacyInventoryMenuExtraData::PlayerName' has a wrong offset!");

// ScriptStruct Altar.Vector3s
// 0x000C (0x000C - 0x0000)
struct FVector3s final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Z;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector3s) == 0x000004, "Wrong alignment on FVector3s");
static_assert(sizeof(FVector3s) == 0x00000C, "Wrong size on FVector3s");
static_assert(offsetof(FVector3s, X) == 0x000000, "Member 'FVector3s::X' has a wrong offset!");
static_assert(offsetof(FVector3s, Y) == 0x000004, "Member 'FVector3s::Y' has a wrong offset!");
static_assert(offsetof(FVector3s, Z) == 0x000008, "Member 'FVector3s::Z' has a wrong offset!");

// ScriptStruct Altar.LegacySpellMakingCost
// 0x000C (0x000C - 0x0000)
struct FLegacySpellMakingCost final
{
public:
	int32                                         CastCost;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoldCost;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerGold;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySpellMakingCost) == 0x000004, "Wrong alignment on FLegacySpellMakingCost");
static_assert(sizeof(FLegacySpellMakingCost) == 0x00000C, "Wrong size on FLegacySpellMakingCost");
static_assert(offsetof(FLegacySpellMakingCost, CastCost) == 0x000000, "Member 'FLegacySpellMakingCost::CastCost' has a wrong offset!");
static_assert(offsetof(FLegacySpellMakingCost, GoldCost) == 0x000004, "Member 'FLegacySpellMakingCost::GoldCost' has a wrong offset!");
static_assert(offsetof(FLegacySpellMakingCost, PlayerGold) == 0x000008, "Member 'FLegacySpellMakingCost::PlayerGold' has a wrong offset!");

// ScriptStruct Altar.VHorsePhysicsData
// 0x0178 (0x0178 - 0x0000)
struct FVHorsePhysicsData final
{
public:
	class FName                                   DefaultHorseReinSocket;                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RiderHandSocket;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RiderFootLeftSocket;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RiderFootRightSocket;                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RiderCalf1LeftSocket;                              // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RiderCalf1RightSocket;                             // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RiderCalf2LeftSocket;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RiderCalf2RightSocket;                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReinLocation;                                      // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StirrupFootLeftLocation;                           // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StirrupFootRightLocation;                          // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StirrupFootLeftRotation;                           // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               StirrupFootRightRotation;                          // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                StirrupCalf1LeftLocation;                          // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StirrupCalf1RightLocation;                         // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StirrupCalf1LeftRotation;                          // 0x00E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               StirrupCalf1RightRotation;                         // 0x0100(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                StirrupCalf2LeftLocation;                          // 0x0118(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StirrupCalf2RightLocation;                         // 0x0130(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StirrupCalf2LeftRotation;                          // 0x0148(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               StirrupCalf2RightRotation;                         // 0x0160(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVHorsePhysicsData) == 0x000008, "Wrong alignment on FVHorsePhysicsData");
static_assert(sizeof(FVHorsePhysicsData) == 0x000178, "Wrong size on FVHorsePhysicsData");
static_assert(offsetof(FVHorsePhysicsData, DefaultHorseReinSocket) == 0x000000, "Member 'FVHorsePhysicsData::DefaultHorseReinSocket' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, RiderHandSocket) == 0x000008, "Member 'FVHorsePhysicsData::RiderHandSocket' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, RiderFootLeftSocket) == 0x000010, "Member 'FVHorsePhysicsData::RiderFootLeftSocket' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, RiderFootRightSocket) == 0x000018, "Member 'FVHorsePhysicsData::RiderFootRightSocket' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, RiderCalf1LeftSocket) == 0x000020, "Member 'FVHorsePhysicsData::RiderCalf1LeftSocket' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, RiderCalf1RightSocket) == 0x000028, "Member 'FVHorsePhysicsData::RiderCalf1RightSocket' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, RiderCalf2LeftSocket) == 0x000030, "Member 'FVHorsePhysicsData::RiderCalf2LeftSocket' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, RiderCalf2RightSocket) == 0x000038, "Member 'FVHorsePhysicsData::RiderCalf2RightSocket' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, ReinLocation) == 0x000040, "Member 'FVHorsePhysicsData::ReinLocation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupFootLeftLocation) == 0x000058, "Member 'FVHorsePhysicsData::StirrupFootLeftLocation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupFootRightLocation) == 0x000070, "Member 'FVHorsePhysicsData::StirrupFootRightLocation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupFootLeftRotation) == 0x000088, "Member 'FVHorsePhysicsData::StirrupFootLeftRotation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupFootRightRotation) == 0x0000A0, "Member 'FVHorsePhysicsData::StirrupFootRightRotation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupCalf1LeftLocation) == 0x0000B8, "Member 'FVHorsePhysicsData::StirrupCalf1LeftLocation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupCalf1RightLocation) == 0x0000D0, "Member 'FVHorsePhysicsData::StirrupCalf1RightLocation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupCalf1LeftRotation) == 0x0000E8, "Member 'FVHorsePhysicsData::StirrupCalf1LeftRotation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupCalf1RightRotation) == 0x000100, "Member 'FVHorsePhysicsData::StirrupCalf1RightRotation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupCalf2LeftLocation) == 0x000118, "Member 'FVHorsePhysicsData::StirrupCalf2LeftLocation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupCalf2RightLocation) == 0x000130, "Member 'FVHorsePhysicsData::StirrupCalf2RightLocation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupCalf2LeftRotation) == 0x000148, "Member 'FVHorsePhysicsData::StirrupCalf2LeftRotation' has a wrong offset!");
static_assert(offsetof(FVHorsePhysicsData, StirrupCalf2RightRotation) == 0x000160, "Member 'FVHorsePhysicsData::StirrupCalf2RightRotation' has a wrong offset!");

// ScriptStruct Altar.LegacyContainerMenuButtonData
// 0x0002 (0x0002 - 0x0000)
struct FLegacyContainerMenuButtonData final
{
public:
	bool                                          IsTakeAll;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNegotiate;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyContainerMenuButtonData) == 0x000001, "Wrong alignment on FLegacyContainerMenuButtonData");
static_assert(sizeof(FLegacyContainerMenuButtonData) == 0x000002, "Wrong size on FLegacyContainerMenuButtonData");
static_assert(offsetof(FLegacyContainerMenuButtonData, IsTakeAll) == 0x000000, "Member 'FLegacyContainerMenuButtonData::IsTakeAll' has a wrong offset!");
static_assert(offsetof(FLegacyContainerMenuButtonData, IsNegotiate) == 0x000001, "Member 'FLegacyContainerMenuButtonData::IsNegotiate' has a wrong offset!");

// ScriptStruct Altar.LegacyContainerMenuNpcData
// 0x0020 (0x0020 - 0x0000)
struct FLegacyContainerMenuNpcData final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyContainerMenuNpcData) == 0x000008, "Wrong alignment on FLegacyContainerMenuNpcData");
static_assert(sizeof(FLegacyContainerMenuNpcData) == 0x000020, "Wrong size on FLegacyContainerMenuNpcData");
static_assert(offsetof(FLegacyContainerMenuNpcData, Name) == 0x000000, "Member 'FLegacyContainerMenuNpcData::Name' has a wrong offset!");
static_assert(offsetof(FLegacyContainerMenuNpcData, Gold) == 0x000018, "Member 'FLegacyContainerMenuNpcData::Gold' has a wrong offset!");

// ScriptStruct Altar.VModernEnchantmentItemProperties
// 0x0050 (0x0050 - 0x0000)
struct FVModernEnchantmentItemProperties final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SoulLevel;                                         // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Health;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatusFlags;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAdded;                                          // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModernEnchantmentMenuItemType                Type;                                              // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x004A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVModernEnchantmentItemProperties) == 0x000008, "Wrong alignment on FVModernEnchantmentItemProperties");
static_assert(sizeof(FVModernEnchantmentItemProperties) == 0x000050, "Wrong size on FVModernEnchantmentItemProperties");
static_assert(offsetof(FVModernEnchantmentItemProperties, Index) == 0x000000, "Member 'FVModernEnchantmentItemProperties::Index' has a wrong offset!");
static_assert(offsetof(FVModernEnchantmentItemProperties, Name) == 0x000008, "Member 'FVModernEnchantmentItemProperties::Name' has a wrong offset!");
static_assert(offsetof(FVModernEnchantmentItemProperties, Icon) == 0x000020, "Member 'FVModernEnchantmentItemProperties::Icon' has a wrong offset!");
static_assert(offsetof(FVModernEnchantmentItemProperties, SoulLevel) == 0x000028, "Member 'FVModernEnchantmentItemProperties::SoulLevel' has a wrong offset!");
static_assert(offsetof(FVModernEnchantmentItemProperties, Health) == 0x000040, "Member 'FVModernEnchantmentItemProperties::Health' has a wrong offset!");
static_assert(offsetof(FVModernEnchantmentItemProperties, StatusFlags) == 0x000044, "Member 'FVModernEnchantmentItemProperties::StatusFlags' has a wrong offset!");
static_assert(offsetof(FVModernEnchantmentItemProperties, bIsAdded) == 0x000048, "Member 'FVModernEnchantmentItemProperties::bIsAdded' has a wrong offset!");
static_assert(offsetof(FVModernEnchantmentItemProperties, Type) == 0x000049, "Member 'FVModernEnchantmentItemProperties::Type' has a wrong offset!");
static_assert(offsetof(FVModernEnchantmentItemProperties, bIsSelected) == 0x00004A, "Member 'FVModernEnchantmentItemProperties::bIsSelected' has a wrong offset!");

// ScriptStruct Altar.LegacyRechargeMenuGoldProperties
// 0x0028 (0x0028 - 0x0000)
struct FLegacyRechargeMenuGoldProperties final
{
public:
	int32                                         PlayerGold;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GoldRechargeCost;                                  // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         RechargeAllAmount;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyRechargeMenuGoldProperties) == 0x000008, "Wrong alignment on FLegacyRechargeMenuGoldProperties");
static_assert(sizeof(FLegacyRechargeMenuGoldProperties) == 0x000028, "Wrong size on FLegacyRechargeMenuGoldProperties");
static_assert(offsetof(FLegacyRechargeMenuGoldProperties, PlayerGold) == 0x000000, "Member 'FLegacyRechargeMenuGoldProperties::PlayerGold' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuGoldProperties, GoldRechargeCost) == 0x000008, "Member 'FLegacyRechargeMenuGoldProperties::GoldRechargeCost' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuGoldProperties, RechargeAllAmount) == 0x000020, "Member 'FLegacyRechargeMenuGoldProperties::RechargeAllAmount' has a wrong offset!");

// ScriptStruct Altar.VLevelWeatherTextureRowBase
// 0x0008 (0x0010 - 0x0008)
struct FVLevelWeatherTextureRowBase final : public FTableRowBase
{
public:
	EVWeatherTexture                              WeatherTexture;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVLevelWeatherTextureRowBase) == 0x000008, "Wrong alignment on FVLevelWeatherTextureRowBase");
static_assert(sizeof(FVLevelWeatherTextureRowBase) == 0x000010, "Wrong size on FVLevelWeatherTextureRowBase");
static_assert(offsetof(FVLevelWeatherTextureRowBase, WeatherTexture) == 0x000008, "Member 'FVLevelWeatherTextureRowBase::WeatherTexture' has a wrong offset!");

// ScriptStruct Altar.SoulGemInfo
// 0x0028 (0x0028 - 0x0000)
struct FSoulGemInfo final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Power;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoulGemInfo) == 0x000008, "Wrong alignment on FSoulGemInfo");
static_assert(sizeof(FSoulGemInfo) == 0x000028, "Wrong size on FSoulGemInfo");
static_assert(offsetof(FSoulGemInfo, Name) == 0x000000, "Member 'FSoulGemInfo::Name' has a wrong offset!");
static_assert(offsetof(FSoulGemInfo, Icon) == 0x000018, "Member 'FSoulGemInfo::Icon' has a wrong offset!");
static_assert(offsetof(FSoulGemInfo, Power) == 0x000020, "Member 'FSoulGemInfo::Power' has a wrong offset!");

// ScriptStruct Altar.LegacyBookStylizedText
// 0x0030 (0x0030 - 0x0000)
struct FLegacyBookStylizedText final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELegacyBookStylizedTextAlignment              Alignment;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FontValue;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyBookStylizedText) == 0x000008, "Wrong alignment on FLegacyBookStylizedText");
static_assert(sizeof(FLegacyBookStylizedText) == 0x000030, "Wrong size on FLegacyBookStylizedText");
static_assert(offsetof(FLegacyBookStylizedText, Text) == 0x000000, "Member 'FLegacyBookStylizedText::Text' has a wrong offset!");
static_assert(offsetof(FLegacyBookStylizedText, Alignment) == 0x000010, "Member 'FLegacyBookStylizedText::Alignment' has a wrong offset!");
static_assert(offsetof(FLegacyBookStylizedText, FontValue) == 0x000018, "Member 'FLegacyBookStylizedText::FontValue' has a wrong offset!");
static_assert(offsetof(FLegacyBookStylizedText, Color) == 0x000028, "Member 'FLegacyBookStylizedText::Color' has a wrong offset!");

// ScriptStruct Altar.DialogueEmotion
// 0x0008 (0x0008 - 0x0000)
struct FDialogueEmotion final
{
public:
	EDialogueEmotion                              Emotion;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDialogueEmotion) == 0x000004, "Wrong alignment on FDialogueEmotion");
static_assert(sizeof(FDialogueEmotion) == 0x000008, "Wrong size on FDialogueEmotion");
static_assert(offsetof(FDialogueEmotion, Emotion) == 0x000000, "Member 'FDialogueEmotion::Emotion' has a wrong offset!");
static_assert(offsetof(FDialogueEmotion, Value) == 0x000004, "Member 'FDialogueEmotion::Value' has a wrong offset!");

// ScriptStruct Altar.LegacyStatsMenuFactionProperties
// 0x0058 (0x0058 - 0x0000)
struct FLegacyStatsMenuFactionProperties final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Rank;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   NextRank;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyStatsMenuFactionProperties) == 0x000008, "Wrong alignment on FLegacyStatsMenuFactionProperties");
static_assert(sizeof(FLegacyStatsMenuFactionProperties) == 0x000058, "Wrong size on FLegacyStatsMenuFactionProperties");
static_assert(offsetof(FLegacyStatsMenuFactionProperties, Name) == 0x000000, "Member 'FLegacyStatsMenuFactionProperties::Name' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuFactionProperties, Rank) == 0x000018, "Member 'FLegacyStatsMenuFactionProperties::Rank' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuFactionProperties, NextRank) == 0x000030, "Member 'FLegacyStatsMenuFactionProperties::NextRank' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuFactionProperties, Icon) == 0x000048, "Member 'FLegacyStatsMenuFactionProperties::Icon' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuFactionProperties, Index) == 0x000050, "Member 'FLegacyStatsMenuFactionProperties::Index' has a wrong offset!");

// ScriptStruct Altar.OriginalMaterial
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FOriginalMaterial final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOriginalMaterial) == 0x000008, "Wrong alignment on FOriginalMaterial");
static_assert(sizeof(FOriginalMaterial) == 0x000018, "Wrong size on FOriginalMaterial");

// ScriptStruct Altar.CreatureBipedBoneAnimationData
// 0x0020 (0x0020 - 0x0000)
struct FCreatureBipedBoneAnimationData final
{
public:
	class FName                                   PelvisBoneName;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PelvisBlendDepth;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftLegBoneName;                                   // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightLegBoneName;                                  // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegsBlendDepth;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreatureBipedBoneAnimationData) == 0x000004, "Wrong alignment on FCreatureBipedBoneAnimationData");
static_assert(sizeof(FCreatureBipedBoneAnimationData) == 0x000020, "Wrong size on FCreatureBipedBoneAnimationData");
static_assert(offsetof(FCreatureBipedBoneAnimationData, PelvisBoneName) == 0x000000, "Member 'FCreatureBipedBoneAnimationData::PelvisBoneName' has a wrong offset!");
static_assert(offsetof(FCreatureBipedBoneAnimationData, PelvisBlendDepth) == 0x000008, "Member 'FCreatureBipedBoneAnimationData::PelvisBlendDepth' has a wrong offset!");
static_assert(offsetof(FCreatureBipedBoneAnimationData, LeftLegBoneName) == 0x00000C, "Member 'FCreatureBipedBoneAnimationData::LeftLegBoneName' has a wrong offset!");
static_assert(offsetof(FCreatureBipedBoneAnimationData, RightLegBoneName) == 0x000014, "Member 'FCreatureBipedBoneAnimationData::RightLegBoneName' has a wrong offset!");
static_assert(offsetof(FCreatureBipedBoneAnimationData, LegsBlendDepth) == 0x00001C, "Member 'FCreatureBipedBoneAnimationData::LegsBlendDepth' has a wrong offset!");

// ScriptStruct Altar.LegacyRepairItemProperties
// 0x0048 (0x0048 - 0x0000)
struct FLegacyRepairItemProperties final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         CurrentDurability;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPercentDurability;                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDurability;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairGoldCost;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairAddedDurability;                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatusFlags;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESForm*                               form;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyRepairItemProperties) == 0x000008, "Wrong alignment on FLegacyRepairItemProperties");
static_assert(sizeof(FLegacyRepairItemProperties) == 0x000048, "Wrong size on FLegacyRepairItemProperties");
static_assert(offsetof(FLegacyRepairItemProperties, Index) == 0x000000, "Member 'FLegacyRepairItemProperties::Index' has a wrong offset!");
static_assert(offsetof(FLegacyRepairItemProperties, Icon) == 0x000008, "Member 'FLegacyRepairItemProperties::Icon' has a wrong offset!");
static_assert(offsetof(FLegacyRepairItemProperties, Name) == 0x000010, "Member 'FLegacyRepairItemProperties::Name' has a wrong offset!");
static_assert(offsetof(FLegacyRepairItemProperties, CurrentDurability) == 0x000028, "Member 'FLegacyRepairItemProperties::CurrentDurability' has a wrong offset!");
static_assert(offsetof(FLegacyRepairItemProperties, CurrentPercentDurability) == 0x00002C, "Member 'FLegacyRepairItemProperties::CurrentPercentDurability' has a wrong offset!");
static_assert(offsetof(FLegacyRepairItemProperties, MaxDurability) == 0x000030, "Member 'FLegacyRepairItemProperties::MaxDurability' has a wrong offset!");
static_assert(offsetof(FLegacyRepairItemProperties, RepairGoldCost) == 0x000034, "Member 'FLegacyRepairItemProperties::RepairGoldCost' has a wrong offset!");
static_assert(offsetof(FLegacyRepairItemProperties, RepairAddedDurability) == 0x000038, "Member 'FLegacyRepairItemProperties::RepairAddedDurability' has a wrong offset!");
static_assert(offsetof(FLegacyRepairItemProperties, StatusFlags) == 0x00003C, "Member 'FLegacyRepairItemProperties::StatusFlags' has a wrong offset!");
static_assert(offsetof(FLegacyRepairItemProperties, form) == 0x000040, "Member 'FLegacyRepairItemProperties::form' has a wrong offset!");

// ScriptStruct Altar.VMainCharacterAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVMainCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVMainCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVMainCharacterAnimInstanceProxy");
static_assert(sizeof(FVMainCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVMainCharacterAnimInstanceProxy");

// ScriptStruct Altar.CharacterHairPieceBaseConstructResult
// 0x0010 (0x0010 - 0x0000)
struct FCharacterHairPieceBaseConstructResult final
{
public:
	class USkeletalMeshComponent*                 HairMeshComponent;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 HairMeshShadowProxyComponent;                      // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterHairPieceBaseConstructResult) == 0x000008, "Wrong alignment on FCharacterHairPieceBaseConstructResult");
static_assert(sizeof(FCharacterHairPieceBaseConstructResult) == 0x000010, "Wrong size on FCharacterHairPieceBaseConstructResult");
static_assert(offsetof(FCharacterHairPieceBaseConstructResult, HairMeshComponent) == 0x000000, "Member 'FCharacterHairPieceBaseConstructResult::HairMeshComponent' has a wrong offset!");
static_assert(offsetof(FCharacterHairPieceBaseConstructResult, HairMeshShadowProxyComponent) == 0x000008, "Member 'FCharacterHairPieceBaseConstructResult::HairMeshShadowProxyComponent' has a wrong offset!");

// ScriptStruct Altar.LegacyVideoTextSettingValues
// 0x0080 (0x0080 - 0x0000)
struct FLegacyVideoTextSettingValues final
{
public:
	TArray<class FText>                           ResolutionOptions;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           DefaultButtonOptions;                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           TextureSizeOptions;                                // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           ShadowFilteringOptions;                            // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           WaterDetailOptions;                                // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           BloodDecalOptions;                                 // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           AntiAliasingOptions;                               // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           NoOptions;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyVideoTextSettingValues) == 0x000008, "Wrong alignment on FLegacyVideoTextSettingValues");
static_assert(sizeof(FLegacyVideoTextSettingValues) == 0x000080, "Wrong size on FLegacyVideoTextSettingValues");
static_assert(offsetof(FLegacyVideoTextSettingValues, ResolutionOptions) == 0x000000, "Member 'FLegacyVideoTextSettingValues::ResolutionOptions' has a wrong offset!");
static_assert(offsetof(FLegacyVideoTextSettingValues, DefaultButtonOptions) == 0x000010, "Member 'FLegacyVideoTextSettingValues::DefaultButtonOptions' has a wrong offset!");
static_assert(offsetof(FLegacyVideoTextSettingValues, TextureSizeOptions) == 0x000020, "Member 'FLegacyVideoTextSettingValues::TextureSizeOptions' has a wrong offset!");
static_assert(offsetof(FLegacyVideoTextSettingValues, ShadowFilteringOptions) == 0x000030, "Member 'FLegacyVideoTextSettingValues::ShadowFilteringOptions' has a wrong offset!");
static_assert(offsetof(FLegacyVideoTextSettingValues, WaterDetailOptions) == 0x000040, "Member 'FLegacyVideoTextSettingValues::WaterDetailOptions' has a wrong offset!");
static_assert(offsetof(FLegacyVideoTextSettingValues, BloodDecalOptions) == 0x000050, "Member 'FLegacyVideoTextSettingValues::BloodDecalOptions' has a wrong offset!");
static_assert(offsetof(FLegacyVideoTextSettingValues, AntiAliasingOptions) == 0x000060, "Member 'FLegacyVideoTextSettingValues::AntiAliasingOptions' has a wrong offset!");
static_assert(offsetof(FLegacyVideoTextSettingValues, NoOptions) == 0x000070, "Member 'FLegacyVideoTextSettingValues::NoOptions' has a wrong offset!");

// ScriptStruct Altar.LegacyControlsInputMapping
// 0x0030 (0x0030 - 0x0000)
struct FLegacyControlsInputMapping final
{
public:
	class FText                                   Action;                                            // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FKey                                   Mapping;                                           // 0x0018(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyControlsInputMapping) == 0x000008, "Wrong alignment on FLegacyControlsInputMapping");
static_assert(sizeof(FLegacyControlsInputMapping) == 0x000030, "Wrong size on FLegacyControlsInputMapping");
static_assert(offsetof(FLegacyControlsInputMapping, Action) == 0x000000, "Member 'FLegacyControlsInputMapping::Action' has a wrong offset!");
static_assert(offsetof(FLegacyControlsInputMapping, Mapping) == 0x000018, "Member 'FLegacyControlsInputMapping::Mapping' has a wrong offset!");

// ScriptStruct Altar.LegacyMenuActionBinding
// 0x0018 (0x0018 - 0x0000)
struct FLegacyMenuActionBinding final
{
public:
	struct FDataTableRowHandle                    ActionData;                                        // 0x0000(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EInputEvent                                   KeyEvent;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyMenuActionBinding) == 0x000008, "Wrong alignment on FLegacyMenuActionBinding");
static_assert(sizeof(FLegacyMenuActionBinding) == 0x000018, "Wrong size on FLegacyMenuActionBinding");
static_assert(offsetof(FLegacyMenuActionBinding, ActionData) == 0x000000, "Member 'FLegacyMenuActionBinding::ActionData' has a wrong offset!");
static_assert(offsetof(FLegacyMenuActionBinding, KeyEvent) == 0x000010, "Member 'FLegacyMenuActionBinding::KeyEvent' has a wrong offset!");

// ScriptStruct Altar.ModernQuickKeysActionBinding
// 0x0038 (0x0038 - 0x0000)
struct FModernQuickKeysActionBinding final
{
public:
	struct FLegacyMenuActionBinding               PressData;                                         // 0x0000(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FLegacyMenuActionBinding               ReleaseData;                                       // 0x0018(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernQuickKeysActionBinding) == 0x000008, "Wrong alignment on FModernQuickKeysActionBinding");
static_assert(sizeof(FModernQuickKeysActionBinding) == 0x000038, "Wrong size on FModernQuickKeysActionBinding");
static_assert(offsetof(FModernQuickKeysActionBinding, PressData) == 0x000000, "Member 'FModernQuickKeysActionBinding::PressData' has a wrong offset!");
static_assert(offsetof(FModernQuickKeysActionBinding, ReleaseData) == 0x000018, "Member 'FModernQuickKeysActionBinding::ReleaseData' has a wrong offset!");

// ScriptStruct Altar.LegacyControlsSettings
// 0x0008 (0x0008 - 0x0000)
struct FLegacyControlsSettings final
{
public:
	float                                         MouseSensitivity;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertY;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SwapStickControls;                                 // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyControlsSettings) == 0x000004, "Wrong alignment on FLegacyControlsSettings");
static_assert(sizeof(FLegacyControlsSettings) == 0x000008, "Wrong size on FLegacyControlsSettings");
static_assert(offsetof(FLegacyControlsSettings, MouseSensitivity) == 0x000000, "Member 'FLegacyControlsSettings::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(FLegacyControlsSettings, InvertY) == 0x000004, "Member 'FLegacyControlsSettings::InvertY' has a wrong offset!");
static_assert(offsetof(FLegacyControlsSettings, SwapStickControls) == 0x000005, "Member 'FLegacyControlsSettings::SwapStickControls' has a wrong offset!");

// ScriptStruct Altar.LegacyScrollbarTextProperties
// 0x0014 (0x0014 - 0x0000)
struct FLegacyScrollbarTextProperties final
{
public:
	struct FLinearColor                           TextColour;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TextEnabled;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyScrollbarTextProperties) == 0x000004, "Wrong alignment on FLegacyScrollbarTextProperties");
static_assert(sizeof(FLegacyScrollbarTextProperties) == 0x000014, "Wrong size on FLegacyScrollbarTextProperties");
static_assert(offsetof(FLegacyScrollbarTextProperties, TextColour) == 0x000000, "Member 'FLegacyScrollbarTextProperties::TextColour' has a wrong offset!");
static_assert(offsetof(FLegacyScrollbarTextProperties, TextEnabled) == 0x000010, "Member 'FLegacyScrollbarTextProperties::TextEnabled' has a wrong offset!");

// ScriptStruct Altar.WedgeData
// 0x0002 (0x0002 - 0x0000)
struct FWedgeData final
{
public:
	EReaction                                     PnjReaction;                                       // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPersuade                                     PersuasionStrategy;                                // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWedgeData) == 0x000001, "Wrong alignment on FWedgeData");
static_assert(sizeof(FWedgeData) == 0x000002, "Wrong size on FWedgeData");
static_assert(offsetof(FWedgeData, PnjReaction) == 0x000000, "Member 'FWedgeData::PnjReaction' has a wrong offset!");
static_assert(offsetof(FWedgeData, PersuasionStrategy) == 0x000001, "Member 'FWedgeData::PersuasionStrategy' has a wrong offset!");

// ScriptStruct Altar.WheelInitializingData
// 0x0030 (0x0030 - 0x0000)
struct FWheelInitializingData final
{
public:
	TArray<struct FWedgeData>                     Wedges;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 WedgesInitialPercentage;                           // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MaxAward;                                          // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBribe;                                          // 0x0024(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanRotate;                                         // 0x0025(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0xA];                                       // 0x0026(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWheelInitializingData) == 0x000008, "Wrong alignment on FWheelInitializingData");
static_assert(sizeof(FWheelInitializingData) == 0x000030, "Wrong size on FWheelInitializingData");
static_assert(offsetof(FWheelInitializingData, Wedges) == 0x000000, "Member 'FWheelInitializingData::Wedges' has a wrong offset!");
static_assert(offsetof(FWheelInitializingData, WedgesInitialPercentage) == 0x000010, "Member 'FWheelInitializingData::WedgesInitialPercentage' has a wrong offset!");
static_assert(offsetof(FWheelInitializingData, MaxAward) == 0x000020, "Member 'FWheelInitializingData::MaxAward' has a wrong offset!");
static_assert(offsetof(FWheelInitializingData, CanBribe) == 0x000024, "Member 'FWheelInitializingData::CanBribe' has a wrong offset!");
static_assert(offsetof(FWheelInitializingData, CanRotate) == 0x000025, "Member 'FWheelInitializingData::CanRotate' has a wrong offset!");

// ScriptStruct Altar.LegacyScrollbarValueProperties
// 0x0010 (0x0010 - 0x0000)
struct FLegacyScrollbarValueProperties final
{
public:
	float                                         MinValue;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepSize;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpSize;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyScrollbarValueProperties) == 0x000004, "Wrong alignment on FLegacyScrollbarValueProperties");
static_assert(sizeof(FLegacyScrollbarValueProperties) == 0x000010, "Wrong size on FLegacyScrollbarValueProperties");
static_assert(offsetof(FLegacyScrollbarValueProperties, MinValue) == 0x000000, "Member 'FLegacyScrollbarValueProperties::MinValue' has a wrong offset!");
static_assert(offsetof(FLegacyScrollbarValueProperties, MaxValue) == 0x000004, "Member 'FLegacyScrollbarValueProperties::MaxValue' has a wrong offset!");
static_assert(offsetof(FLegacyScrollbarValueProperties, StepSize) == 0x000008, "Member 'FLegacyScrollbarValueProperties::StepSize' has a wrong offset!");
static_assert(offsetof(FLegacyScrollbarValueProperties, JumpSize) == 0x00000C, "Member 'FLegacyScrollbarValueProperties::JumpSize' has a wrong offset!");

// ScriptStruct Altar.CellInteriorData
// 0x0040 (0x0040 - 0x0000)
struct FCellInteriorData final
{
public:
	int64                                         Ambient;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Directional;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Fog;                                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogNear;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogFar;                                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DirectionalXY;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DirectionalZ;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalFade;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClipDist;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         InteriorOffset;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCellInteriorData) == 0x000008, "Wrong alignment on FCellInteriorData");
static_assert(sizeof(FCellInteriorData) == 0x000040, "Wrong size on FCellInteriorData");
static_assert(offsetof(FCellInteriorData, Ambient) == 0x000000, "Member 'FCellInteriorData::Ambient' has a wrong offset!");
static_assert(offsetof(FCellInteriorData, Directional) == 0x000008, "Member 'FCellInteriorData::Directional' has a wrong offset!");
static_assert(offsetof(FCellInteriorData, Fog) == 0x000010, "Member 'FCellInteriorData::Fog' has a wrong offset!");
static_assert(offsetof(FCellInteriorData, FogNear) == 0x000018, "Member 'FCellInteriorData::FogNear' has a wrong offset!");
static_assert(offsetof(FCellInteriorData, FogFar) == 0x00001C, "Member 'FCellInteriorData::FogFar' has a wrong offset!");
static_assert(offsetof(FCellInteriorData, DirectionalXY) == 0x000020, "Member 'FCellInteriorData::DirectionalXY' has a wrong offset!");
static_assert(offsetof(FCellInteriorData, DirectionalZ) == 0x000028, "Member 'FCellInteriorData::DirectionalZ' has a wrong offset!");
static_assert(offsetof(FCellInteriorData, DirectionalFade) == 0x000030, "Member 'FCellInteriorData::DirectionalFade' has a wrong offset!");
static_assert(offsetof(FCellInteriorData, ClipDist) == 0x000034, "Member 'FCellInteriorData::ClipDist' has a wrong offset!");
static_assert(offsetof(FCellInteriorData, InteriorOffset) == 0x000038, "Member 'FCellInteriorData::InteriorOffset' has a wrong offset!");

// ScriptStruct Altar.LegacyMagicMenuItemProperties
// 0x0060 (0x0060 - 0x0000)
struct FLegacyMagicMenuItemProperties final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Property;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELegacyMagicMenuItemCategory                  Category;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELegacyMagicMenuItemType                      Type;                                              // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquiped;                                         // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InventoryIndex;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModernMagicMenuItemSchool                    School;                                            // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModernMagicMenuActiveEffectValue             EffectValue;                                       // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CannotCastReason;                                  // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsImmuneToSilence;                                // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFavorite;                                       // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyMagicMenuItemProperties) == 0x000008, "Wrong alignment on FLegacyMagicMenuItemProperties");
static_assert(sizeof(FLegacyMagicMenuItemProperties) == 0x000060, "Wrong size on FLegacyMagicMenuItemProperties");
static_assert(offsetof(FLegacyMagicMenuItemProperties, Name) == 0x000000, "Member 'FLegacyMagicMenuItemProperties::Name' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, Property) == 0x000018, "Member 'FLegacyMagicMenuItemProperties::Property' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, Icon) == 0x000020, "Member 'FLegacyMagicMenuItemProperties::Icon' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, Category) == 0x000028, "Member 'FLegacyMagicMenuItemProperties::Category' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, Type) == 0x000029, "Member 'FLegacyMagicMenuItemProperties::Type' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, IsEquiped) == 0x00002A, "Member 'FLegacyMagicMenuItemProperties::IsEquiped' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, InventoryIndex) == 0x00002C, "Member 'FLegacyMagicMenuItemProperties::InventoryIndex' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, School) == 0x000030, "Member 'FLegacyMagicMenuItemProperties::School' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, EffectValue) == 0x000031, "Member 'FLegacyMagicMenuItemProperties::EffectValue' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, CannotCastReason) == 0x000038, "Member 'FLegacyMagicMenuItemProperties::CannotCastReason' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, bIsImmuneToSilence) == 0x000050, "Member 'FLegacyMagicMenuItemProperties::bIsImmuneToSilence' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, Count) == 0x000054, "Member 'FLegacyMagicMenuItemProperties::Count' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuItemProperties, bIsFavorite) == 0x000058, "Member 'FLegacyMagicMenuItemProperties::bIsFavorite' has a wrong offset!");

// ScriptStruct Altar.LightRigParameters
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FLightRigParameters final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightRigParameters) == 0x000008, "Wrong alignment on FLightRigParameters");
static_assert(sizeof(FLightRigParameters) == 0x000018, "Wrong size on FLightRigParameters");

// ScriptStruct Altar.ModernSpellEffectivenessProperties
// 0x0048 (0x0048 - 0x0000)
struct FModernSpellEffectivenessProperties final
{
public:
	int32                                         HeavyPiecesCount;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HeavyArmorSkillName;                               // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         HeavyModifier;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightPiecesCount;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LightArmorSkillName;                               // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         LightModifier;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernSpellEffectivenessProperties) == 0x000008, "Wrong alignment on FModernSpellEffectivenessProperties");
static_assert(sizeof(FModernSpellEffectivenessProperties) == 0x000048, "Wrong size on FModernSpellEffectivenessProperties");
static_assert(offsetof(FModernSpellEffectivenessProperties, HeavyPiecesCount) == 0x000000, "Member 'FModernSpellEffectivenessProperties::HeavyPiecesCount' has a wrong offset!");
static_assert(offsetof(FModernSpellEffectivenessProperties, HeavyArmorSkillName) == 0x000008, "Member 'FModernSpellEffectivenessProperties::HeavyArmorSkillName' has a wrong offset!");
static_assert(offsetof(FModernSpellEffectivenessProperties, HeavyModifier) == 0x000020, "Member 'FModernSpellEffectivenessProperties::HeavyModifier' has a wrong offset!");
static_assert(offsetof(FModernSpellEffectivenessProperties, LightPiecesCount) == 0x000024, "Member 'FModernSpellEffectivenessProperties::LightPiecesCount' has a wrong offset!");
static_assert(offsetof(FModernSpellEffectivenessProperties, LightArmorSkillName) == 0x000028, "Member 'FModernSpellEffectivenessProperties::LightArmorSkillName' has a wrong offset!");
static_assert(offsetof(FModernSpellEffectivenessProperties, LightModifier) == 0x000040, "Member 'FModernSpellEffectivenessProperties::LightModifier' has a wrong offset!");

// ScriptStruct Altar.ApplyMatrixTableNode
// 0x0018 (0x0028 - 0x0010)
struct FApplyMatrixTableNode final : public FAnimNode_Base
{
public:
	int32                                         MinimumTableSize;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     Matrices;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FApplyMatrixTableNode) == 0x000008, "Wrong alignment on FApplyMatrixTableNode");
static_assert(sizeof(FApplyMatrixTableNode) == 0x000028, "Wrong size on FApplyMatrixTableNode");
static_assert(offsetof(FApplyMatrixTableNode, MinimumTableSize) == 0x000010, "Member 'FApplyMatrixTableNode::MinimumTableSize' has a wrong offset!");
static_assert(offsetof(FApplyMatrixTableNode, Matrices) == 0x000018, "Member 'FApplyMatrixTableNode::Matrices' has a wrong offset!");

// ScriptStruct Altar.ModernMagicFilterTableRow
// 0x0998 (0x09A0 - 0x0008)
struct FModernMagicFilterTableRow final : public FTableRowBase
{
public:
	ELegacyMagicMenuSortType                      EnumKey;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FButtonStyle                           EnableFilterStyle;                                 // 0x0010(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FButtonStyle                           DisableFilterStyle;                                // 0x0400(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            EnableBackgroundBrush;                             // 0x07F0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            HoveredBackgroundBrush;                            // 0x08C0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector2D                              MinDesiredSize;                                    // 0x0990(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernMagicFilterTableRow) == 0x000010, "Wrong alignment on FModernMagicFilterTableRow");
static_assert(sizeof(FModernMagicFilterTableRow) == 0x0009A0, "Wrong size on FModernMagicFilterTableRow");
static_assert(offsetof(FModernMagicFilterTableRow, EnumKey) == 0x000008, "Member 'FModernMagicFilterTableRow::EnumKey' has a wrong offset!");
static_assert(offsetof(FModernMagicFilterTableRow, EnableFilterStyle) == 0x000010, "Member 'FModernMagicFilterTableRow::EnableFilterStyle' has a wrong offset!");
static_assert(offsetof(FModernMagicFilterTableRow, DisableFilterStyle) == 0x000400, "Member 'FModernMagicFilterTableRow::DisableFilterStyle' has a wrong offset!");
static_assert(offsetof(FModernMagicFilterTableRow, EnableBackgroundBrush) == 0x0007F0, "Member 'FModernMagicFilterTableRow::EnableBackgroundBrush' has a wrong offset!");
static_assert(offsetof(FModernMagicFilterTableRow, HoveredBackgroundBrush) == 0x0008C0, "Member 'FModernMagicFilterTableRow::HoveredBackgroundBrush' has a wrong offset!");
static_assert(offsetof(FModernMagicFilterTableRow, MinDesiredSize) == 0x000990, "Member 'FModernMagicFilterTableRow::MinDesiredSize' has a wrong offset!");

// ScriptStruct Altar.ESPDataProperty
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FESPDataProperty
{
};
#pragma pack(pop)
static_assert(alignof(FESPDataProperty) == 0x000001, "Wrong alignment on FESPDataProperty");
static_assert(sizeof(FESPDataProperty) == 0x000001, "Wrong size on FESPDataProperty");

// ScriptStruct Altar.Uses
// 0x0001 (0x0001 - 0x0000)
struct FUses final : public FESPDataProperty
{
public:
	uint8                                         Uses;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUses) == 0x000001, "Wrong alignment on FUses");
static_assert(sizeof(FUses) == 0x000001, "Wrong size on FUses");
static_assert(offsetof(FUses, Uses) == 0x000000, "Member 'FUses::Uses' has a wrong offset!");

// ScriptStruct Altar.Original_InventoryFilterTableRow
// 0x0998 (0x09A0 - 0x0008)
struct FOriginal_InventoryFilterTableRow final : public FTableRowBase
{
public:
	EOriginalInventoryMenuSortType                EnumKey;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FButtonStyle                           EnableFilterStyle;                                 // 0x0010(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FButtonStyle                           DisableFilterStyle;                                // 0x0400(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            EnableBackgroundBrush;                             // 0x07F0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            HoveredBackgroundBrush;                            // 0x08C0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector2D                              MinDesiredSize;                                    // 0x0990(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOriginal_InventoryFilterTableRow) == 0x000010, "Wrong alignment on FOriginal_InventoryFilterTableRow");
static_assert(sizeof(FOriginal_InventoryFilterTableRow) == 0x0009A0, "Wrong size on FOriginal_InventoryFilterTableRow");
static_assert(offsetof(FOriginal_InventoryFilterTableRow, EnumKey) == 0x000008, "Member 'FOriginal_InventoryFilterTableRow::EnumKey' has a wrong offset!");
static_assert(offsetof(FOriginal_InventoryFilterTableRow, EnableFilterStyle) == 0x000010, "Member 'FOriginal_InventoryFilterTableRow::EnableFilterStyle' has a wrong offset!");
static_assert(offsetof(FOriginal_InventoryFilterTableRow, DisableFilterStyle) == 0x000400, "Member 'FOriginal_InventoryFilterTableRow::DisableFilterStyle' has a wrong offset!");
static_assert(offsetof(FOriginal_InventoryFilterTableRow, EnableBackgroundBrush) == 0x0007F0, "Member 'FOriginal_InventoryFilterTableRow::EnableBackgroundBrush' has a wrong offset!");
static_assert(offsetof(FOriginal_InventoryFilterTableRow, HoveredBackgroundBrush) == 0x0008C0, "Member 'FOriginal_InventoryFilterTableRow::HoveredBackgroundBrush' has a wrong offset!");
static_assert(offsetof(FOriginal_InventoryFilterTableRow, MinDesiredSize) == 0x000990, "Member 'FOriginal_InventoryFilterTableRow::MinDesiredSize' has a wrong offset!");

// ScriptStruct Altar.CompassIconMarker
// 0x0040 (0x0040 - 0x0000)
struct FCompassIconMarker final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LocalisedName;                                     // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUser2;                                            // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModernMarkerType                             Type;                                              // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastTravelEnabled;                                // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUser9;                                            // 0x0033(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Depth;                                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsThroughLoadDoor;                                // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAQuestTarget;                                   // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsThePlayerMarker;                                // 0x003B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompassIconMarker) == 0x000008, "Wrong alignment on FCompassIconMarker");
static_assert(sizeof(FCompassIconMarker) == 0x000040, "Wrong size on FCompassIconMarker");
static_assert(offsetof(FCompassIconMarker, Name) == 0x000000, "Member 'FCompassIconMarker::Name' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, LocalisedName) == 0x000010, "Member 'FCompassIconMarker::LocalisedName' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, Angle) == 0x000028, "Member 'FCompassIconMarker::Angle' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, Distance) == 0x00002C, "Member 'FCompassIconMarker::Distance' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, bUser2) == 0x000030, "Member 'FCompassIconMarker::bUser2' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, Type) == 0x000031, "Member 'FCompassIconMarker::Type' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, bFastTravelEnabled) == 0x000032, "Member 'FCompassIconMarker::bFastTravelEnabled' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, bUser9) == 0x000033, "Member 'FCompassIconMarker::bUser9' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, Depth) == 0x000034, "Member 'FCompassIconMarker::Depth' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, bIsVisible) == 0x000038, "Member 'FCompassIconMarker::bIsVisible' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, bIsThroughLoadDoor) == 0x000039, "Member 'FCompassIconMarker::bIsThroughLoadDoor' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, bIsAQuestTarget) == 0x00003A, "Member 'FCompassIconMarker::bIsAQuestTarget' has a wrong offset!");
static_assert(offsetof(FCompassIconMarker, bIsThePlayerMarker) == 0x00003B, "Member 'FCompassIconMarker::bIsThePlayerMarker' has a wrong offset!");

// ScriptStruct Altar.LegacyRechargeMenuItemProperties
// 0x0040 (0x0040 - 0x0000)
struct FLegacyRechargeMenuItemProperties final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Image;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   NameText;                                          // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         CurrentCharge;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCharge;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Health;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatusFlags;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESForm*                               form;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyRechargeMenuItemProperties) == 0x000008, "Wrong alignment on FLegacyRechargeMenuItemProperties");
static_assert(sizeof(FLegacyRechargeMenuItemProperties) == 0x000040, "Wrong size on FLegacyRechargeMenuItemProperties");
static_assert(offsetof(FLegacyRechargeMenuItemProperties, Index) == 0x000000, "Member 'FLegacyRechargeMenuItemProperties::Index' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuItemProperties, Image) == 0x000008, "Member 'FLegacyRechargeMenuItemProperties::Image' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuItemProperties, NameText) == 0x000010, "Member 'FLegacyRechargeMenuItemProperties::NameText' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuItemProperties, CurrentCharge) == 0x000028, "Member 'FLegacyRechargeMenuItemProperties::CurrentCharge' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuItemProperties, MaxCharge) == 0x00002C, "Member 'FLegacyRechargeMenuItemProperties::MaxCharge' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuItemProperties, Health) == 0x000030, "Member 'FLegacyRechargeMenuItemProperties::Health' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuItemProperties, StatusFlags) == 0x000034, "Member 'FLegacyRechargeMenuItemProperties::StatusFlags' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuItemProperties, form) == 0x000038, "Member 'FLegacyRechargeMenuItemProperties::form' has a wrong offset!");

// ScriptStruct Altar.VLocomotionCharacterAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVLocomotionCharacterAnimInstanceProxy : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVLocomotionCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVLocomotionCharacterAnimInstanceProxy");
static_assert(sizeof(FVLocomotionCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVLocomotionCharacterAnimInstanceProxy");

// ScriptStruct Altar.VLocomotionStandTurnAnimInstanceProxy
// 0x0000 (0x0710 - 0x0710)
struct FVLocomotionStandTurnAnimInstanceProxy final : public FVLocomotionCharacterAnimInstanceProxy
{
};
static_assert(alignof(FVLocomotionStandTurnAnimInstanceProxy) == 0x000010, "Wrong alignment on FVLocomotionStandTurnAnimInstanceProxy");
static_assert(sizeof(FVLocomotionStandTurnAnimInstanceProxy) == 0x000710, "Wrong size on FVLocomotionStandTurnAnimInstanceProxy");

// ScriptStruct Altar.ModernRechargeMenuCharacterData
// 0x0020 (0x0020 - 0x0000)
struct FModernRechargeMenuCharacterData final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         GoldAmount;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernRechargeMenuCharacterData) == 0x000008, "Wrong alignment on FModernRechargeMenuCharacterData");
static_assert(sizeof(FModernRechargeMenuCharacterData) == 0x000020, "Wrong size on FModernRechargeMenuCharacterData");
static_assert(offsetof(FModernRechargeMenuCharacterData, Name) == 0x000000, "Member 'FModernRechargeMenuCharacterData::Name' has a wrong offset!");
static_assert(offsetof(FModernRechargeMenuCharacterData, GoldAmount) == 0x000018, "Member 'FModernRechargeMenuCharacterData::GoldAmount' has a wrong offset!");

// ScriptStruct Altar.VPawnKnockdownRequest
// 0x0028 (0x0028 - 0x0000)
struct FVPawnKnockdownRequest final
{
public:
	float                                         Force;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                KnockVector;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExplosion;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVPawnKnockdownRequest) == 0x000008, "Wrong alignment on FVPawnKnockdownRequest");
static_assert(sizeof(FVPawnKnockdownRequest) == 0x000028, "Wrong size on FVPawnKnockdownRequest");
static_assert(offsetof(FVPawnKnockdownRequest, Force) == 0x000000, "Member 'FVPawnKnockdownRequest::Force' has a wrong offset!");
static_assert(offsetof(FVPawnKnockdownRequest, KnockVector) == 0x000008, "Member 'FVPawnKnockdownRequest::KnockVector' has a wrong offset!");
static_assert(offsetof(FVPawnKnockdownRequest, bIsExplosion) == 0x000020, "Member 'FVPawnKnockdownRequest::bIsExplosion' has a wrong offset!");

// ScriptStruct Altar.SkillInformation
// 0x0020 (0x0020 - 0x0000)
struct FSkillInformation final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESkillAndClassSpecialization                  Specialization;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillStat                                    SkillStatsEnum;                                    // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillInformation) == 0x000008, "Wrong alignment on FSkillInformation");
static_assert(sizeof(FSkillInformation) == 0x000020, "Wrong size on FSkillInformation");
static_assert(offsetof(FSkillInformation, Name) == 0x000000, "Member 'FSkillInformation::Name' has a wrong offset!");
static_assert(offsetof(FSkillInformation, Specialization) == 0x000018, "Member 'FSkillInformation::Specialization' has a wrong offset!");
static_assert(offsetof(FSkillInformation, SkillStatsEnum) == 0x000019, "Member 'FSkillInformation::SkillStatsEnum' has a wrong offset!");

// ScriptStruct Altar.PlayerClassItemProperties
// 0x00A0 (0x00A0 - 0x0000)
struct FPlayerClassItemProperties final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   IdentifierName;                                    // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         ClassIndex;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Picture;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Specialisation;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESkillAndClassSpecialization                  SpecializationEnum;                                // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PrimaryAttribute;                                  // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   SecondaryAttribute;                                // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FSkillInformation>              Skills;                                            // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerClassItemProperties) == 0x000008, "Wrong alignment on FPlayerClassItemProperties");
static_assert(sizeof(FPlayerClassItemProperties) == 0x0000A0, "Wrong size on FPlayerClassItemProperties");
static_assert(offsetof(FPlayerClassItemProperties, Name) == 0x000000, "Member 'FPlayerClassItemProperties::Name' has a wrong offset!");
static_assert(offsetof(FPlayerClassItemProperties, IdentifierName) == 0x000018, "Member 'FPlayerClassItemProperties::IdentifierName' has a wrong offset!");
static_assert(offsetof(FPlayerClassItemProperties, ClassIndex) == 0x000030, "Member 'FPlayerClassItemProperties::ClassIndex' has a wrong offset!");
static_assert(offsetof(FPlayerClassItemProperties, Picture) == 0x000038, "Member 'FPlayerClassItemProperties::Picture' has a wrong offset!");
static_assert(offsetof(FPlayerClassItemProperties, Specialisation) == 0x000040, "Member 'FPlayerClassItemProperties::Specialisation' has a wrong offset!");
static_assert(offsetof(FPlayerClassItemProperties, SpecializationEnum) == 0x000058, "Member 'FPlayerClassItemProperties::SpecializationEnum' has a wrong offset!");
static_assert(offsetof(FPlayerClassItemProperties, PrimaryAttribute) == 0x000060, "Member 'FPlayerClassItemProperties::PrimaryAttribute' has a wrong offset!");
static_assert(offsetof(FPlayerClassItemProperties, SecondaryAttribute) == 0x000078, "Member 'FPlayerClassItemProperties::SecondaryAttribute' has a wrong offset!");
static_assert(offsetof(FPlayerClassItemProperties, Skills) == 0x000090, "Member 'FPlayerClassItemProperties::Skills' has a wrong offset!");

// ScriptStruct Altar.LegacyRechargeMenuSoulProperties
// 0x0040 (0x0040 - 0x0000)
struct FLegacyRechargeMenuSoulProperties final
{
public:
	class UTexture2D*                             SoulGemImage;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SoulGemText;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   SoulLevelName;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         SoulPoints;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyRechargeMenuSoulProperties) == 0x000008, "Wrong alignment on FLegacyRechargeMenuSoulProperties");
static_assert(sizeof(FLegacyRechargeMenuSoulProperties) == 0x000040, "Wrong size on FLegacyRechargeMenuSoulProperties");
static_assert(offsetof(FLegacyRechargeMenuSoulProperties, SoulGemImage) == 0x000000, "Member 'FLegacyRechargeMenuSoulProperties::SoulGemImage' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuSoulProperties, SoulGemText) == 0x000008, "Member 'FLegacyRechargeMenuSoulProperties::SoulGemText' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuSoulProperties, SoulLevelName) == 0x000020, "Member 'FLegacyRechargeMenuSoulProperties::SoulLevelName' has a wrong offset!");
static_assert(offsetof(FLegacyRechargeMenuSoulProperties, SoulPoints) == 0x000038, "Member 'FLegacyRechargeMenuSoulProperties::SoulPoints' has a wrong offset!");

// ScriptStruct Altar.LegacyRepairAmount
// 0x0004 (0x0004 - 0x0000)
struct FLegacyRepairAmount final
{
public:
	int32                                         RepairAmount;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyRepairAmount) == 0x000004, "Wrong alignment on FLegacyRepairAmount");
static_assert(sizeof(FLegacyRepairAmount) == 0x000004, "Wrong size on FLegacyRepairAmount");
static_assert(offsetof(FLegacyRepairAmount, RepairAmount) == 0x000000, "Member 'FLegacyRepairAmount::RepairAmount' has a wrong offset!");

// ScriptStruct Altar.VFormPtr
// 0x0080 (0x0080 - 0x0000)
struct FVFormPtr final
{
public:
	int64                                         TargetFormID;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTESForm>                TargetObject;                                      // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<EFormID>                                 TargetTypes;                                       // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FVFormPtr) == 0x000008, "Wrong alignment on FVFormPtr");
static_assert(sizeof(FVFormPtr) == 0x000080, "Wrong size on FVFormPtr");
static_assert(offsetof(FVFormPtr, TargetFormID) == 0x000000, "Member 'FVFormPtr::TargetFormID' has a wrong offset!");
static_assert(offsetof(FVFormPtr, TargetObject) == 0x000008, "Member 'FVFormPtr::TargetObject' has a wrong offset!");
static_assert(offsetof(FVFormPtr, TargetTypes) == 0x000030, "Member 'FVFormPtr::TargetTypes' has a wrong offset!");

// ScriptStruct Altar.ScriptEffectItemData
// 0x00A8 (0x00A8 - 0x0000)
struct FScriptEffectItemData final
{
public:
	struct FVFormPtr                              Script;                                            // 0x0000(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EMagicSchool                                  MagicSchool;                                       // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EffectName;                                        // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffectID                                     VisualEffectID;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EffectIsHostile;                                   // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScriptEffectItemData) == 0x000008, "Wrong alignment on FScriptEffectItemData");
static_assert(sizeof(FScriptEffectItemData) == 0x0000A8, "Wrong size on FScriptEffectItemData");
static_assert(offsetof(FScriptEffectItemData, Script) == 0x000000, "Member 'FScriptEffectItemData::Script' has a wrong offset!");
static_assert(offsetof(FScriptEffectItemData, MagicSchool) == 0x000080, "Member 'FScriptEffectItemData::MagicSchool' has a wrong offset!");
static_assert(offsetof(FScriptEffectItemData, EffectName) == 0x000088, "Member 'FScriptEffectItemData::EffectName' has a wrong offset!");
static_assert(offsetof(FScriptEffectItemData, VisualEffectID) == 0x000098, "Member 'FScriptEffectItemData::VisualEffectID' has a wrong offset!");
static_assert(offsetof(FScriptEffectItemData, EffectIsHostile) == 0x0000A0, "Member 'FScriptEffectItemData::EffectIsHostile' has a wrong offset!");

// ScriptStruct Altar.ModernRepairMenuCharacterData
// 0x0020 (0x0020 - 0x0000)
struct FModernRepairMenuCharacterData final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         GoldAmount;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernRepairMenuCharacterData) == 0x000008, "Wrong alignment on FModernRepairMenuCharacterData");
static_assert(sizeof(FModernRepairMenuCharacterData) == 0x000020, "Wrong size on FModernRepairMenuCharacterData");
static_assert(offsetof(FModernRepairMenuCharacterData, Name) == 0x000000, "Member 'FModernRepairMenuCharacterData::Name' has a wrong offset!");
static_assert(offsetof(FModernRepairMenuCharacterData, GoldAmount) == 0x000018, "Member 'FModernRepairMenuCharacterData::GoldAmount' has a wrong offset!");

// ScriptStruct Altar.StandSwimMeleeAttackPowerSingle
// 0x0070 (0x0070 - 0x0000)
struct FStandSwimMeleeAttackPowerSingle final
{
public:
	class UAnimSequence*                          AttackRight;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AttackLeft;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PowerAttack;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForwardPowerAttack;                                // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BackwardPowerAttack;                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RightPowerAttack;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LeftPowerAttack;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SwimAttackRight;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SwimAttackLeft;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimPowerAttack;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimForwardPowerAttack;                            // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimBackwardPowerAttack;                           // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimRightPowerAttack;                              // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimLeftPowerAttack;                               // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandSwimMeleeAttackPowerSingle) == 0x000008, "Wrong alignment on FStandSwimMeleeAttackPowerSingle");
static_assert(sizeof(FStandSwimMeleeAttackPowerSingle) == 0x000070, "Wrong size on FStandSwimMeleeAttackPowerSingle");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, AttackRight) == 0x000000, "Member 'FStandSwimMeleeAttackPowerSingle::AttackRight' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, AttackLeft) == 0x000008, "Member 'FStandSwimMeleeAttackPowerSingle::AttackLeft' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, PowerAttack) == 0x000010, "Member 'FStandSwimMeleeAttackPowerSingle::PowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, ForwardPowerAttack) == 0x000018, "Member 'FStandSwimMeleeAttackPowerSingle::ForwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, BackwardPowerAttack) == 0x000020, "Member 'FStandSwimMeleeAttackPowerSingle::BackwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, RightPowerAttack) == 0x000028, "Member 'FStandSwimMeleeAttackPowerSingle::RightPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, LeftPowerAttack) == 0x000030, "Member 'FStandSwimMeleeAttackPowerSingle::LeftPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, SwimAttackRight) == 0x000038, "Member 'FStandSwimMeleeAttackPowerSingle::SwimAttackRight' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, SwimAttackLeft) == 0x000040, "Member 'FStandSwimMeleeAttackPowerSingle::SwimAttackLeft' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, SwimPowerAttack) == 0x000048, "Member 'FStandSwimMeleeAttackPowerSingle::SwimPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, SwimForwardPowerAttack) == 0x000050, "Member 'FStandSwimMeleeAttackPowerSingle::SwimForwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, SwimBackwardPowerAttack) == 0x000058, "Member 'FStandSwimMeleeAttackPowerSingle::SwimBackwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, SwimRightPowerAttack) == 0x000060, "Member 'FStandSwimMeleeAttackPowerSingle::SwimRightPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingle, SwimLeftPowerAttack) == 0x000068, "Member 'FStandSwimMeleeAttackPowerSingle::SwimLeftPowerAttack' has a wrong offset!");

// ScriptStruct Altar.LegacyLockpickMenuTumblerProperties
// 0x0010 (0x0010 - 0x0000)
struct FLegacyLockpickMenuTumblerProperties final
{
public:
	float                                         StartVelocity;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PauseTime;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAnimationTime;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyLockpickMenuTumblerProperties) == 0x000004, "Wrong alignment on FLegacyLockpickMenuTumblerProperties");
static_assert(sizeof(FLegacyLockpickMenuTumblerProperties) == 0x000010, "Wrong size on FLegacyLockpickMenuTumblerProperties");
static_assert(offsetof(FLegacyLockpickMenuTumblerProperties, StartVelocity) == 0x000000, "Member 'FLegacyLockpickMenuTumblerProperties::StartVelocity' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuTumblerProperties, Gravity) == 0x000004, "Member 'FLegacyLockpickMenuTumblerProperties::Gravity' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuTumblerProperties, PauseTime) == 0x000008, "Member 'FLegacyLockpickMenuTumblerProperties::PauseTime' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuTumblerProperties, MaxAnimationTime) == 0x00000C, "Member 'FLegacyLockpickMenuTumblerProperties::MaxAnimationTime' has a wrong offset!");

// ScriptStruct Altar.ModernSigilStoneMenuItemProperties
// 0x0040 (0x0040 - 0x0000)
struct FModernSigilStoneMenuItemProperties final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Health;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponDamage;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmorRating;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatusFlags;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWeapon;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernSigilStoneMenuItemProperties) == 0x000008, "Wrong alignment on FModernSigilStoneMenuItemProperties");
static_assert(sizeof(FModernSigilStoneMenuItemProperties) == 0x000040, "Wrong size on FModernSigilStoneMenuItemProperties");
static_assert(offsetof(FModernSigilStoneMenuItemProperties, Index) == 0x000000, "Member 'FModernSigilStoneMenuItemProperties::Index' has a wrong offset!");
static_assert(offsetof(FModernSigilStoneMenuItemProperties, Name) == 0x000008, "Member 'FModernSigilStoneMenuItemProperties::Name' has a wrong offset!");
static_assert(offsetof(FModernSigilStoneMenuItemProperties, Icon) == 0x000020, "Member 'FModernSigilStoneMenuItemProperties::Icon' has a wrong offset!");
static_assert(offsetof(FModernSigilStoneMenuItemProperties, Health) == 0x000028, "Member 'FModernSigilStoneMenuItemProperties::Health' has a wrong offset!");
static_assert(offsetof(FModernSigilStoneMenuItemProperties, WeaponDamage) == 0x00002C, "Member 'FModernSigilStoneMenuItemProperties::WeaponDamage' has a wrong offset!");
static_assert(offsetof(FModernSigilStoneMenuItemProperties, ArmorRating) == 0x000030, "Member 'FModernSigilStoneMenuItemProperties::ArmorRating' has a wrong offset!");
static_assert(offsetof(FModernSigilStoneMenuItemProperties, StatusFlags) == 0x000034, "Member 'FModernSigilStoneMenuItemProperties::StatusFlags' has a wrong offset!");
static_assert(offsetof(FModernSigilStoneMenuItemProperties, bIsWeapon) == 0x000038, "Member 'FModernSigilStoneMenuItemProperties::bIsWeapon' has a wrong offset!");

// ScriptStruct Altar.TorchAnimationData
// 0x0040 (0x0040 - 0x0000)
struct FTorchAnimationData final
{
public:
	class UAnimSequence*                          TorchPose;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          TorchPoseSneak;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            TorchBlendSpace;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            TorchSneakBlendSpace;                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TorchArmBlendBone;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TorchHandBlendBone;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TorchBlendDepth;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorchEquipBlendTime;                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorchCrouchBlendTime;                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTorchAnimationData) == 0x000008, "Wrong alignment on FTorchAnimationData");
static_assert(sizeof(FTorchAnimationData) == 0x000040, "Wrong size on FTorchAnimationData");
static_assert(offsetof(FTorchAnimationData, TorchPose) == 0x000000, "Member 'FTorchAnimationData::TorchPose' has a wrong offset!");
static_assert(offsetof(FTorchAnimationData, TorchPoseSneak) == 0x000008, "Member 'FTorchAnimationData::TorchPoseSneak' has a wrong offset!");
static_assert(offsetof(FTorchAnimationData, TorchBlendSpace) == 0x000010, "Member 'FTorchAnimationData::TorchBlendSpace' has a wrong offset!");
static_assert(offsetof(FTorchAnimationData, TorchSneakBlendSpace) == 0x000018, "Member 'FTorchAnimationData::TorchSneakBlendSpace' has a wrong offset!");
static_assert(offsetof(FTorchAnimationData, TorchArmBlendBone) == 0x000020, "Member 'FTorchAnimationData::TorchArmBlendBone' has a wrong offset!");
static_assert(offsetof(FTorchAnimationData, TorchHandBlendBone) == 0x000028, "Member 'FTorchAnimationData::TorchHandBlendBone' has a wrong offset!");
static_assert(offsetof(FTorchAnimationData, TorchBlendDepth) == 0x000030, "Member 'FTorchAnimationData::TorchBlendDepth' has a wrong offset!");
static_assert(offsetof(FTorchAnimationData, TorchEquipBlendTime) == 0x000034, "Member 'FTorchAnimationData::TorchEquipBlendTime' has a wrong offset!");
static_assert(offsetof(FTorchAnimationData, TorchCrouchBlendTime) == 0x000038, "Member 'FTorchAnimationData::TorchCrouchBlendTime' has a wrong offset!");

// ScriptStruct Altar.ByteArray
// 0x0018 (0x0018 - 0x0000)
struct FByteArray final
{
public:
	int64                                         DataSize;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 Data;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FByteArray) == 0x000008, "Wrong alignment on FByteArray");
static_assert(sizeof(FByteArray) == 0x000018, "Wrong size on FByteArray");
static_assert(offsetof(FByteArray, DataSize) == 0x000000, "Member 'FByteArray::DataSize' has a wrong offset!");
static_assert(offsetof(FByteArray, Data) == 0x000008, "Member 'FByteArray::Data' has a wrong offset!");

// ScriptStruct Altar.LegacyEffectsItemProperties
// 0x0030 (0x0030 - 0x0000)
struct FLegacyEffectsItemProperties final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NameText;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Image;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyEffectsItemProperties) == 0x000008, "Wrong alignment on FLegacyEffectsItemProperties");
static_assert(sizeof(FLegacyEffectsItemProperties) == 0x000030, "Wrong size on FLegacyEffectsItemProperties");
static_assert(offsetof(FLegacyEffectsItemProperties, Index) == 0x000000, "Member 'FLegacyEffectsItemProperties::Index' has a wrong offset!");
static_assert(offsetof(FLegacyEffectsItemProperties, NameText) == 0x000008, "Member 'FLegacyEffectsItemProperties::NameText' has a wrong offset!");
static_assert(offsetof(FLegacyEffectsItemProperties, Image) == 0x000020, "Member 'FLegacyEffectsItemProperties::Image' has a wrong offset!");
static_assert(offsetof(FLegacyEffectsItemProperties, bIsSelected) == 0x000028, "Member 'FLegacyEffectsItemProperties::bIsSelected' has a wrong offset!");

// ScriptStruct Altar.BasicUINavigation
// 0x0060 (0x0060 - 0x0000)
struct FBasicUINavigation final
{
public:
	TMap<ENavigationInputAction, class UWidget*>  DestinationWidgets;                                // 0x0000(0x0050)(Edit, ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TScriptInterface<class INavigationUIElement>  WidgetNavigationParent;                            // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FBasicUINavigation) == 0x000008, "Wrong alignment on FBasicUINavigation");
static_assert(sizeof(FBasicUINavigation) == 0x000060, "Wrong size on FBasicUINavigation");
static_assert(offsetof(FBasicUINavigation, DestinationWidgets) == 0x000000, "Member 'FBasicUINavigation::DestinationWidgets' has a wrong offset!");
static_assert(offsetof(FBasicUINavigation, WidgetNavigationParent) == 0x000050, "Member 'FBasicUINavigation::WidgetNavigationParent' has a wrong offset!");

// ScriptStruct Altar.VInstancerRemoveData
// 0x0020 (0x0020 - 0x0000)
struct FVInstancerRemoveData final
{
public:
	TArray<struct FTransform>                     Transforms;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<int32>                                 Indexes;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVInstancerRemoveData) == 0x000008, "Wrong alignment on FVInstancerRemoveData");
static_assert(sizeof(FVInstancerRemoveData) == 0x000020, "Wrong size on FVInstancerRemoveData");
static_assert(offsetof(FVInstancerRemoveData, Transforms) == 0x000000, "Member 'FVInstancerRemoveData::Transforms' has a wrong offset!");
static_assert(offsetof(FVInstancerRemoveData, Indexes) == 0x000010, "Member 'FVInstancerRemoveData::Indexes' has a wrong offset!");

// ScriptStruct Altar.VTurnInPlaceCreatureAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVTurnInPlaceCreatureAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVTurnInPlaceCreatureAnimInstanceProxy) == 0x000010, "Wrong alignment on FVTurnInPlaceCreatureAnimInstanceProxy");
static_assert(sizeof(FVTurnInPlaceCreatureAnimInstanceProxy) == 0x000710, "Wrong size on FVTurnInPlaceCreatureAnimInstanceProxy");

// ScriptStruct Altar.HitReactionKeyframeData
// 0x0030 (0x0030 - 0x0000)
struct FHitReactionKeyframeData final
{
public:
	class UBlendSpace*                            LightHitReactBlendSpace;                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightHitReactAlpha;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            HeavyHitReactBlendSpace;                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeavyHitReactAlpha;                                // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            SpellArrowHitReactBlendSpace;                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpellArrowHitReactAlpha;                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitReactionKeyframeData) == 0x000008, "Wrong alignment on FHitReactionKeyframeData");
static_assert(sizeof(FHitReactionKeyframeData) == 0x000030, "Wrong size on FHitReactionKeyframeData");
static_assert(offsetof(FHitReactionKeyframeData, LightHitReactBlendSpace) == 0x000000, "Member 'FHitReactionKeyframeData::LightHitReactBlendSpace' has a wrong offset!");
static_assert(offsetof(FHitReactionKeyframeData, LightHitReactAlpha) == 0x000008, "Member 'FHitReactionKeyframeData::LightHitReactAlpha' has a wrong offset!");
static_assert(offsetof(FHitReactionKeyframeData, HeavyHitReactBlendSpace) == 0x000010, "Member 'FHitReactionKeyframeData::HeavyHitReactBlendSpace' has a wrong offset!");
static_assert(offsetof(FHitReactionKeyframeData, HeavyHitReactAlpha) == 0x000018, "Member 'FHitReactionKeyframeData::HeavyHitReactAlpha' has a wrong offset!");
static_assert(offsetof(FHitReactionKeyframeData, SpellArrowHitReactBlendSpace) == 0x000020, "Member 'FHitReactionKeyframeData::SpellArrowHitReactBlendSpace' has a wrong offset!");
static_assert(offsetof(FHitReactionKeyframeData, SpellArrowHitReactAlpha) == 0x000028, "Member 'FHitReactionKeyframeData::SpellArrowHitReactAlpha' has a wrong offset!");

// ScriptStruct Altar.SkelMeshMergeSectionMapping_BP
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshMergeSectionMapping_BP final
{
public:
	TArray<int32>                                 SectionIDs;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkelMeshMergeSectionMapping_BP) == 0x000008, "Wrong alignment on FSkelMeshMergeSectionMapping_BP");
static_assert(sizeof(FSkelMeshMergeSectionMapping_BP) == 0x000010, "Wrong size on FSkelMeshMergeSectionMapping_BP");
static_assert(offsetof(FSkelMeshMergeSectionMapping_BP, SectionIDs) == 0x000000, "Member 'FSkelMeshMergeSectionMapping_BP::SectionIDs' has a wrong offset!");

// ScriptStruct Altar.SkelMeshMergeUVTransform
// 0x0010 (0x0010 - 0x0000)
struct FSkelMeshMergeUVTransform final
{
public:
	TArray<struct FTransform>                     UVTransforms;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkelMeshMergeUVTransform) == 0x000008, "Wrong alignment on FSkelMeshMergeUVTransform");
static_assert(sizeof(FSkelMeshMergeUVTransform) == 0x000010, "Wrong size on FSkelMeshMergeUVTransform");
static_assert(offsetof(FSkelMeshMergeUVTransform, UVTransforms) == 0x000000, "Member 'FSkelMeshMergeUVTransform::UVTransforms' has a wrong offset!");

// ScriptStruct Altar.VSkelMeshMergeUVTransformMapping
// 0x0010 (0x0010 - 0x0000)
struct FVSkelMeshMergeUVTransformMapping final
{
public:
	TArray<struct FSkelMeshMergeUVTransform>      UVTransformsPerMesh;                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSkelMeshMergeUVTransformMapping) == 0x000008, "Wrong alignment on FVSkelMeshMergeUVTransformMapping");
static_assert(sizeof(FVSkelMeshMergeUVTransformMapping) == 0x000010, "Wrong size on FVSkelMeshMergeUVTransformMapping");
static_assert(offsetof(FVSkelMeshMergeUVTransformMapping, UVTransformsPerMesh) == 0x000000, "Member 'FVSkelMeshMergeUVTransformMapping::UVTransformsPerMesh' has a wrong offset!");

// ScriptStruct Altar.LegacyTrainMenuProperties
// 0x00C8 (0x00C8 - 0x0000)
struct FLegacyTrainMenuProperties final
{
public:
	class UTexture2D*                             Illustration;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SkillName;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   SkillDescription;                                  // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TrainerSkill;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Skill;                                             // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TimeTrained;                                       // 0x0068(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   PlayerName;                                        // 0x0080(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   NPCName;                                           // 0x0098(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         TimeTrainedInt;                                    // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTimeTrained;                                    // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Costs;                                             // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayedGold;                                        // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcGold;                                           // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrainAvailable;                                    // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyTrainMenuProperties) == 0x000008, "Wrong alignment on FLegacyTrainMenuProperties");
static_assert(sizeof(FLegacyTrainMenuProperties) == 0x0000C8, "Wrong size on FLegacyTrainMenuProperties");
static_assert(offsetof(FLegacyTrainMenuProperties, Illustration) == 0x000000, "Member 'FLegacyTrainMenuProperties::Illustration' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, SkillName) == 0x000008, "Member 'FLegacyTrainMenuProperties::SkillName' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, SkillDescription) == 0x000020, "Member 'FLegacyTrainMenuProperties::SkillDescription' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, TrainerSkill) == 0x000038, "Member 'FLegacyTrainMenuProperties::TrainerSkill' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, Skill) == 0x000050, "Member 'FLegacyTrainMenuProperties::Skill' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, TimeTrained) == 0x000068, "Member 'FLegacyTrainMenuProperties::TimeTrained' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, PlayerName) == 0x000080, "Member 'FLegacyTrainMenuProperties::PlayerName' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, NPCName) == 0x000098, "Member 'FLegacyTrainMenuProperties::NPCName' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, TimeTrainedInt) == 0x0000B0, "Member 'FLegacyTrainMenuProperties::TimeTrainedInt' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, MaxTimeTrained) == 0x0000B4, "Member 'FLegacyTrainMenuProperties::MaxTimeTrained' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, Costs) == 0x0000B8, "Member 'FLegacyTrainMenuProperties::Costs' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, PlayedGold) == 0x0000BC, "Member 'FLegacyTrainMenuProperties::PlayedGold' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, NpcGold) == 0x0000C0, "Member 'FLegacyTrainMenuProperties::NpcGold' has a wrong offset!");
static_assert(offsetof(FLegacyTrainMenuProperties, TrainAvailable) == 0x0000C4, "Member 'FLegacyTrainMenuProperties::TrainAvailable' has a wrong offset!");

// ScriptStruct Altar.SkeletalMeshMergeParams
// 0x0040 (0x0040 - 0x0000)
struct FSkeletalMeshMergeParams final
{
public:
	TArray<struct FSkelMeshMergeSectionMapping_BP> MeshSectionMappings;                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVSkelMeshMergeUVTransformMapping> UVTransformsPerMesh;                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  MeshesToMerge;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StripTopLODS;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNeedsCpuAccess : 1;                               // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkeletonBefore : 1;                               // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              Skeleton;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletalMeshMergeParams) == 0x000008, "Wrong alignment on FSkeletalMeshMergeParams");
static_assert(sizeof(FSkeletalMeshMergeParams) == 0x000040, "Wrong size on FSkeletalMeshMergeParams");
static_assert(offsetof(FSkeletalMeshMergeParams, MeshSectionMappings) == 0x000000, "Member 'FSkeletalMeshMergeParams::MeshSectionMappings' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, UVTransformsPerMesh) == 0x000010, "Member 'FSkeletalMeshMergeParams::UVTransformsPerMesh' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, MeshesToMerge) == 0x000020, "Member 'FSkeletalMeshMergeParams::MeshesToMerge' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, StripTopLODS) == 0x000030, "Member 'FSkeletalMeshMergeParams::StripTopLODS' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshMergeParams, Skeleton) == 0x000038, "Member 'FSkeletalMeshMergeParams::Skeleton' has a wrong offset!");

// ScriptStruct Altar.ModernLockpickMenuTumblerProperties
// 0x0010 (0x0010 - 0x0000)
struct FModernLockpickMenuTumblerProperties final
{
public:
	float                                         StartVelocity;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PauseTime;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAnimationTime;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernLockpickMenuTumblerProperties) == 0x000004, "Wrong alignment on FModernLockpickMenuTumblerProperties");
static_assert(sizeof(FModernLockpickMenuTumblerProperties) == 0x000010, "Wrong size on FModernLockpickMenuTumblerProperties");
static_assert(offsetof(FModernLockpickMenuTumblerProperties, StartVelocity) == 0x000000, "Member 'FModernLockpickMenuTumblerProperties::StartVelocity' has a wrong offset!");
static_assert(offsetof(FModernLockpickMenuTumblerProperties, Gravity) == 0x000004, "Member 'FModernLockpickMenuTumblerProperties::Gravity' has a wrong offset!");
static_assert(offsetof(FModernLockpickMenuTumblerProperties, PauseTime) == 0x000008, "Member 'FModernLockpickMenuTumblerProperties::PauseTime' has a wrong offset!");
static_assert(offsetof(FModernLockpickMenuTumblerProperties, MaxAnimationTime) == 0x00000C, "Member 'FModernLockpickMenuTumblerProperties::MaxAnimationTime' has a wrong offset!");

// ScriptStruct Altar.VWeaponCategorySneakBonusDataRow
// 0x0020 (0x0028 - 0x0008)
struct FVWeaponCategorySneakBonusDataRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           WeaponTag;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoviceSneakBonusMult;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApprenticeSneakBonusMult;                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JourneymanSneakBonusMult;                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpertSneakBonusMult;                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MasterSneakBonusMult;                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVWeaponCategorySneakBonusDataRow) == 0x000008, "Wrong alignment on FVWeaponCategorySneakBonusDataRow");
static_assert(sizeof(FVWeaponCategorySneakBonusDataRow) == 0x000028, "Wrong size on FVWeaponCategorySneakBonusDataRow");
static_assert(offsetof(FVWeaponCategorySneakBonusDataRow, WeaponTag) == 0x000008, "Member 'FVWeaponCategorySneakBonusDataRow::WeaponTag' has a wrong offset!");
static_assert(offsetof(FVWeaponCategorySneakBonusDataRow, NoviceSneakBonusMult) == 0x000010, "Member 'FVWeaponCategorySneakBonusDataRow::NoviceSneakBonusMult' has a wrong offset!");
static_assert(offsetof(FVWeaponCategorySneakBonusDataRow, ApprenticeSneakBonusMult) == 0x000014, "Member 'FVWeaponCategorySneakBonusDataRow::ApprenticeSneakBonusMult' has a wrong offset!");
static_assert(offsetof(FVWeaponCategorySneakBonusDataRow, JourneymanSneakBonusMult) == 0x000018, "Member 'FVWeaponCategorySneakBonusDataRow::JourneymanSneakBonusMult' has a wrong offset!");
static_assert(offsetof(FVWeaponCategorySneakBonusDataRow, ExpertSneakBonusMult) == 0x00001C, "Member 'FVWeaponCategorySneakBonusDataRow::ExpertSneakBonusMult' has a wrong offset!");
static_assert(offsetof(FVWeaponCategorySneakBonusDataRow, MasterSneakBonusMult) == 0x000020, "Member 'FVWeaponCategorySneakBonusDataRow::MasterSneakBonusMult' has a wrong offset!");

// ScriptStruct Altar.NavigationMappingProperties
// 0x0020 (0x0020 - 0x0000)
struct FNavigationMappingProperties final
{
public:
	struct FKey                                   Mapping;                                           // 0x0000(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConsumeInputEvent;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavigationMappingProperties) == 0x000008, "Wrong alignment on FNavigationMappingProperties");
static_assert(sizeof(FNavigationMappingProperties) == 0x000020, "Wrong size on FNavigationMappingProperties");
static_assert(offsetof(FNavigationMappingProperties, Mapping) == 0x000000, "Member 'FNavigationMappingProperties::Mapping' has a wrong offset!");
static_assert(offsetof(FNavigationMappingProperties, ConsumeInputEvent) == 0x000018, "Member 'FNavigationMappingProperties::ConsumeInputEvent' has a wrong offset!");

// ScriptStruct Altar.NavigationActionMappingTableRow
// 0x0018 (0x0020 - 0x0008)
struct FNavigationActionMappingTableRow final : public FTableRowBase
{
public:
	ENavigationInputAction                        Action;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNavigationMappingProperties>   Mappings;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavigationActionMappingTableRow) == 0x000008, "Wrong alignment on FNavigationActionMappingTableRow");
static_assert(sizeof(FNavigationActionMappingTableRow) == 0x000020, "Wrong size on FNavigationActionMappingTableRow");
static_assert(offsetof(FNavigationActionMappingTableRow, Action) == 0x000008, "Member 'FNavigationActionMappingTableRow::Action' has a wrong offset!");
static_assert(offsetof(FNavigationActionMappingTableRow, Mappings) == 0x000010, "Member 'FNavigationActionMappingTableRow::Mappings' has a wrong offset!");

// ScriptStruct Altar.VHumanoidLowerAndUpperBodySetup
// 0x0038 (0x0038 - 0x0000)
struct FVHumanoidLowerAndUpperBodySetup final
{
public:
	class FName                                   PelvisBoneName;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PelvisBlendDepth;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftLegBoneName;                                   // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightLegBoneName;                                  // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegsBlendDepth;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpperBodyBoneName;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperBodyBlendDepth;                               // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SwimUpperBodyBoneName;                             // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SwimUpperBodyBlendDepth;                           // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVHumanoidLowerAndUpperBodySetup) == 0x000004, "Wrong alignment on FVHumanoidLowerAndUpperBodySetup");
static_assert(sizeof(FVHumanoidLowerAndUpperBodySetup) == 0x000038, "Wrong size on FVHumanoidLowerAndUpperBodySetup");
static_assert(offsetof(FVHumanoidLowerAndUpperBodySetup, PelvisBoneName) == 0x000000, "Member 'FVHumanoidLowerAndUpperBodySetup::PelvisBoneName' has a wrong offset!");
static_assert(offsetof(FVHumanoidLowerAndUpperBodySetup, PelvisBlendDepth) == 0x000008, "Member 'FVHumanoidLowerAndUpperBodySetup::PelvisBlendDepth' has a wrong offset!");
static_assert(offsetof(FVHumanoidLowerAndUpperBodySetup, LeftLegBoneName) == 0x00000C, "Member 'FVHumanoidLowerAndUpperBodySetup::LeftLegBoneName' has a wrong offset!");
static_assert(offsetof(FVHumanoidLowerAndUpperBodySetup, RightLegBoneName) == 0x000014, "Member 'FVHumanoidLowerAndUpperBodySetup::RightLegBoneName' has a wrong offset!");
static_assert(offsetof(FVHumanoidLowerAndUpperBodySetup, LegsBlendDepth) == 0x00001C, "Member 'FVHumanoidLowerAndUpperBodySetup::LegsBlendDepth' has a wrong offset!");
static_assert(offsetof(FVHumanoidLowerAndUpperBodySetup, UpperBodyBoneName) == 0x000020, "Member 'FVHumanoidLowerAndUpperBodySetup::UpperBodyBoneName' has a wrong offset!");
static_assert(offsetof(FVHumanoidLowerAndUpperBodySetup, UpperBodyBlendDepth) == 0x000028, "Member 'FVHumanoidLowerAndUpperBodySetup::UpperBodyBlendDepth' has a wrong offset!");
static_assert(offsetof(FVHumanoidLowerAndUpperBodySetup, SwimUpperBodyBoneName) == 0x00002C, "Member 'FVHumanoidLowerAndUpperBodySetup::SwimUpperBodyBoneName' has a wrong offset!");
static_assert(offsetof(FVHumanoidLowerAndUpperBodySetup, SwimUpperBodyBlendDepth) == 0x000034, "Member 'FVHumanoidLowerAndUpperBodySetup::SwimUpperBodyBlendDepth' has a wrong offset!");

// ScriptStruct Altar.NavMeshLandmarkType
// 0x0030 (0x0030 - 0x0000)
struct FNavMeshLandmarkType final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavMeshLandmarkType) == 0x000008, "Wrong alignment on FNavMeshLandmarkType");
static_assert(sizeof(FNavMeshLandmarkType) == 0x000030, "Wrong size on FNavMeshLandmarkType");
static_assert(offsetof(FNavMeshLandmarkType, ActorClass) == 0x000000, "Member 'FNavMeshLandmarkType::ActorClass' has a wrong offset!");

// ScriptStruct Altar.NavMeshLandmark
// 0x0030 (0x0030 - 0x0000)
struct FNavMeshLandmark final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavMeshLandmark) == 0x000008, "Wrong alignment on FNavMeshLandmark");
static_assert(sizeof(FNavMeshLandmark) == 0x000030, "Wrong size on FNavMeshLandmark");
static_assert(offsetof(FNavMeshLandmark, Actor) == 0x000000, "Member 'FNavMeshLandmark::Actor' has a wrong offset!");

// ScriptStruct Altar.NavMeshLandmarkMetaCluster
// 0x0060 (0x0060 - 0x0000)
struct FNavMeshLandmarkMetaCluster final
{
public:
	TArray<struct FNavMeshLandmark>               NavMeshLandmarks;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x50];                                      // 0x0010(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavMeshLandmarkMetaCluster) == 0x000008, "Wrong alignment on FNavMeshLandmarkMetaCluster");
static_assert(sizeof(FNavMeshLandmarkMetaCluster) == 0x000060, "Wrong size on FNavMeshLandmarkMetaCluster");
static_assert(offsetof(FNavMeshLandmarkMetaCluster, NavMeshLandmarks) == 0x000000, "Member 'FNavMeshLandmarkMetaCluster::NavMeshLandmarks' has a wrong offset!");

// ScriptStruct Altar.NavigationDataLandmarkMetaClusters
// 0x0048 (0x0048 - 0x0000)
struct FNavigationDataLandmarkMetaClusters final
{
public:
	class ARecastNavMesh*                         RecastNavMesh;                                     // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNavMeshLandmarkMetaCluster>    LandmarkMetaClusters;                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FNavMeshLandmark>               PendingNavMeshLandmarks;                           // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x1F];                                      // 0x0029(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavigationDataLandmarkMetaClusters) == 0x000008, "Wrong alignment on FNavigationDataLandmarkMetaClusters");
static_assert(sizeof(FNavigationDataLandmarkMetaClusters) == 0x000048, "Wrong size on FNavigationDataLandmarkMetaClusters");
static_assert(offsetof(FNavigationDataLandmarkMetaClusters, RecastNavMesh) == 0x000000, "Member 'FNavigationDataLandmarkMetaClusters::RecastNavMesh' has a wrong offset!");
static_assert(offsetof(FNavigationDataLandmarkMetaClusters, LandmarkMetaClusters) == 0x000008, "Member 'FNavigationDataLandmarkMetaClusters::LandmarkMetaClusters' has a wrong offset!");
static_assert(offsetof(FNavigationDataLandmarkMetaClusters, PendingNavMeshLandmarks) == 0x000018, "Member 'FNavigationDataLandmarkMetaClusters::PendingNavMeshLandmarks' has a wrong offset!");
static_assert(offsetof(FNavigationDataLandmarkMetaClusters, bValid) == 0x000028, "Member 'FNavigationDataLandmarkMetaClusters::bValid' has a wrong offset!");

// ScriptStruct Altar.TurnInPlaceAnimSet
// 0x0010 (0x0010 - 0x0000)
struct FTurnInPlaceAnimSet final
{
public:
	class UAnimSequenceBase*                      TurnLeft;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      TurnRight;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTurnInPlaceAnimSet) == 0x000008, "Wrong alignment on FTurnInPlaceAnimSet");
static_assert(sizeof(FTurnInPlaceAnimSet) == 0x000010, "Wrong size on FTurnInPlaceAnimSet");
static_assert(offsetof(FTurnInPlaceAnimSet, TurnLeft) == 0x000000, "Member 'FTurnInPlaceAnimSet::TurnLeft' has a wrong offset!");
static_assert(offsetof(FTurnInPlaceAnimSet, TurnRight) == 0x000008, "Member 'FTurnInPlaceAnimSet::TurnRight' has a wrong offset!");

// ScriptStruct Altar.TurnInPlaceFP
// 0x0030 (0x0030 - 0x0000)
struct FTurnInPlaceFP final
{
public:
	struct FTurnInPlaceAnimSet                    StandingSet;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FTurnInPlaceAnimSet                    SneakingSet;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FTurnInPlaceAnimSet                    SwimmingSet;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTurnInPlaceFP) == 0x000008, "Wrong alignment on FTurnInPlaceFP");
static_assert(sizeof(FTurnInPlaceFP) == 0x000030, "Wrong size on FTurnInPlaceFP");
static_assert(offsetof(FTurnInPlaceFP, StandingSet) == 0x000000, "Member 'FTurnInPlaceFP::StandingSet' has a wrong offset!");
static_assert(offsetof(FTurnInPlaceFP, SneakingSet) == 0x000010, "Member 'FTurnInPlaceFP::SneakingSet' has a wrong offset!");
static_assert(offsetof(FTurnInPlaceFP, SwimmingSet) == 0x000020, "Member 'FTurnInPlaceFP::SwimmingSet' has a wrong offset!");

// ScriptStruct Altar.NiAGDDataStreamFlags
// 0x0001 (0x0001 - 0x0000)
struct FNiAGDDataStreamFlags final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNiAGDDataStreamFlags) == 0x000001, "Wrong alignment on FNiAGDDataStreamFlags");
static_assert(sizeof(FNiAGDDataStreamFlags) == 0x000001, "Wrong size on FNiAGDDataStreamFlags");

// ScriptStruct Altar.NiBound
// 0x0020 (0x0020 - 0x0000)
struct FNiBound final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNiBound) == 0x000008, "Wrong alignment on FNiBound");
static_assert(sizeof(FNiBound) == 0x000020, "Wrong size on FNiBound");
static_assert(offsetof(FNiBound, Center) == 0x000000, "Member 'FNiBound::Center' has a wrong offset!");
static_assert(offsetof(FNiBound, Radius) == 0x000018, "Member 'FNiBound::Radius' has a wrong offset!");

// ScriptStruct Altar.FogFlags
// 0x0002 (0x0002 - 0x0000)
struct alignas(0x02) FFogFlags final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFogFlags) == 0x000002, "Wrong alignment on FFogFlags");
static_assert(sizeof(FFogFlags) == 0x000002, "Wrong size on FFogFlags");

// ScriptStruct Altar.NifString
// 0x0010 (0x0010 - 0x0000)
struct FNifString final
{
public:
	class FString                                 String;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNifString) == 0x000008, "Wrong alignment on FNifString");
static_assert(sizeof(FNifString) == 0x000010, "Wrong size on FNifString");
static_assert(offsetof(FNifString, String) == 0x000000, "Member 'FNifString::String' has a wrong offset!");

// ScriptStruct Altar.VRaceDataRows
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FVRaceDataRows final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVRaceDataRows) == 0x000008, "Wrong alignment on FVRaceDataRows");
static_assert(sizeof(FVRaceDataRows) == 0x000010, "Wrong size on FVRaceDataRows");

// ScriptStruct Altar.StencilFlags
// 0x0002 (0x0002 - 0x0000)
struct alignas(0x02) FStencilFlags final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStencilFlags) == 0x000002, "Wrong alignment on FStencilFlags");
static_assert(sizeof(FStencilFlags) == 0x000002, "Wrong size on FStencilFlags");

// ScriptStruct Altar.TexturingFlags
// 0x0004 (0x0004 - 0x0000)
struct FTexturingFlags final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTexturingFlags) == 0x000004, "Wrong alignment on FTexturingFlags");
static_assert(sizeof(FTexturingFlags) == 0x000004, "Wrong size on FTexturingFlags");
static_assert(offsetof(FTexturingFlags, Value) == 0x000000, "Member 'FTexturingFlags::Value' has a wrong offset!");

// ScriptStruct Altar.TimeControllerFlags
// 0x0004 (0x0004 - 0x0000)
struct FTimeControllerFlags final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimeControllerFlags) == 0x000004, "Wrong alignment on FTimeControllerFlags");
static_assert(sizeof(FTimeControllerFlags) == 0x000004, "Wrong size on FTimeControllerFlags");
static_assert(offsetof(FTimeControllerFlags, Value) == 0x000000, "Member 'FTimeControllerFlags::Value' has a wrong offset!");

// ScriptStruct Altar.VertexColorFlags
// 0x0002 (0x0002 - 0x0000)
struct alignas(0x02) FVertexColorFlags final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVertexColorFlags) == 0x000002, "Wrong alignment on FVertexColorFlags");
static_assert(sizeof(FVertexColorFlags) == 0x000002, "Wrong size on FVertexColorFlags");

// ScriptStruct Altar.VStatsDataStructure
// 0x0068 (0x0068 - 0x0000)
struct FVStatsDataStructure
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                RowIcon;                                           // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                TileIcon;                                          // 0x0040(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVStatsDataStructure) == 0x000008, "Wrong alignment on FVStatsDataStructure");
static_assert(sizeof(FVStatsDataStructure) == 0x000068, "Wrong size on FVStatsDataStructure");
static_assert(offsetof(FVStatsDataStructure, Name) == 0x000000, "Member 'FVStatsDataStructure::Name' has a wrong offset!");
static_assert(offsetof(FVStatsDataStructure, RowIcon) == 0x000018, "Member 'FVStatsDataStructure::RowIcon' has a wrong offset!");
static_assert(offsetof(FVStatsDataStructure, TileIcon) == 0x000040, "Member 'FVStatsDataStructure::TileIcon' has a wrong offset!");

// ScriptStruct Altar.VSkillStatDataStructure
// 0x0008 (0x0070 - 0x0068)
struct FVSkillStatDataStructure final : public FVStatsDataStructure
{
public:
	ESkillStat                                    Type;                                              // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVSkillStatDataStructure) == 0x000008, "Wrong alignment on FVSkillStatDataStructure");
static_assert(sizeof(FVSkillStatDataStructure) == 0x000070, "Wrong size on FVSkillStatDataStructure");
static_assert(offsetof(FVSkillStatDataStructure, Type) == 0x000068, "Member 'FVSkillStatDataStructure::Type' has a wrong offset!");

// ScriptStruct Altar.ActorInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FActorInfo final
{
public:
	class FString                                 ModelPath;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorName;                                         // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderName;                                        // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ClassToSpawn;                                      // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 LightColor;                                        // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightRadius;                                       // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightIntensity;                                    // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TailModelPath;                                     // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkeletalMeshSex;                                   // 0x0058(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         BodyPaths;                                         // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ClothArmorPaths;                                   // 0x0070(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BipedObjectSlots;                                  // 0x0080(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SoundPath;                                         // 0x0090(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorInfo) == 0x000008, "Wrong alignment on FActorInfo");
static_assert(sizeof(FActorInfo) == 0x0000A0, "Wrong size on FActorInfo");
static_assert(offsetof(FActorInfo, ModelPath) == 0x000000, "Member 'FActorInfo::ModelPath' has a wrong offset!");
static_assert(offsetof(FActorInfo, ActorName) == 0x000010, "Member 'FActorInfo::ActorName' has a wrong offset!");
static_assert(offsetof(FActorInfo, FolderName) == 0x000020, "Member 'FActorInfo::FolderName' has a wrong offset!");
static_assert(offsetof(FActorInfo, ClassToSpawn) == 0x000030, "Member 'FActorInfo::ClassToSpawn' has a wrong offset!");
static_assert(offsetof(FActorInfo, LightColor) == 0x000038, "Member 'FActorInfo::LightColor' has a wrong offset!");
static_assert(offsetof(FActorInfo, LightRadius) == 0x00003C, "Member 'FActorInfo::LightRadius' has a wrong offset!");
static_assert(offsetof(FActorInfo, LightIntensity) == 0x000040, "Member 'FActorInfo::LightIntensity' has a wrong offset!");
static_assert(offsetof(FActorInfo, TailModelPath) == 0x000048, "Member 'FActorInfo::TailModelPath' has a wrong offset!");
static_assert(offsetof(FActorInfo, SkeletalMeshSex) == 0x000058, "Member 'FActorInfo::SkeletalMeshSex' has a wrong offset!");
static_assert(offsetof(FActorInfo, BodyPaths) == 0x000060, "Member 'FActorInfo::BodyPaths' has a wrong offset!");
static_assert(offsetof(FActorInfo, ClothArmorPaths) == 0x000070, "Member 'FActorInfo::ClothArmorPaths' has a wrong offset!");
static_assert(offsetof(FActorInfo, BipedObjectSlots) == 0x000080, "Member 'FActorInfo::BipedObjectSlots' has a wrong offset!");
static_assert(offsetof(FActorInfo, SoundPath) == 0x000090, "Member 'FActorInfo::SoundPath' has a wrong offset!");

// ScriptStruct Altar.StainedGlassElement
// 0x0040 (0x0040 - 0x0000)
struct FStainedGlassElement final
{
public:
	TWeakObjectPtr<class UMeshComponent>          Glass;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GlassOrigin;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GlassExtent;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStainedGlassElement) == 0x000008, "Wrong alignment on FStainedGlassElement");
static_assert(sizeof(FStainedGlassElement) == 0x000040, "Wrong size on FStainedGlassElement");
static_assert(offsetof(FStainedGlassElement, Glass) == 0x000000, "Member 'FStainedGlassElement::Glass' has a wrong offset!");
static_assert(offsetof(FStainedGlassElement, GlassOrigin) == 0x000008, "Member 'FStainedGlassElement::GlassOrigin' has a wrong offset!");
static_assert(offsetof(FStainedGlassElement, GlassExtent) == 0x000020, "Member 'FStainedGlassElement::GlassExtent' has a wrong offset!");
static_assert(offsetof(FStainedGlassElement, Intensity) == 0x000038, "Member 'FStainedGlassElement::Intensity' has a wrong offset!");

// ScriptStruct Altar.AnimationPresetData
// 0x0018 (0x0018 - 0x0000)
struct FAnimationPresetData final
{
public:
	class UAnimSequenceBase*                      Animation;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseActionStateDuration;                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomAnimationDuration;                       // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomAnimationDuration;                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimationWeight;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimationPresetData) == 0x000008, "Wrong alignment on FAnimationPresetData");
static_assert(sizeof(FAnimationPresetData) == 0x000018, "Wrong size on FAnimationPresetData");
static_assert(offsetof(FAnimationPresetData, Animation) == 0x000000, "Member 'FAnimationPresetData::Animation' has a wrong offset!");
static_assert(offsetof(FAnimationPresetData, bUseActionStateDuration) == 0x000008, "Member 'FAnimationPresetData::bUseActionStateDuration' has a wrong offset!");
static_assert(offsetof(FAnimationPresetData, bUseCustomAnimationDuration) == 0x000009, "Member 'FAnimationPresetData::bUseCustomAnimationDuration' has a wrong offset!");
static_assert(offsetof(FAnimationPresetData, CustomAnimationDuration) == 0x00000C, "Member 'FAnimationPresetData::CustomAnimationDuration' has a wrong offset!");
static_assert(offsetof(FAnimationPresetData, AnimationWeight) == 0x000010, "Member 'FAnimationPresetData::AnimationWeight' has a wrong offset!");

// ScriptStruct Altar.VActionStatePresets
// 0x0040 (0x0048 - 0x0008)
struct FVActionStatePresets final : public FTableRowBase
{
public:
	struct FGameplayTagContainer                  AnimGroupKey;                                      // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ActionStateDuration;                               // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimationPresetData>           AnimationList;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BaseActionStateDuration;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRotationSpeedMultiplier;                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVActionStatePresets) == 0x000008, "Wrong alignment on FVActionStatePresets");
static_assert(sizeof(FVActionStatePresets) == 0x000048, "Wrong size on FVActionStatePresets");
static_assert(offsetof(FVActionStatePresets, AnimGroupKey) == 0x000008, "Member 'FVActionStatePresets::AnimGroupKey' has a wrong offset!");
static_assert(offsetof(FVActionStatePresets, ActionStateDuration) == 0x000028, "Member 'FVActionStatePresets::ActionStateDuration' has a wrong offset!");
static_assert(offsetof(FVActionStatePresets, AnimationList) == 0x000030, "Member 'FVActionStatePresets::AnimationList' has a wrong offset!");
static_assert(offsetof(FVActionStatePresets, BaseActionStateDuration) == 0x000040, "Member 'FVActionStatePresets::BaseActionStateDuration' has a wrong offset!");
static_assert(offsetof(FVActionStatePresets, YawRotationSpeedMultiplier) == 0x000044, "Member 'FVActionStatePresets::YawRotationSpeedMultiplier' has a wrong offset!");

// ScriptStruct Altar.VRecoilMultiple
// 0x0010 (0x0010 - 0x0000)
struct FVRecoilMultiple final
{
public:
	TArray<class UAnimMontage*>                   Recoil;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVRecoilMultiple) == 0x000008, "Wrong alignment on FVRecoilMultiple");
static_assert(sizeof(FVRecoilMultiple) == 0x000010, "Wrong size on FVRecoilMultiple");
static_assert(offsetof(FVRecoilMultiple, Recoil) == 0x000000, "Member 'FVRecoilMultiple::Recoil' has a wrong offset!");

// ScriptStruct Altar.ACTOR_BASE_DATA
// 0x0008 (0x0008 - 0x0000)
struct FACTOR_BASE_DATA final
{
public:
	int32                                         ActorBaseFlag;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FACTOR_BASE_DATA) == 0x000004, "Wrong alignment on FACTOR_BASE_DATA");
static_assert(sizeof(FACTOR_BASE_DATA) == 0x000008, "Wrong size on FACTOR_BASE_DATA");
static_assert(offsetof(FACTOR_BASE_DATA, ActorBaseFlag) == 0x000000, "Member 'FACTOR_BASE_DATA::ActorBaseFlag' has a wrong offset!");
static_assert(offsetof(FACTOR_BASE_DATA, Level) == 0x000004, "Member 'FACTOR_BASE_DATA::Level' has a wrong offset!");

// ScriptStruct Altar.ACTOR_FACTION_RANK
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FACTOR_FACTION_RANK final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FACTOR_FACTION_RANK) == 0x000008, "Wrong alignment on FACTOR_FACTION_RANK");
static_assert(sizeof(FACTOR_FACTION_RANK) == 0x000010, "Wrong size on FACTOR_FACTION_RANK");

// ScriptStruct Altar.CellExteriorData
// 0x0008 (0x0008 - 0x0000)
struct FCellExteriorData final
{
public:
	int32                                         CellX;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellY;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCellExteriorData) == 0x000004, "Wrong alignment on FCellExteriorData");
static_assert(sizeof(FCellExteriorData) == 0x000008, "Wrong size on FCellExteriorData");
static_assert(offsetof(FCellExteriorData, CellX) == 0x000000, "Member 'FCellExteriorData::CellX' has a wrong offset!");
static_assert(offsetof(FCellExteriorData, CellY) == 0x000004, "Member 'FCellExteriorData::CellY' has a wrong offset!");

// ScriptStruct Altar.VSenescenceTexturePair
// 0x0010 (0x0010 - 0x0000)
struct FVSenescenceTexturePair final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSenescenceTexturePair) == 0x000008, "Wrong alignment on FVSenescenceTexturePair");
static_assert(sizeof(FVSenescenceTexturePair) == 0x000010, "Wrong size on FVSenescenceTexturePair");
static_assert(offsetof(FVSenescenceTexturePair, ParameterName) == 0x000000, "Member 'FVSenescenceTexturePair::ParameterName' has a wrong offset!");
static_assert(offsetof(FVSenescenceTexturePair, Texture) == 0x000008, "Member 'FVSenescenceTexturePair::Texture' has a wrong offset!");

// ScriptStruct Altar.Enchantment
// 0x0088 (0x0088 - 0x0000)
struct FEnchantment final : public FESPDataProperty
{
public:
	struct FVFormPtr                              EnchantmentForm;                                   // 0x0000(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         AmountOfEnchantment;                               // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnchantment) == 0x000008, "Wrong alignment on FEnchantment");
static_assert(sizeof(FEnchantment) == 0x000088, "Wrong size on FEnchantment");
static_assert(offsetof(FEnchantment, EnchantmentForm) == 0x000000, "Member 'FEnchantment::EnchantmentForm' has a wrong offset!");
static_assert(offsetof(FEnchantment, AmountOfEnchantment) == 0x000080, "Member 'FEnchantment::AmountOfEnchantment' has a wrong offset!");

// ScriptStruct Altar.Script
// 0x0080 (0x0080 - 0x0000)
struct FScript final : public FESPDataProperty
{
public:
	struct FVFormPtr                              Script;                                            // 0x0000(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScript) == 0x000008, "Wrong alignment on FScript");
static_assert(sizeof(FScript) == 0x000080, "Wrong size on FScript");
static_assert(offsetof(FScript, Script) == 0x000000, "Member 'FScript::Script' has a wrong offset!");

// ScriptStruct Altar.Weight
// 0x0004 (0x0004 - 0x0000)
struct FWeight final : public FESPDataProperty
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeight) == 0x000004, "Wrong alignment on FWeight");
static_assert(sizeof(FWeight) == 0x000004, "Wrong size on FWeight");
static_assert(offsetof(FWeight, Weight) == 0x000000, "Member 'FWeight::Weight' has a wrong offset!");

// ScriptStruct Altar.SeasonProduceChance
// 0x0004 (0x0004 - 0x0000)
struct FSeasonProduceChance final
{
public:
	uint8                                         Spring;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Summer;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Fall;                                              // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Winter;                                            // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonProduceChance) == 0x000001, "Wrong alignment on FSeasonProduceChance");
static_assert(sizeof(FSeasonProduceChance) == 0x000004, "Wrong size on FSeasonProduceChance");
static_assert(offsetof(FSeasonProduceChance, Spring) == 0x000000, "Member 'FSeasonProduceChance::Spring' has a wrong offset!");
static_assert(offsetof(FSeasonProduceChance, Summer) == 0x000001, "Member 'FSeasonProduceChance::Summer' has a wrong offset!");
static_assert(offsetof(FSeasonProduceChance, Fall) == 0x000002, "Member 'FSeasonProduceChance::Fall' has a wrong offset!");
static_assert(offsetof(FSeasonProduceChance, Winter) == 0x000003, "Member 'FSeasonProduceChance::Winter' has a wrong offset!");

// ScriptStruct Altar.ProduceIngredient
// 0x0088 (0x0088 - 0x0000)
struct FProduceIngredient final : public FESPDataProperty
{
public:
	struct FVFormPtr                              Ingredient;                                        // 0x0000(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSeasonProduceChance                   ProduceChance;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProduceIngredient) == 0x000008, "Wrong alignment on FProduceIngredient");
static_assert(sizeof(FProduceIngredient) == 0x000088, "Wrong size on FProduceIngredient");
static_assert(offsetof(FProduceIngredient, Ingredient) == 0x000000, "Member 'FProduceIngredient::Ingredient' has a wrong offset!");
static_assert(offsetof(FProduceIngredient, ProduceChance) == 0x000080, "Member 'FProduceIngredient::ProduceChance' has a wrong offset!");

// ScriptStruct Altar.Value
// 0x0008 (0x0008 - 0x0000)
struct FValue final : public FESPDataProperty
{
public:
	int64                                         Value;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FValue) == 0x000008, "Wrong alignment on FValue");
static_assert(sizeof(FValue) == 0x000008, "Wrong size on FValue");
static_assert(offsetof(FValue, Value) == 0x000000, "Member 'FValue::Value' has a wrong offset!");

// ScriptStruct Altar.AttackDamage
// 0x0004 (0x0004 - 0x0000)
struct FAttackDamage final : public FESPDataProperty
{
public:
	int32                                         Damage;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackDamage) == 0x000004, "Wrong alignment on FAttackDamage");
static_assert(sizeof(FAttackDamage) == 0x000004, "Wrong size on FAttackDamage");
static_assert(offsetof(FAttackDamage, Damage) == 0x000000, "Member 'FAttackDamage::Damage' has a wrong offset!");

// ScriptStruct Altar.Health
// 0x0008 (0x0008 - 0x0000)
struct FHealth final : public FESPDataProperty
{
public:
	int64                                         Health;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHealth) == 0x000008, "Wrong alignment on FHealth");
static_assert(sizeof(FHealth) == 0x000008, "Wrong size on FHealth");
static_assert(offsetof(FHealth, Health) == 0x000000, "Member 'FHealth::Health' has a wrong offset!");

// ScriptStruct Altar.Quality
// 0x0004 (0x0004 - 0x0000)
struct FQuality final : public FESPDataProperty
{
public:
	float                                         Quality;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuality) == 0x000004, "Wrong alignment on FQuality");
static_assert(sizeof(FQuality) == 0x000004, "Wrong size on FQuality");
static_assert(offsetof(FQuality, Quality) == 0x000000, "Member 'FQuality::Quality' has a wrong offset!");

// ScriptStruct Altar.Effect
// 0x00C8 (0x00C8 - 0x0000)
struct FEffect final
{
public:
	EEffectID                                     EffectID;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Magnitude;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Area;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Duration;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERange                                        Range;                                             // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EActorValue                                   ActorValue;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScriptEffectItemData                  ScriptEffectData;                                  // 0x0020(0x00A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffect) == 0x000008, "Wrong alignment on FEffect");
static_assert(sizeof(FEffect) == 0x0000C8, "Wrong size on FEffect");
static_assert(offsetof(FEffect, EffectID) == 0x000000, "Member 'FEffect::EffectID' has a wrong offset!");
static_assert(offsetof(FEffect, Magnitude) == 0x000008, "Member 'FEffect::Magnitude' has a wrong offset!");
static_assert(offsetof(FEffect, Area) == 0x00000C, "Member 'FEffect::Area' has a wrong offset!");
static_assert(offsetof(FEffect, Duration) == 0x000010, "Member 'FEffect::Duration' has a wrong offset!");
static_assert(offsetof(FEffect, Range) == 0x000014, "Member 'FEffect::Range' has a wrong offset!");
static_assert(offsetof(FEffect, ActorValue) == 0x000018, "Member 'FEffect::ActorValue' has a wrong offset!");
static_assert(offsetof(FEffect, ScriptEffectData) == 0x000020, "Member 'FEffect::ScriptEffectData' has a wrong offset!");

// ScriptStruct Altar.EffectItemList
// 0x0010 (0x0010 - 0x0000)
struct FEffectItemList final
{
public:
	TArray<struct FEffect>                        EffectList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectItemList) == 0x000008, "Wrong alignment on FEffectItemList");
static_assert(sizeof(FEffectItemList) == 0x000010, "Wrong size on FEffectItemList");
static_assert(offsetof(FEffectItemList, EffectList) == 0x000000, "Member 'FEffectItemList::EffectList' has a wrong offset!");

// ScriptStruct Altar.VTSVector4f
// 0x0010 (0x0010 - 0x0000)
struct FVTSVector4f final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         W;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVTSVector4f) == 0x000004, "Wrong alignment on FVTSVector4f");
static_assert(sizeof(FVTSVector4f) == 0x000010, "Wrong size on FVTSVector4f");
static_assert(offsetof(FVTSVector4f, X) == 0x000000, "Member 'FVTSVector4f::X' has a wrong offset!");
static_assert(offsetof(FVTSVector4f, Y) == 0x000004, "Member 'FVTSVector4f::Y' has a wrong offset!");
static_assert(offsetof(FVTSVector4f, Z) == 0x000008, "Member 'FVTSVector4f::Z' has a wrong offset!");
static_assert(offsetof(FVTSVector4f, W) == 0x00000C, "Member 'FVTSVector4f::W' has a wrong offset!");

// ScriptStruct Altar.MagicItem
// 0x0010 (0x0010 - 0x0000)
struct FMagicItem final
{
public:
	struct FEffectItemList                        EffectList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMagicItem) == 0x000008, "Wrong alignment on FMagicItem");
static_assert(sizeof(FMagicItem) == 0x000010, "Wrong size on FMagicItem");
static_assert(offsetof(FMagicItem, EffectList) == 0x000000, "Member 'FMagicItem::EffectList' has a wrong offset!");

// ScriptStruct Altar.LeveledObjectItem
// 0x0090 (0x0090 - 0x0000)
struct FLeveledObjectItem final : public FESPDataProperty
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVFormPtr                              Item;                                              // 0x0008(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeveledObjectItem) == 0x000008, "Wrong alignment on FLeveledObjectItem");
static_assert(sizeof(FLeveledObjectItem) == 0x000090, "Wrong size on FLeveledObjectItem");
static_assert(offsetof(FLeveledObjectItem, Level) == 0x000000, "Member 'FLeveledObjectItem::Level' has a wrong offset!");
static_assert(offsetof(FLeveledObjectItem, Item) == 0x000008, "Member 'FLeveledObjectItem::Item' has a wrong offset!");
static_assert(offsetof(FLeveledObjectItem, Count) == 0x000088, "Member 'FLeveledObjectItem::Count' has a wrong offset!");

// ScriptStruct Altar.ContainerItem
// 0x0088 (0x0088 - 0x0000)
struct FContainerItem final
{
public:
	struct FVFormPtr                              Item;                                              // 0x0000(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContainerItem) == 0x000008, "Wrong alignment on FContainerItem");
static_assert(sizeof(FContainerItem) == 0x000088, "Wrong size on FContainerItem");
static_assert(offsetof(FContainerItem, Item) == 0x000000, "Member 'FContainerItem::Item' has a wrong offset!");
static_assert(offsetof(FContainerItem, Count) == 0x000080, "Member 'FContainerItem::Count' has a wrong offset!");

// ScriptStruct Altar.ContainerComponent
// 0x0010 (0x0010 - 0x0000)
struct FContainerComponent final
{
public:
	TArray<struct FContainerItem>                 Items;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContainerComponent) == 0x000008, "Wrong alignment on FContainerComponent");
static_assert(sizeof(FContainerComponent) == 0x000010, "Wrong size on FContainerComponent");
static_assert(offsetof(FContainerComponent, Items) == 0x000000, "Member 'FContainerComponent::Items' has a wrong offset!");

// ScriptStruct Altar.LeveledCreatureItem
// 0x0090 (0x0090 - 0x0000)
struct FLeveledCreatureItem final : public FESPDataProperty
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVFormPtr                              Item;                                              // 0x0008(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeveledCreatureItem) == 0x000008, "Wrong alignment on FLeveledCreatureItem");
static_assert(sizeof(FLeveledCreatureItem) == 0x000090, "Wrong size on FLeveledCreatureItem");
static_assert(offsetof(FLeveledCreatureItem, Level) == 0x000000, "Member 'FLeveledCreatureItem::Level' has a wrong offset!");
static_assert(offsetof(FLeveledCreatureItem, Item) == 0x000008, "Member 'FLeveledCreatureItem::Item' has a wrong offset!");
static_assert(offsetof(FLeveledCreatureItem, Count) == 0x000088, "Member 'FLeveledCreatureItem::Count' has a wrong offset!");

// ScriptStruct Altar.PackageLocation
// 0x0210 (0x0210 - 0x0000)
struct FPackageLocation final
{
public:
	EPackageLocationType                          Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Radius;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVFormPtr                              LocationObject;                                    // 0x0008(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVFormPtr                              LocationRef;                                       // 0x0088(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVFormPtr                              LocationCell;                                      // 0x0108(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVFormPtr                              LocationForm;                                      // 0x0188(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EPackageObjectType                            ObjectType;                                        // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPackageLocation) == 0x000008, "Wrong alignment on FPackageLocation");
static_assert(sizeof(FPackageLocation) == 0x000210, "Wrong size on FPackageLocation");
static_assert(offsetof(FPackageLocation, Type) == 0x000000, "Member 'FPackageLocation::Type' has a wrong offset!");
static_assert(offsetof(FPackageLocation, Radius) == 0x000004, "Member 'FPackageLocation::Radius' has a wrong offset!");
static_assert(offsetof(FPackageLocation, LocationObject) == 0x000008, "Member 'FPackageLocation::LocationObject' has a wrong offset!");
static_assert(offsetof(FPackageLocation, LocationRef) == 0x000088, "Member 'FPackageLocation::LocationRef' has a wrong offset!");
static_assert(offsetof(FPackageLocation, LocationCell) == 0x000108, "Member 'FPackageLocation::LocationCell' has a wrong offset!");
static_assert(offsetof(FPackageLocation, LocationForm) == 0x000188, "Member 'FPackageLocation::LocationForm' has a wrong offset!");
static_assert(offsetof(FPackageLocation, ObjectType) == 0x000208, "Member 'FPackageLocation::ObjectType' has a wrong offset!");

// ScriptStruct Altar.PackageTarget
// 0x0110 (0x0110 - 0x0000)
struct FPackageTarget final
{
public:
	EPackageTargetType                            Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVFormPtr                              TargetRef;                                         // 0x0008(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVFormPtr                              TargetObject;                                      // 0x0088(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EPackageObjectType                            TargetObjectType;                                  // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPackageTarget) == 0x000008, "Wrong alignment on FPackageTarget");
static_assert(sizeof(FPackageTarget) == 0x000110, "Wrong size on FPackageTarget");
static_assert(offsetof(FPackageTarget, Type) == 0x000000, "Member 'FPackageTarget::Type' has a wrong offset!");
static_assert(offsetof(FPackageTarget, Value) == 0x000004, "Member 'FPackageTarget::Value' has a wrong offset!");
static_assert(offsetof(FPackageTarget, TargetRef) == 0x000008, "Member 'FPackageTarget::TargetRef' has a wrong offset!");
static_assert(offsetof(FPackageTarget, TargetObject) == 0x000088, "Member 'FPackageTarget::TargetObject' has a wrong offset!");
static_assert(offsetof(FPackageTarget, TargetObjectType) == 0x000108, "Member 'FPackageTarget::TargetObjectType' has a wrong offset!");

// ScriptStruct Altar.PackageSchedule
// 0x0010 (0x0010 - 0x0000)
struct FPackageSchedule final
{
public:
	EPackageScheduleDayOfWeek                     DayOfWeek;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPackageScheduleMonth                         Month;                                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HourOfTheDay;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DayOfTheMonth;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Duration;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackageSchedule) == 0x000004, "Wrong alignment on FPackageSchedule");
static_assert(sizeof(FPackageSchedule) == 0x000010, "Wrong size on FPackageSchedule");
static_assert(offsetof(FPackageSchedule, DayOfWeek) == 0x000000, "Member 'FPackageSchedule::DayOfWeek' has a wrong offset!");
static_assert(offsetof(FPackageSchedule, Month) == 0x000001, "Member 'FPackageSchedule::Month' has a wrong offset!");
static_assert(offsetof(FPackageSchedule, HourOfTheDay) == 0x000004, "Member 'FPackageSchedule::HourOfTheDay' has a wrong offset!");
static_assert(offsetof(FPackageSchedule, DayOfTheMonth) == 0x000008, "Member 'FPackageSchedule::DayOfTheMonth' has a wrong offset!");
static_assert(offsetof(FPackageSchedule, Duration) == 0x00000C, "Member 'FPackageSchedule::Duration' has a wrong offset!");

// ScriptStruct Altar.BlueprintParameters
// 0x0030 (0x0030 - 0x0000)
struct FBlueprintParameters final
{
public:
	float                                         Size;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   Colors;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector3f                              Offset;                                            // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              Orientation;                                       // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueprintParameters) == 0x000008, "Wrong alignment on FBlueprintParameters");
static_assert(sizeof(FBlueprintParameters) == 0x000030, "Wrong size on FBlueprintParameters");
static_assert(offsetof(FBlueprintParameters, Size) == 0x000000, "Member 'FBlueprintParameters::Size' has a wrong offset!");
static_assert(offsetof(FBlueprintParameters, Colors) == 0x000008, "Member 'FBlueprintParameters::Colors' has a wrong offset!");
static_assert(offsetof(FBlueprintParameters, Offset) == 0x000018, "Member 'FBlueprintParameters::Offset' has a wrong offset!");
static_assert(offsetof(FBlueprintParameters, Orientation) == 0x000024, "Member 'FBlueprintParameters::Orientation' has a wrong offset!");

// ScriptStruct Altar.StatusEffectAnimationSettings
// 0x0008 (0x0008 - 0x0000)
struct FStatusEffectAnimationSettings final
{
public:
	float                                         FadeInDuration;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusEffectAnimationSettings) == 0x000004, "Wrong alignment on FStatusEffectAnimationSettings");
static_assert(sizeof(FStatusEffectAnimationSettings) == 0x000008, "Wrong size on FStatusEffectAnimationSettings");
static_assert(offsetof(FStatusEffectAnimationSettings, FadeInDuration) == 0x000000, "Member 'FStatusEffectAnimationSettings::FadeInDuration' has a wrong offset!");
static_assert(offsetof(FStatusEffectAnimationSettings, FadeOutDuration) == 0x000004, "Member 'FStatusEffectAnimationSettings::FadeOutDuration' has a wrong offset!");

// ScriptStruct Altar.TESHeightmapData
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FTESHeightmapData final
{
public:
	float                                         HeightScale;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVerticesHeight;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVerticesHeight;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeightmapSize;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlippedYAxis;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x1F];                                      // 0x0011(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTESHeightmapData) == 0x000008, "Wrong alignment on FTESHeightmapData");
static_assert(sizeof(FTESHeightmapData) == 0x000030, "Wrong size on FTESHeightmapData");
static_assert(offsetof(FTESHeightmapData, HeightScale) == 0x000000, "Member 'FTESHeightmapData::HeightScale' has a wrong offset!");
static_assert(offsetof(FTESHeightmapData, MinVerticesHeight) == 0x000004, "Member 'FTESHeightmapData::MinVerticesHeight' has a wrong offset!");
static_assert(offsetof(FTESHeightmapData, MaxVerticesHeight) == 0x000008, "Member 'FTESHeightmapData::MaxVerticesHeight' has a wrong offset!");
static_assert(offsetof(FTESHeightmapData, HeightmapSize) == 0x00000C, "Member 'FTESHeightmapData::HeightmapSize' has a wrong offset!");
static_assert(offsetof(FTESHeightmapData, bFlippedYAxis) == 0x000010, "Member 'FTESHeightmapData::bFlippedYAxis' has a wrong offset!");

// ScriptStruct Altar.TextureHavokData
// 0x0003 (0x0003 - 0x0000)
struct FTextureHavokData final
{
public:
	uint8                                         MaterialType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Friction;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Restitution;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextureHavokData) == 0x000001, "Wrong alignment on FTextureHavokData");
static_assert(sizeof(FTextureHavokData) == 0x000003, "Wrong size on FTextureHavokData");
static_assert(offsetof(FTextureHavokData, MaterialType) == 0x000000, "Member 'FTextureHavokData::MaterialType' has a wrong offset!");
static_assert(offsetof(FTextureHavokData, Friction) == 0x000001, "Member 'FTextureHavokData::Friction' has a wrong offset!");
static_assert(offsetof(FTextureHavokData, Restitution) == 0x000002, "Member 'FTextureHavokData::Restitution' has a wrong offset!");

// ScriptStruct Altar.LEVELED_OBJECT
// 0x0018 (0x0018 - 0x0000)
struct FLEVELED_OBJECT final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESForm*                               form;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLEVELED_OBJECT) == 0x000008, "Wrong alignment on FLEVELED_OBJECT");
static_assert(sizeof(FLEVELED_OBJECT) == 0x000018, "Wrong size on FLEVELED_OBJECT");
static_assert(offsetof(FLEVELED_OBJECT, Level) == 0x000004, "Member 'FLEVELED_OBJECT::Level' has a wrong offset!");
static_assert(offsetof(FLEVELED_OBJECT, form) == 0x000008, "Member 'FLEVELED_OBJECT::form' has a wrong offset!");
static_assert(offsetof(FLEVELED_OBJECT, Count) == 0x000010, "Member 'FLEVELED_OBJECT::Count' has a wrong offset!");

// ScriptStruct Altar.OBJ_LIGH
// 0x0028 (0x0028 - 0x0000)
struct FOBJ_LIGH final
{
public:
	int32                                         Time;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Radius;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Color;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Flags;                                             // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallOffExponent;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOBJ_LIGH) == 0x000008, "Wrong alignment on FOBJ_LIGH");
static_assert(sizeof(FOBJ_LIGH) == 0x000028, "Wrong size on FOBJ_LIGH");
static_assert(offsetof(FOBJ_LIGH, Time) == 0x000000, "Member 'FOBJ_LIGH::Time' has a wrong offset!");
static_assert(offsetof(FOBJ_LIGH, Radius) == 0x000008, "Member 'FOBJ_LIGH::Radius' has a wrong offset!");
static_assert(offsetof(FOBJ_LIGH, Color) == 0x000010, "Member 'FOBJ_LIGH::Color' has a wrong offset!");
static_assert(offsetof(FOBJ_LIGH, Flags) == 0x000018, "Member 'FOBJ_LIGH::Flags' has a wrong offset!");
static_assert(offsetof(FOBJ_LIGH, FallOffExponent) == 0x000020, "Member 'FOBJ_LIGH::FallOffExponent' has a wrong offset!");
static_assert(offsetof(FOBJ_LIGH, FOV) == 0x000024, "Member 'FOBJ_LIGH::FOV' has a wrong offset!");

// ScriptStruct Altar.TESLoadedLandData
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FTESLoadedLandData final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTESLoadedLandData) == 0x000008, "Wrong alignment on FTESLoadedLandData");
static_assert(sizeof(FTESLoadedLandData) == 0x000090, "Wrong size on FTESLoadedLandData");

// ScriptStruct Altar.Destination
// 0x0080 (0x0080 - 0x0000)
struct FDestination final
{
public:
	struct FVFormPtr                              Target;                                            // 0x0000(0x0080)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestination) == 0x000008, "Wrong alignment on FDestination");
static_assert(sizeof(FDestination) == 0x000080, "Wrong size on FDestination");
static_assert(offsetof(FDestination, Target) == 0x000000, "Member 'FDestination::Target' has a wrong offset!");

// ScriptStruct Altar.OBJ_REFR
// 0x0050 (0x0050 - 0x0000)
struct FOBJ_REFR final
{
public:
	class UTESBoundObject*                        ObjectReference;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x48];                                       // 0x0008(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOBJ_REFR) == 0x000008, "Wrong alignment on FOBJ_REFR");
static_assert(sizeof(FOBJ_REFR) == 0x000050, "Wrong size on FOBJ_REFR");
static_assert(offsetof(FOBJ_REFR, ObjectReference) == 0x000000, "Member 'FOBJ_REFR::ObjectReference' has a wrong offset!");

// ScriptStruct Altar.OBJ_TREE
// 0x0020 (0x0020 - 0x0000)
struct FOBJ_TREE final
{
public:
	float                                         CurveScalar;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumLeafAngle;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumLeafAngle;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BranchDimming;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeafDimming;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CanopyShadowRadius;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RockSpeed;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RustleSpeed;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOBJ_TREE) == 0x000004, "Wrong alignment on FOBJ_TREE");
static_assert(sizeof(FOBJ_TREE) == 0x000020, "Wrong size on FOBJ_TREE");
static_assert(offsetof(FOBJ_TREE, CurveScalar) == 0x000000, "Member 'FOBJ_TREE::CurveScalar' has a wrong offset!");
static_assert(offsetof(FOBJ_TREE, MinimumLeafAngle) == 0x000004, "Member 'FOBJ_TREE::MinimumLeafAngle' has a wrong offset!");
static_assert(offsetof(FOBJ_TREE, MaximumLeafAngle) == 0x000008, "Member 'FOBJ_TREE::MaximumLeafAngle' has a wrong offset!");
static_assert(offsetof(FOBJ_TREE, BranchDimming) == 0x00000C, "Member 'FOBJ_TREE::BranchDimming' has a wrong offset!");
static_assert(offsetof(FOBJ_TREE, LeafDimming) == 0x000010, "Member 'FOBJ_TREE::LeafDimming' has a wrong offset!");
static_assert(offsetof(FOBJ_TREE, CanopyShadowRadius) == 0x000014, "Member 'FOBJ_TREE::CanopyShadowRadius' has a wrong offset!");
static_assert(offsetof(FOBJ_TREE, RockSpeed) == 0x000018, "Member 'FOBJ_TREE::RockSpeed' has a wrong offset!");
static_assert(offsetof(FOBJ_TREE, RustleSpeed) == 0x00001C, "Member 'FOBJ_TREE::RustleSpeed' has a wrong offset!");

// ScriptStruct Altar.PathGridPointData
// 0x0050 (0x0050 - 0x0000)
struct FPathGridPointData final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OriginalCoord;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointCoord;                                        // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumConnections;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Connections;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPathGridPointData) == 0x000008, "Wrong alignment on FPathGridPointData");
static_assert(sizeof(FPathGridPointData) == 0x000050, "Wrong size on FPathGridPointData");
static_assert(offsetof(FPathGridPointData, PointIndex) == 0x000000, "Member 'FPathGridPointData::PointIndex' has a wrong offset!");
static_assert(offsetof(FPathGridPointData, OriginalCoord) == 0x000008, "Member 'FPathGridPointData::OriginalCoord' has a wrong offset!");
static_assert(offsetof(FPathGridPointData, PointCoord) == 0x000020, "Member 'FPathGridPointData::PointCoord' has a wrong offset!");
static_assert(offsetof(FPathGridPointData, NumConnections) == 0x000038, "Member 'FPathGridPointData::NumConnections' has a wrong offset!");
static_assert(offsetof(FPathGridPointData, Connections) == 0x000040, "Member 'FPathGridPointData::Connections' has a wrong offset!");

// ScriptStruct Altar.ModernSettingCommand
// 0x0010 (0x0010 - 0x0000)
struct FModernSettingCommand final
{
public:
	class FString                                 ConsoleCommand;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernSettingCommand) == 0x000008, "Wrong alignment on FModernSettingCommand");
static_assert(sizeof(FModernSettingCommand) == 0x000010, "Wrong size on FModernSettingCommand");
static_assert(offsetof(FModernSettingCommand, ConsoleCommand) == 0x000000, "Member 'FModernSettingCommand::ConsoleCommand' has a wrong offset!");

// ScriptStruct Altar.ModernSettingSingleCommand
// 0x0030 (0x0030 - 0x0000)
struct FModernSettingSingleCommand final
{
public:
	class FText                                   Label;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FModernSettingCommand                  Command;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bRequireExtraPlatformFlags;                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlatformFlag;                                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernSettingSingleCommand) == 0x000008, "Wrong alignment on FModernSettingSingleCommand");
static_assert(sizeof(FModernSettingSingleCommand) == 0x000030, "Wrong size on FModernSettingSingleCommand");
static_assert(offsetof(FModernSettingSingleCommand, Label) == 0x000000, "Member 'FModernSettingSingleCommand::Label' has a wrong offset!");
static_assert(offsetof(FModernSettingSingleCommand, Command) == 0x000018, "Member 'FModernSettingSingleCommand::Command' has a wrong offset!");
static_assert(offsetof(FModernSettingSingleCommand, bRequireExtraPlatformFlags) == 0x000028, "Member 'FModernSettingSingleCommand::bRequireExtraPlatformFlags' has a wrong offset!");
static_assert(offsetof(FModernSettingSingleCommand, PlatformFlag) == 0x00002C, "Member 'FModernSettingSingleCommand::PlatformFlag' has a wrong offset!");

// ScriptStruct Altar.ModernSettingComboBoxProperties
// 0x0018 (0x0018 - 0x0000)
struct FModernSettingComboBoxProperties final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultIndex;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FModernSettingSingleCommand>    Entries;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernSettingComboBoxProperties) == 0x000008, "Wrong alignment on FModernSettingComboBoxProperties");
static_assert(sizeof(FModernSettingComboBoxProperties) == 0x000018, "Wrong size on FModernSettingComboBoxProperties");
static_assert(offsetof(FModernSettingComboBoxProperties, Index) == 0x000000, "Member 'FModernSettingComboBoxProperties::Index' has a wrong offset!");
static_assert(offsetof(FModernSettingComboBoxProperties, DefaultIndex) == 0x000004, "Member 'FModernSettingComboBoxProperties::DefaultIndex' has a wrong offset!");
static_assert(offsetof(FModernSettingComboBoxProperties, Entries) == 0x000008, "Member 'FModernSettingComboBoxProperties::Entries' has a wrong offset!");

// ScriptStruct Altar.IntergridConnection
// 0x0038 (0x0038 - 0x0000)
struct FIntergridConnection final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OriginalCoord;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointCoord;                                        // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntergridConnection) == 0x000008, "Wrong alignment on FIntergridConnection");
static_assert(sizeof(FIntergridConnection) == 0x000038, "Wrong size on FIntergridConnection");
static_assert(offsetof(FIntergridConnection, PointIndex) == 0x000000, "Member 'FIntergridConnection::PointIndex' has a wrong offset!");
static_assert(offsetof(FIntergridConnection, OriginalCoord) == 0x000008, "Member 'FIntergridConnection::OriginalCoord' has a wrong offset!");
static_assert(offsetof(FIntergridConnection, PointCoord) == 0x000020, "Member 'FIntergridConnection::PointCoord' has a wrong offset!");

// ScriptStruct Altar.PathGridPointDataArray
// 0x0010 (0x0010 - 0x0000)
struct FPathGridPointDataArray final
{
public:
	TArray<struct FPathGridPointData>             Array;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPathGridPointDataArray) == 0x000008, "Wrong alignment on FPathGridPointDataArray");
static_assert(sizeof(FPathGridPointDataArray) == 0x000010, "Wrong size on FPathGridPointDataArray");
static_assert(offsetof(FPathGridPointDataArray, Array) == 0x000000, "Member 'FPathGridPointDataArray::Array' has a wrong offset!");

// ScriptStruct Altar.RaceData
// 0x0010 (0x0010 - 0x0000)
struct FRaceData final
{
public:
	TArray<float>                                 Height;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRaceData) == 0x000008, "Wrong alignment on FRaceData");
static_assert(sizeof(FRaceData) == 0x000010, "Wrong size on FRaceData");
static_assert(offsetof(FRaceData, Height) == 0x000000, "Member 'FRaceData::Height' has a wrong offset!");

// ScriptStruct Altar.VRaceEyeParameterPair
// 0x000C (0x000C - 0x0000)
struct FVRaceEyeParameterPair final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVRaceEyeParameterPair) == 0x000004, "Wrong alignment on FVRaceEyeParameterPair");
static_assert(sizeof(FVRaceEyeParameterPair) == 0x00000C, "Wrong size on FVRaceEyeParameterPair");
static_assert(offsetof(FVRaceEyeParameterPair, Name) == 0x000000, "Member 'FVRaceEyeParameterPair::Name' has a wrong offset!");
static_assert(offsetof(FVRaceEyeParameterPair, Value) == 0x000008, "Member 'FVRaceEyeParameterPair::Value' has a wrong offset!");

// ScriptStruct Altar.Modern_AltarMapIconDesignTableRow
// 0x0DA8 (0x0DB0 - 0x0008)
struct FModern_AltarMapIconDesignTableRow final : public FTableRowBase
{
public:
	ELegacyMapMenuIcon                            EnumKey;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            IconDesign;                                        // 0x0010(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            UndiscoverIconDesign;                              // 0x00E0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   FilterTooltip;                                     // 0x01B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FButtonStyle                           EnableFilterStyle;                                 // 0x01D0(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FButtonStyle                           DisableFilterStyle;                                // 0x05C0(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bDisplayWhenEmpty;                                 // 0x09B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B1[0xF];                                      // 0x09B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FButtonStyle                           EmptyFilterStyle;                                  // 0x09C0(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModern_AltarMapIconDesignTableRow) == 0x000010, "Wrong alignment on FModern_AltarMapIconDesignTableRow");
static_assert(sizeof(FModern_AltarMapIconDesignTableRow) == 0x000DB0, "Wrong size on FModern_AltarMapIconDesignTableRow");
static_assert(offsetof(FModern_AltarMapIconDesignTableRow, EnumKey) == 0x000008, "Member 'FModern_AltarMapIconDesignTableRow::EnumKey' has a wrong offset!");
static_assert(offsetof(FModern_AltarMapIconDesignTableRow, IconDesign) == 0x000010, "Member 'FModern_AltarMapIconDesignTableRow::IconDesign' has a wrong offset!");
static_assert(offsetof(FModern_AltarMapIconDesignTableRow, UndiscoverIconDesign) == 0x0000E0, "Member 'FModern_AltarMapIconDesignTableRow::UndiscoverIconDesign' has a wrong offset!");
static_assert(offsetof(FModern_AltarMapIconDesignTableRow, FilterTooltip) == 0x0001B0, "Member 'FModern_AltarMapIconDesignTableRow::FilterTooltip' has a wrong offset!");
static_assert(offsetof(FModern_AltarMapIconDesignTableRow, EnableFilterStyle) == 0x0001D0, "Member 'FModern_AltarMapIconDesignTableRow::EnableFilterStyle' has a wrong offset!");
static_assert(offsetof(FModern_AltarMapIconDesignTableRow, DisableFilterStyle) == 0x0005C0, "Member 'FModern_AltarMapIconDesignTableRow::DisableFilterStyle' has a wrong offset!");
static_assert(offsetof(FModern_AltarMapIconDesignTableRow, bDisplayWhenEmpty) == 0x0009B0, "Member 'FModern_AltarMapIconDesignTableRow::bDisplayWhenEmpty' has a wrong offset!");
static_assert(offsetof(FModern_AltarMapIconDesignTableRow, EmptyFilterStyle) == 0x0009C0, "Member 'FModern_AltarMapIconDesignTableRow::EmptyFilterStyle' has a wrong offset!");

// ScriptStruct Altar.VRaceEyeParameters
// 0x0038 (0x0038 - 0x0000)
struct FVRaceEyeParameters final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      OverrideMaterial;                                  // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVRaceEyeParameterPair>         EyeParameters;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVRaceEyeParameters) == 0x000008, "Wrong alignment on FVRaceEyeParameters");
static_assert(sizeof(FVRaceEyeParameters) == 0x000038, "Wrong size on FVRaceEyeParameters");
static_assert(offsetof(FVRaceEyeParameters, OverrideMaterial) == 0x000000, "Member 'FVRaceEyeParameters::OverrideMaterial' has a wrong offset!");
static_assert(offsetof(FVRaceEyeParameters, EyeParameters) == 0x000028, "Member 'FVRaceEyeParameters::EyeParameters' has a wrong offset!");

// ScriptStruct Altar.RaceBody
// 0x00F8 (0x00F8 - 0x0000)
struct FRaceBody final
{
public:
	class UDataTable*                             Senescence;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EVSenescenceModifiers, struct FVRaceEyeParameters> ModifierEyes;                            // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           FullBodySkeletalMesh;                              // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBodyProperties                        BodyProperties;                                    // 0x0080(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVCharacterPhenotypePreset> PhenotypePreset;                                // 0x00D0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRaceBody) == 0x000008, "Wrong alignment on FRaceBody");
static_assert(sizeof(FRaceBody) == 0x0000F8, "Wrong size on FRaceBody");
static_assert(offsetof(FRaceBody, Senescence) == 0x000000, "Member 'FRaceBody::Senescence' has a wrong offset!");
static_assert(offsetof(FRaceBody, ModifierEyes) == 0x000008, "Member 'FRaceBody::ModifierEyes' has a wrong offset!");
static_assert(offsetof(FRaceBody, FullBodySkeletalMesh) == 0x000058, "Member 'FRaceBody::FullBodySkeletalMesh' has a wrong offset!");
static_assert(offsetof(FRaceBody, BodyProperties) == 0x000080, "Member 'FRaceBody::BodyProperties' has a wrong offset!");
static_assert(offsetof(FRaceBody, PhenotypePreset) == 0x0000D0, "Member 'FRaceBody::PhenotypePreset' has a wrong offset!");

// ScriptStruct Altar.TESRegionPointList
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FTESRegionPointList final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTESRegionPointList) == 0x000008, "Wrong alignment on FTESRegionPointList");
static_assert(sizeof(FTESRegionPointList) == 0x000048, "Wrong size on FTESRegionPointList");

// ScriptStruct Altar.CreatureOctopedBoneAnimationData
// 0x006C (0x006C - 0x0000)
struct FCreatureOctopedBoneAnimationData final
{
public:
	class FName                                   Leg1Bone;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Leg1BlendDepth;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Leg2Bone;                                          // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Leg2BlendDepth;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Leg3Bone;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Leg3BlendDepth;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Leg4Bone;                                          // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Leg4BlendDepth;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Leg5Bone;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Leg5BlendDepth;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Leg6Bone;                                          // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Leg6BlendDepth;                                    // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Leg7Bone;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Leg7BlendDepth;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Leg8Bone;                                          // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Leg8BlendDepth;                                    // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpperBone;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperBlendDepth;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreatureOctopedBoneAnimationData) == 0x000004, "Wrong alignment on FCreatureOctopedBoneAnimationData");
static_assert(sizeof(FCreatureOctopedBoneAnimationData) == 0x00006C, "Wrong size on FCreatureOctopedBoneAnimationData");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg1Bone) == 0x000000, "Member 'FCreatureOctopedBoneAnimationData::Leg1Bone' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg1BlendDepth) == 0x000008, "Member 'FCreatureOctopedBoneAnimationData::Leg1BlendDepth' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg2Bone) == 0x00000C, "Member 'FCreatureOctopedBoneAnimationData::Leg2Bone' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg2BlendDepth) == 0x000014, "Member 'FCreatureOctopedBoneAnimationData::Leg2BlendDepth' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg3Bone) == 0x000018, "Member 'FCreatureOctopedBoneAnimationData::Leg3Bone' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg3BlendDepth) == 0x000020, "Member 'FCreatureOctopedBoneAnimationData::Leg3BlendDepth' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg4Bone) == 0x000024, "Member 'FCreatureOctopedBoneAnimationData::Leg4Bone' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg4BlendDepth) == 0x00002C, "Member 'FCreatureOctopedBoneAnimationData::Leg4BlendDepth' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg5Bone) == 0x000030, "Member 'FCreatureOctopedBoneAnimationData::Leg5Bone' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg5BlendDepth) == 0x000038, "Member 'FCreatureOctopedBoneAnimationData::Leg5BlendDepth' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg6Bone) == 0x00003C, "Member 'FCreatureOctopedBoneAnimationData::Leg6Bone' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg6BlendDepth) == 0x000044, "Member 'FCreatureOctopedBoneAnimationData::Leg6BlendDepth' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg7Bone) == 0x000048, "Member 'FCreatureOctopedBoneAnimationData::Leg7Bone' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg7BlendDepth) == 0x000050, "Member 'FCreatureOctopedBoneAnimationData::Leg7BlendDepth' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg8Bone) == 0x000054, "Member 'FCreatureOctopedBoneAnimationData::Leg8Bone' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, Leg8BlendDepth) == 0x00005C, "Member 'FCreatureOctopedBoneAnimationData::Leg8BlendDepth' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, UpperBone) == 0x000060, "Member 'FCreatureOctopedBoneAnimationData::UpperBone' has a wrong offset!");
static_assert(offsetof(FCreatureOctopedBoneAnimationData, UpperBlendDepth) == 0x000068, "Member 'FCreatureOctopedBoneAnimationData::UpperBlendDepth' has a wrong offset!");

// ScriptStruct Altar.TESSoundData
// 0x0018 (0x0018 - 0x0000)
struct FTESSoundData final
{
public:
	uint8                                         MinAttenuationDistance;                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxAttenuationDistance;                            // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pitch;                                             // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Padding;                                           // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Flags;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attenuation;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeConstraints;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTESSoundData) == 0x000008, "Wrong alignment on FTESSoundData");
static_assert(sizeof(FTESSoundData) == 0x000018, "Wrong size on FTESSoundData");
static_assert(offsetof(FTESSoundData, MinAttenuationDistance) == 0x000000, "Member 'FTESSoundData::MinAttenuationDistance' has a wrong offset!");
static_assert(offsetof(FTESSoundData, MaxAttenuationDistance) == 0x000001, "Member 'FTESSoundData::MaxAttenuationDistance' has a wrong offset!");
static_assert(offsetof(FTESSoundData, Pitch) == 0x000002, "Member 'FTESSoundData::Pitch' has a wrong offset!");
static_assert(offsetof(FTESSoundData, Padding) == 0x000003, "Member 'FTESSoundData::Padding' has a wrong offset!");
static_assert(offsetof(FTESSoundData, Flags) == 0x000008, "Member 'FTESSoundData::Flags' has a wrong offset!");
static_assert(offsetof(FTESSoundData, Attenuation) == 0x000010, "Member 'FTESSoundData::Attenuation' has a wrong offset!");
static_assert(offsetof(FTESSoundData, TimeConstraints) == 0x000014, "Member 'FTESSoundData::TimeConstraints' has a wrong offset!");

// ScriptStruct Altar.TESSoundDataConversion
// 0x0018 (0x0020 - 0x0008)
struct FTESSoundDataConversion final : public FTableRowBase
{
public:
	float                                         MinAttenuationDistanceConversionFactor;            // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAttenuationDistanceConversionFactor;            // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchConversionFactor;                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaddingConversionFactor;                           // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationConversionFactor;                       // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeConstraintsConversionFactor;                   // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTESSoundDataConversion) == 0x000008, "Wrong alignment on FTESSoundDataConversion");
static_assert(sizeof(FTESSoundDataConversion) == 0x000020, "Wrong size on FTESSoundDataConversion");
static_assert(offsetof(FTESSoundDataConversion, MinAttenuationDistanceConversionFactor) == 0x000008, "Member 'FTESSoundDataConversion::MinAttenuationDistanceConversionFactor' has a wrong offset!");
static_assert(offsetof(FTESSoundDataConversion, MaxAttenuationDistanceConversionFactor) == 0x00000C, "Member 'FTESSoundDataConversion::MaxAttenuationDistanceConversionFactor' has a wrong offset!");
static_assert(offsetof(FTESSoundDataConversion, PitchConversionFactor) == 0x000010, "Member 'FTESSoundDataConversion::PitchConversionFactor' has a wrong offset!");
static_assert(offsetof(FTESSoundDataConversion, PaddingConversionFactor) == 0x000014, "Member 'FTESSoundDataConversion::PaddingConversionFactor' has a wrong offset!");
static_assert(offsetof(FTESSoundDataConversion, AttenuationConversionFactor) == 0x000018, "Member 'FTESSoundDataConversion::AttenuationConversionFactor' has a wrong offset!");
static_assert(offsetof(FTESSoundDataConversion, TimeConstraintsConversionFactor) == 0x00001C, "Member 'FTESSoundDataConversion::TimeConstraintsConversionFactor' has a wrong offset!");

// ScriptStruct Altar.AttackMovesetItem
// 0x0010 (0x0018 - 0x0008)
struct FAttackMovesetItem final : public FTableRowBase
{
public:
	class UAnimSequence*                          AnimationSequence;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackMovesetItem) == 0x000008, "Wrong alignment on FAttackMovesetItem");
static_assert(sizeof(FAttackMovesetItem) == 0x000018, "Wrong size on FAttackMovesetItem");
static_assert(offsetof(FAttackMovesetItem, AnimationSequence) == 0x000008, "Member 'FAttackMovesetItem::AnimationSequence' has a wrong offset!");
static_assert(offsetof(FAttackMovesetItem, SpeedModifier) == 0x000010, "Member 'FAttackMovesetItem::SpeedModifier' has a wrong offset!");

// ScriptStruct Altar.AnimCharacterAttackStartInfo
// 0x00E8 (0x00E8 - 0x0000)
struct FAnimCharacterAttackStartInfo final
{
public:
	struct FHitResult                             PreliminaryTargetRaycast;                          // 0x0000(0x00E8)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimCharacterAttackStartInfo) == 0x000008, "Wrong alignment on FAnimCharacterAttackStartInfo");
static_assert(sizeof(FAnimCharacterAttackStartInfo) == 0x0000E8, "Wrong size on FAnimCharacterAttackStartInfo");
static_assert(offsetof(FAnimCharacterAttackStartInfo, PreliminaryTargetRaycast) == 0x000000, "Member 'FAnimCharacterAttackStartInfo::PreliminaryTargetRaycast' has a wrong offset!");

// ScriptStruct Altar.VPerceptionState
// 0x0002 (0x0002 - 0x0000)
struct FVPerceptionState final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVPerceptionState) == 0x000001, "Wrong alignment on FVPerceptionState");
static_assert(sizeof(FVPerceptionState) == 0x000002, "Wrong size on FVPerceptionState");

// ScriptStruct Altar.MeleeAttackDamageEvent
// 0x0038 (0x0048 - 0x0010)
struct FMeleeAttackDamageEvent final : public FDamageEvent
{
public:
	struct FVector                                IncidencePoint;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    HitPrimitive;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeAttackDamageEvent) == 0x000008, "Wrong alignment on FMeleeAttackDamageEvent");
static_assert(sizeof(FMeleeAttackDamageEvent) == 0x000048, "Wrong size on FMeleeAttackDamageEvent");
static_assert(offsetof(FMeleeAttackDamageEvent, IncidencePoint) == 0x000010, "Member 'FMeleeAttackDamageEvent::IncidencePoint' has a wrong offset!");
static_assert(offsetof(FMeleeAttackDamageEvent, ImpactPoint) == 0x000028, "Member 'FMeleeAttackDamageEvent::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FMeleeAttackDamageEvent, HitPrimitive) == 0x000040, "Member 'FMeleeAttackDamageEvent::HitPrimitive' has a wrong offset!");

// ScriptStruct Altar.TESTextureList
// 0x0001 (0x0001 - 0x0000)
struct FTESTextureList final
{
public:
	uint8                                         TextureCount;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTESTextureList) == 0x000001, "Wrong alignment on FTESTextureList");
static_assert(sizeof(FTESTextureList) == 0x000001, "Wrong size on FTESTextureList");
static_assert(offsetof(FTESTextureList, TextureCount) == 0x000000, "Member 'FTESTextureList::TextureCount' has a wrong offset!");

// ScriptStruct Altar.VResponseKey
// 0x0038 (0x0038 - 0x0000)
struct FVResponseKey final
{
public:
	ECharacterSex                                 Sex;                                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTESRace>                Race;                                              // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVVoiceType                                   VoiceType;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVResponseKey) == 0x000008, "Wrong alignment on FVResponseKey");
static_assert(sizeof(FVResponseKey) == 0x000038, "Wrong size on FVResponseKey");
static_assert(offsetof(FVResponseKey, Sex) == 0x000000, "Member 'FVResponseKey::Sex' has a wrong offset!");
static_assert(offsetof(FVResponseKey, Race) == 0x000008, "Member 'FVResponseKey::Race' has a wrong offset!");
static_assert(offsetof(FVResponseKey, VoiceType) == 0x000030, "Member 'FVResponseKey::VoiceType' has a wrong offset!");

// ScriptStruct Altar.TESResponse
// 0x0130 (0x0130 - 0x0000)
struct FTESResponse final
{
public:
	int32                                         ResponseID;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Text;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int64, TSoftObjectPtr<class USoundWave>> Audios;                                            // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FVResponseKey, TSoftObjectPtr<class UAkAudioEvent>> AkAudioEvents;                   // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FVResponseKey, TSoftObjectPtr<class UAnimSequence>> Animations;                      // 0x00B8(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           Animation;                                         // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTESResponse) == 0x000008, "Wrong alignment on FTESResponse");
static_assert(sizeof(FTESResponse) == 0x000130, "Wrong size on FTESResponse");
static_assert(offsetof(FTESResponse, ResponseID) == 0x000000, "Member 'FTESResponse::ResponseID' has a wrong offset!");
static_assert(offsetof(FTESResponse, Text) == 0x000008, "Member 'FTESResponse::Text' has a wrong offset!");
static_assert(offsetof(FTESResponse, Audios) == 0x000018, "Member 'FTESResponse::Audios' has a wrong offset!");
static_assert(offsetof(FTESResponse, AkAudioEvents) == 0x000068, "Member 'FTESResponse::AkAudioEvents' has a wrong offset!");
static_assert(offsetof(FTESResponse, Animations) == 0x0000B8, "Member 'FTESResponse::Animations' has a wrong offset!");
static_assert(offsetof(FTESResponse, Animation) == 0x000108, "Member 'FTESResponse::Animation' has a wrong offset!");

// ScriptStruct Altar.TopicInfoData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FTopicInfoData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTopicInfoData) == 0x000004, "Wrong alignment on FTopicInfoData");
static_assert(sizeof(FTopicInfoData) == 0x000008, "Wrong size on FTopicInfoData");

// ScriptStruct Altar.OriginalVideoOption
// 0x0028 (0x0028 - 0x0000)
struct FOriginalVideoOption final
{
public:
	class FText                                   Label;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FString>                         Commands;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOriginalVideoOption) == 0x000008, "Wrong alignment on FOriginalVideoOption");
static_assert(sizeof(FOriginalVideoOption) == 0x000028, "Wrong size on FOriginalVideoOption");
static_assert(offsetof(FOriginalVideoOption, Label) == 0x000000, "Member 'FOriginalVideoOption::Label' has a wrong offset!");
static_assert(offsetof(FOriginalVideoOption, Commands) == 0x000018, "Member 'FOriginalVideoOption::Commands' has a wrong offset!");

// ScriptStruct Altar.OriginalVideoTableRow
// 0x0038 (0x0040 - 0x0008)
struct FOriginalVideoTableRow final : public FTableRowBase
{
public:
	class FText                                   Label;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UVOriginalVideoSettingWidget> WidgetClass;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOriginalVideoOption>           OptionValues;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ExtremalValue;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOriginalVideoTableRow) == 0x000008, "Wrong alignment on FOriginalVideoTableRow");
static_assert(sizeof(FOriginalVideoTableRow) == 0x000040, "Wrong size on FOriginalVideoTableRow");
static_assert(offsetof(FOriginalVideoTableRow, Label) == 0x000008, "Member 'FOriginalVideoTableRow::Label' has a wrong offset!");
static_assert(offsetof(FOriginalVideoTableRow, WidgetClass) == 0x000020, "Member 'FOriginalVideoTableRow::WidgetClass' has a wrong offset!");
static_assert(offsetof(FOriginalVideoTableRow, OptionValues) == 0x000028, "Member 'FOriginalVideoTableRow::OptionValues' has a wrong offset!");
static_assert(offsetof(FOriginalVideoTableRow, ExtremalValue) == 0x000038, "Member 'FOriginalVideoTableRow::ExtremalValue' has a wrong offset!");

// ScriptStruct Altar.WaterShaderData
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FWaterShaderData final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaterShaderData) == 0x000008, "Wrong alignment on FWaterShaderData");
static_assert(sizeof(FWaterShaderData) == 0x000078, "Wrong size on FWaterShaderData");

// ScriptStruct Altar.WeatherEntry
// 0x0010 (0x0010 - 0x0000)
struct FWeatherEntry final
{
public:
	class UTESWeather*                            Weather;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chance;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeatherEntry) == 0x000008, "Wrong alignment on FWeatherEntry");
static_assert(sizeof(FWeatherEntry) == 0x000010, "Wrong size on FWeatherEntry");
static_assert(offsetof(FWeatherEntry, Weather) == 0x000000, "Member 'FWeatherEntry::Weather' has a wrong offset!");
static_assert(offsetof(FWeatherEntry, Chance) == 0x000008, "Member 'FWeatherEntry::Chance' has a wrong offset!");

// ScriptStruct Altar.TESWeatherList
// 0x0010 (0x0010 - 0x0000)
struct FTESWeatherList final
{
public:
	TArray<struct FWeatherEntry>                  WeatherEntries;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTESWeatherList) == 0x000008, "Wrong alignment on FTESWeatherList");
static_assert(sizeof(FTESWeatherList) == 0x000010, "Wrong size on FTESWeatherList");
static_assert(offsetof(FTESWeatherList, WeatherEntries) == 0x000000, "Member 'FTESWeatherList::WeatherEntries' has a wrong offset!");

// ScriptStruct Altar.WorldMapData
// 0x0020 (0x0020 - 0x0000)
struct FWorldMapData final
{
public:
	int64                                         UsableWidth;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         UsableHeight;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NWCellX;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NWCellY;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SECellX;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SECellY;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldMapData) == 0x000008, "Wrong alignment on FWorldMapData");
static_assert(sizeof(FWorldMapData) == 0x000020, "Wrong size on FWorldMapData");
static_assert(offsetof(FWorldMapData, UsableWidth) == 0x000000, "Member 'FWorldMapData::UsableWidth' has a wrong offset!");
static_assert(offsetof(FWorldMapData, UsableHeight) == 0x000008, "Member 'FWorldMapData::UsableHeight' has a wrong offset!");
static_assert(offsetof(FWorldMapData, NWCellX) == 0x000010, "Member 'FWorldMapData::NWCellX' has a wrong offset!");
static_assert(offsetof(FWorldMapData, NWCellY) == 0x000014, "Member 'FWorldMapData::NWCellY' has a wrong offset!");
static_assert(offsetof(FWorldMapData, SECellX) == 0x000018, "Member 'FWorldMapData::SECellX' has a wrong offset!");
static_assert(offsetof(FWorldMapData, SECellY) == 0x00001C, "Member 'FWorldMapData::SECellY' has a wrong offset!");

// ScriptStruct Altar.WeatherSlice
// 0x0018 (0x0018 - 0x0000)
struct FWeatherSlice final
{
public:
	class UAkAudioEvent*                          PlayEvent;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopEvent;                                         // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeatherSlice) == 0x000008, "Wrong alignment on FWeatherSlice");
static_assert(sizeof(FWeatherSlice) == 0x000018, "Wrong size on FWeatherSlice");
static_assert(offsetof(FWeatherSlice, PlayEvent) == 0x000000, "Member 'FWeatherSlice::PlayEvent' has a wrong offset!");
static_assert(offsetof(FWeatherSlice, StopEvent) == 0x000008, "Member 'FWeatherSlice::StopEvent' has a wrong offset!");

// ScriptStruct Altar.WorldMapLandscapeSettings
// 0x0024 (0x0024 - 0x0000)
struct FWorldMapLandscapeSettings final
{
public:
	float                                         TESToUnrealWorldScaleFactor;                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TESCellMetricSize;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TESCellQuadsCount;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TESCellQuadMetricSize;                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TESCellsPerComponent;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionsPerComponent;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuadsPerSection;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldPartitionGridSize;                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlipYAxis;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateLayers;                                   // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugCells;                                       // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorldMapLandscapeSettings) == 0x000004, "Wrong alignment on FWorldMapLandscapeSettings");
static_assert(sizeof(FWorldMapLandscapeSettings) == 0x000024, "Wrong size on FWorldMapLandscapeSettings");
static_assert(offsetof(FWorldMapLandscapeSettings, TESToUnrealWorldScaleFactor) == 0x000000, "Member 'FWorldMapLandscapeSettings::TESToUnrealWorldScaleFactor' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeSettings, TESCellMetricSize) == 0x000004, "Member 'FWorldMapLandscapeSettings::TESCellMetricSize' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeSettings, TESCellQuadsCount) == 0x000008, "Member 'FWorldMapLandscapeSettings::TESCellQuadsCount' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeSettings, TESCellQuadMetricSize) == 0x00000C, "Member 'FWorldMapLandscapeSettings::TESCellQuadMetricSize' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeSettings, TESCellsPerComponent) == 0x000010, "Member 'FWorldMapLandscapeSettings::TESCellsPerComponent' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeSettings, SectionsPerComponent) == 0x000014, "Member 'FWorldMapLandscapeSettings::SectionsPerComponent' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeSettings, QuadsPerSection) == 0x000018, "Member 'FWorldMapLandscapeSettings::QuadsPerSection' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeSettings, WorldPartitionGridSize) == 0x00001C, "Member 'FWorldMapLandscapeSettings::WorldPartitionGridSize' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeSettings, bFlipYAxis) == 0x000020, "Member 'FWorldMapLandscapeSettings::bFlipYAxis' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeSettings, bGenerateLayers) == 0x000021, "Member 'FWorldMapLandscapeSettings::bGenerateLayers' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeSettings, bDebugCells) == 0x000022, "Member 'FWorldMapLandscapeSettings::bDebugCells' has a wrong offset!");

// ScriptStruct Altar.WorldMapLandscapeInfo
// 0x0060 (0x0060 - 0x0000)
struct FWorldMapLandscapeInfo final
{
public:
	struct FIntPoint                              TESWorldspaceCellsCount;                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              TESWorldspaceQuadsCount;                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TESWorldspaceMetricSize;                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              LandscapeComponentsCount;                          // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              LandscapeSectionsCount;                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              LandscapeQuadsCount;                               // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LandscapeMetricSize;                               // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LandscapeQuadMetricSize;                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLandscapeMetricHeight;                          // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLandscapeMetricHeight;                          // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldMapLandscapeInfo) == 0x000008, "Wrong alignment on FWorldMapLandscapeInfo");
static_assert(sizeof(FWorldMapLandscapeInfo) == 0x000060, "Wrong size on FWorldMapLandscapeInfo");
static_assert(offsetof(FWorldMapLandscapeInfo, TESWorldspaceCellsCount) == 0x000000, "Member 'FWorldMapLandscapeInfo::TESWorldspaceCellsCount' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeInfo, TESWorldspaceQuadsCount) == 0x000008, "Member 'FWorldMapLandscapeInfo::TESWorldspaceQuadsCount' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeInfo, TESWorldspaceMetricSize) == 0x000010, "Member 'FWorldMapLandscapeInfo::TESWorldspaceMetricSize' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeInfo, LandscapeComponentsCount) == 0x000020, "Member 'FWorldMapLandscapeInfo::LandscapeComponentsCount' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeInfo, LandscapeSectionsCount) == 0x000028, "Member 'FWorldMapLandscapeInfo::LandscapeSectionsCount' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeInfo, LandscapeQuadsCount) == 0x000030, "Member 'FWorldMapLandscapeInfo::LandscapeQuadsCount' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeInfo, LandscapeMetricSize) == 0x000038, "Member 'FWorldMapLandscapeInfo::LandscapeMetricSize' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeInfo, LandscapeQuadMetricSize) == 0x000048, "Member 'FWorldMapLandscapeInfo::LandscapeQuadMetricSize' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeInfo, MinLandscapeMetricHeight) == 0x000058, "Member 'FWorldMapLandscapeInfo::MinLandscapeMetricHeight' has a wrong offset!");
static_assert(offsetof(FWorldMapLandscapeInfo, MaxLandscapeMetricHeight) == 0x00005C, "Member 'FWorldMapLandscapeInfo::MaxLandscapeMetricHeight' has a wrong offset!");

// ScriptStruct Altar.TexturingMapFlags
// 0x0002 (0x0002 - 0x0000)
struct alignas(0x02) FTexturingMapFlags final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTexturingMapFlags) == 0x000002, "Wrong alignment on FTexturingMapFlags");
static_assert(sizeof(FTexturingMapFlags) == 0x000002, "Wrong size on FTexturingMapFlags");

// ScriptStruct Altar.VActiveEffectsData
// 0x0038 (0x0038 - 0x0000)
struct FVActiveEffectsData final
{
public:
	class FText                                   EffectName;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   AdditionalEffectName;                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingDuration;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVActiveEffectsData) == 0x000008, "Wrong alignment on FVActiveEffectsData");
static_assert(sizeof(FVActiveEffectsData) == 0x000038, "Wrong size on FVActiveEffectsData");
static_assert(offsetof(FVActiveEffectsData, EffectName) == 0x000000, "Member 'FVActiveEffectsData::EffectName' has a wrong offset!");
static_assert(offsetof(FVActiveEffectsData, AdditionalEffectName) == 0x000018, "Member 'FVActiveEffectsData::AdditionalEffectName' has a wrong offset!");
static_assert(offsetof(FVActiveEffectsData, Magnitude) == 0x000030, "Member 'FVActiveEffectsData::Magnitude' has a wrong offset!");
static_assert(offsetof(FVActiveEffectsData, RemainingDuration) == 0x000034, "Member 'FVActiveEffectsData::RemainingDuration' has a wrong offset!");

// ScriptStruct Altar.EquipmentSocketInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FEquipmentSocketInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEquipmentSocketInfo) == 0x000004, "Wrong alignment on FEquipmentSocketInfo");
static_assert(sizeof(FEquipmentSocketInfo) == 0x000008, "Wrong size on FEquipmentSocketInfo");

// ScriptStruct Altar.SocketEquipmentStatus
// 0x0020 (0x0020 - 0x0000)
struct FSocketEquipmentStatus final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 EquippedItem;                                      // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSocketEquipmentStatus) == 0x000008, "Wrong alignment on FSocketEquipmentStatus");
static_assert(sizeof(FSocketEquipmentStatus) == 0x000020, "Wrong size on FSocketEquipmentStatus");
static_assert(offsetof(FSocketEquipmentStatus, EquippedItem) == 0x000018, "Member 'FSocketEquipmentStatus::EquippedItem' has a wrong offset!");

// ScriptStruct Altar.ArrowsSocketStatus
// 0x0020 (0x0020 - 0x0000)
struct FArrowsSocketStatus final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 EquippedArrow;                                     // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrowsSocketStatus) == 0x000008, "Wrong alignment on FArrowsSocketStatus");
static_assert(sizeof(FArrowsSocketStatus) == 0x000020, "Wrong size on FArrowsSocketStatus");
static_assert(offsetof(FArrowsSocketStatus, EquippedArrow) == 0x000018, "Member 'FArrowsSocketStatus::EquippedArrow' has a wrong offset!");

// ScriptStruct Altar.VActorValue
// 0x0008 (0x0008 - 0x0000)
struct FVActorValue final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModifiedValue;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVActorValue) == 0x000004, "Wrong alignment on FVActorValue");
static_assert(sizeof(FVActorValue) == 0x000008, "Wrong size on FVActorValue");
static_assert(offsetof(FVActorValue, BaseValue) == 0x000000, "Member 'FVActorValue::BaseValue' has a wrong offset!");
static_assert(offsetof(FVActorValue, ModifiedValue) == 0x000004, "Member 'FVActorValue::ModifiedValue' has a wrong offset!");

// ScriptStruct Altar.LegacyAddedEffectItemProperties
// 0x0060 (0x0060 - 0x0000)
struct FLegacyAddedEffectItemProperties final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   StringDebug;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   AddedEffectstring;                                 // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         EffectValue;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectTime;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TargetString;                                      // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Image;                                             // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyAddedEffectItemProperties) == 0x000008, "Wrong alignment on FLegacyAddedEffectItemProperties");
static_assert(sizeof(FLegacyAddedEffectItemProperties) == 0x000060, "Wrong size on FLegacyAddedEffectItemProperties");
static_assert(offsetof(FLegacyAddedEffectItemProperties, Index) == 0x000000, "Member 'FLegacyAddedEffectItemProperties::Index' has a wrong offset!");
static_assert(offsetof(FLegacyAddedEffectItemProperties, StringDebug) == 0x000008, "Member 'FLegacyAddedEffectItemProperties::StringDebug' has a wrong offset!");
static_assert(offsetof(FLegacyAddedEffectItemProperties, AddedEffectstring) == 0x000020, "Member 'FLegacyAddedEffectItemProperties::AddedEffectstring' has a wrong offset!");
static_assert(offsetof(FLegacyAddedEffectItemProperties, EffectValue) == 0x000038, "Member 'FLegacyAddedEffectItemProperties::EffectValue' has a wrong offset!");
static_assert(offsetof(FLegacyAddedEffectItemProperties, EffectTime) == 0x00003C, "Member 'FLegacyAddedEffectItemProperties::EffectTime' has a wrong offset!");
static_assert(offsetof(FLegacyAddedEffectItemProperties, TargetString) == 0x000040, "Member 'FLegacyAddedEffectItemProperties::TargetString' has a wrong offset!");
static_assert(offsetof(FLegacyAddedEffectItemProperties, Image) == 0x000058, "Member 'FLegacyAddedEffectItemProperties::Image' has a wrong offset!");

// ScriptStruct Altar.ModernItemEffectProperties
// 0x0040 (0x0040 - 0x0000)
struct FModernItemEffectProperties final
{
public:
	class UTexture2D*                             Icon;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TextKey;                                           // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsUnknow;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHostile;                                        // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernItemEffectProperties) == 0x000008, "Wrong alignment on FModernItemEffectProperties");
static_assert(sizeof(FModernItemEffectProperties) == 0x000040, "Wrong size on FModernItemEffectProperties");
static_assert(offsetof(FModernItemEffectProperties, Icon) == 0x000000, "Member 'FModernItemEffectProperties::Icon' has a wrong offset!");
static_assert(offsetof(FModernItemEffectProperties, Text) == 0x000008, "Member 'FModernItemEffectProperties::Text' has a wrong offset!");
static_assert(offsetof(FModernItemEffectProperties, TextKey) == 0x000020, "Member 'FModernItemEffectProperties::TextKey' has a wrong offset!");
static_assert(offsetof(FModernItemEffectProperties, bIsUnknow) == 0x000038, "Member 'FModernItemEffectProperties::bIsUnknow' has a wrong offset!");
static_assert(offsetof(FModernItemEffectProperties, bIsHostile) == 0x000039, "Member 'FModernItemEffectProperties::bIsHostile' has a wrong offset!");

// ScriptStruct Altar.LegacyIngredientItemProperties
// 0x0040 (0x0040 - 0x0000)
struct FLegacyIngredientItemProperties final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   NameText;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Image;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsItemSelected;                                   // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDisplay;                                    // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FModernItemEffectProperties>    Effects;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyIngredientItemProperties) == 0x000008, "Wrong alignment on FLegacyIngredientItemProperties");
static_assert(sizeof(FLegacyIngredientItemProperties) == 0x000040, "Wrong size on FLegacyIngredientItemProperties");
static_assert(offsetof(FLegacyIngredientItemProperties, Index) == 0x000000, "Member 'FLegacyIngredientItemProperties::Index' has a wrong offset!");
static_assert(offsetof(FLegacyIngredientItemProperties, SlotIndex) == 0x000004, "Member 'FLegacyIngredientItemProperties::SlotIndex' has a wrong offset!");
static_assert(offsetof(FLegacyIngredientItemProperties, NameText) == 0x000008, "Member 'FLegacyIngredientItemProperties::NameText' has a wrong offset!");
static_assert(offsetof(FLegacyIngredientItemProperties, Image) == 0x000020, "Member 'FLegacyIngredientItemProperties::Image' has a wrong offset!");
static_assert(offsetof(FLegacyIngredientItemProperties, Quantity) == 0x000028, "Member 'FLegacyIngredientItemProperties::Quantity' has a wrong offset!");
static_assert(offsetof(FLegacyIngredientItemProperties, bIsItemSelected) == 0x00002C, "Member 'FLegacyIngredientItemProperties::bIsItemSelected' has a wrong offset!");
static_assert(offsetof(FLegacyIngredientItemProperties, bShouldDisplay) == 0x00002D, "Member 'FLegacyIngredientItemProperties::bShouldDisplay' has a wrong offset!");
static_assert(offsetof(FLegacyIngredientItemProperties, Effects) == 0x000030, "Member 'FLegacyIngredientItemProperties::Effects' has a wrong offset!");

// ScriptStruct Altar.ModernApparatusProperties
// 0x0030 (0x0030 - 0x0000)
struct FModernApparatusProperties final
{
public:
	EVApparatusType                               ApparatusType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QualityLevel;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernApparatusProperties) == 0x000008, "Wrong alignment on FModernApparatusProperties");
static_assert(sizeof(FModernApparatusProperties) == 0x000030, "Wrong size on FModernApparatusProperties");
static_assert(offsetof(FModernApparatusProperties, ApparatusType) == 0x000000, "Member 'FModernApparatusProperties::ApparatusType' has a wrong offset!");
static_assert(offsetof(FModernApparatusProperties, Name) == 0x000008, "Member 'FModernApparatusProperties::Name' has a wrong offset!");
static_assert(offsetof(FModernApparatusProperties, Icon) == 0x000020, "Member 'FModernApparatusProperties::Icon' has a wrong offset!");
static_assert(offsetof(FModernApparatusProperties, QualityLevel) == 0x000028, "Member 'FModernApparatusProperties::QualityLevel' has a wrong offset!");

// ScriptStruct Altar.VideoTimestampTableRow
// 0x0020 (0x0028 - 0x0008)
struct FVideoTimestampTableRow final : public FTableRowBase
{
public:
	float                                         Start;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         End;                                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVideoTimestampTableRow) == 0x000008, "Wrong alignment on FVideoTimestampTableRow");
static_assert(sizeof(FVideoTimestampTableRow) == 0x000028, "Wrong size on FVideoTimestampTableRow");
static_assert(offsetof(FVideoTimestampTableRow, Start) == 0x000008, "Member 'FVideoTimestampTableRow::Start' has a wrong offset!");
static_assert(offsetof(FVideoTimestampTableRow, End) == 0x00000C, "Member 'FVideoTimestampTableRow::End' has a wrong offset!");
static_assert(offsetof(FVideoTimestampTableRow, Text) == 0x000010, "Member 'FVideoTimestampTableRow::Text' has a wrong offset!");

// ScriptStruct Altar.VAltarBlueprintTableRow
// 0x0030 (0x0038 - 0x0008)
struct FVAltarBlueprintTableRow final : public FTableRowBase
{
public:
	uint32                                        FormID;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVModdableBlueprint>     Blueprint;                                         // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVAltarBlueprintTableRow) == 0x000008, "Wrong alignment on FVAltarBlueprintTableRow");
static_assert(sizeof(FVAltarBlueprintTableRow) == 0x000038, "Wrong size on FVAltarBlueprintTableRow");
static_assert(offsetof(FVAltarBlueprintTableRow, FormID) == 0x000008, "Member 'FVAltarBlueprintTableRow::FormID' has a wrong offset!");
static_assert(offsetof(FVAltarBlueprintTableRow, Blueprint) == 0x000010, "Member 'FVAltarBlueprintTableRow::Blueprint' has a wrong offset!");

// ScriptStruct Altar.ImageCorrectionData
// 0x00F0 (0x00F0 - 0x0000)
struct FImageCorrectionData final
{
public:
	bool                                          bFixPowerOfTwoOffsets;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OriginalImageSize;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0020(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImageCorrectionData) == 0x000010, "Wrong alignment on FImageCorrectionData");
static_assert(sizeof(FImageCorrectionData) == 0x0000F0, "Wrong size on FImageCorrectionData");
static_assert(offsetof(FImageCorrectionData, bFixPowerOfTwoOffsets) == 0x000000, "Member 'FImageCorrectionData::bFixPowerOfTwoOffsets' has a wrong offset!");
static_assert(offsetof(FImageCorrectionData, OriginalImageSize) == 0x000008, "Member 'FImageCorrectionData::OriginalImageSize' has a wrong offset!");
static_assert(offsetof(FImageCorrectionData, Brush) == 0x000020, "Member 'FImageCorrectionData::Brush' has a wrong offset!");

// ScriptStruct Altar.ButtonCorrectionData
// 0x03C0 (0x03C0 - 0x0000)
struct FButtonCorrectionData final
{
public:
	struct FImageCorrectionData                   base;                                              // 0x0000(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FImageCorrectionData                   Hovered;                                           // 0x00F0(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FImageCorrectionData                   Pressed;                                           // 0x01E0(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FImageCorrectionData                   Disabled;                                          // 0x02D0(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FButtonCorrectionData) == 0x000010, "Wrong alignment on FButtonCorrectionData");
static_assert(sizeof(FButtonCorrectionData) == 0x0003C0, "Wrong size on FButtonCorrectionData");
static_assert(offsetof(FButtonCorrectionData, base) == 0x000000, "Member 'FButtonCorrectionData::base' has a wrong offset!");
static_assert(offsetof(FButtonCorrectionData, Hovered) == 0x0000F0, "Member 'FButtonCorrectionData::Hovered' has a wrong offset!");
static_assert(offsetof(FButtonCorrectionData, Pressed) == 0x0001E0, "Member 'FButtonCorrectionData::Pressed' has a wrong offset!");
static_assert(offsetof(FButtonCorrectionData, Disabled) == 0x0002D0, "Member 'FButtonCorrectionData::Disabled' has a wrong offset!");

// ScriptStruct Altar.CreditsData
// 0x0060 (0x0068 - 0x0008)
struct FCreditsData final : public FTableRowBase
{
public:
	class FString                                 CompanyName;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SectionName;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubSectionName;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JobTitle;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FirstName;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastName;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditsData) == 0x000008, "Wrong alignment on FCreditsData");
static_assert(sizeof(FCreditsData) == 0x000068, "Wrong size on FCreditsData");
static_assert(offsetof(FCreditsData, CompanyName) == 0x000008, "Member 'FCreditsData::CompanyName' has a wrong offset!");
static_assert(offsetof(FCreditsData, SectionName) == 0x000018, "Member 'FCreditsData::SectionName' has a wrong offset!");
static_assert(offsetof(FCreditsData, SubSectionName) == 0x000028, "Member 'FCreditsData::SubSectionName' has a wrong offset!");
static_assert(offsetof(FCreditsData, JobTitle) == 0x000038, "Member 'FCreditsData::JobTitle' has a wrong offset!");
static_assert(offsetof(FCreditsData, FirstName) == 0x000048, "Member 'FCreditsData::FirstName' has a wrong offset!");
static_assert(offsetof(FCreditsData, LastName) == 0x000058, "Member 'FCreditsData::LastName' has a wrong offset!");

// ScriptStruct Altar.VAltarDeadPoseTable
// 0x0158 (0x0160 - 0x0008)
struct FVAltarDeadPoseTable final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UPoseAsset>              DeadPose;                                          // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PoseName;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CapsuleWorldTransform;                             // 0x0040(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             MeshWorldTransform;                                // 0x00A0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAreAllConstraintsBroken;                          // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             BrokenConstraints;                                 // 0x0108(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVAltarDeadPoseTable) == 0x000010, "Wrong alignment on FVAltarDeadPoseTable");
static_assert(sizeof(FVAltarDeadPoseTable) == 0x000160, "Wrong size on FVAltarDeadPoseTable");
static_assert(offsetof(FVAltarDeadPoseTable, DeadPose) == 0x000008, "Member 'FVAltarDeadPoseTable::DeadPose' has a wrong offset!");
static_assert(offsetof(FVAltarDeadPoseTable, PoseName) == 0x000030, "Member 'FVAltarDeadPoseTable::PoseName' has a wrong offset!");
static_assert(offsetof(FVAltarDeadPoseTable, CapsuleWorldTransform) == 0x000040, "Member 'FVAltarDeadPoseTable::CapsuleWorldTransform' has a wrong offset!");
static_assert(offsetof(FVAltarDeadPoseTable, MeshWorldTransform) == 0x0000A0, "Member 'FVAltarDeadPoseTable::MeshWorldTransform' has a wrong offset!");
static_assert(offsetof(FVAltarDeadPoseTable, bAreAllConstraintsBroken) == 0x000100, "Member 'FVAltarDeadPoseTable::bAreAllConstraintsBroken' has a wrong offset!");
static_assert(offsetof(FVAltarDeadPoseTable, BrokenConstraints) == 0x000108, "Member 'FVAltarDeadPoseTable::BrokenConstraints' has a wrong offset!");

// ScriptStruct Altar.VPhysicsAssetPose
// 0x0028 (0x0028 - 0x0000)
struct FVPhysicsAssetPose final
{
public:
	class FName                                   PhysicsAssetName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     BodiesWorldTransforms;                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  AreConstraintsBroken;                              // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVPhysicsAssetPose) == 0x000008, "Wrong alignment on FVPhysicsAssetPose");
static_assert(sizeof(FVPhysicsAssetPose) == 0x000028, "Wrong size on FVPhysicsAssetPose");
static_assert(offsetof(FVPhysicsAssetPose, PhysicsAssetName) == 0x000000, "Member 'FVPhysicsAssetPose::PhysicsAssetName' has a wrong offset!");
static_assert(offsetof(FVPhysicsAssetPose, BodiesWorldTransforms) == 0x000008, "Member 'FVPhysicsAssetPose::BodiesWorldTransforms' has a wrong offset!");
static_assert(offsetof(FVPhysicsAssetPose, AreConstraintsBroken) == 0x000018, "Member 'FVPhysicsAssetPose::AreConstraintsBroken' has a wrong offset!");

// ScriptStruct Altar.VAltarDeadBodiesTransformTable
// 0x00F8 (0x0100 - 0x0008)
struct FVAltarDeadBodiesTransformTable final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CapsuleWorldTransform;                             // 0x0010(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             MeshWorldTransform;                                // 0x0070(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVPhysicsAssetPose                     PhysicsAssetPose;                                  // 0x00D0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVAltarDeadBodiesTransformTable) == 0x000010, "Wrong alignment on FVAltarDeadBodiesTransformTable");
static_assert(sizeof(FVAltarDeadBodiesTransformTable) == 0x000100, "Wrong size on FVAltarDeadBodiesTransformTable");
static_assert(offsetof(FVAltarDeadBodiesTransformTable, CapsuleWorldTransform) == 0x000010, "Member 'FVAltarDeadBodiesTransformTable::CapsuleWorldTransform' has a wrong offset!");
static_assert(offsetof(FVAltarDeadBodiesTransformTable, MeshWorldTransform) == 0x000070, "Member 'FVAltarDeadBodiesTransformTable::MeshWorldTransform' has a wrong offset!");
static_assert(offsetof(FVAltarDeadBodiesTransformTable, PhysicsAssetPose) == 0x0000D0, "Member 'FVAltarDeadBodiesTransformTable::PhysicsAssetPose' has a wrong offset!");

// ScriptStruct Altar.UserInputTextPair
// 0x0028 (0x0028 - 0x0000)
struct FUserInputTextPair final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Value;                                             // 0x0010(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserInputTextPair) == 0x000008, "Wrong alignment on FUserInputTextPair");
static_assert(sizeof(FUserInputTextPair) == 0x000028, "Wrong size on FUserInputTextPair");
static_assert(offsetof(FUserInputTextPair, Key) == 0x000000, "Member 'FUserInputTextPair::Key' has a wrong offset!");
static_assert(offsetof(FUserInputTextPair, Value) == 0x000010, "Member 'FUserInputTextPair::Value' has a wrong offset!");

// ScriptStruct Altar.OblivionDateTimeInfo
// 0x0010 (0x0010 - 0x0000)
struct FOblivionDateTimeInfo final
{
public:
	int32                                         Day;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Month;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Year;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameDayPassed;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOblivionDateTimeInfo) == 0x000004, "Wrong alignment on FOblivionDateTimeInfo");
static_assert(sizeof(FOblivionDateTimeInfo) == 0x000010, "Wrong size on FOblivionDateTimeInfo");
static_assert(offsetof(FOblivionDateTimeInfo, Day) == 0x000000, "Member 'FOblivionDateTimeInfo::Day' has a wrong offset!");
static_assert(offsetof(FOblivionDateTimeInfo, Month) == 0x000004, "Member 'FOblivionDateTimeInfo::Month' has a wrong offset!");
static_assert(offsetof(FOblivionDateTimeInfo, Year) == 0x000008, "Member 'FOblivionDateTimeInfo::Year' has a wrong offset!");
static_assert(offsetof(FOblivionDateTimeInfo, GameDayPassed) == 0x00000C, "Member 'FOblivionDateTimeInfo::GameDayPassed' has a wrong offset!");

// ScriptStruct Altar.VDebugTextContent
// 0x0030 (0x0030 - 0x0000)
struct FVDebugTextContent final
{
public:
	class FString                                 TextContent;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              position;                                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVDebugTextContent) == 0x000008, "Wrong alignment on FVDebugTextContent");
static_assert(sizeof(FVDebugTextContent) == 0x000030, "Wrong size on FVDebugTextContent");
static_assert(offsetof(FVDebugTextContent, TextContent) == 0x000000, "Member 'FVDebugTextContent::TextContent' has a wrong offset!");
static_assert(offsetof(FVDebugTextContent, Color) == 0x000010, "Member 'FVDebugTextContent::Color' has a wrong offset!");
static_assert(offsetof(FVDebugTextContent, position) == 0x000020, "Member 'FVDebugTextContent::position' has a wrong offset!");

// ScriptStruct Altar.VAltarMenuDefaults
// 0x0030 (0x0030 - 0x0000)
struct FVAltarMenuDefaults final
{
public:
	TSoftClassPtr<class UClass>                   DefaultCreatedClass;                               // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LayerTag;                                          // 0x0028(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVAltarMenuDefaults) == 0x000008, "Wrong alignment on FVAltarMenuDefaults");
static_assert(sizeof(FVAltarMenuDefaults) == 0x000030, "Wrong size on FVAltarMenuDefaults");
static_assert(offsetof(FVAltarMenuDefaults, DefaultCreatedClass) == 0x000000, "Member 'FVAltarMenuDefaults::DefaultCreatedClass' has a wrong offset!");
static_assert(offsetof(FVAltarMenuDefaults, LayerTag) == 0x000028, "Member 'FVAltarMenuDefaults::LayerTag' has a wrong offset!");

// ScriptStruct Altar.VAltarMenuDefaultsTableRow
// 0x0058 (0x0060 - 0x0008)
struct FVAltarMenuDefaultsTableRow final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   BaseClass;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultCreatedClass;                               // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LayerTag;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVAltarMenuDefaultsTableRow) == 0x000008, "Wrong alignment on FVAltarMenuDefaultsTableRow");
static_assert(sizeof(FVAltarMenuDefaultsTableRow) == 0x000060, "Wrong size on FVAltarMenuDefaultsTableRow");
static_assert(offsetof(FVAltarMenuDefaultsTableRow, BaseClass) == 0x000008, "Member 'FVAltarMenuDefaultsTableRow::BaseClass' has a wrong offset!");
static_assert(offsetof(FVAltarMenuDefaultsTableRow, DefaultCreatedClass) == 0x000030, "Member 'FVAltarMenuDefaultsTableRow::DefaultCreatedClass' has a wrong offset!");
static_assert(offsetof(FVAltarMenuDefaultsTableRow, LayerTag) == 0x000058, "Member 'FVAltarMenuDefaultsTableRow::LayerTag' has a wrong offset!");

// ScriptStruct Altar.LongPathNavQueryFilter
// 0x0020 (0x0020 - 0x0000)
struct FLongPathNavQueryFilter final
{
public:
	class ANavigationData*                        NavigationData;                                    // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     NavigationQueryFilterClass;                        // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLongPathNavQueryFilter) == 0x000008, "Wrong alignment on FLongPathNavQueryFilter");
static_assert(sizeof(FLongPathNavQueryFilter) == 0x000020, "Wrong size on FLongPathNavQueryFilter");
static_assert(offsetof(FLongPathNavQueryFilter, NavigationData) == 0x000000, "Member 'FLongPathNavQueryFilter::NavigationData' has a wrong offset!");
static_assert(offsetof(FLongPathNavQueryFilter, NavigationQueryFilterClass) == 0x000008, "Member 'FLongPathNavQueryFilter::NavigationQueryFilterClass' has a wrong offset!");

// ScriptStruct Altar.OnboardingEULATableRow
// 0x0040 (0x0048 - 0x0008)
struct FOnboardingEULATableRow final : public FTableRowBase
{
public:
	EVCountryGroup                                CountryGroup;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MainEULA;                                          // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bDoesHaveAdditiveText;                             // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AdditiveEULA;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnboardingEULATableRow) == 0x000008, "Wrong alignment on FOnboardingEULATableRow");
static_assert(sizeof(FOnboardingEULATableRow) == 0x000048, "Wrong size on FOnboardingEULATableRow");
static_assert(offsetof(FOnboardingEULATableRow, CountryGroup) == 0x000008, "Member 'FOnboardingEULATableRow::CountryGroup' has a wrong offset!");
static_assert(offsetof(FOnboardingEULATableRow, MainEULA) == 0x000010, "Member 'FOnboardingEULATableRow::MainEULA' has a wrong offset!");
static_assert(offsetof(FOnboardingEULATableRow, bDoesHaveAdditiveText) == 0x000028, "Member 'FOnboardingEULATableRow::bDoesHaveAdditiveText' has a wrong offset!");
static_assert(offsetof(FOnboardingEULATableRow, AdditiveEULA) == 0x000030, "Member 'FOnboardingEULATableRow::AdditiveEULA' has a wrong offset!");

// ScriptStruct Altar.VCameraSettingData
// 0x00B0 (0x00B0 - 0x0000)
struct FVCameraSettingData final
{
public:
	float                                         TransitionDuration;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             EaseCurve;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredArmLength;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DesiredTargetOffset;                               // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DesiredSocketOffset;                               // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredOverrideFieldOfView;                        // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredOffsetToAddFieldOfView;                     // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredViewPitchMin;                               // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredViewPitchMax;                               // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredViewYawMin;                                 // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredViewYawMax;                                 // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DialogueFocusBoneName;                             // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetWhenInDialogue;                              // 0x0088(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionLagSpeed;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationLagSpeedPitch;                             // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationLagSpeedYaw;                               // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagMaxDistance;                              // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVCameraSettingData) == 0x000008, "Wrong alignment on FVCameraSettingData");
static_assert(sizeof(FVCameraSettingData) == 0x0000B0, "Wrong size on FVCameraSettingData");
static_assert(offsetof(FVCameraSettingData, TransitionDuration) == 0x000000, "Member 'FVCameraSettingData::TransitionDuration' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, EaseCurve) == 0x000008, "Member 'FVCameraSettingData::EaseCurve' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, DesiredArmLength) == 0x000030, "Member 'FVCameraSettingData::DesiredArmLength' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, DesiredTargetOffset) == 0x000038, "Member 'FVCameraSettingData::DesiredTargetOffset' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, DesiredSocketOffset) == 0x000050, "Member 'FVCameraSettingData::DesiredSocketOffset' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, DesiredOverrideFieldOfView) == 0x000068, "Member 'FVCameraSettingData::DesiredOverrideFieldOfView' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, DesiredOffsetToAddFieldOfView) == 0x00006C, "Member 'FVCameraSettingData::DesiredOffsetToAddFieldOfView' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, DesiredViewPitchMin) == 0x000070, "Member 'FVCameraSettingData::DesiredViewPitchMin' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, DesiredViewPitchMax) == 0x000074, "Member 'FVCameraSettingData::DesiredViewPitchMax' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, DesiredViewYawMin) == 0x000078, "Member 'FVCameraSettingData::DesiredViewYawMin' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, DesiredViewYawMax) == 0x00007C, "Member 'FVCameraSettingData::DesiredViewYawMax' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, DialogueFocusBoneName) == 0x000080, "Member 'FVCameraSettingData::DialogueFocusBoneName' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, OffsetWhenInDialogue) == 0x000088, "Member 'FVCameraSettingData::OffsetWhenInDialogue' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, PositionLagSpeed) == 0x0000A0, "Member 'FVCameraSettingData::PositionLagSpeed' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, RotationLagSpeedPitch) == 0x0000A4, "Member 'FVCameraSettingData::RotationLagSpeedPitch' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, RotationLagSpeedYaw) == 0x0000A8, "Member 'FVCameraSettingData::RotationLagSpeedYaw' has a wrong offset!");
static_assert(offsetof(FVCameraSettingData, CameraLagMaxDistance) == 0x0000AC, "Member 'FVCameraSettingData::CameraLagMaxDistance' has a wrong offset!");

// ScriptStruct Altar.VCameraSettings
// 0x0238 (0x0240 - 0x0008)
struct FVCameraSettings final : public FTableRowBase
{
public:
	struct FGameplayTagContainer                  CameraTagsKey;                                     // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVCameraSettingData                    ThirdPersonCameraSettingDataClose;                 // 0x0028(0x00B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVCameraSettingData                    ThirdPersonCameraSettingDataFar;                   // 0x00D8(0x00B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVCameraSettingData                    FirstPersonCameraSettingData;                      // 0x0188(0x00B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAlwaysUseCloseThirdPersonSetting;                 // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVCameraSettings) == 0x000008, "Wrong alignment on FVCameraSettings");
static_assert(sizeof(FVCameraSettings) == 0x000240, "Wrong size on FVCameraSettings");
static_assert(offsetof(FVCameraSettings, CameraTagsKey) == 0x000008, "Member 'FVCameraSettings::CameraTagsKey' has a wrong offset!");
static_assert(offsetof(FVCameraSettings, ThirdPersonCameraSettingDataClose) == 0x000028, "Member 'FVCameraSettings::ThirdPersonCameraSettingDataClose' has a wrong offset!");
static_assert(offsetof(FVCameraSettings, ThirdPersonCameraSettingDataFar) == 0x0000D8, "Member 'FVCameraSettings::ThirdPersonCameraSettingDataFar' has a wrong offset!");
static_assert(offsetof(FVCameraSettings, FirstPersonCameraSettingData) == 0x000188, "Member 'FVCameraSettings::FirstPersonCameraSettingData' has a wrong offset!");
static_assert(offsetof(FVCameraSettings, bAlwaysUseCloseThirdPersonSetting) == 0x000238, "Member 'FVCameraSettings::bAlwaysUseCloseThirdPersonSetting' has a wrong offset!");

// ScriptStruct Altar.LegacyMapMenuLocalMapProperties
// 0x0028 (0x0028 - 0x0000)
struct FLegacyMapMenuLocalMapProperties final
{
public:
	class UMaterialInterface*                     Map;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MapSize;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DesiredTextureSize;                                // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyMapMenuLocalMapProperties) == 0x000008, "Wrong alignment on FLegacyMapMenuLocalMapProperties");
static_assert(sizeof(FLegacyMapMenuLocalMapProperties) == 0x000028, "Wrong size on FLegacyMapMenuLocalMapProperties");
static_assert(offsetof(FLegacyMapMenuLocalMapProperties, Map) == 0x000000, "Member 'FLegacyMapMenuLocalMapProperties::Map' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuLocalMapProperties, MapSize) == 0x000008, "Member 'FLegacyMapMenuLocalMapProperties::MapSize' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuLocalMapProperties, DesiredTextureSize) == 0x000018, "Member 'FLegacyMapMenuLocalMapProperties::DesiredTextureSize' has a wrong offset!");

// ScriptStruct Altar.VCameraShake
// 0x0028 (0x0028 - 0x0000)
struct FVCameraShake final
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVCameraShake) == 0x000008, "Wrong alignment on FVCameraShake");
static_assert(sizeof(FVCameraShake) == 0x000028, "Wrong size on FVCameraShake");
static_assert(offsetof(FVCameraShake, Tags) == 0x000000, "Member 'FVCameraShake::Tags' has a wrong offset!");
static_assert(offsetof(FVCameraShake, CameraShake) == 0x000020, "Member 'FVCameraShake::CameraShake' has a wrong offset!");

// ScriptStruct Altar.RichInputActionRow
// 0x0108 (0x0110 - 0x0008)
struct FRichInputActionRow final : public FTableRowBase
{
public:
	class UInputAction*                           InputAction;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputMappingContext>    InputMappingContext;                               // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0040(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRichInputActionRow) == 0x000010, "Wrong alignment on FRichInputActionRow");
static_assert(sizeof(FRichInputActionRow) == 0x000110, "Wrong size on FRichInputActionRow");
static_assert(offsetof(FRichInputActionRow, InputAction) == 0x000008, "Member 'FRichInputActionRow::InputAction' has a wrong offset!");
static_assert(offsetof(FRichInputActionRow, InputMappingContext) == 0x000010, "Member 'FRichInputActionRow::InputMappingContext' has a wrong offset!");
static_assert(offsetof(FRichInputActionRow, Brush) == 0x000040, "Member 'FRichInputActionRow::Brush' has a wrong offset!");

// ScriptStruct Altar.ModernScrollbarProperties
// 0x0010 (0x0010 - 0x0000)
struct FModernScrollbarProperties final
{
public:
	float                                         MinValue;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThumbFractionSize;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernScrollbarProperties) == 0x000004, "Wrong alignment on FModernScrollbarProperties");
static_assert(sizeof(FModernScrollbarProperties) == 0x000010, "Wrong size on FModernScrollbarProperties");
static_assert(offsetof(FModernScrollbarProperties, MinValue) == 0x000000, "Member 'FModernScrollbarProperties::MinValue' has a wrong offset!");
static_assert(offsetof(FModernScrollbarProperties, MaxValue) == 0x000004, "Member 'FModernScrollbarProperties::MaxValue' has a wrong offset!");
static_assert(offsetof(FModernScrollbarProperties, CurrentValue) == 0x000008, "Member 'FModernScrollbarProperties::CurrentValue' has a wrong offset!");
static_assert(offsetof(FModernScrollbarProperties, ThumbFractionSize) == 0x00000C, "Member 'FModernScrollbarProperties::ThumbFractionSize' has a wrong offset!");

// ScriptStruct Altar.VSaveGameDetails
// 0x00B8 (0x00B8 - 0x0000)
struct FVSaveGameDetails final
{
public:
	class FString                                 SaveName;                                          // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaveNumber;                                        // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayPlayerName;                                 // 0x0028(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerLocation;                                    // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              PlayTime;                                          // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InGameDate;                                        // 0x0060(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              SaveDate;                                          // 0x0068(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 SaveThumbnail;                                     // 0x0070(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SlotName;                                          // 0x0080(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVSaveType                                    Type;                                              // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsESS;                                            // 0x0094(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedTheWholeGameDownloaded;                       // 0x0095(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAchievementsDisabled;                           // 0x0096(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_97[0x1];                                       // 0x0097(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SaveHash;                                          // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  CharacterId;                                       // 0x00A8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSaveGameDetails) == 0x000008, "Wrong alignment on FVSaveGameDetails");
static_assert(sizeof(FVSaveGameDetails) == 0x0000B8, "Wrong size on FVSaveGameDetails");
static_assert(offsetof(FVSaveGameDetails, SaveName) == 0x000000, "Member 'FVSaveGameDetails::SaveName' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, SaveNumber) == 0x000010, "Member 'FVSaveGameDetails::SaveNumber' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, PlayerName) == 0x000018, "Member 'FVSaveGameDetails::PlayerName' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, DisplayPlayerName) == 0x000028, "Member 'FVSaveGameDetails::DisplayPlayerName' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, PlayerLevel) == 0x000040, "Member 'FVSaveGameDetails::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, PlayerLocation) == 0x000048, "Member 'FVSaveGameDetails::PlayerLocation' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, PlayTime) == 0x000058, "Member 'FVSaveGameDetails::PlayTime' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, InGameDate) == 0x000060, "Member 'FVSaveGameDetails::InGameDate' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, SaveDate) == 0x000068, "Member 'FVSaveGameDetails::SaveDate' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, SaveThumbnail) == 0x000070, "Member 'FVSaveGameDetails::SaveThumbnail' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, SlotName) == 0x000080, "Member 'FVSaveGameDetails::SlotName' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, Type) == 0x000090, "Member 'FVSaveGameDetails::Type' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, bIsESS) == 0x000094, "Member 'FVSaveGameDetails::bIsESS' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, bNeedTheWholeGameDownloaded) == 0x000095, "Member 'FVSaveGameDetails::bNeedTheWholeGameDownloaded' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, bIsAchievementsDisabled) == 0x000096, "Member 'FVSaveGameDetails::bIsAchievementsDisabled' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, SaveHash) == 0x000098, "Member 'FVSaveGameDetails::SaveHash' has a wrong offset!");
static_assert(offsetof(FVSaveGameDetails, CharacterId) == 0x0000A8, "Member 'FVSaveGameDetails::CharacterId' has a wrong offset!");

// ScriptStruct Altar.SerializedAltarSaveData
// 0x0018 (0x0018 - 0x0000)
struct FSerializedAltarSaveData final
{
public:
	class FName                                   SaveDataName;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 SerializedData;                                    // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSerializedAltarSaveData) == 0x000008, "Wrong alignment on FSerializedAltarSaveData");
static_assert(sizeof(FSerializedAltarSaveData) == 0x000018, "Wrong size on FSerializedAltarSaveData");
static_assert(offsetof(FSerializedAltarSaveData, SaveDataName) == 0x000000, "Member 'FSerializedAltarSaveData::SaveDataName' has a wrong offset!");
static_assert(offsetof(FSerializedAltarSaveData, SerializedData) == 0x000008, "Member 'FSerializedAltarSaveData::SerializedData' has a wrong offset!");

// ScriptStruct Altar.VPhysicsSettingsAuthorityFlags
// 0x0004 (0x0004 - 0x0000)
struct FVPhysicsSettingsAuthorityFlags final
{
public:
	bool                                          bIsCollisionProfileCodeDriven;                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWeightCodeDriven;                               // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAreDampingValuesCodeDriven;                       // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAreNavigationSettingsCodeDriven;                  // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVPhysicsSettingsAuthorityFlags) == 0x000001, "Wrong alignment on FVPhysicsSettingsAuthorityFlags");
static_assert(sizeof(FVPhysicsSettingsAuthorityFlags) == 0x000004, "Wrong size on FVPhysicsSettingsAuthorityFlags");
static_assert(offsetof(FVPhysicsSettingsAuthorityFlags, bIsCollisionProfileCodeDriven) == 0x000000, "Member 'FVPhysicsSettingsAuthorityFlags::bIsCollisionProfileCodeDriven' has a wrong offset!");
static_assert(offsetof(FVPhysicsSettingsAuthorityFlags, bIsWeightCodeDriven) == 0x000001, "Member 'FVPhysicsSettingsAuthorityFlags::bIsWeightCodeDriven' has a wrong offset!");
static_assert(offsetof(FVPhysicsSettingsAuthorityFlags, bAreDampingValuesCodeDriven) == 0x000002, "Member 'FVPhysicsSettingsAuthorityFlags::bAreDampingValuesCodeDriven' has a wrong offset!");
static_assert(offsetof(FVPhysicsSettingsAuthorityFlags, bAreNavigationSettingsCodeDriven) == 0x000003, "Member 'FVPhysicsSettingsAuthorityFlags::bAreNavigationSettingsCodeDriven' has a wrong offset!");

// ScriptStruct Altar.VSaveNumbers
// 0x0008 (0x0008 - 0x0000)
struct FVSaveNumbers final
{
public:
	int32                                         SaveCounter;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoSaveCounter;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSaveNumbers) == 0x000004, "Wrong alignment on FVSaveNumbers");
static_assert(sizeof(FVSaveNumbers) == 0x000008, "Wrong size on FVSaveNumbers");
static_assert(offsetof(FVSaveNumbers, SaveCounter) == 0x000000, "Member 'FVSaveNumbers::SaveCounter' has a wrong offset!");
static_assert(offsetof(FVSaveNumbers, AutoSaveCounter) == 0x000004, "Member 'FVSaveNumbers::AutoSaveCounter' has a wrong offset!");

// ScriptStruct Altar.VAltarScreenShotCaptureObject
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FVAltarScreenShotCaptureObject final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UVAltarSaveSystem>       SaveSystem;                                        // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVAltarScreenShotCaptureObject) == 0x000008, "Wrong alignment on FVAltarScreenShotCaptureObject");
static_assert(sizeof(FVAltarScreenShotCaptureObject) == 0x000028, "Wrong size on FVAltarScreenShotCaptureObject");
static_assert(offsetof(FVAltarScreenShotCaptureObject, SaveSystem) == 0x000020, "Member 'FVAltarScreenShotCaptureObject::SaveSystem' has a wrong offset!");

// ScriptStruct Altar.ModernRebindData
// 0x0060 (0x0060 - 0x0000)
struct FModernRebindData final
{
public:
	class UInputMappingContext*                   MappingContext;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputAction*                           InputAction;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   DefaultPrimaryKeyboardKey;                         // 0x0010(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   DefaultSecondaryKeyboardKey;                       // 0x0028(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   DefaultPrimaryGamepadKey;                          // 0x0040(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVModernRebindCategory                        DefaultCategory;                                   // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernRebindData) == 0x000008, "Wrong alignment on FModernRebindData");
static_assert(sizeof(FModernRebindData) == 0x000060, "Wrong size on FModernRebindData");
static_assert(offsetof(FModernRebindData, MappingContext) == 0x000000, "Member 'FModernRebindData::MappingContext' has a wrong offset!");
static_assert(offsetof(FModernRebindData, InputAction) == 0x000008, "Member 'FModernRebindData::InputAction' has a wrong offset!");
static_assert(offsetof(FModernRebindData, DefaultPrimaryKeyboardKey) == 0x000010, "Member 'FModernRebindData::DefaultPrimaryKeyboardKey' has a wrong offset!");
static_assert(offsetof(FModernRebindData, DefaultSecondaryKeyboardKey) == 0x000028, "Member 'FModernRebindData::DefaultSecondaryKeyboardKey' has a wrong offset!");
static_assert(offsetof(FModernRebindData, DefaultPrimaryGamepadKey) == 0x000040, "Member 'FModernRebindData::DefaultPrimaryGamepadKey' has a wrong offset!");
static_assert(offsetof(FModernRebindData, DefaultCategory) == 0x000058, "Member 'FModernRebindData::DefaultCategory' has a wrong offset!");

// ScriptStruct Altar.WidgetContext
// 0x0010 (0x0010 - 0x0000)
struct FWidgetContext final
{
public:
	TSubclassOf<class UVAltarMenu>                ContextClass;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContextName;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetContext) == 0x000008, "Wrong alignment on FWidgetContext");
static_assert(sizeof(FWidgetContext) == 0x000010, "Wrong size on FWidgetContext");
static_assert(offsetof(FWidgetContext, ContextClass) == 0x000000, "Member 'FWidgetContext::ContextClass' has a wrong offset!");
static_assert(offsetof(FWidgetContext, ContextName) == 0x000008, "Member 'FWidgetContext::ContextName' has a wrong offset!");

// ScriptStruct Altar.CameraTrackingSettings
// 0x0024 (0x0024 - 0x0000)
struct FCameraTrackingSettings final
{
public:
	float                                         MinTrackingAngle;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTrackingAngle;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTrackingDistance;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTrackingDistance;                               // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTrackingExtraSpeedMultiplier;                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTrackingRampUpEndThreshold;                  // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTrackingRampDownStartThreshold;              // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAllAxisOnCameraTracking;                       // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePreventiveHitBox;                              // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePreventiveAngle;                               // 0x001E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitBoxExpandValue;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraTrackingSettings) == 0x000004, "Wrong alignment on FCameraTrackingSettings");
static_assert(sizeof(FCameraTrackingSettings) == 0x000024, "Wrong size on FCameraTrackingSettings");
static_assert(offsetof(FCameraTrackingSettings, MinTrackingAngle) == 0x000000, "Member 'FCameraTrackingSettings::MinTrackingAngle' has a wrong offset!");
static_assert(offsetof(FCameraTrackingSettings, MaxTrackingAngle) == 0x000004, "Member 'FCameraTrackingSettings::MaxTrackingAngle' has a wrong offset!");
static_assert(offsetof(FCameraTrackingSettings, MinTrackingDistance) == 0x000008, "Member 'FCameraTrackingSettings::MinTrackingDistance' has a wrong offset!");
static_assert(offsetof(FCameraTrackingSettings, MaxTrackingDistance) == 0x00000C, "Member 'FCameraTrackingSettings::MaxTrackingDistance' has a wrong offset!");
static_assert(offsetof(FCameraTrackingSettings, CameraTrackingExtraSpeedMultiplier) == 0x000010, "Member 'FCameraTrackingSettings::CameraTrackingExtraSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FCameraTrackingSettings, CameraTrackingRampUpEndThreshold) == 0x000014, "Member 'FCameraTrackingSettings::CameraTrackingRampUpEndThreshold' has a wrong offset!");
static_assert(offsetof(FCameraTrackingSettings, CameraTrackingRampDownStartThreshold) == 0x000018, "Member 'FCameraTrackingSettings::CameraTrackingRampDownStartThreshold' has a wrong offset!");
static_assert(offsetof(FCameraTrackingSettings, bUseAllAxisOnCameraTracking) == 0x00001C, "Member 'FCameraTrackingSettings::bUseAllAxisOnCameraTracking' has a wrong offset!");
static_assert(offsetof(FCameraTrackingSettings, bUsePreventiveHitBox) == 0x00001D, "Member 'FCameraTrackingSettings::bUsePreventiveHitBox' has a wrong offset!");
static_assert(offsetof(FCameraTrackingSettings, bUsePreventiveAngle) == 0x00001E, "Member 'FCameraTrackingSettings::bUsePreventiveAngle' has a wrong offset!");
static_assert(offsetof(FCameraTrackingSettings, HitBoxExpandValue) == 0x000020, "Member 'FCameraTrackingSettings::HitBoxExpandValue' has a wrong offset!");

// ScriptStruct Altar.VATMRecordingFrameStars
// 0x0014 (0x0014 - 0x0000)
struct FVATMRecordingFrameStars final
{
public:
	bool                                          bUpdated;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisX;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisY;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisZ;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVATMRecordingFrameStars) == 0x000004, "Wrong alignment on FVATMRecordingFrameStars");
static_assert(sizeof(FVATMRecordingFrameStars) == 0x000014, "Wrong size on FVATMRecordingFrameStars");
static_assert(offsetof(FVATMRecordingFrameStars, bUpdated) == 0x000000, "Member 'FVATMRecordingFrameStars::bUpdated' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameStars, AxisX) == 0x000004, "Member 'FVATMRecordingFrameStars::AxisX' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameStars, AxisY) == 0x000008, "Member 'FVATMRecordingFrameStars::AxisY' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameStars, AxisZ) == 0x00000C, "Member 'FVATMRecordingFrameStars::AxisZ' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameStars, Angle) == 0x000010, "Member 'FVATMRecordingFrameStars::Angle' has a wrong offset!");

// ScriptStruct Altar.ModernSettingMultiCommand
// 0x0030 (0x0030 - 0x0000)
struct FModernSettingMultiCommand final
{
public:
	class FText                                   Label;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FModernSettingCommand>          Commands;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bRequireExtraPlatformFlags;                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlatformFlag;                                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernSettingMultiCommand) == 0x000008, "Wrong alignment on FModernSettingMultiCommand");
static_assert(sizeof(FModernSettingMultiCommand) == 0x000030, "Wrong size on FModernSettingMultiCommand");
static_assert(offsetof(FModernSettingMultiCommand, Label) == 0x000000, "Member 'FModernSettingMultiCommand::Label' has a wrong offset!");
static_assert(offsetof(FModernSettingMultiCommand, Commands) == 0x000018, "Member 'FModernSettingMultiCommand::Commands' has a wrong offset!");
static_assert(offsetof(FModernSettingMultiCommand, bRequireExtraPlatformFlags) == 0x000028, "Member 'FModernSettingMultiCommand::bRequireExtraPlatformFlags' has a wrong offset!");
static_assert(offsetof(FModernSettingMultiCommand, PlatformFlag) == 0x00002C, "Member 'FModernSettingMultiCommand::PlatformFlag' has a wrong offset!");

// ScriptStruct Altar.VATMRecordingFrameSun
// 0x0018 (0x0018 - 0x0000)
struct FVATMRecordingFrameSun final
{
public:
	bool                                          bUpdated;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisX;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisY;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisZ;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunriseBegin;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunsetEnd;                                         // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVATMRecordingFrameSun) == 0x000004, "Wrong alignment on FVATMRecordingFrameSun");
static_assert(sizeof(FVATMRecordingFrameSun) == 0x000018, "Wrong size on FVATMRecordingFrameSun");
static_assert(offsetof(FVATMRecordingFrameSun, bUpdated) == 0x000000, "Member 'FVATMRecordingFrameSun::bUpdated' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameSun, AxisX) == 0x000004, "Member 'FVATMRecordingFrameSun::AxisX' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameSun, AxisY) == 0x000008, "Member 'FVATMRecordingFrameSun::AxisY' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameSun, AxisZ) == 0x00000C, "Member 'FVATMRecordingFrameSun::AxisZ' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameSun, SunriseBegin) == 0x000010, "Member 'FVATMRecordingFrameSun::SunriseBegin' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrameSun, SunsetEnd) == 0x000014, "Member 'FVATMRecordingFrameSun::SunsetEnd' has a wrong offset!");

// ScriptStruct Altar.VATMRecordingFrame
// 0x0058 (0x0058 - 0x0000)
struct FVATMRecordingFrame final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVATMRecordingFrameMoon                Moon[0x2];                                         // 0x0004(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVATMRecordingFrameStars               Stars;                                             // 0x002C(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVATMRecordingFrameSun                 Sun;                                               // 0x0040(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVATMRecordingFrame) == 0x000004, "Wrong alignment on FVATMRecordingFrame");
static_assert(sizeof(FVATMRecordingFrame) == 0x000058, "Wrong size on FVATMRecordingFrame");
static_assert(offsetof(FVATMRecordingFrame, Time) == 0x000000, "Member 'FVATMRecordingFrame::Time' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrame, Moon) == 0x000004, "Member 'FVATMRecordingFrame::Moon' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrame, Stars) == 0x00002C, "Member 'FVATMRecordingFrame::Stars' has a wrong offset!");
static_assert(offsetof(FVATMRecordingFrame, Sun) == 0x000040, "Member 'FVATMRecordingFrame::Sun' has a wrong offset!");

// ScriptStruct Altar.VHorseRiderLocomotionSwim
// 0x0018 (0x0018 - 0x0000)
struct FVHorseRiderLocomotionSwim final
{
public:
	class UBlendSpace*                            Blendspace_Forward;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Blendspace_Backward;                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Idle;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVHorseRiderLocomotionSwim) == 0x000008, "Wrong alignment on FVHorseRiderLocomotionSwim");
static_assert(sizeof(FVHorseRiderLocomotionSwim) == 0x000018, "Wrong size on FVHorseRiderLocomotionSwim");
static_assert(offsetof(FVHorseRiderLocomotionSwim, Blendspace_Forward) == 0x000000, "Member 'FVHorseRiderLocomotionSwim::Blendspace_Forward' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionSwim, Blendspace_Backward) == 0x000008, "Member 'FVHorseRiderLocomotionSwim::Blendspace_Backward' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionSwim, Idle) == 0x000010, "Member 'FVHorseRiderLocomotionSwim::Idle' has a wrong offset!");

// ScriptStruct Altar.VATMRecordingFrameArray
// 0x0010 (0x0010 - 0x0000)
struct FVATMRecordingFrameArray final
{
public:
	TArray<struct FVATMRecordingFrame>            Frames;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVATMRecordingFrameArray) == 0x000008, "Wrong alignment on FVATMRecordingFrameArray");
static_assert(sizeof(FVATMRecordingFrameArray) == 0x000010, "Wrong size on FVATMRecordingFrameArray");
static_assert(offsetof(FVATMRecordingFrameArray, Frames) == 0x000000, "Member 'FVATMRecordingFrameArray::Frames' has a wrong offset!");

// ScriptStruct Altar.AvailableEffectData
// 0x0028 (0x0028 - 0x0000)
struct FAvailableEffectData final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NameText;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Image;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAvailableEffectData) == 0x000008, "Wrong alignment on FAvailableEffectData");
static_assert(sizeof(FAvailableEffectData) == 0x000028, "Wrong size on FAvailableEffectData");
static_assert(offsetof(FAvailableEffectData, Index) == 0x000000, "Member 'FAvailableEffectData::Index' has a wrong offset!");
static_assert(offsetof(FAvailableEffectData, NameText) == 0x000008, "Member 'FAvailableEffectData::NameText' has a wrong offset!");
static_assert(offsetof(FAvailableEffectData, Image) == 0x000020, "Member 'FAvailableEffectData::Image' has a wrong offset!");

// ScriptStruct Altar.ModernSettingPageTableRow
// 0x0828 (0x0830 - 0x0008)
struct FModernSettingPageTableRow final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         PlatformFlag;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FButtonStyle                           DefaultButtonStyle;                                // 0x0030(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FButtonStyle                           SelectedButtonStyle;                               // 0x0420(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EFModernSettingsPageType                      PageType;                                          // 0x0810(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_811[0x7];                                      // 0x0811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVModernSettingCategoryTable*           Categories;                                        // 0x0818(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVModernSettingRebindData*              RebindTable;                                       // 0x0820(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                OverrideWidget;                                    // 0x0828(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernSettingPageTableRow) == 0x000010, "Wrong alignment on FModernSettingPageTableRow");
static_assert(sizeof(FModernSettingPageTableRow) == 0x000830, "Wrong size on FModernSettingPageTableRow");
static_assert(offsetof(FModernSettingPageTableRow, Name) == 0x000008, "Member 'FModernSettingPageTableRow::Name' has a wrong offset!");
static_assert(offsetof(FModernSettingPageTableRow, PlatformFlag) == 0x000020, "Member 'FModernSettingPageTableRow::PlatformFlag' has a wrong offset!");
static_assert(offsetof(FModernSettingPageTableRow, DefaultButtonStyle) == 0x000030, "Member 'FModernSettingPageTableRow::DefaultButtonStyle' has a wrong offset!");
static_assert(offsetof(FModernSettingPageTableRow, SelectedButtonStyle) == 0x000420, "Member 'FModernSettingPageTableRow::SelectedButtonStyle' has a wrong offset!");
static_assert(offsetof(FModernSettingPageTableRow, PageType) == 0x000810, "Member 'FModernSettingPageTableRow::PageType' has a wrong offset!");
static_assert(offsetof(FModernSettingPageTableRow, Categories) == 0x000818, "Member 'FModernSettingPageTableRow::Categories' has a wrong offset!");
static_assert(offsetof(FModernSettingPageTableRow, RebindTable) == 0x000820, "Member 'FModernSettingPageTableRow::RebindTable' has a wrong offset!");
static_assert(offsetof(FModernSettingPageTableRow, OverrideWidget) == 0x000828, "Member 'FModernSettingPageTableRow::OverrideWidget' has a wrong offset!");

// ScriptStruct Altar.VBlinkCharacterAnimInstanceProxy
// 0x0020 (0x0720 - 0x0700)
struct FVBlinkCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x20];                                     // 0x0700(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVBlinkCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVBlinkCharacterAnimInstanceProxy");
static_assert(sizeof(FVBlinkCharacterAnimInstanceProxy) == 0x000720, "Wrong size on FVBlinkCharacterAnimInstanceProxy");

// ScriptStruct Altar.ActorBlinkData
// 0x00A0 (0x00A0 - 0x0000)
struct FActorBlinkData final
{
public:
	class UCurveFloat*                            BlinkWeightCurve;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      BlinkPoseAnimSequence;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid1BoneName;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid2BoneName;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid3BoneName;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid4BoneName;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid5BoneName;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid6BoneName;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid7BoneName;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid8BoneName;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid9BoneName;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid10BoneName;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid11BoneName;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid12BoneName;                                  // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid13BoneName;                                  // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid14BoneName;                                  // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid15BoneName;                                  // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid16BoneName;                                  // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid17BoneName;                                  // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Eyelid18BoneName;                                  // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorBlinkData) == 0x000008, "Wrong alignment on FActorBlinkData");
static_assert(sizeof(FActorBlinkData) == 0x0000A0, "Wrong size on FActorBlinkData");
static_assert(offsetof(FActorBlinkData, BlinkWeightCurve) == 0x000000, "Member 'FActorBlinkData::BlinkWeightCurve' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, BlinkPoseAnimSequence) == 0x000008, "Member 'FActorBlinkData::BlinkPoseAnimSequence' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid1BoneName) == 0x000010, "Member 'FActorBlinkData::Eyelid1BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid2BoneName) == 0x000018, "Member 'FActorBlinkData::Eyelid2BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid3BoneName) == 0x000020, "Member 'FActorBlinkData::Eyelid3BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid4BoneName) == 0x000028, "Member 'FActorBlinkData::Eyelid4BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid5BoneName) == 0x000030, "Member 'FActorBlinkData::Eyelid5BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid6BoneName) == 0x000038, "Member 'FActorBlinkData::Eyelid6BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid7BoneName) == 0x000040, "Member 'FActorBlinkData::Eyelid7BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid8BoneName) == 0x000048, "Member 'FActorBlinkData::Eyelid8BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid9BoneName) == 0x000050, "Member 'FActorBlinkData::Eyelid9BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid10BoneName) == 0x000058, "Member 'FActorBlinkData::Eyelid10BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid11BoneName) == 0x000060, "Member 'FActorBlinkData::Eyelid11BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid12BoneName) == 0x000068, "Member 'FActorBlinkData::Eyelid12BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid13BoneName) == 0x000070, "Member 'FActorBlinkData::Eyelid13BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid14BoneName) == 0x000078, "Member 'FActorBlinkData::Eyelid14BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid15BoneName) == 0x000080, "Member 'FActorBlinkData::Eyelid15BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid16BoneName) == 0x000088, "Member 'FActorBlinkData::Eyelid16BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid17BoneName) == 0x000090, "Member 'FActorBlinkData::Eyelid17BoneName' has a wrong offset!");
static_assert(offsetof(FActorBlinkData, Eyelid18BoneName) == 0x000098, "Member 'FActorBlinkData::Eyelid18BoneName' has a wrong offset!");

// ScriptStruct Altar.MeleeAttackSingle
// 0x0018 (0x0018 - 0x0000)
struct FMeleeAttackSingle final
{
public:
	class UAnimSequence*                          AttackRight;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AttackLeft;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PowerAttack;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeAttackSingle) == 0x000008, "Wrong alignment on FMeleeAttackSingle");
static_assert(sizeof(FMeleeAttackSingle) == 0x000018, "Wrong size on FMeleeAttackSingle");
static_assert(offsetof(FMeleeAttackSingle, AttackRight) == 0x000000, "Member 'FMeleeAttackSingle::AttackRight' has a wrong offset!");
static_assert(offsetof(FMeleeAttackSingle, AttackLeft) == 0x000008, "Member 'FMeleeAttackSingle::AttackLeft' has a wrong offset!");
static_assert(offsetof(FMeleeAttackSingle, PowerAttack) == 0x000010, "Member 'FMeleeAttackSingle::PowerAttack' has a wrong offset!");

// ScriptStruct Altar.BlockShieldAnimationData
// 0x0030 (0x0030 - 0x0000)
struct FBlockShieldAnimationData final
{
public:
	class UAnimSequence*                          BlockIdleSequence;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BlockHitSequence;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BlockShieldSequence;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BlockShieldHitSequence;                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BlockShieldBashMontage;                            // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            AimOffsetBlendSpace;                               // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockShieldAnimationData) == 0x000008, "Wrong alignment on FBlockShieldAnimationData");
static_assert(sizeof(FBlockShieldAnimationData) == 0x000030, "Wrong size on FBlockShieldAnimationData");
static_assert(offsetof(FBlockShieldAnimationData, BlockIdleSequence) == 0x000000, "Member 'FBlockShieldAnimationData::BlockIdleSequence' has a wrong offset!");
static_assert(offsetof(FBlockShieldAnimationData, BlockHitSequence) == 0x000008, "Member 'FBlockShieldAnimationData::BlockHitSequence' has a wrong offset!");
static_assert(offsetof(FBlockShieldAnimationData, BlockShieldSequence) == 0x000010, "Member 'FBlockShieldAnimationData::BlockShieldSequence' has a wrong offset!");
static_assert(offsetof(FBlockShieldAnimationData, BlockShieldHitSequence) == 0x000018, "Member 'FBlockShieldAnimationData::BlockShieldHitSequence' has a wrong offset!");
static_assert(offsetof(FBlockShieldAnimationData, BlockShieldBashMontage) == 0x000020, "Member 'FBlockShieldAnimationData::BlockShieldBashMontage' has a wrong offset!");
static_assert(offsetof(FBlockShieldAnimationData, AimOffsetBlendSpace) == 0x000028, "Member 'FBlockShieldAnimationData::AimOffsetBlendSpace' has a wrong offset!");

// ScriptStruct Altar.VBlockCharacterAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVBlockCharacterAnimInstanceProxy : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVBlockCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVBlockCharacterAnimInstanceProxy");
static_assert(sizeof(FVBlockCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVBlockCharacterAnimInstanceProxy");

// ScriptStruct Altar.MeleeAttackMultiple
// 0x0030 (0x0030 - 0x0000)
struct FMeleeAttackMultiple final
{
public:
	TArray<class UAnimSequence*>                  AttackRight;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  AttackLeft;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   PowerAttack;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeAttackMultiple) == 0x000008, "Wrong alignment on FMeleeAttackMultiple");
static_assert(sizeof(FMeleeAttackMultiple) == 0x000030, "Wrong size on FMeleeAttackMultiple");
static_assert(offsetof(FMeleeAttackMultiple, AttackRight) == 0x000000, "Member 'FMeleeAttackMultiple::AttackRight' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiple, AttackLeft) == 0x000010, "Member 'FMeleeAttackMultiple::AttackLeft' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiple, PowerAttack) == 0x000020, "Member 'FMeleeAttackMultiple::PowerAttack' has a wrong offset!");

// ScriptStruct Altar.VBlockShieldCharacterAnimInstanceProxy
// 0x0000 (0x0710 - 0x0710)
struct FVBlockShieldCharacterAnimInstanceProxy final : public FVBlockCharacterAnimInstanceProxy
{
};
static_assert(alignof(FVBlockShieldCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVBlockShieldCharacterAnimInstanceProxy");
static_assert(sizeof(FVBlockShieldCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVBlockShieldCharacterAnimInstanceProxy");

// ScriptStruct Altar.TagData
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FTagData final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTagData) == 0x000008, "Wrong alignment on FTagData");
static_assert(sizeof(FTagData) == 0x000068, "Wrong size on FTagData");

// ScriptStruct Altar.VSpecialIdleAndDockCharacterAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVSpecialIdleAndDockCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVSpecialIdleAndDockCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVSpecialIdleAndDockCharacterAnimInstanceProxy");
static_assert(sizeof(FVSpecialIdleAndDockCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVSpecialIdleAndDockCharacterAnimInstanceProxy");

// ScriptStruct Altar.LegacyBookTagProperties
// 0x0028 (0x0028 - 0x0000)
struct FLegacyBookTagProperties final
{
public:
	class FString                                 TagText;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELegacyBookTagType                            TagType;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                FontObject;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELegacyBookStylizedTextAlignment              AlignmentValue;                                    // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyBookTagProperties) == 0x000008, "Wrong alignment on FLegacyBookTagProperties");
static_assert(sizeof(FLegacyBookTagProperties) == 0x000028, "Wrong size on FLegacyBookTagProperties");
static_assert(offsetof(FLegacyBookTagProperties, TagText) == 0x000000, "Member 'FLegacyBookTagProperties::TagText' has a wrong offset!");
static_assert(offsetof(FLegacyBookTagProperties, TagType) == 0x000010, "Member 'FLegacyBookTagProperties::TagType' has a wrong offset!");
static_assert(offsetof(FLegacyBookTagProperties, FontObject) == 0x000018, "Member 'FLegacyBookTagProperties::FontObject' has a wrong offset!");
static_assert(offsetof(FLegacyBookTagProperties, Color) == 0x000020, "Member 'FLegacyBookTagProperties::Color' has a wrong offset!");
static_assert(offsetof(FLegacyBookTagProperties, AlignmentValue) == 0x000024, "Member 'FLegacyBookTagProperties::AlignmentValue' has a wrong offset!");

// ScriptStruct Altar.ModernSettingStepProperties
// 0x0018 (0x0018 - 0x0000)
struct FModernSettingStepProperties final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultIndex;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FModernSettingSingleCommand>    Steps;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernSettingStepProperties) == 0x000008, "Wrong alignment on FModernSettingStepProperties");
static_assert(sizeof(FModernSettingStepProperties) == 0x000018, "Wrong size on FModernSettingStepProperties");
static_assert(offsetof(FModernSettingStepProperties, Index) == 0x000000, "Member 'FModernSettingStepProperties::Index' has a wrong offset!");
static_assert(offsetof(FModernSettingStepProperties, DefaultIndex) == 0x000004, "Member 'FModernSettingStepProperties::DefaultIndex' has a wrong offset!");
static_assert(offsetof(FModernSettingStepProperties, Steps) == 0x000008, "Member 'FModernSettingStepProperties::Steps' has a wrong offset!");

// ScriptStruct Altar.LegacyBookProperties
// 0x0018 (0x0018 - 0x0000)
struct FLegacyBookProperties final
{
public:
	TArray<struct FLegacyBookStylizedText>        FormatedBookText;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsAScroll;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeTaken;                                        // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyBookProperties) == 0x000008, "Wrong alignment on FLegacyBookProperties");
static_assert(sizeof(FLegacyBookProperties) == 0x000018, "Wrong size on FLegacyBookProperties");
static_assert(offsetof(FLegacyBookProperties, FormatedBookText) == 0x000000, "Member 'FLegacyBookProperties::FormatedBookText' has a wrong offset!");
static_assert(offsetof(FLegacyBookProperties, IsAScroll) == 0x000010, "Member 'FLegacyBookProperties::IsAScroll' has a wrong offset!");
static_assert(offsetof(FLegacyBookProperties, CanBeTaken) == 0x000011, "Member 'FLegacyBookProperties::CanBeTaken' has a wrong offset!");

// ScriptStruct Altar.VBossDataTableRow
// 0x0018 (0x0020 - 0x0008)
struct FVBossDataTableRow final : public FTableRowBase
{
public:
	class FString                                 EditorID;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVBossCategory                                Category;                                          // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVBossDataTableRow) == 0x000008, "Wrong alignment on FVBossDataTableRow");
static_assert(sizeof(FVBossDataTableRow) == 0x000020, "Wrong size on FVBossDataTableRow");
static_assert(offsetof(FVBossDataTableRow, EditorID) == 0x000008, "Member 'FVBossDataTableRow::EditorID' has a wrong offset!");
static_assert(offsetof(FVBossDataTableRow, Category) == 0x000018, "Member 'FVBossDataTableRow::Category' has a wrong offset!");

// ScriptStruct Altar.LegacySpellPurchaseMenuItemProperties
// 0x0050 (0x0050 - 0x0000)
struct FLegacySpellPurchaseMenuItemProperties final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Costs;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoldCost;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELegacySpellPurchaseMenuItemCategory          Category;                                          // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELegacySpellPurchaseMenuItemType              Type;                                              // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELegacySpellPurchaseMenuSpellSchool           School;                                            // 0x002E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CannotCastReason;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsImmuneToSilence;                                // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpellId;                                           // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySpellPurchaseMenuItemProperties) == 0x000008, "Wrong alignment on FLegacySpellPurchaseMenuItemProperties");
static_assert(sizeof(FLegacySpellPurchaseMenuItemProperties) == 0x000050, "Wrong size on FLegacySpellPurchaseMenuItemProperties");
static_assert(offsetof(FLegacySpellPurchaseMenuItemProperties, Name) == 0x000000, "Member 'FLegacySpellPurchaseMenuItemProperties::Name' has a wrong offset!");
static_assert(offsetof(FLegacySpellPurchaseMenuItemProperties, Costs) == 0x000018, "Member 'FLegacySpellPurchaseMenuItemProperties::Costs' has a wrong offset!");
static_assert(offsetof(FLegacySpellPurchaseMenuItemProperties, Icon) == 0x000020, "Member 'FLegacySpellPurchaseMenuItemProperties::Icon' has a wrong offset!");
static_assert(offsetof(FLegacySpellPurchaseMenuItemProperties, GoldCost) == 0x000028, "Member 'FLegacySpellPurchaseMenuItemProperties::GoldCost' has a wrong offset!");
static_assert(offsetof(FLegacySpellPurchaseMenuItemProperties, Category) == 0x00002C, "Member 'FLegacySpellPurchaseMenuItemProperties::Category' has a wrong offset!");
static_assert(offsetof(FLegacySpellPurchaseMenuItemProperties, Type) == 0x00002D, "Member 'FLegacySpellPurchaseMenuItemProperties::Type' has a wrong offset!");
static_assert(offsetof(FLegacySpellPurchaseMenuItemProperties, School) == 0x00002E, "Member 'FLegacySpellPurchaseMenuItemProperties::School' has a wrong offset!");
static_assert(offsetof(FLegacySpellPurchaseMenuItemProperties, CannotCastReason) == 0x000030, "Member 'FLegacySpellPurchaseMenuItemProperties::CannotCastReason' has a wrong offset!");
static_assert(offsetof(FLegacySpellPurchaseMenuItemProperties, bIsImmuneToSilence) == 0x000048, "Member 'FLegacySpellPurchaseMenuItemProperties::bIsImmuneToSilence' has a wrong offset!");
static_assert(offsetof(FLegacySpellPurchaseMenuItemProperties, SpellId) == 0x00004C, "Member 'FLegacySpellPurchaseMenuItemProperties::SpellId' has a wrong offset!");

// ScriptStruct Altar.VBowAttack
// 0x0020 (0x0020 - 0x0000)
struct FVBowAttack final
{
public:
	class UAnimSequenceBase*                      Start;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Loop;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Release;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            AimOffsetBlendSpace;                               // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVBowAttack) == 0x000008, "Wrong alignment on FVBowAttack");
static_assert(sizeof(FVBowAttack) == 0x000020, "Wrong size on FVBowAttack");
static_assert(offsetof(FVBowAttack, Start) == 0x000000, "Member 'FVBowAttack::Start' has a wrong offset!");
static_assert(offsetof(FVBowAttack, Loop) == 0x000008, "Member 'FVBowAttack::Loop' has a wrong offset!");
static_assert(offsetof(FVBowAttack, Release) == 0x000010, "Member 'FVBowAttack::Release' has a wrong offset!");
static_assert(offsetof(FVBowAttack, AimOffsetBlendSpace) == 0x000018, "Member 'FVBowAttack::AimOffsetBlendSpace' has a wrong offset!");

// ScriptStruct Altar.VPersuasionMiniGameButtonData
// 0x0003 (0x0003 - 0x0000)
struct FVPersuasionMiniGameButtonData final
{
public:
	bool                                          bAlreadyClicked;                                   // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWedgeData                             WedgeData;                                         // 0x0001(0x0002)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVPersuasionMiniGameButtonData) == 0x000001, "Wrong alignment on FVPersuasionMiniGameButtonData");
static_assert(sizeof(FVPersuasionMiniGameButtonData) == 0x000003, "Wrong size on FVPersuasionMiniGameButtonData");
static_assert(offsetof(FVPersuasionMiniGameButtonData, bAlreadyClicked) == 0x000000, "Member 'FVPersuasionMiniGameButtonData::bAlreadyClicked' has a wrong offset!");
static_assert(offsetof(FVPersuasionMiniGameButtonData, WedgeData) == 0x000001, "Member 'FVPersuasionMiniGameButtonData::WedgeData' has a wrong offset!");

// ScriptStruct Altar.VPontoonGenerationDecision
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FVPontoonGenerationDecision final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVPontoonGenerationDecision) == 0x000004, "Wrong alignment on FVPontoonGenerationDecision");
static_assert(sizeof(FVPontoonGenerationDecision) == 0x00000C, "Wrong size on FVPontoonGenerationDecision");

// ScriptStruct Altar.VBodyInstancePartition
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FVBodyInstancePartition final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVBodyInstancePartition) == 0x000008, "Wrong alignment on FVBodyInstancePartition");
static_assert(sizeof(FVBodyInstancePartition) == 0x000038, "Wrong size on FVBodyInstancePartition");

// ScriptStruct Altar.VAIControllerCombatData
// 0x0058 (0x0058 - 0x0000)
struct FVAIControllerCombatData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         fAcceptanceRadius;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVOblivionStrategy                            Strategy;                                          // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVOblivionManeuver                            Maneuver;                                          // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVOblivionCombatState                         CombatState;                                       // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DirectionalMovementVector;                         // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PositionMovementDestination;                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReachTarget;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVAIControllerCombatData) == 0x000008, "Wrong alignment on FVAIControllerCombatData");
static_assert(sizeof(FVAIControllerCombatData) == 0x000058, "Wrong size on FVAIControllerCombatData");
static_assert(offsetof(FVAIControllerCombatData, fAcceptanceRadius) == 0x00000C, "Member 'FVAIControllerCombatData::fAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(FVAIControllerCombatData, TargetActor) == 0x000010, "Member 'FVAIControllerCombatData::TargetActor' has a wrong offset!");
static_assert(offsetof(FVAIControllerCombatData, Strategy) == 0x000018, "Member 'FVAIControllerCombatData::Strategy' has a wrong offset!");
static_assert(offsetof(FVAIControllerCombatData, Maneuver) == 0x000019, "Member 'FVAIControllerCombatData::Maneuver' has a wrong offset!");
static_assert(offsetof(FVAIControllerCombatData, CombatState) == 0x00001A, "Member 'FVAIControllerCombatData::CombatState' has a wrong offset!");
static_assert(offsetof(FVAIControllerCombatData, DirectionalMovementVector) == 0x000020, "Member 'FVAIControllerCombatData::DirectionalMovementVector' has a wrong offset!");
static_assert(offsetof(FVAIControllerCombatData, PositionMovementDestination) == 0x000038, "Member 'FVAIControllerCombatData::PositionMovementDestination' has a wrong offset!");
static_assert(offsetof(FVAIControllerCombatData, bCanReachTarget) == 0x000050, "Member 'FVAIControllerCombatData::bCanReachTarget' has a wrong offset!");

// ScriptStruct Altar.VBodyPontoonInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FVBodyPontoonInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVBodyPontoonInfo) == 0x000008, "Wrong alignment on FVBodyPontoonInfo");
static_assert(sizeof(FVBodyPontoonInfo) == 0x000030, "Wrong size on FVBodyPontoonInfo");

// ScriptStruct Altar.OblivionNPCFaceGenData
// 0x0030 (0x0030 - 0x0000)
struct FOblivionNPCFaceGenData final
{
public:
	TArray<float>                                 SymmetricalGeometryData;                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AsymmetricalGeometryData;                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 TextureData;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOblivionNPCFaceGenData) == 0x000008, "Wrong alignment on FOblivionNPCFaceGenData");
static_assert(sizeof(FOblivionNPCFaceGenData) == 0x000030, "Wrong size on FOblivionNPCFaceGenData");
static_assert(offsetof(FOblivionNPCFaceGenData, SymmetricalGeometryData) == 0x000000, "Member 'FOblivionNPCFaceGenData::SymmetricalGeometryData' has a wrong offset!");
static_assert(offsetof(FOblivionNPCFaceGenData, AsymmetricalGeometryData) == 0x000010, "Member 'FOblivionNPCFaceGenData::AsymmetricalGeometryData' has a wrong offset!");
static_assert(offsetof(FOblivionNPCFaceGenData, TextureData) == 0x000020, "Member 'FOblivionNPCFaceGenData::TextureData' has a wrong offset!");

// ScriptStruct Altar.VVelocityAndFallTimerMovementData
// 0x0020 (0x0020 - 0x0000)
struct FVVelocityAndFallTimerMovementData final
{
public:
	struct FVector                                SavedVelocity;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SavedFallTimer;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVVelocityAndFallTimerMovementData) == 0x000008, "Wrong alignment on FVVelocityAndFallTimerMovementData");
static_assert(sizeof(FVVelocityAndFallTimerMovementData) == 0x000020, "Wrong size on FVVelocityAndFallTimerMovementData");
static_assert(offsetof(FVVelocityAndFallTimerMovementData, SavedVelocity) == 0x000000, "Member 'FVVelocityAndFallTimerMovementData::SavedVelocity' has a wrong offset!");
static_assert(offsetof(FVVelocityAndFallTimerMovementData, SavedFallTimer) == 0x000018, "Member 'FVVelocityAndFallTimerMovementData::SavedFallTimer' has a wrong offset!");

// ScriptStruct Altar.CharacterFaceMorphAxis
// 0x0010 (0x0010 - 0x0000)
struct FCharacterFaceMorphAxis final
{
public:
	class FName                                   NegativeMorphTargetName;                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PositiveMorphTargetName;                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterFaceMorphAxis) == 0x000004, "Wrong alignment on FCharacterFaceMorphAxis");
static_assert(sizeof(FCharacterFaceMorphAxis) == 0x000010, "Wrong size on FCharacterFaceMorphAxis");
static_assert(offsetof(FCharacterFaceMorphAxis, NegativeMorphTargetName) == 0x000000, "Member 'FCharacterFaceMorphAxis::NegativeMorphTargetName' has a wrong offset!");
static_assert(offsetof(FCharacterFaceMorphAxis, PositiveMorphTargetName) == 0x000008, "Member 'FCharacterFaceMorphAxis::PositiveMorphTargetName' has a wrong offset!");

// ScriptStruct Altar.VCharacterHairPieceMeshPair
// 0x0050 (0x0050 - 0x0000)
struct FVCharacterHairPieceMeshPair final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           MeshComponent;                                     // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           MeshShadowProxyComponent;                          // 0x0028(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVCharacterHairPieceMeshPair) == 0x000008, "Wrong alignment on FVCharacterHairPieceMeshPair");
static_assert(sizeof(FVCharacterHairPieceMeshPair) == 0x000050, "Wrong size on FVCharacterHairPieceMeshPair");
static_assert(offsetof(FVCharacterHairPieceMeshPair, MeshComponent) == 0x000000, "Member 'FVCharacterHairPieceMeshPair::MeshComponent' has a wrong offset!");
static_assert(offsetof(FVCharacterHairPieceMeshPair, MeshShadowProxyComponent) == 0x000028, "Member 'FVCharacterHairPieceMeshPair::MeshShadowProxyComponent' has a wrong offset!");

// ScriptStruct Altar.VPawnPhysicsInteractionData
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FVPawnPhysicsInteractionData final
{
public:
	TWeakObjectPtr<class AVPairedPawn>            PawnA;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AVPairedPawn>            PawnB;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x58];                                      // 0x0010(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVPawnPhysicsInteractionData) == 0x000008, "Wrong alignment on FVPawnPhysicsInteractionData");
static_assert(sizeof(FVPawnPhysicsInteractionData) == 0x000068, "Wrong size on FVPawnPhysicsInteractionData");
static_assert(offsetof(FVPawnPhysicsInteractionData, PawnA) == 0x000000, "Member 'FVPawnPhysicsInteractionData::PawnA' has a wrong offset!");
static_assert(offsetof(FVPawnPhysicsInteractionData, PawnB) == 0x000008, "Member 'FVPawnPhysicsInteractionData::PawnB' has a wrong offset!");

// ScriptStruct Altar.VSexAndRaceMapKey
// 0x0030 (0x0030 - 0x0000)
struct FVSexAndRaceMapKey final
{
public:
	ECharacterSex                                 Sex;                                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTESRace>                Race;                                              // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSexAndRaceMapKey) == 0x000008, "Wrong alignment on FVSexAndRaceMapKey");
static_assert(sizeof(FVSexAndRaceMapKey) == 0x000030, "Wrong size on FVSexAndRaceMapKey");
static_assert(offsetof(FVSexAndRaceMapKey, Sex) == 0x000000, "Member 'FVSexAndRaceMapKey::Sex' has a wrong offset!");
static_assert(offsetof(FVSexAndRaceMapKey, Race) == 0x000008, "Member 'FVSexAndRaceMapKey::Race' has a wrong offset!");

// ScriptStruct Altar.OblivionToAltarFaceConversionValue
// 0x0018 (0x0018 - 0x0000)
struct FOblivionToAltarFaceConversionValue final
{
public:
	class FName                                   AltarMorphAxisName;                                // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConversionMultiplier;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConversionBias;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMin;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOblivionToAltarFaceConversionValue) == 0x000004, "Wrong alignment on FOblivionToAltarFaceConversionValue");
static_assert(sizeof(FOblivionToAltarFaceConversionValue) == 0x000018, "Wrong size on FOblivionToAltarFaceConversionValue");
static_assert(offsetof(FOblivionToAltarFaceConversionValue, AltarMorphAxisName) == 0x000000, "Member 'FOblivionToAltarFaceConversionValue::AltarMorphAxisName' has a wrong offset!");
static_assert(offsetof(FOblivionToAltarFaceConversionValue, ConversionMultiplier) == 0x000008, "Member 'FOblivionToAltarFaceConversionValue::ConversionMultiplier' has a wrong offset!");
static_assert(offsetof(FOblivionToAltarFaceConversionValue, ConversionBias) == 0x00000C, "Member 'FOblivionToAltarFaceConversionValue::ConversionBias' has a wrong offset!");
static_assert(offsetof(FOblivionToAltarFaceConversionValue, ClampMax) == 0x000010, "Member 'FOblivionToAltarFaceConversionValue::ClampMax' has a wrong offset!");
static_assert(offsetof(FOblivionToAltarFaceConversionValue, ClampMin) == 0x000014, "Member 'FOblivionToAltarFaceConversionValue::ClampMin' has a wrong offset!");

// ScriptStruct Altar.VCharacterSkinParameterModifier
// 0x0008 (0x0008 - 0x0000)
struct FVCharacterSkinParameterModifier final
{
public:
	float                                         ClampMin;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVCharacterSkinParameterModifier) == 0x000004, "Wrong alignment on FVCharacterSkinParameterModifier");
static_assert(sizeof(FVCharacterSkinParameterModifier) == 0x000008, "Wrong size on FVCharacterSkinParameterModifier");
static_assert(offsetof(FVCharacterSkinParameterModifier, ClampMin) == 0x000000, "Member 'FVCharacterSkinParameterModifier::ClampMin' has a wrong offset!");
static_assert(offsetof(FVCharacterSkinParameterModifier, ClampMax) == 0x000004, "Member 'FVCharacterSkinParameterModifier::ClampMax' has a wrong offset!");

// ScriptStruct Altar.VCharacterSkinParameter
// 0x0070 (0x0070 - 0x0000)
struct FVCharacterSkinParameter final
{
public:
	int32                                         PrimitiveSlot;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVCharacterParameterType                      ParameterType;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultColorL;                                     // 0x000C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfSucessiveSlots;                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EVSenescenceModifiers, struct FVCharacterSkinParameterModifier> Modifiers;                  // 0x0020(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVCharacterSkinParameter) == 0x000008, "Wrong alignment on FVCharacterSkinParameter");
static_assert(sizeof(FVCharacterSkinParameter) == 0x000070, "Wrong size on FVCharacterSkinParameter");
static_assert(offsetof(FVCharacterSkinParameter, PrimitiveSlot) == 0x000000, "Member 'FVCharacterSkinParameter::PrimitiveSlot' has a wrong offset!");
static_assert(offsetof(FVCharacterSkinParameter, ParameterType) == 0x000004, "Member 'FVCharacterSkinParameter::ParameterType' has a wrong offset!");
static_assert(offsetof(FVCharacterSkinParameter, DefaultValue) == 0x000008, "Member 'FVCharacterSkinParameter::DefaultValue' has a wrong offset!");
static_assert(offsetof(FVCharacterSkinParameter, DefaultColorL) == 0x00000C, "Member 'FVCharacterSkinParameter::DefaultColorL' has a wrong offset!");
static_assert(offsetof(FVCharacterSkinParameter, NumberOfSucessiveSlots) == 0x00001C, "Member 'FVCharacterSkinParameter::NumberOfSucessiveSlots' has a wrong offset!");
static_assert(offsetof(FVCharacterSkinParameter, Modifiers) == 0x000020, "Member 'FVCharacterSkinParameter::Modifiers' has a wrong offset!");

// ScriptStruct Altar.VBodyDampingData
// 0x0008 (0x0008 - 0x0000)
struct FVBodyDampingData final
{
public:
	float                                         LinearDamping;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVBodyDampingData) == 0x000004, "Wrong alignment on FVBodyDampingData");
static_assert(sizeof(FVBodyDampingData) == 0x000008, "Wrong size on FVBodyDampingData");
static_assert(offsetof(FVBodyDampingData, LinearDamping) == 0x000000, "Member 'FVBodyDampingData::LinearDamping' has a wrong offset!");
static_assert(offsetof(FVBodyDampingData, AngularDamping) == 0x000004, "Member 'FVBodyDampingData::AngularDamping' has a wrong offset!");

// ScriptStruct Altar.VAltarCinematicState
// 0x0008 (0x0008 - 0x0000)
struct FVAltarCinematicState final
{
public:
	struct FFrameTime                             CinematicFrameTime;                                // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVAltarCinematicState) == 0x000004, "Wrong alignment on FVAltarCinematicState");
static_assert(sizeof(FVAltarCinematicState) == 0x000008, "Wrong size on FVAltarCinematicState");
static_assert(offsetof(FVAltarCinematicState, CinematicFrameTime) == 0x000000, "Member 'FVAltarCinematicState::CinematicFrameTime' has a wrong offset!");

// ScriptStruct Altar.LegacyCodexMenuEntry
// 0x0068 (0x0070 - 0x0008)
struct FLegacyCodexMenuEntry final : public FTableRowBase
{
public:
	class FText                                   EntryName;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   EntryCategory;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CardTitle;                                         // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CardText;                                          // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             CardTexture;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyCodexMenuEntry) == 0x000008, "Wrong alignment on FLegacyCodexMenuEntry");
static_assert(sizeof(FLegacyCodexMenuEntry) == 0x000070, "Wrong size on FLegacyCodexMenuEntry");
static_assert(offsetof(FLegacyCodexMenuEntry, EntryName) == 0x000008, "Member 'FLegacyCodexMenuEntry::EntryName' has a wrong offset!");
static_assert(offsetof(FLegacyCodexMenuEntry, EntryCategory) == 0x000020, "Member 'FLegacyCodexMenuEntry::EntryCategory' has a wrong offset!");
static_assert(offsetof(FLegacyCodexMenuEntry, CardTitle) == 0x000038, "Member 'FLegacyCodexMenuEntry::CardTitle' has a wrong offset!");
static_assert(offsetof(FLegacyCodexMenuEntry, CardText) == 0x000050, "Member 'FLegacyCodexMenuEntry::CardText' has a wrong offset!");
static_assert(offsetof(FLegacyCodexMenuEntry, CardTexture) == 0x000068, "Member 'FLegacyCodexMenuEntry::CardTexture' has a wrong offset!");

// ScriptStruct Altar.VHitReactEvent
// 0x0048 (0x0048 - 0x0000)
struct FVHitReactEvent final
{
public:
	struct FVector                                WorldSpaceHitLocation;                             // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldSpaceHitDirection;                            // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Attacker;                                          // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackerWeaponTag;                                 // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPowerAttack;                                    // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArrowAttack;                                    // 0x0041(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpellAttack;                                    // 0x0042(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTrapAttack;                                     // 0x0043(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVHitReactEvent) == 0x000008, "Wrong alignment on FVHitReactEvent");
static_assert(sizeof(FVHitReactEvent) == 0x000048, "Wrong size on FVHitReactEvent");
static_assert(offsetof(FVHitReactEvent, WorldSpaceHitLocation) == 0x000000, "Member 'FVHitReactEvent::WorldSpaceHitLocation' has a wrong offset!");
static_assert(offsetof(FVHitReactEvent, WorldSpaceHitDirection) == 0x000018, "Member 'FVHitReactEvent::WorldSpaceHitDirection' has a wrong offset!");
static_assert(offsetof(FVHitReactEvent, Attacker) == 0x000030, "Member 'FVHitReactEvent::Attacker' has a wrong offset!");
static_assert(offsetof(FVHitReactEvent, AttackerWeaponTag) == 0x000038, "Member 'FVHitReactEvent::AttackerWeaponTag' has a wrong offset!");
static_assert(offsetof(FVHitReactEvent, bIsPowerAttack) == 0x000040, "Member 'FVHitReactEvent::bIsPowerAttack' has a wrong offset!");
static_assert(offsetof(FVHitReactEvent, bIsArrowAttack) == 0x000041, "Member 'FVHitReactEvent::bIsArrowAttack' has a wrong offset!");
static_assert(offsetof(FVHitReactEvent, bIsSpellAttack) == 0x000042, "Member 'FVHitReactEvent::bIsSpellAttack' has a wrong offset!");
static_assert(offsetof(FVHitReactEvent, bIsTrapAttack) == 0x000043, "Member 'FVHitReactEvent::bIsTrapAttack' has a wrong offset!");

// ScriptStruct Altar.ConversationIdleData
// 0x0020 (0x0020 - 0x0000)
struct FConversationIdleData final
{
public:
	TArray<class UAnimSequence*>                  Animations;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              TimeBetweenAnimations;                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConversationIdleData) == 0x000008, "Wrong alignment on FConversationIdleData");
static_assert(sizeof(FConversationIdleData) == 0x000020, "Wrong size on FConversationIdleData");
static_assert(offsetof(FConversationIdleData, Animations) == 0x000000, "Member 'FConversationIdleData::Animations' has a wrong offset!");
static_assert(offsetof(FConversationIdleData, TimeBetweenAnimations) == 0x000010, "Member 'FConversationIdleData::TimeBetweenAnimations' has a wrong offset!");

// ScriptStruct Altar.VConversationIdleAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVConversationIdleAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVConversationIdleAnimInstanceProxy) == 0x000010, "Wrong alignment on FVConversationIdleAnimInstanceProxy");
static_assert(sizeof(FVConversationIdleAnimInstanceProxy) == 0x000710, "Wrong size on FVConversationIdleAnimInstanceProxy");

// ScriptStruct Altar.ModernSettingCustomProperties
// 0x0018 (0x0018 - 0x0000)
struct FModernSettingCustomProperties final
{
public:
	TSubclassOf<class UUserWidget>                Widget;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CVAR;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernSettingCustomProperties) == 0x000008, "Wrong alignment on FModernSettingCustomProperties");
static_assert(sizeof(FModernSettingCustomProperties) == 0x000018, "Wrong size on FModernSettingCustomProperties");
static_assert(offsetof(FModernSettingCustomProperties, Widget) == 0x000000, "Member 'FModernSettingCustomProperties::Widget' has a wrong offset!");
static_assert(offsetof(FModernSettingCustomProperties, CVAR) == 0x000008, "Member 'FModernSettingCustomProperties::CVAR' has a wrong offset!");

// ScriptStruct Altar.DeathAnimationData
// 0x0008 (0x0008 - 0x0000)
struct FDeathAnimationData final
{
public:
	class UAnimMontage*                           Death;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeathAnimationData) == 0x000008, "Wrong alignment on FDeathAnimationData");
static_assert(sizeof(FDeathAnimationData) == 0x000008, "Wrong size on FDeathAnimationData");
static_assert(offsetof(FDeathAnimationData, Death) == 0x000000, "Member 'FDeathAnimationData::Death' has a wrong offset!");

// ScriptStruct Altar.LegacyDialogMenuButtonVisibility
// 0x0008 (0x0010 - 0x0008)
struct FLegacyDialogMenuButtonVisibility final : public FTableRowBase
{
public:
	bool                                          bPersuasion;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBarter;                                           // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpellBarter;                                      // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepairing;                                        // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraining;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecharging;                                       // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGoodbye;                                          // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyDialogMenuButtonVisibility) == 0x000008, "Wrong alignment on FLegacyDialogMenuButtonVisibility");
static_assert(sizeof(FLegacyDialogMenuButtonVisibility) == 0x000010, "Wrong size on FLegacyDialogMenuButtonVisibility");
static_assert(offsetof(FLegacyDialogMenuButtonVisibility, bPersuasion) == 0x000008, "Member 'FLegacyDialogMenuButtonVisibility::bPersuasion' has a wrong offset!");
static_assert(offsetof(FLegacyDialogMenuButtonVisibility, bBarter) == 0x000009, "Member 'FLegacyDialogMenuButtonVisibility::bBarter' has a wrong offset!");
static_assert(offsetof(FLegacyDialogMenuButtonVisibility, bSpellBarter) == 0x00000A, "Member 'FLegacyDialogMenuButtonVisibility::bSpellBarter' has a wrong offset!");
static_assert(offsetof(FLegacyDialogMenuButtonVisibility, bRepairing) == 0x00000B, "Member 'FLegacyDialogMenuButtonVisibility::bRepairing' has a wrong offset!");
static_assert(offsetof(FLegacyDialogMenuButtonVisibility, bTraining) == 0x00000C, "Member 'FLegacyDialogMenuButtonVisibility::bTraining' has a wrong offset!");
static_assert(offsetof(FLegacyDialogMenuButtonVisibility, bRecharging) == 0x00000D, "Member 'FLegacyDialogMenuButtonVisibility::bRecharging' has a wrong offset!");
static_assert(offsetof(FLegacyDialogMenuButtonVisibility, bGoodbye) == 0x00000E, "Member 'FLegacyDialogMenuButtonVisibility::bGoodbye' has a wrong offset!");

// ScriptStruct Altar.VSpecialIdleAndDockData
// 0x0040 (0x0040 - 0x0000)
struct FVSpecialIdleAndDockData final
{
public:
	class FName                                   TorchBlendBoneName;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpperBodyBoneName;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperBodyBlendDepth;                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SleepBedIdle;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SleepBedrollIdle;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      VampireSleepIdle;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SitChairIdle;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      HorseRiderIdle;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSpecialIdleAndDockData) == 0x000008, "Wrong alignment on FVSpecialIdleAndDockData");
static_assert(sizeof(FVSpecialIdleAndDockData) == 0x000040, "Wrong size on FVSpecialIdleAndDockData");
static_assert(offsetof(FVSpecialIdleAndDockData, TorchBlendBoneName) == 0x000000, "Member 'FVSpecialIdleAndDockData::TorchBlendBoneName' has a wrong offset!");
static_assert(offsetof(FVSpecialIdleAndDockData, UpperBodyBoneName) == 0x000008, "Member 'FVSpecialIdleAndDockData::UpperBodyBoneName' has a wrong offset!");
static_assert(offsetof(FVSpecialIdleAndDockData, UpperBodyBlendDepth) == 0x000010, "Member 'FVSpecialIdleAndDockData::UpperBodyBlendDepth' has a wrong offset!");
static_assert(offsetof(FVSpecialIdleAndDockData, SleepBedIdle) == 0x000018, "Member 'FVSpecialIdleAndDockData::SleepBedIdle' has a wrong offset!");
static_assert(offsetof(FVSpecialIdleAndDockData, SleepBedrollIdle) == 0x000020, "Member 'FVSpecialIdleAndDockData::SleepBedrollIdle' has a wrong offset!");
static_assert(offsetof(FVSpecialIdleAndDockData, VampireSleepIdle) == 0x000028, "Member 'FVSpecialIdleAndDockData::VampireSleepIdle' has a wrong offset!");
static_assert(offsetof(FVSpecialIdleAndDockData, SitChairIdle) == 0x000030, "Member 'FVSpecialIdleAndDockData::SitChairIdle' has a wrong offset!");
static_assert(offsetof(FVSpecialIdleAndDockData, HorseRiderIdle) == 0x000038, "Member 'FVSpecialIdleAndDockData::HorseRiderIdle' has a wrong offset!");

// ScriptStruct Altar.ResponsesData
// 0x0020 (0x0020 - 0x0000)
struct FResponsesData final
{
public:
	class FText                                   ResponseText;                                      // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         ResponseID;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNewResponse;                                    // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResponsesData) == 0x000008, "Wrong alignment on FResponsesData");
static_assert(sizeof(FResponsesData) == 0x000020, "Wrong size on FResponsesData");
static_assert(offsetof(FResponsesData, ResponseText) == 0x000000, "Member 'FResponsesData::ResponseText' has a wrong offset!");
static_assert(offsetof(FResponsesData, ResponseID) == 0x000018, "Member 'FResponsesData::ResponseID' has a wrong offset!");
static_assert(offsetof(FResponsesData, bIsNewResponse) == 0x00001C, "Member 'FResponsesData::bIsNewResponse' has a wrong offset!");

// ScriptStruct Altar.DodgeAnimationData
// 0x0050 (0x0050 - 0x0000)
struct FDodgeAnimationData final
{
public:
	TMap<EDodgeDirection, class UAnimMontage*>    DodgeAnimations;                                   // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDodgeAnimationData) == 0x000008, "Wrong alignment on FDodgeAnimationData");
static_assert(sizeof(FDodgeAnimationData) == 0x000050, "Wrong size on FDodgeAnimationData");
static_assert(offsetof(FDodgeAnimationData, DodgeAnimations) == 0x000000, "Member 'FDodgeAnimationData::DodgeAnimations' has a wrong offset!");

// ScriptStruct Altar.VPhysicsControllableDebugData
// 0x00D0 (0x00D0 - 0x0000)
struct FVPhysicsControllableDebugData final
{
public:
	class FName                                   LabelName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClassName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InstanceIDName;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReferenceIDName;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGrabbable;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTelekinesisTargetable;                          // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnchored;                                       // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVPhysicsSimulationBehaviour                  SimulationBehaviour;                               // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVPhysicsLoadingBehaviour                     PhysicsLoadingBehaviour;                           // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesRepositionOnLoad;                             // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesReattachOnLoad;                               // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesRestoreAttachmentAfterSimulation;             // 0x0027(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesGeneratePontoonsAtRuntime;                    // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GeneratedPontoonSizeScale;                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuoyancyCoefficient;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesPlayCollisionSound;                           // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVDefaultSurfaceType                          DefaultSelfSurfaceType;                            // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPaired;                                         // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0037(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSimulating;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVConstrainingMode                            ConstrainingMode;                                  // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSleeping;                                       // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsingBuoyancy;                                  // 0x003B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGrabbed;                                        // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVPhysicsSettingsAuthority                    ControlSettingsAuthority;                          // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVPhysicsSettingsAuthority                    CollisionProfileAuthority;                         // 0x003E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVPhysicsSettingsAuthority                    WeightsAuthority;                                  // 0x003F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVPhysicsSettingsAuthority                    DampingValuesAuthority;                            // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVPhysicsSettingsAuthority                    NavigationSettingsAuthority;                       // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UVPrimitiveComponentDebugData*>  PrimitiveComponentsData;                           // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ControllableTransform;                             // 0x0060(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVPhysicsControllableDebugData) == 0x000010, "Wrong alignment on FVPhysicsControllableDebugData");
static_assert(sizeof(FVPhysicsControllableDebugData) == 0x0000D0, "Wrong size on FVPhysicsControllableDebugData");
static_assert(offsetof(FVPhysicsControllableDebugData, LabelName) == 0x000000, "Member 'FVPhysicsControllableDebugData::LabelName' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, ClassName) == 0x000008, "Member 'FVPhysicsControllableDebugData::ClassName' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, InstanceIDName) == 0x000010, "Member 'FVPhysicsControllableDebugData::InstanceIDName' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, ReferenceIDName) == 0x000018, "Member 'FVPhysicsControllableDebugData::ReferenceIDName' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bIsGrabbable) == 0x000020, "Member 'FVPhysicsControllableDebugData::bIsGrabbable' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bIsTelekinesisTargetable) == 0x000021, "Member 'FVPhysicsControllableDebugData::bIsTelekinesisTargetable' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bIsAnchored) == 0x000022, "Member 'FVPhysicsControllableDebugData::bIsAnchored' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, SimulationBehaviour) == 0x000023, "Member 'FVPhysicsControllableDebugData::SimulationBehaviour' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, PhysicsLoadingBehaviour) == 0x000024, "Member 'FVPhysicsControllableDebugData::PhysicsLoadingBehaviour' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bDoesRepositionOnLoad) == 0x000025, "Member 'FVPhysicsControllableDebugData::bDoesRepositionOnLoad' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bDoesReattachOnLoad) == 0x000026, "Member 'FVPhysicsControllableDebugData::bDoesReattachOnLoad' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bDoesRestoreAttachmentAfterSimulation) == 0x000027, "Member 'FVPhysicsControllableDebugData::bDoesRestoreAttachmentAfterSimulation' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bDoesGeneratePontoonsAtRuntime) == 0x000028, "Member 'FVPhysicsControllableDebugData::bDoesGeneratePontoonsAtRuntime' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, GeneratedPontoonSizeScale) == 0x00002C, "Member 'FVPhysicsControllableDebugData::GeneratedPontoonSizeScale' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, BuoyancyCoefficient) == 0x000030, "Member 'FVPhysicsControllableDebugData::BuoyancyCoefficient' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bDoesPlayCollisionSound) == 0x000034, "Member 'FVPhysicsControllableDebugData::bDoesPlayCollisionSound' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, DefaultSelfSurfaceType) == 0x000035, "Member 'FVPhysicsControllableDebugData::DefaultSelfSurfaceType' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bIsPaired) == 0x000036, "Member 'FVPhysicsControllableDebugData::bIsPaired' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bIsEnabled) == 0x000037, "Member 'FVPhysicsControllableDebugData::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bIsSimulating) == 0x000038, "Member 'FVPhysicsControllableDebugData::bIsSimulating' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, ConstrainingMode) == 0x000039, "Member 'FVPhysicsControllableDebugData::ConstrainingMode' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bIsSleeping) == 0x00003A, "Member 'FVPhysicsControllableDebugData::bIsSleeping' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bIsUsingBuoyancy) == 0x00003B, "Member 'FVPhysicsControllableDebugData::bIsUsingBuoyancy' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, bIsGrabbed) == 0x00003C, "Member 'FVPhysicsControllableDebugData::bIsGrabbed' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, ControlSettingsAuthority) == 0x00003D, "Member 'FVPhysicsControllableDebugData::ControlSettingsAuthority' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, CollisionProfileAuthority) == 0x00003E, "Member 'FVPhysicsControllableDebugData::CollisionProfileAuthority' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, WeightsAuthority) == 0x00003F, "Member 'FVPhysicsControllableDebugData::WeightsAuthority' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, DampingValuesAuthority) == 0x000040, "Member 'FVPhysicsControllableDebugData::DampingValuesAuthority' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, NavigationSettingsAuthority) == 0x000041, "Member 'FVPhysicsControllableDebugData::NavigationSettingsAuthority' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, PrimitiveComponentsData) == 0x000048, "Member 'FVPhysicsControllableDebugData::PrimitiveComponentsData' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableDebugData, ControllableTransform) == 0x000060, "Member 'FVPhysicsControllableDebugData::ControllableTransform' has a wrong offset!");

// ScriptStruct Altar.VDoorNavigationTestingActorGroup
// 0x00A8 (0x00A8 - 0x0000)
struct FVDoorNavigationTestingActorGroup final
{
public:
	int32                                         GroupID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSoftObjectPtr<class AVDoor>>            StartTestingDoorsIncluded;                         // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<TSoftObjectPtr<class AVDoor>>            StartTestingDoorsExcluded;                         // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVDoorNavigationTestingActorGroup) == 0x000008, "Wrong alignment on FVDoorNavigationTestingActorGroup");
static_assert(sizeof(FVDoorNavigationTestingActorGroup) == 0x0000A8, "Wrong size on FVDoorNavigationTestingActorGroup");
static_assert(offsetof(FVDoorNavigationTestingActorGroup, GroupID) == 0x000000, "Member 'FVDoorNavigationTestingActorGroup::GroupID' has a wrong offset!");
static_assert(offsetof(FVDoorNavigationTestingActorGroup, StartTestingDoorsIncluded) == 0x000008, "Member 'FVDoorNavigationTestingActorGroup::StartTestingDoorsIncluded' has a wrong offset!");
static_assert(offsetof(FVDoorNavigationTestingActorGroup, StartTestingDoorsExcluded) == 0x000058, "Member 'FVDoorNavigationTestingActorGroup::StartTestingDoorsExcluded' has a wrong offset!");

// ScriptStruct Altar.LegacyMapMenuTitleProperties
// 0x0030 (0x0030 - 0x0000)
struct FLegacyMapMenuTitleProperties final
{
public:
	class FText                                   Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Date;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyMapMenuTitleProperties) == 0x000008, "Wrong alignment on FLegacyMapMenuTitleProperties");
static_assert(sizeof(FLegacyMapMenuTitleProperties) == 0x000030, "Wrong size on FLegacyMapMenuTitleProperties");
static_assert(offsetof(FLegacyMapMenuTitleProperties, Location) == 0x000000, "Member 'FLegacyMapMenuTitleProperties::Location' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuTitleProperties, Date) == 0x000018, "Member 'FLegacyMapMenuTitleProperties::Date' has a wrong offset!");

// ScriptStruct Altar.LegacyEffectProperties
// 0x0020 (0x0020 - 0x0000)
struct FLegacyEffectProperties final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyEffectProperties) == 0x000008, "Wrong alignment on FLegacyEffectProperties");
static_assert(sizeof(FLegacyEffectProperties) == 0x000020, "Wrong size on FLegacyEffectProperties");
static_assert(offsetof(FLegacyEffectProperties, Name) == 0x000000, "Member 'FLegacyEffectProperties::Name' has a wrong offset!");
static_assert(offsetof(FLegacyEffectProperties, Icon) == 0x000018, "Member 'FLegacyEffectProperties::Icon' has a wrong offset!");

// ScriptStruct Altar.LegacyEffectCost
// 0x000C (0x000C - 0x0000)
struct FLegacyEffectCost final
{
public:
	int32                                         CastCost;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoldCost;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerGold;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyEffectCost) == 0x000004, "Wrong alignment on FLegacyEffectCost");
static_assert(sizeof(FLegacyEffectCost) == 0x00000C, "Wrong size on FLegacyEffectCost");
static_assert(offsetof(FLegacyEffectCost, CastCost) == 0x000000, "Member 'FLegacyEffectCost::CastCost' has a wrong offset!");
static_assert(offsetof(FLegacyEffectCost, GoldCost) == 0x000004, "Member 'FLegacyEffectCost::GoldCost' has a wrong offset!");
static_assert(offsetof(FLegacyEffectCost, PlayerGold) == 0x000008, "Member 'FLegacyEffectCost::PlayerGold' has a wrong offset!");

// ScriptStruct Altar.InitialEquipmentInfo
// 0x0010 (0x0010 - 0x0000)
struct FInitialEquipmentInfo final
{
public:
	class UTESForm*                               EquipmentForm;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseNPCDefault;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInitialEquipmentInfo) == 0x000008, "Wrong alignment on FInitialEquipmentInfo");
static_assert(sizeof(FInitialEquipmentInfo) == 0x000010, "Wrong size on FInitialEquipmentInfo");
static_assert(offsetof(FInitialEquipmentInfo, EquipmentForm) == 0x000000, "Member 'FInitialEquipmentInfo::EquipmentForm' has a wrong offset!");
static_assert(offsetof(FInitialEquipmentInfo, bUseNPCDefault) == 0x000008, "Member 'FInitialEquipmentInfo::bUseNPCDefault' has a wrong offset!");

// ScriptStruct Altar.VEnhancedInAirAnimInstanceData
// 0x0040 (0x0040 - 0x0000)
struct FVEnhancedInAirAnimInstanceData final
{
public:
	class UAnimSequenceBase*                      JumpingInPlaceAnimSequence;                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpingLeftFootAnimSequence;                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpingRightFootAnimSequence;                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      InAirInPlaceAnimSequence;                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      InAirLeftFootAnimSequence;                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      InAirRightFootAnimSequence;                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      LandInPlaceAnimSequence;                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      LandToSneakAnimSequence;                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVEnhancedInAirAnimInstanceData) == 0x000008, "Wrong alignment on FVEnhancedInAirAnimInstanceData");
static_assert(sizeof(FVEnhancedInAirAnimInstanceData) == 0x000040, "Wrong size on FVEnhancedInAirAnimInstanceData");
static_assert(offsetof(FVEnhancedInAirAnimInstanceData, JumpingInPlaceAnimSequence) == 0x000000, "Member 'FVEnhancedInAirAnimInstanceData::JumpingInPlaceAnimSequence' has a wrong offset!");
static_assert(offsetof(FVEnhancedInAirAnimInstanceData, JumpingLeftFootAnimSequence) == 0x000008, "Member 'FVEnhancedInAirAnimInstanceData::JumpingLeftFootAnimSequence' has a wrong offset!");
static_assert(offsetof(FVEnhancedInAirAnimInstanceData, JumpingRightFootAnimSequence) == 0x000010, "Member 'FVEnhancedInAirAnimInstanceData::JumpingRightFootAnimSequence' has a wrong offset!");
static_assert(offsetof(FVEnhancedInAirAnimInstanceData, InAirInPlaceAnimSequence) == 0x000018, "Member 'FVEnhancedInAirAnimInstanceData::InAirInPlaceAnimSequence' has a wrong offset!");
static_assert(offsetof(FVEnhancedInAirAnimInstanceData, InAirLeftFootAnimSequence) == 0x000020, "Member 'FVEnhancedInAirAnimInstanceData::InAirLeftFootAnimSequence' has a wrong offset!");
static_assert(offsetof(FVEnhancedInAirAnimInstanceData, InAirRightFootAnimSequence) == 0x000028, "Member 'FVEnhancedInAirAnimInstanceData::InAirRightFootAnimSequence' has a wrong offset!");
static_assert(offsetof(FVEnhancedInAirAnimInstanceData, LandInPlaceAnimSequence) == 0x000030, "Member 'FVEnhancedInAirAnimInstanceData::LandInPlaceAnimSequence' has a wrong offset!");
static_assert(offsetof(FVEnhancedInAirAnimInstanceData, LandToSneakAnimSequence) == 0x000038, "Member 'FVEnhancedInAirAnimInstanceData::LandToSneakAnimSequence' has a wrong offset!");

// ScriptStruct Altar.VEnhancedInAirCharacterAnimInstanceProxy
// 0x0030 (0x0730 - 0x0700)
struct FVEnhancedInAirCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x30];                                     // 0x0700(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVEnhancedInAirCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVEnhancedInAirCharacterAnimInstanceProxy");
static_assert(sizeof(FVEnhancedInAirCharacterAnimInstanceProxy) == 0x000730, "Wrong size on FVEnhancedInAirCharacterAnimInstanceProxy");

// ScriptStruct Altar.LegacyMapMenuQuestProperties
// 0x0098 (0x0098 - 0x0000)
struct FLegacyMapMenuQuestProperties final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Date;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ControllerText;                                    // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   KeyboardText;                                      // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActive;                                          // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QuestId;                                           // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuestPriority;                                     // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsQuestCompleted;                                 // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QuestIndex;                                        // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyMapMenuQuestProperties) == 0x000008, "Wrong alignment on FLegacyMapMenuQuestProperties");
static_assert(sizeof(FLegacyMapMenuQuestProperties) == 0x000098, "Wrong size on FLegacyMapMenuQuestProperties");
static_assert(offsetof(FLegacyMapMenuQuestProperties, Name) == 0x000000, "Member 'FLegacyMapMenuQuestProperties::Name' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuQuestProperties, Date) == 0x000018, "Member 'FLegacyMapMenuQuestProperties::Date' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuQuestProperties, Body) == 0x000030, "Member 'FLegacyMapMenuQuestProperties::Body' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuQuestProperties, ControllerText) == 0x000048, "Member 'FLegacyMapMenuQuestProperties::ControllerText' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuQuestProperties, KeyboardText) == 0x000060, "Member 'FLegacyMapMenuQuestProperties::KeyboardText' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuQuestProperties, Icon) == 0x000078, "Member 'FLegacyMapMenuQuestProperties::Icon' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuQuestProperties, IsActive) == 0x000080, "Member 'FLegacyMapMenuQuestProperties::IsActive' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuQuestProperties, QuestId) == 0x000084, "Member 'FLegacyMapMenuQuestProperties::QuestId' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuQuestProperties, QuestPriority) == 0x000088, "Member 'FLegacyMapMenuQuestProperties::QuestPriority' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuQuestProperties, bIsQuestCompleted) == 0x00008C, "Member 'FLegacyMapMenuQuestProperties::bIsQuestCompleted' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuQuestProperties, QuestIndex) == 0x000090, "Member 'FLegacyMapMenuQuestProperties::QuestIndex' has a wrong offset!");

// ScriptStruct Altar.LocomotionAnimationData
// 0x0008 (0x0008 - 0x0000)
struct FLocomotionAnimationData final
{
public:
	class UBlendSpace*                            BlendspaceMoving;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocomotionAnimationData) == 0x000008, "Wrong alignment on FLocomotionAnimationData");
static_assert(sizeof(FLocomotionAnimationData) == 0x000008, "Wrong size on FLocomotionAnimationData");
static_assert(offsetof(FLocomotionAnimationData, BlendspaceMoving) == 0x000000, "Member 'FLocomotionAnimationData::BlendspaceMoving' has a wrong offset!");

// ScriptStruct Altar.SprintingAnimationData
// 0x0008 (0x0008 - 0x0000)
struct FSprintingAnimationData final
{
public:
	class UAnimSequence*                          Sprint;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSprintingAnimationData) == 0x000008, "Wrong alignment on FSprintingAnimationData");
static_assert(sizeof(FSprintingAnimationData) == 0x000008, "Wrong size on FSprintingAnimationData");
static_assert(offsetof(FSprintingAnimationData, Sprint) == 0x000000, "Member 'FSprintingAnimationData::Sprint' has a wrong offset!");

// ScriptStruct Altar.VPhysicsControllableState
// 0x00C0 (0x00C0 - 0x0000)
struct FVPhysicsControllableState final
{
public:
	bool                                          bIsStateValid;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSimulatingPhysics;                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0xE];                                        // 0x0002(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ActorTransform;                                    // 0x0010(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVPhysicsAssetPose>             PhysicsAssetPoses;                                 // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     WorldTransforms;                                   // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        AttachParentFormID;                                // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AttachComponentName;                               // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Timestamp;                                         // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVPhysicsControllableState) == 0x000010, "Wrong alignment on FVPhysicsControllableState");
static_assert(sizeof(FVPhysicsControllableState) == 0x0000C0, "Wrong size on FVPhysicsControllableState");
static_assert(offsetof(FVPhysicsControllableState, bIsStateValid) == 0x000000, "Member 'FVPhysicsControllableState::bIsStateValid' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableState, bIsSimulatingPhysics) == 0x000001, "Member 'FVPhysicsControllableState::bIsSimulatingPhysics' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableState, ActorTransform) == 0x000010, "Member 'FVPhysicsControllableState::ActorTransform' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableState, PhysicsAssetPoses) == 0x000070, "Member 'FVPhysicsControllableState::PhysicsAssetPoses' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableState, WorldTransforms) == 0x000080, "Member 'FVPhysicsControllableState::WorldTransforms' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableState, AttachParentFormID) == 0x000090, "Member 'FVPhysicsControllableState::AttachParentFormID' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableState, AttachComponentName) == 0x000098, "Member 'FVPhysicsControllableState::AttachComponentName' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableState, AttachSocketName) == 0x0000A8, "Member 'FVPhysicsControllableState::AttachSocketName' has a wrong offset!");
static_assert(offsetof(FVPhysicsControllableState, Timestamp) == 0x0000B0, "Member 'FVPhysicsControllableState::Timestamp' has a wrong offset!");

// ScriptStruct Altar.VEnhancedLocomotionCharacterAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVEnhancedLocomotionCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVEnhancedLocomotionCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVEnhancedLocomotionCharacterAnimInstanceProxy");
static_assert(sizeof(FVEnhancedLocomotionCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVEnhancedLocomotionCharacterAnimInstanceProxy");

// ScriptStruct Altar.EnhancedLocomotionSystemData
// 0x0050 (0x0050 - 0x0000)
struct FEnhancedLocomotionSystemData final
{
public:
	class UBlendSpace*                            StartBlendSpace;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StopLeftFootMontage;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StopRightFootMontage;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StopSneakLeftFootMontage;                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StopSneakRightFootMontage;                         // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            LeanBlendSpace;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFootBoneName;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFootBoneName;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      StandToSneakAnim;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SneakToStandAnim;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnhancedLocomotionSystemData) == 0x000008, "Wrong alignment on FEnhancedLocomotionSystemData");
static_assert(sizeof(FEnhancedLocomotionSystemData) == 0x000050, "Wrong size on FEnhancedLocomotionSystemData");
static_assert(offsetof(FEnhancedLocomotionSystemData, StartBlendSpace) == 0x000000, "Member 'FEnhancedLocomotionSystemData::StartBlendSpace' has a wrong offset!");
static_assert(offsetof(FEnhancedLocomotionSystemData, StopLeftFootMontage) == 0x000008, "Member 'FEnhancedLocomotionSystemData::StopLeftFootMontage' has a wrong offset!");
static_assert(offsetof(FEnhancedLocomotionSystemData, StopRightFootMontage) == 0x000010, "Member 'FEnhancedLocomotionSystemData::StopRightFootMontage' has a wrong offset!");
static_assert(offsetof(FEnhancedLocomotionSystemData, StopSneakLeftFootMontage) == 0x000018, "Member 'FEnhancedLocomotionSystemData::StopSneakLeftFootMontage' has a wrong offset!");
static_assert(offsetof(FEnhancedLocomotionSystemData, StopSneakRightFootMontage) == 0x000020, "Member 'FEnhancedLocomotionSystemData::StopSneakRightFootMontage' has a wrong offset!");
static_assert(offsetof(FEnhancedLocomotionSystemData, LeanBlendSpace) == 0x000028, "Member 'FEnhancedLocomotionSystemData::LeanBlendSpace' has a wrong offset!");
static_assert(offsetof(FEnhancedLocomotionSystemData, LeftFootBoneName) == 0x000030, "Member 'FEnhancedLocomotionSystemData::LeftFootBoneName' has a wrong offset!");
static_assert(offsetof(FEnhancedLocomotionSystemData, RightFootBoneName) == 0x000038, "Member 'FEnhancedLocomotionSystemData::RightFootBoneName' has a wrong offset!");
static_assert(offsetof(FEnhancedLocomotionSystemData, StandToSneakAnim) == 0x000040, "Member 'FEnhancedLocomotionSystemData::StandToSneakAnim' has a wrong offset!");
static_assert(offsetof(FEnhancedLocomotionSystemData, SneakToStandAnim) == 0x000048, "Member 'FEnhancedLocomotionSystemData::SneakToStandAnim' has a wrong offset!");

// ScriptStruct Altar.MeleeAttackMultiplePowerSingle
// 0x0048 (0x0048 - 0x0000)
struct FMeleeAttackMultiplePowerSingle final
{
public:
	TArray<class UAnimSequence*>                  AttackRight;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  AttackLeft;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PowerAttack;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForwardPowerAttack;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BackwardPowerAttack;                               // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RightPowerAttack;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LeftPowerAttack;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeAttackMultiplePowerSingle) == 0x000008, "Wrong alignment on FMeleeAttackMultiplePowerSingle");
static_assert(sizeof(FMeleeAttackMultiplePowerSingle) == 0x000048, "Wrong size on FMeleeAttackMultiplePowerSingle");
static_assert(offsetof(FMeleeAttackMultiplePowerSingle, AttackRight) == 0x000000, "Member 'FMeleeAttackMultiplePowerSingle::AttackRight' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerSingle, AttackLeft) == 0x000010, "Member 'FMeleeAttackMultiplePowerSingle::AttackLeft' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerSingle, PowerAttack) == 0x000020, "Member 'FMeleeAttackMultiplePowerSingle::PowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerSingle, ForwardPowerAttack) == 0x000028, "Member 'FMeleeAttackMultiplePowerSingle::ForwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerSingle, BackwardPowerAttack) == 0x000030, "Member 'FMeleeAttackMultiplePowerSingle::BackwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerSingle, RightPowerAttack) == 0x000038, "Member 'FMeleeAttackMultiplePowerSingle::RightPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerSingle, LeftPowerAttack) == 0x000040, "Member 'FMeleeAttackMultiplePowerSingle::LeftPowerAttack' has a wrong offset!");

// ScriptStruct Altar.VEnhancedLocomotionSystemCharacterAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVEnhancedLocomotionSystemCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVEnhancedLocomotionSystemCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVEnhancedLocomotionSystemCharacterAnimInstanceProxy");
static_assert(sizeof(FVEnhancedLocomotionSystemCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVEnhancedLocomotionSystemCharacterAnimInstanceProxy");

// ScriptStruct Altar.VEquipUnequipCharacterAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVEquipUnequipCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVEquipUnequipCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVEquipUnequipCharacterAnimInstanceProxy");
static_assert(sizeof(FVEquipUnequipCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVEquipUnequipCharacterAnimInstanceProxy");

// ScriptStruct Altar.VSinglePrimitiveSweepTraceResult
// 0x03D0 (0x03D0 - 0x0000)
struct FVSinglePrimitiveSweepTraceResult final
{
public:
	TWeakObjectPtr<class UPrimitiveComponent>     PrimitiveComponent;                                // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x00E8)(Edit, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x2E0];                                     // 0x00F0(0x02E0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVSinglePrimitiveSweepTraceResult) == 0x000008, "Wrong alignment on FVSinglePrimitiveSweepTraceResult");
static_assert(sizeof(FVSinglePrimitiveSweepTraceResult) == 0x0003D0, "Wrong size on FVSinglePrimitiveSweepTraceResult");
static_assert(offsetof(FVSinglePrimitiveSweepTraceResult, PrimitiveComponent) == 0x000000, "Member 'FVSinglePrimitiveSweepTraceResult::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(FVSinglePrimitiveSweepTraceResult, HitResult) == 0x000008, "Member 'FVSinglePrimitiveSweepTraceResult::HitResult' has a wrong offset!");

// ScriptStruct Altar.EquipUnequipMultiLayerData
// 0x0020 (0x0020 - 0x0000)
struct FEquipUnequipMultiLayerData final
{
public:
	TArray<class UAnimSequenceBase*>              EquipAnim;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              UnequipAnim;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipUnequipMultiLayerData) == 0x000008, "Wrong alignment on FEquipUnequipMultiLayerData");
static_assert(sizeof(FEquipUnequipMultiLayerData) == 0x000020, "Wrong size on FEquipUnequipMultiLayerData");
static_assert(offsetof(FEquipUnequipMultiLayerData, EquipAnim) == 0x000000, "Member 'FEquipUnequipMultiLayerData::EquipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipMultiLayerData, UnequipAnim) == 0x000010, "Member 'FEquipUnequipMultiLayerData::UnequipAnim' has a wrong offset!");

// ScriptStruct Altar.EquipUnequipSingleLayerData
// 0x0010 (0x0010 - 0x0000)
struct FEquipUnequipSingleLayerData final
{
public:
	class UAnimSequenceBase*                      EquipAnim;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      UnequipAnim;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipUnequipSingleLayerData) == 0x000008, "Wrong alignment on FEquipUnequipSingleLayerData");
static_assert(sizeof(FEquipUnequipSingleLayerData) == 0x000010, "Wrong size on FEquipUnequipSingleLayerData");
static_assert(offsetof(FEquipUnequipSingleLayerData, EquipAnim) == 0x000000, "Member 'FEquipUnequipSingleLayerData::EquipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipSingleLayerData, UnequipAnim) == 0x000008, "Member 'FEquipUnequipSingleLayerData::UnequipAnim' has a wrong offset!");

// ScriptStruct Altar.ModernRaceSexMenuArchetypeProperties
// 0x0040 (0x0040 - 0x0000)
struct FModernRaceSexMenuArchetypeProperties final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           ArchetypesPros;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernRaceSexMenuArchetypeProperties) == 0x000008, "Wrong alignment on FModernRaceSexMenuArchetypeProperties");
static_assert(sizeof(FModernRaceSexMenuArchetypeProperties) == 0x000040, "Wrong size on FModernRaceSexMenuArchetypeProperties");
static_assert(offsetof(FModernRaceSexMenuArchetypeProperties, Name) == 0x000000, "Member 'FModernRaceSexMenuArchetypeProperties::Name' has a wrong offset!");
static_assert(offsetof(FModernRaceSexMenuArchetypeProperties, Description) == 0x000018, "Member 'FModernRaceSexMenuArchetypeProperties::Description' has a wrong offset!");
static_assert(offsetof(FModernRaceSexMenuArchetypeProperties, ArchetypesPros) == 0x000030, "Member 'FModernRaceSexMenuArchetypeProperties::ArchetypesPros' has a wrong offset!");

// ScriptStruct Altar.LegacyRaceSexMenuRaceProperties
// 0x00C0 (0x00C8 - 0x0008)
struct FLegacyRaceSexMenuRaceProperties final : public FTableRowBase
{
public:
	class FString                                 RaceName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             RacePortrait;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             RacePortraitHover;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             Table;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DescriptionText;                                   // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MagickaBonus;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           HeaderLabes;                                       // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FModernRaceSexMenuArchetypeProperties> ArchetypesProperties;                       // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RaceId;                                            // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           Pros;                                              // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTESRace>                Race;                                              // 0x00A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyRaceSexMenuRaceProperties) == 0x000008, "Wrong alignment on FLegacyRaceSexMenuRaceProperties");
static_assert(sizeof(FLegacyRaceSexMenuRaceProperties) == 0x0000C8, "Wrong size on FLegacyRaceSexMenuRaceProperties");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, RaceName) == 0x000008, "Member 'FLegacyRaceSexMenuRaceProperties::RaceName' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, RacePortrait) == 0x000018, "Member 'FLegacyRaceSexMenuRaceProperties::RacePortrait' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, RacePortraitHover) == 0x000020, "Member 'FLegacyRaceSexMenuRaceProperties::RacePortraitHover' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, Table) == 0x000028, "Member 'FLegacyRaceSexMenuRaceProperties::Table' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, DisplayName) == 0x000030, "Member 'FLegacyRaceSexMenuRaceProperties::DisplayName' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, DescriptionText) == 0x000048, "Member 'FLegacyRaceSexMenuRaceProperties::DescriptionText' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, MagickaBonus) == 0x000060, "Member 'FLegacyRaceSexMenuRaceProperties::MagickaBonus' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, HeaderLabes) == 0x000068, "Member 'FLegacyRaceSexMenuRaceProperties::HeaderLabes' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, ArchetypesProperties) == 0x000078, "Member 'FLegacyRaceSexMenuRaceProperties::ArchetypesProperties' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, RaceId) == 0x000088, "Member 'FLegacyRaceSexMenuRaceProperties::RaceId' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, Pros) == 0x000090, "Member 'FLegacyRaceSexMenuRaceProperties::Pros' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuRaceProperties, Race) == 0x0000A0, "Member 'FLegacyRaceSexMenuRaceProperties::Race' has a wrong offset!");

// ScriptStruct Altar.EquipUnequipStandSneakSwimSingleData
// 0x0030 (0x0030 - 0x0000)
struct FEquipUnequipStandSneakSwimSingleData final
{
public:
	class UAnimSequenceBase*                      EquipAnim;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      UnequipAnim;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SneakEquipAnim;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SneakUnequipAnim;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SwimEquipAnim;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SwimUnequipAnim;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipUnequipStandSneakSwimSingleData) == 0x000008, "Wrong alignment on FEquipUnequipStandSneakSwimSingleData");
static_assert(sizeof(FEquipUnequipStandSneakSwimSingleData) == 0x000030, "Wrong size on FEquipUnequipStandSneakSwimSingleData");
static_assert(offsetof(FEquipUnequipStandSneakSwimSingleData, EquipAnim) == 0x000000, "Member 'FEquipUnequipStandSneakSwimSingleData::EquipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipStandSneakSwimSingleData, UnequipAnim) == 0x000008, "Member 'FEquipUnequipStandSneakSwimSingleData::UnequipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipStandSneakSwimSingleData, SneakEquipAnim) == 0x000010, "Member 'FEquipUnequipStandSneakSwimSingleData::SneakEquipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipStandSneakSwimSingleData, SneakUnequipAnim) == 0x000018, "Member 'FEquipUnequipStandSneakSwimSingleData::SneakUnequipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipStandSneakSwimSingleData, SwimEquipAnim) == 0x000020, "Member 'FEquipUnequipStandSneakSwimSingleData::SwimEquipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipStandSneakSwimSingleData, SwimUnequipAnim) == 0x000028, "Member 'FEquipUnequipStandSneakSwimSingleData::SwimUnequipAnim' has a wrong offset!");

// ScriptStruct Altar.EquipUnequipStandSwimSingleData
// 0x0020 (0x0020 - 0x0000)
struct FEquipUnequipStandSwimSingleData final
{
public:
	class UAnimSequenceBase*                      EquipAnim;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      UnequipAnim;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SwimEquipAnim;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SwimUnequipAnim;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipUnequipStandSwimSingleData) == 0x000008, "Wrong alignment on FEquipUnequipStandSwimSingleData");
static_assert(sizeof(FEquipUnequipStandSwimSingleData) == 0x000020, "Wrong size on FEquipUnequipStandSwimSingleData");
static_assert(offsetof(FEquipUnequipStandSwimSingleData, EquipAnim) == 0x000000, "Member 'FEquipUnequipStandSwimSingleData::EquipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipStandSwimSingleData, UnequipAnim) == 0x000008, "Member 'FEquipUnequipStandSwimSingleData::UnequipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipStandSwimSingleData, SwimEquipAnim) == 0x000010, "Member 'FEquipUnequipStandSwimSingleData::SwimEquipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipStandSwimSingleData, SwimUnequipAnim) == 0x000018, "Member 'FEquipUnequipStandSwimSingleData::SwimUnequipAnim' has a wrong offset!");

// ScriptStruct Altar.VHairColorCustomisationOptions
// 0x000C (0x000C - 0x0000)
struct FVHairColorCustomisationOptions final
{
public:
	EVFacialHairType                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 HairColor;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetToDefault;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVHairColorCustomisationOptions) == 0x000004, "Wrong alignment on FVHairColorCustomisationOptions");
static_assert(sizeof(FVHairColorCustomisationOptions) == 0x00000C, "Wrong size on FVHairColorCustomisationOptions");
static_assert(offsetof(FVHairColorCustomisationOptions, Type) == 0x000000, "Member 'FVHairColorCustomisationOptions::Type' has a wrong offset!");
static_assert(offsetof(FVHairColorCustomisationOptions, HairColor) == 0x000004, "Member 'FVHairColorCustomisationOptions::HairColor' has a wrong offset!");
static_assert(offsetof(FVHairColorCustomisationOptions, bResetToDefault) == 0x000008, "Member 'FVHairColorCustomisationOptions::bResetToDefault' has a wrong offset!");

// ScriptStruct Altar.EquipUnequipStandSneakSingleLayerData
// 0x0020 (0x0020 - 0x0000)
struct FEquipUnequipStandSneakSingleLayerData final
{
public:
	class UAnimSequenceBase*                      EquipAnim;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      UnequipAnim;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SneakEquipAnim;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SneakUnequipAnim;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipUnequipStandSneakSingleLayerData) == 0x000008, "Wrong alignment on FEquipUnequipStandSneakSingleLayerData");
static_assert(sizeof(FEquipUnequipStandSneakSingleLayerData) == 0x000020, "Wrong size on FEquipUnequipStandSneakSingleLayerData");
static_assert(offsetof(FEquipUnequipStandSneakSingleLayerData, EquipAnim) == 0x000000, "Member 'FEquipUnequipStandSneakSingleLayerData::EquipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipStandSneakSingleLayerData, UnequipAnim) == 0x000008, "Member 'FEquipUnequipStandSneakSingleLayerData::UnequipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipStandSneakSingleLayerData, SneakEquipAnim) == 0x000010, "Member 'FEquipUnequipStandSneakSingleLayerData::SneakEquipAnim' has a wrong offset!");
static_assert(offsetof(FEquipUnequipStandSneakSingleLayerData, SneakUnequipAnim) == 0x000018, "Member 'FEquipUnequipStandSneakSingleLayerData::SneakUnequipAnim' has a wrong offset!");

// ScriptStruct Altar.VFreezeLayer
// 0x0018 (0x0018 - 0x0000)
struct FVFreezeLayer final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         SparedActorList;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVFreezeLayer) == 0x000008, "Wrong alignment on FVFreezeLayer");
static_assert(sizeof(FVFreezeLayer) == 0x000018, "Wrong size on FVFreezeLayer");
static_assert(offsetof(FVFreezeLayer, Name) == 0x000000, "Member 'FVFreezeLayer::Name' has a wrong offset!");
static_assert(offsetof(FVFreezeLayer, SparedActorList) == 0x000008, "Member 'FVFreezeLayer::SparedActorList' has a wrong offset!");

// ScriptStruct Altar.VResistStatDataStructure
// 0x0008 (0x0070 - 0x0068)
struct FVResistStatDataStructure final : public FVStatsDataStructure
{
public:
	EResistStat                                   Type;                                              // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVResistStatDataStructure) == 0x000008, "Wrong alignment on FVResistStatDataStructure");
static_assert(sizeof(FVResistStatDataStructure) == 0x000070, "Wrong size on FVResistStatDataStructure");
static_assert(offsetof(FVResistStatDataStructure, Type) == 0x000068, "Member 'FVResistStatDataStructure::Type' has a wrong offset!");

// ScriptStruct Altar.LegacyQuestAddedProperties
// 0x00A8 (0x00A8 - 0x0000)
struct FLegacyQuestAddedProperties final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Date;                                              // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ButtonOneText;                                     // 0x0068(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          ButtonTwoActive;                                   // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ButtonTwoText;                                     // 0x0088(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsSkillIncreasedMenu;                             // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNewQuest;                                       // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyQuestAddedProperties) == 0x000008, "Wrong alignment on FLegacyQuestAddedProperties");
static_assert(sizeof(FLegacyQuestAddedProperties) == 0x0000A8, "Wrong size on FLegacyQuestAddedProperties");
static_assert(offsetof(FLegacyQuestAddedProperties, Title) == 0x000000, "Member 'FLegacyQuestAddedProperties::Title' has a wrong offset!");
static_assert(offsetof(FLegacyQuestAddedProperties, Name) == 0x000018, "Member 'FLegacyQuestAddedProperties::Name' has a wrong offset!");
static_assert(offsetof(FLegacyQuestAddedProperties, Date) == 0x000030, "Member 'FLegacyQuestAddedProperties::Date' has a wrong offset!");
static_assert(offsetof(FLegacyQuestAddedProperties, Body) == 0x000048, "Member 'FLegacyQuestAddedProperties::Body' has a wrong offset!");
static_assert(offsetof(FLegacyQuestAddedProperties, Icon) == 0x000060, "Member 'FLegacyQuestAddedProperties::Icon' has a wrong offset!");
static_assert(offsetof(FLegacyQuestAddedProperties, ButtonOneText) == 0x000068, "Member 'FLegacyQuestAddedProperties::ButtonOneText' has a wrong offset!");
static_assert(offsetof(FLegacyQuestAddedProperties, ButtonTwoActive) == 0x000080, "Member 'FLegacyQuestAddedProperties::ButtonTwoActive' has a wrong offset!");
static_assert(offsetof(FLegacyQuestAddedProperties, ButtonTwoText) == 0x000088, "Member 'FLegacyQuestAddedProperties::ButtonTwoText' has a wrong offset!");
static_assert(offsetof(FLegacyQuestAddedProperties, bIsSkillIncreasedMenu) == 0x0000A0, "Member 'FLegacyQuestAddedProperties::bIsSkillIncreasedMenu' has a wrong offset!");
static_assert(offsetof(FLegacyQuestAddedProperties, bIsNewQuest) == 0x0000A1, "Member 'FLegacyQuestAddedProperties::bIsNewQuest' has a wrong offset!");

// ScriptStruct Altar.GetUpAnimationData
// 0x0018 (0x0018 - 0x0000)
struct FGetUpAnimationData final
{
public:
	class UAnimMontage*                           GetUpFaceDownOrRightMontage;                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GetUpFaceUpOrLeftMontage;                          // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftRight;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetUpAnimationData) == 0x000008, "Wrong alignment on FGetUpAnimationData");
static_assert(sizeof(FGetUpAnimationData) == 0x000018, "Wrong size on FGetUpAnimationData");
static_assert(offsetof(FGetUpAnimationData, GetUpFaceDownOrRightMontage) == 0x000000, "Member 'FGetUpAnimationData::GetUpFaceDownOrRightMontage' has a wrong offset!");
static_assert(offsetof(FGetUpAnimationData, GetUpFaceUpOrLeftMontage) == 0x000008, "Member 'FGetUpAnimationData::GetUpFaceUpOrLeftMontage' has a wrong offset!");
static_assert(offsetof(FGetUpAnimationData, bIsLeftRight) == 0x000010, "Member 'FGetUpAnimationData::bIsLeftRight' has a wrong offset!");

// ScriptStruct Altar.LegacyStatsMenuSecondaryAttribute
// 0x0008 (0x0008 - 0x0000)
struct FLegacyStatsMenuSecondaryAttribute final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         base;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyStatsMenuSecondaryAttribute) == 0x000004, "Wrong alignment on FLegacyStatsMenuSecondaryAttribute");
static_assert(sizeof(FLegacyStatsMenuSecondaryAttribute) == 0x000008, "Wrong size on FLegacyStatsMenuSecondaryAttribute");
static_assert(offsetof(FLegacyStatsMenuSecondaryAttribute, Value) == 0x000000, "Member 'FLegacyStatsMenuSecondaryAttribute::Value' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSecondaryAttribute, base) == 0x000004, "Member 'FLegacyStatsMenuSecondaryAttribute::base' has a wrong offset!");

// ScriptStruct Altar.VGrabOverridenSettings
// 0x0008 (0x0008 - 0x0000)
struct FVGrabOverridenSettings final
{
public:
	float                                         StaticMeshPhysicBodyLinearDamping;                 // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticMeshPhysicBodyAngularDamping;                // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVGrabOverridenSettings) == 0x000004, "Wrong alignment on FVGrabOverridenSettings");
static_assert(sizeof(FVGrabOverridenSettings) == 0x000008, "Wrong size on FVGrabOverridenSettings");
static_assert(offsetof(FVGrabOverridenSettings, StaticMeshPhysicBodyLinearDamping) == 0x000000, "Member 'FVGrabOverridenSettings::StaticMeshPhysicBodyLinearDamping' has a wrong offset!");
static_assert(offsetof(FVGrabOverridenSettings, StaticMeshPhysicBodyAngularDamping) == 0x000004, "Member 'FVGrabOverridenSettings::StaticMeshPhysicBodyAngularDamping' has a wrong offset!");

// ScriptStruct Altar.VGrabActionData
// 0x0048 (0x0048 - 0x0000)
struct FVGrabActionData final
{
public:
	TWeakObjectPtr<class AActor>                  GrabbedActor;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     GrabbedComponent;                                  // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GrabbedBoneName;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitPoint;                                          // 0x0020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVGrabState                                   State;                                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPulling;                                        // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPushing;                                        // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrabStateElapsedTime;                              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDuration;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVGrabActionData) == 0x000008, "Wrong alignment on FVGrabActionData");
static_assert(sizeof(FVGrabActionData) == 0x000048, "Wrong size on FVGrabActionData");
static_assert(offsetof(FVGrabActionData, GrabbedActor) == 0x000000, "Member 'FVGrabActionData::GrabbedActor' has a wrong offset!");
static_assert(offsetof(FVGrabActionData, GrabbedComponent) == 0x000008, "Member 'FVGrabActionData::GrabbedComponent' has a wrong offset!");
static_assert(offsetof(FVGrabActionData, GrabbedBoneName) == 0x000018, "Member 'FVGrabActionData::GrabbedBoneName' has a wrong offset!");
static_assert(offsetof(FVGrabActionData, HitPoint) == 0x000020, "Member 'FVGrabActionData::HitPoint' has a wrong offset!");
static_assert(offsetof(FVGrabActionData, State) == 0x000038, "Member 'FVGrabActionData::State' has a wrong offset!");
static_assert(offsetof(FVGrabActionData, bIsPulling) == 0x000039, "Member 'FVGrabActionData::bIsPulling' has a wrong offset!");
static_assert(offsetof(FVGrabActionData, bIsPushing) == 0x00003A, "Member 'FVGrabActionData::bIsPushing' has a wrong offset!");
static_assert(offsetof(FVGrabActionData, GrabStateElapsedTime) == 0x00003C, "Member 'FVGrabActionData::GrabStateElapsedTime' has a wrong offset!");
static_assert(offsetof(FVGrabActionData, MaxDuration) == 0x000040, "Member 'FVGrabActionData::MaxDuration' has a wrong offset!");

// ScriptStruct Altar.VRecoil
// 0x0010 (0x0010 - 0x0000)
struct FVRecoil final
{
public:
	class UAnimMontage*                           Recoil;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdleBlend;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVRecoil) == 0x000008, "Wrong alignment on FVRecoil");
static_assert(sizeof(FVRecoil) == 0x000010, "Wrong size on FVRecoil");
static_assert(offsetof(FVRecoil, Recoil) == 0x000000, "Member 'FVRecoil::Recoil' has a wrong offset!");
static_assert(offsetof(FVRecoil, IdleBlend) == 0x000008, "Member 'FVRecoil::IdleBlend' has a wrong offset!");

// ScriptStruct Altar.OriginalGraphicsOption
// 0x0028 (0x0028 - 0x0000)
struct FOriginalGraphicsOption final
{
public:
	class FText                                   Label;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FString>                         Commands;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOriginalGraphicsOption) == 0x000008, "Wrong alignment on FOriginalGraphicsOption");
static_assert(sizeof(FOriginalGraphicsOption) == 0x000028, "Wrong size on FOriginalGraphicsOption");
static_assert(offsetof(FOriginalGraphicsOption, Label) == 0x000000, "Member 'FOriginalGraphicsOption::Label' has a wrong offset!");
static_assert(offsetof(FOriginalGraphicsOption, Commands) == 0x000018, "Member 'FOriginalGraphicsOption::Commands' has a wrong offset!");

// ScriptStruct Altar.OriginalGraphicsTableRow
// 0x0038 (0x0040 - 0x0008)
struct FOriginalGraphicsTableRow final : public FTableRowBase
{
public:
	class FText                                   Label;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UVOriginalVideoSettingWidget> WidgetClass;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOriginalGraphicsOption>        OptionValues;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ExtremalValue;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOriginalGraphicsTableRow) == 0x000008, "Wrong alignment on FOriginalGraphicsTableRow");
static_assert(sizeof(FOriginalGraphicsTableRow) == 0x000040, "Wrong size on FOriginalGraphicsTableRow");
static_assert(offsetof(FOriginalGraphicsTableRow, Label) == 0x000008, "Member 'FOriginalGraphicsTableRow::Label' has a wrong offset!");
static_assert(offsetof(FOriginalGraphicsTableRow, WidgetClass) == 0x000020, "Member 'FOriginalGraphicsTableRow::WidgetClass' has a wrong offset!");
static_assert(offsetof(FOriginalGraphicsTableRow, OptionValues) == 0x000028, "Member 'FOriginalGraphicsTableRow::OptionValues' has a wrong offset!");
static_assert(offsetof(FOriginalGraphicsTableRow, ExtremalValue) == 0x000038, "Member 'FOriginalGraphicsTableRow::ExtremalValue' has a wrong offset!");

// ScriptStruct Altar.VFaceMorphLimits
// 0x0280 (0x0280 - 0x0000)
struct FVFaceMorphLimits final
{
public:
	TMap<class FName, float>                      FaceMorphForcedMinValues;                          // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      FaceMorphForcedMaxValues;                          // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      XAxisUpscaleThresholds;                            // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      XAxisDownscaleThresholds;                          // 0x00F0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      YAxisUpscaleThresholds;                            // 0x0140(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      YAxisDownscaleThresholds;                          // 0x0190(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ZAxisUpscaleThresholds;                            // 0x01E0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ZAxisDownscaleThresholds;                          // 0x0230(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVFaceMorphLimits) == 0x000008, "Wrong alignment on FVFaceMorphLimits");
static_assert(sizeof(FVFaceMorphLimits) == 0x000280, "Wrong size on FVFaceMorphLimits");
static_assert(offsetof(FVFaceMorphLimits, FaceMorphForcedMinValues) == 0x000000, "Member 'FVFaceMorphLimits::FaceMorphForcedMinValues' has a wrong offset!");
static_assert(offsetof(FVFaceMorphLimits, FaceMorphForcedMaxValues) == 0x000050, "Member 'FVFaceMorphLimits::FaceMorphForcedMaxValues' has a wrong offset!");
static_assert(offsetof(FVFaceMorphLimits, XAxisUpscaleThresholds) == 0x0000A0, "Member 'FVFaceMorphLimits::XAxisUpscaleThresholds' has a wrong offset!");
static_assert(offsetof(FVFaceMorphLimits, XAxisDownscaleThresholds) == 0x0000F0, "Member 'FVFaceMorphLimits::XAxisDownscaleThresholds' has a wrong offset!");
static_assert(offsetof(FVFaceMorphLimits, YAxisUpscaleThresholds) == 0x000140, "Member 'FVFaceMorphLimits::YAxisUpscaleThresholds' has a wrong offset!");
static_assert(offsetof(FVFaceMorphLimits, YAxisDownscaleThresholds) == 0x000190, "Member 'FVFaceMorphLimits::YAxisDownscaleThresholds' has a wrong offset!");
static_assert(offsetof(FVFaceMorphLimits, ZAxisUpscaleThresholds) == 0x0001E0, "Member 'FVFaceMorphLimits::ZAxisUpscaleThresholds' has a wrong offset!");
static_assert(offsetof(FVFaceMorphLimits, ZAxisDownscaleThresholds) == 0x000230, "Member 'FVFaceMorphLimits::ZAxisDownscaleThresholds' has a wrong offset!");

// ScriptStruct Altar.VSenescenceTexture
// 0x0040 (0x0040 - 0x0000)
struct FVSenescenceTexture final
{
public:
	TArray<struct FVSenescenceTexturePair>        SenescenceTextures;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EVSenescencePhenotypeBehaviour                PhenotypeBehaviour;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVCharacterPhenotypePreset> Phenotype;                                      // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSenescenceTexture) == 0x000008, "Wrong alignment on FVSenescenceTexture");
static_assert(sizeof(FVSenescenceTexture) == 0x000040, "Wrong size on FVSenescenceTexture");
static_assert(offsetof(FVSenescenceTexture, SenescenceTextures) == 0x000000, "Member 'FVSenescenceTexture::SenescenceTextures' has a wrong offset!");
static_assert(offsetof(FVSenescenceTexture, PhenotypeBehaviour) == 0x000010, "Member 'FVSenescenceTexture::PhenotypeBehaviour' has a wrong offset!");
static_assert(offsetof(FVSenescenceTexture, Phenotype) == 0x000018, "Member 'FVSenescenceTexture::Phenotype' has a wrong offset!");

// ScriptStruct Altar.VMorphLimitsRaceOverride
// 0x0798 (0x0798 - 0x0000)
struct FVMorphLimitsRaceOverride final
{
public:
	bool                                          bHasFemaleLimitsOverride;                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVFaceMorphLimits                      FemaleLimits;                                      // 0x0008(0x0280)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHasMaleLimitsOverride;                            // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVFaceMorphLimits                      MaleLimits;                                        // 0x0290(0x0280)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHasDefaultLimitsOverride;                         // 0x0510(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_511[0x7];                                      // 0x0511(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVFaceMorphLimits                      DefaultLimits;                                     // 0x0518(0x0280)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVMorphLimitsRaceOverride) == 0x000008, "Wrong alignment on FVMorphLimitsRaceOverride");
static_assert(sizeof(FVMorphLimitsRaceOverride) == 0x000798, "Wrong size on FVMorphLimitsRaceOverride");
static_assert(offsetof(FVMorphLimitsRaceOverride, bHasFemaleLimitsOverride) == 0x000000, "Member 'FVMorphLimitsRaceOverride::bHasFemaleLimitsOverride' has a wrong offset!");
static_assert(offsetof(FVMorphLimitsRaceOverride, FemaleLimits) == 0x000008, "Member 'FVMorphLimitsRaceOverride::FemaleLimits' has a wrong offset!");
static_assert(offsetof(FVMorphLimitsRaceOverride, bHasMaleLimitsOverride) == 0x000288, "Member 'FVMorphLimitsRaceOverride::bHasMaleLimitsOverride' has a wrong offset!");
static_assert(offsetof(FVMorphLimitsRaceOverride, MaleLimits) == 0x000290, "Member 'FVMorphLimitsRaceOverride::MaleLimits' has a wrong offset!");
static_assert(offsetof(FVMorphLimitsRaceOverride, bHasDefaultLimitsOverride) == 0x000510, "Member 'FVMorphLimitsRaceOverride::bHasDefaultLimitsOverride' has a wrong offset!");
static_assert(offsetof(FVMorphLimitsRaceOverride, DefaultLimits) == 0x000518, "Member 'FVMorphLimitsRaceOverride::DefaultLimits' has a wrong offset!");

// ScriptStruct Altar.VHitResult
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FVHitResult final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVHitResult) == 0x000008, "Wrong alignment on FVHitResult");
static_assert(sizeof(FVHitResult) == 0x000050, "Wrong size on FVHitResult");

// ScriptStruct Altar.LegacyIconProperties
// 0x0028 (0x0028 - 0x0000)
struct FLegacyIconProperties final
{
public:
	ELegacyHudInfoIcon                            Icon;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyIconProperties) == 0x000008, "Wrong alignment on FLegacyIconProperties");
static_assert(sizeof(FLegacyIconProperties) == 0x000028, "Wrong size on FLegacyIconProperties");
static_assert(offsetof(FLegacyIconProperties, Icon) == 0x000000, "Member 'FLegacyIconProperties::Icon' has a wrong offset!");
static_assert(offsetof(FLegacyIconProperties, Text) == 0x000008, "Member 'FLegacyIconProperties::Text' has a wrong offset!");
static_assert(offsetof(FLegacyIconProperties, bIsVisible) == 0x000020, "Member 'FLegacyIconProperties::bIsVisible' has a wrong offset!");

// ScriptStruct Altar.LegacyActionProperties
// 0x0020 (0x0020 - 0x0000)
struct FLegacyActionProperties final
{
public:
	ELegacyXboxFloatingHintButton                 ButtonIcon;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyActionProperties) == 0x000008, "Wrong alignment on FLegacyActionProperties");
static_assert(sizeof(FLegacyActionProperties) == 0x000020, "Wrong size on FLegacyActionProperties");
static_assert(offsetof(FLegacyActionProperties, ButtonIcon) == 0x000000, "Member 'FLegacyActionProperties::ButtonIcon' has a wrong offset!");
static_assert(offsetof(FLegacyActionProperties, Text) == 0x000008, "Member 'FLegacyActionProperties::Text' has a wrong offset!");

// ScriptStruct Altar.ModernRebindDataStockageStructure
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FModernRebindDataStockageStructure final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernRebindDataStockageStructure) == 0x000008, "Wrong alignment on FModernRebindDataStockageStructure");
static_assert(sizeof(FModernRebindDataStockageStructure) == 0x000078, "Wrong size on FModernRebindDataStockageStructure");

// ScriptStruct Altar.WeaponChargeParams
// 0x0008 (0x0008 - 0x0000)
struct FWeaponChargeParams final
{
public:
	bool                                          bNeedInterpolation;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         fWeaponChargePercent;                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponChargeParams) == 0x000004, "Wrong alignment on FWeaponChargeParams");
static_assert(sizeof(FWeaponChargeParams) == 0x000008, "Wrong size on FWeaponChargeParams");
static_assert(offsetof(FWeaponChargeParams, bNeedInterpolation) == 0x000000, "Member 'FWeaponChargeParams::bNeedInterpolation' has a wrong offset!");
static_assert(offsetof(FWeaponChargeParams, fWeaponChargePercent) == 0x000004, "Member 'FWeaponChargeParams::fWeaponChargePercent' has a wrong offset!");

// ScriptStruct Altar.ModernSkillProgression
// 0x0028 (0x0028 - 0x0000)
struct FModernSkillProgression final
{
public:
	class FText                                   TextToShow;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         SkillLevel;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerLevelProgress;                               // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernSkillProgression) == 0x000008, "Wrong alignment on FModernSkillProgression");
static_assert(sizeof(FModernSkillProgression) == 0x000028, "Wrong size on FModernSkillProgression");
static_assert(offsetof(FModernSkillProgression, TextToShow) == 0x000000, "Member 'FModernSkillProgression::TextToShow' has a wrong offset!");
static_assert(offsetof(FModernSkillProgression, SkillLevel) == 0x000018, "Member 'FModernSkillProgression::SkillLevel' has a wrong offset!");
static_assert(offsetof(FModernSkillProgression, PlayerLevelProgress) == 0x00001C, "Member 'FModernSkillProgression::PlayerLevelProgress' has a wrong offset!");
static_assert(offsetof(FModernSkillProgression, PlayerLevel) == 0x000020, "Member 'FModernSkillProgression::PlayerLevel' has a wrong offset!");

// ScriptStruct Altar.ModernApparelData
// 0x0002 (0x0002 - 0x0000)
struct FModernApparelData final
{
public:
	bool                                          bIsApparelAboutToBreak;                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsApparelBroken;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernApparelData) == 0x000001, "Wrong alignment on FModernApparelData");
static_assert(sizeof(FModernApparelData) == 0x000002, "Wrong size on FModernApparelData");
static_assert(offsetof(FModernApparelData, bIsApparelAboutToBreak) == 0x000000, "Member 'FModernApparelData::bIsApparelAboutToBreak' has a wrong offset!");
static_assert(offsetof(FModernApparelData, bIsApparelBroken) == 0x000001, "Member 'FModernApparelData::bIsApparelBroken' has a wrong offset!");

// ScriptStruct Altar.EyebrowColorProperty
// 0x0008 (0x0008 - 0x0000)
struct FEyebrowColorProperty final
{
public:
	float                                         PhenotypeColor;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Redness;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEyebrowColorProperty) == 0x000004, "Wrong alignment on FEyebrowColorProperty");
static_assert(sizeof(FEyebrowColorProperty) == 0x000008, "Wrong size on FEyebrowColorProperty");
static_assert(offsetof(FEyebrowColorProperty, PhenotypeColor) == 0x000000, "Member 'FEyebrowColorProperty::PhenotypeColor' has a wrong offset!");
static_assert(offsetof(FEyebrowColorProperty, Redness) == 0x000004, "Member 'FEyebrowColorProperty::Redness' has a wrong offset!");

// ScriptStruct Altar.ModernRaceSexMenuEyebrowColorProperties
// 0x0020 (0x0020 - 0x0000)
struct FModernRaceSexMenuEyebrowColorProperties final
{
public:
	class FName                                   PhenotypeColorKey;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhenotypeRednessKey;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEyebrowColorProperty>          Options;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernRaceSexMenuEyebrowColorProperties) == 0x000008, "Wrong alignment on FModernRaceSexMenuEyebrowColorProperties");
static_assert(sizeof(FModernRaceSexMenuEyebrowColorProperties) == 0x000020, "Wrong size on FModernRaceSexMenuEyebrowColorProperties");
static_assert(offsetof(FModernRaceSexMenuEyebrowColorProperties, PhenotypeColorKey) == 0x000000, "Member 'FModernRaceSexMenuEyebrowColorProperties::PhenotypeColorKey' has a wrong offset!");
static_assert(offsetof(FModernRaceSexMenuEyebrowColorProperties, PhenotypeRednessKey) == 0x000008, "Member 'FModernRaceSexMenuEyebrowColorProperties::PhenotypeRednessKey' has a wrong offset!");
static_assert(offsetof(FModernRaceSexMenuEyebrowColorProperties, Options) == 0x000010, "Member 'FModernRaceSexMenuEyebrowColorProperties::Options' has a wrong offset!");

// ScriptStruct Altar.HostileData
// 0x0008 (0x0008 - 0x0000)
struct FHostileData final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHostileData) == 0x000004, "Wrong alignment on FHostileData");
static_assert(sizeof(FHostileData) == 0x000008, "Wrong size on FHostileData");
static_assert(offsetof(FHostileData, Distance) == 0x000000, "Member 'FHostileData::Distance' has a wrong offset!");
static_assert(offsetof(FHostileData, Angle) == 0x000004, "Member 'FHostileData::Angle' has a wrong offset!");

// ScriptStruct Altar.SetCompassIconMarkersAsyncTickFunction
// 0x0010 (0x0038 - 0x0028)
struct FSetCompassIconMarkersAsyncTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSetCompassIconMarkersAsyncTickFunction) == 0x000008, "Wrong alignment on FSetCompassIconMarkersAsyncTickFunction");
static_assert(sizeof(FSetCompassIconMarkersAsyncTickFunction) == 0x000038, "Wrong size on FSetCompassIconMarkersAsyncTickFunction");

// ScriptStruct Altar.SetCompassIconMarkersGameThreadTickFunction
// 0x0018 (0x0040 - 0x0028)
struct FSetCompassIconMarkersGameThreadTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSetCompassIconMarkersGameThreadTickFunction) == 0x000008, "Wrong alignment on FSetCompassIconMarkersGameThreadTickFunction");
static_assert(sizeof(FSetCompassIconMarkersGameThreadTickFunction) == 0x000040, "Wrong size on FSetCompassIconMarkersGameThreadTickFunction");

// ScriptStruct Altar.LegacyReticleSneakingProperties
// 0x0008 (0x0008 - 0x0000)
struct FLegacyReticleSneakingProperties final
{
public:
	float                                         SneakingLevel;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyReticleSneakingProperties) == 0x000004, "Wrong alignment on FLegacyReticleSneakingProperties");
static_assert(sizeof(FLegacyReticleSneakingProperties) == 0x000008, "Wrong size on FLegacyReticleSneakingProperties");
static_assert(offsetof(FLegacyReticleSneakingProperties, SneakingLevel) == 0x000000, "Member 'FLegacyReticleSneakingProperties::SneakingLevel' has a wrong offset!");
static_assert(offsetof(FLegacyReticleSneakingProperties, bIsVisible) == 0x000004, "Member 'FLegacyReticleSneakingProperties::bIsVisible' has a wrong offset!");

// ScriptStruct Altar.VHairSenescenceTable
// 0x0050 (0x0050 - 0x0000)
struct FVHairSenescenceTable final
{
public:
	TMap<EVFacialHairType, TSoftObjectPtr<class UVSenescenceLevel>> HairMap;                         // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVHairSenescenceTable) == 0x000008, "Wrong alignment on FVHairSenescenceTable");
static_assert(sizeof(FVHairSenescenceTable) == 0x000050, "Wrong size on FVHairSenescenceTable");
static_assert(offsetof(FVHairSenescenceTable, HairMap) == 0x000000, "Member 'FVHairSenescenceTable::HairMap' has a wrong offset!");

// ScriptStruct Altar.VSenescenceTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FVSenescenceTableRow final : public FTableRowBase
{
public:
	TMap<int32, TSoftObjectPtr<class UVSenescenceLevel>> HeadSenescences;                            // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<int32, TSoftObjectPtr<class UVSenescenceLevel>> BodySenescences;                            // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<int32, struct FVHairSenescenceTable>     HairSenescences;                                   // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSenescenceTableRow) == 0x000008, "Wrong alignment on FVSenescenceTableRow");
static_assert(sizeof(FVSenescenceTableRow) == 0x0000F8, "Wrong size on FVSenescenceTableRow");
static_assert(offsetof(FVSenescenceTableRow, HeadSenescences) == 0x000008, "Member 'FVSenescenceTableRow::HeadSenescences' has a wrong offset!");
static_assert(offsetof(FVSenescenceTableRow, BodySenescences) == 0x000058, "Member 'FVSenescenceTableRow::BodySenescences' has a wrong offset!");
static_assert(offsetof(FVSenescenceTableRow, HairSenescences) == 0x0000A8, "Member 'FVSenescenceTableRow::HairSenescences' has a wrong offset!");

// ScriptStruct Altar.LegacyReticleEnemyHealthProperties
// 0x0008 (0x0008 - 0x0000)
struct FLegacyReticleEnemyHealthProperties final
{
public:
	float                                         EnemyHealthPercentage;                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnimated;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyReticleEnemyHealthProperties) == 0x000004, "Wrong alignment on FLegacyReticleEnemyHealthProperties");
static_assert(sizeof(FLegacyReticleEnemyHealthProperties) == 0x000008, "Wrong size on FLegacyReticleEnemyHealthProperties");
static_assert(offsetof(FLegacyReticleEnemyHealthProperties, EnemyHealthPercentage) == 0x000000, "Member 'FLegacyReticleEnemyHealthProperties::EnemyHealthPercentage' has a wrong offset!");
static_assert(offsetof(FLegacyReticleEnemyHealthProperties, bIsAnimated) == 0x000004, "Member 'FLegacyReticleEnemyHealthProperties::bIsAnimated' has a wrong offset!");
static_assert(offsetof(FLegacyReticleEnemyHealthProperties, bIsVisible) == 0x000005, "Member 'FLegacyReticleEnemyHealthProperties::bIsVisible' has a wrong offset!");

// ScriptStruct Altar.VHumanoidHeadCharacterAnimInstanceProxy
// 0x0050 (0x0750 - 0x0700)
struct FVHumanoidHeadCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x50];                                     // 0x0700(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVHumanoidHeadCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVHumanoidHeadCharacterAnimInstanceProxy");
static_assert(sizeof(FVHumanoidHeadCharacterAnimInstanceProxy) == 0x000750, "Wrong size on FVHumanoidHeadCharacterAnimInstanceProxy");

// ScriptStruct Altar.VHumanoidLowerAndUpperCharacterAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVHumanoidLowerAndUpperCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVHumanoidLowerAndUpperCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVHumanoidLowerAndUpperCharacterAnimInstanceProxy");
static_assert(sizeof(FVHumanoidLowerAndUpperCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVHumanoidLowerAndUpperCharacterAnimInstanceProxy");

// ScriptStruct Altar.VInventoryObjectRealignData
// 0x0080 (0x0088 - 0x0008)
struct FVInventoryObjectRealignData final : public FTableRowBase
{
public:
	class FName                                   Context;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTransform>          ActorPositionOffsetOverride;                       // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      InventoryPreviewBackgroundMaterial;                // 0x0060(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVInventoryObjectRealignData) == 0x000008, "Wrong alignment on FVInventoryObjectRealignData");
static_assert(sizeof(FVInventoryObjectRealignData) == 0x000088, "Wrong size on FVInventoryObjectRealignData");
static_assert(offsetof(FVInventoryObjectRealignData, Context) == 0x000008, "Member 'FVInventoryObjectRealignData::Context' has a wrong offset!");
static_assert(offsetof(FVInventoryObjectRealignData, ActorPositionOffsetOverride) == 0x000010, "Member 'FVInventoryObjectRealignData::ActorPositionOffsetOverride' has a wrong offset!");
static_assert(offsetof(FVInventoryObjectRealignData, InventoryPreviewBackgroundMaterial) == 0x000060, "Member 'FVInventoryObjectRealignData::InventoryPreviewBackgroundMaterial' has a wrong offset!");

// ScriptStruct Altar.VAttributeStatDataStructure
// 0x0008 (0x0070 - 0x0068)
struct FVAttributeStatDataStructure final : public FVStatsDataStructure
{
public:
	EAttributeStat                                Type;                                              // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultValue;                                      // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVAttributeStatDataStructure) == 0x000008, "Wrong alignment on FVAttributeStatDataStructure");
static_assert(sizeof(FVAttributeStatDataStructure) == 0x000070, "Wrong size on FVAttributeStatDataStructure");
static_assert(offsetof(FVAttributeStatDataStructure, Type) == 0x000068, "Member 'FVAttributeStatDataStructure::Type' has a wrong offset!");
static_assert(offsetof(FVAttributeStatDataStructure, DefaultValue) == 0x00006C, "Member 'FVAttributeStatDataStructure::DefaultValue' has a wrong offset!");

// ScriptStruct Altar.OriginalInventoryMenuItemSkillInformations
// 0x0060 (0x0060 - 0x0000)
struct FOriginalInventoryMenuItemSkillInformations final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   LevelName;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         CurrentProgression;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentSkill;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillBase;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SkillNameKey;                                      // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOriginalInventoryMenuItemSkillInformations) == 0x000008, "Wrong alignment on FOriginalInventoryMenuItemSkillInformations");
static_assert(sizeof(FOriginalInventoryMenuItemSkillInformations) == 0x000060, "Wrong size on FOriginalInventoryMenuItemSkillInformations");
static_assert(offsetof(FOriginalInventoryMenuItemSkillInformations, Name) == 0x000000, "Member 'FOriginalInventoryMenuItemSkillInformations::Name' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemSkillInformations, LevelName) == 0x000018, "Member 'FOriginalInventoryMenuItemSkillInformations::LevelName' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemSkillInformations, CurrentProgression) == 0x000030, "Member 'FOriginalInventoryMenuItemSkillInformations::CurrentProgression' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemSkillInformations, CurrentSkill) == 0x000034, "Member 'FOriginalInventoryMenuItemSkillInformations::CurrentSkill' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemSkillInformations, SkillBase) == 0x000038, "Member 'FOriginalInventoryMenuItemSkillInformations::SkillBase' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemSkillInformations, Icon) == 0x000040, "Member 'FOriginalInventoryMenuItemSkillInformations::Icon' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemSkillInformations, SkillNameKey) == 0x000048, "Member 'FOriginalInventoryMenuItemSkillInformations::SkillNameKey' has a wrong offset!");

// ScriptStruct Altar.OriginalInventoryMenuItemEffects
// 0x0020 (0x0020 - 0x0000)
struct FOriginalInventoryMenuItemEffects final
{
public:
	bool                                          bIsPoison;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Effect;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOriginalInventoryMenuItemEffects) == 0x000008, "Wrong alignment on FOriginalInventoryMenuItemEffects");
static_assert(sizeof(FOriginalInventoryMenuItemEffects) == 0x000020, "Wrong size on FOriginalInventoryMenuItemEffects");
static_assert(offsetof(FOriginalInventoryMenuItemEffects, bIsPoison) == 0x000000, "Member 'FOriginalInventoryMenuItemEffects::bIsPoison' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuItemEffects, Effect) == 0x000008, "Member 'FOriginalInventoryMenuItemEffects::Effect' has a wrong offset!");

// ScriptStruct Altar.VStaggerSwim
// 0x0010 (0x0010 - 0x0000)
struct FVStaggerSwim final
{
public:
	class UAnimMontage*                           Stagger;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Swim_Stagger;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVStaggerSwim) == 0x000008, "Wrong alignment on FVStaggerSwim");
static_assert(sizeof(FVStaggerSwim) == 0x000010, "Wrong size on FVStaggerSwim");
static_assert(offsetof(FVStaggerSwim, Stagger) == 0x000000, "Member 'FVStaggerSwim::Stagger' has a wrong offset!");
static_assert(offsetof(FVStaggerSwim, Swim_Stagger) == 0x000008, "Member 'FVStaggerSwim::Swim_Stagger' has a wrong offset!");

// ScriptStruct Altar.OriginalInventoryMenuSigilstoneEffects
// 0x0018 (0x0018 - 0x0000)
struct FOriginalInventoryMenuSigilstoneEffects final
{
public:
	class FText                                   Effect;                                            // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOriginalInventoryMenuSigilstoneEffects) == 0x000008, "Wrong alignment on FOriginalInventoryMenuSigilstoneEffects");
static_assert(sizeof(FOriginalInventoryMenuSigilstoneEffects) == 0x000018, "Wrong size on FOriginalInventoryMenuSigilstoneEffects");
static_assert(offsetof(FOriginalInventoryMenuSigilstoneEffects, Effect) == 0x000000, "Member 'FOriginalInventoryMenuSigilstoneEffects::Effect' has a wrong offset!");

// ScriptStruct Altar.OriginalInventoryMenuIngredientEffects
// 0x0028 (0x0028 - 0x0000)
struct FOriginalInventoryMenuIngredientEffects final
{
public:
	bool                                          bIsUnknown;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Effect;                                            // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOriginalInventoryMenuIngredientEffects) == 0x000008, "Wrong alignment on FOriginalInventoryMenuIngredientEffects");
static_assert(sizeof(FOriginalInventoryMenuIngredientEffects) == 0x000028, "Wrong size on FOriginalInventoryMenuIngredientEffects");
static_assert(offsetof(FOriginalInventoryMenuIngredientEffects, bIsUnknown) == 0x000000, "Member 'FOriginalInventoryMenuIngredientEffects::bIsUnknown' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuIngredientEffects, Icon) == 0x000008, "Member 'FOriginalInventoryMenuIngredientEffects::Icon' has a wrong offset!");
static_assert(offsetof(FOriginalInventoryMenuIngredientEffects, Effect) == 0x000010, "Member 'FOriginalInventoryMenuIngredientEffects::Effect' has a wrong offset!");

// ScriptStruct Altar.SkillsMenuProperties
// 0x0050 (0x0050 - 0x0000)
struct FSkillsMenuProperties final
{
public:
	ESkillMenuType                                MenuType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InformationText;                                   // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   CustomClassName;                                   // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 CustomClassNameKey;                                // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromClassMenu;                                     // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfItemsToSelect;                             // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillsMenuProperties) == 0x000008, "Wrong alignment on FSkillsMenuProperties");
static_assert(sizeof(FSkillsMenuProperties) == 0x000050, "Wrong size on FSkillsMenuProperties");
static_assert(offsetof(FSkillsMenuProperties, MenuType) == 0x000000, "Member 'FSkillsMenuProperties::MenuType' has a wrong offset!");
static_assert(offsetof(FSkillsMenuProperties, InformationText) == 0x000008, "Member 'FSkillsMenuProperties::InformationText' has a wrong offset!");
static_assert(offsetof(FSkillsMenuProperties, CustomClassName) == 0x000020, "Member 'FSkillsMenuProperties::CustomClassName' has a wrong offset!");
static_assert(offsetof(FSkillsMenuProperties, CustomClassNameKey) == 0x000038, "Member 'FSkillsMenuProperties::CustomClassNameKey' has a wrong offset!");
static_assert(offsetof(FSkillsMenuProperties, FromClassMenu) == 0x000048, "Member 'FSkillsMenuProperties::FromClassMenu' has a wrong offset!");
static_assert(offsetof(FSkillsMenuProperties, NumberOfItemsToSelect) == 0x00004C, "Member 'FSkillsMenuProperties::NumberOfItemsToSelect' has a wrong offset!");

// ScriptStruct Altar.LegacyAudioSettings
// 0x0014 (0x0014 - 0x0000)
struct FLegacyAudioSettings final
{
public:
	float                                         MasterVolume;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoiceVolume;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectVolume;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootVolume;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicVolume;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyAudioSettings) == 0x000004, "Wrong alignment on FLegacyAudioSettings");
static_assert(sizeof(FLegacyAudioSettings) == 0x000014, "Wrong size on FLegacyAudioSettings");
static_assert(offsetof(FLegacyAudioSettings, MasterVolume) == 0x000000, "Member 'FLegacyAudioSettings::MasterVolume' has a wrong offset!");
static_assert(offsetof(FLegacyAudioSettings, VoiceVolume) == 0x000004, "Member 'FLegacyAudioSettings::VoiceVolume' has a wrong offset!");
static_assert(offsetof(FLegacyAudioSettings, EffectVolume) == 0x000008, "Member 'FLegacyAudioSettings::EffectVolume' has a wrong offset!");
static_assert(offsetof(FLegacyAudioSettings, FootVolume) == 0x00000C, "Member 'FLegacyAudioSettings::FootVolume' has a wrong offset!");
static_assert(offsetof(FLegacyAudioSettings, MusicVolume) == 0x000010, "Member 'FLegacyAudioSettings::MusicVolume' has a wrong offset!");

// ScriptStruct Altar.LegacyLoadingMenuGameInfo
// 0x0020 (0x0020 - 0x0000)
struct FLegacyLoadingMenuGameInfo final
{
public:
	class UTexture2D*                             LoadingTexture;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LoadingText;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyLoadingMenuGameInfo) == 0x000008, "Wrong alignment on FLegacyLoadingMenuGameInfo");
static_assert(sizeof(FLegacyLoadingMenuGameInfo) == 0x000020, "Wrong size on FLegacyLoadingMenuGameInfo");
static_assert(offsetof(FLegacyLoadingMenuGameInfo, LoadingTexture) == 0x000000, "Member 'FLegacyLoadingMenuGameInfo::LoadingTexture' has a wrong offset!");
static_assert(offsetof(FLegacyLoadingMenuGameInfo, LoadingText) == 0x000008, "Member 'FLegacyLoadingMenuGameInfo::LoadingText' has a wrong offset!");

// ScriptStruct Altar.LegacyNotificationProperties
// 0x0030 (0x0030 - 0x0000)
struct FLegacyNotificationProperties final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         ShowSeconds;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsQuest;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyNotificationProperties) == 0x000008, "Wrong alignment on FLegacyNotificationProperties");
static_assert(sizeof(FLegacyNotificationProperties) == 0x000030, "Wrong size on FLegacyNotificationProperties");
static_assert(offsetof(FLegacyNotificationProperties, Text) == 0x000000, "Member 'FLegacyNotificationProperties::Text' has a wrong offset!");
static_assert(offsetof(FLegacyNotificationProperties, ShowSeconds) == 0x000018, "Member 'FLegacyNotificationProperties::ShowSeconds' has a wrong offset!");
static_assert(offsetof(FLegacyNotificationProperties, Icon) == 0x000020, "Member 'FLegacyNotificationProperties::Icon' has a wrong offset!");
static_assert(offsetof(FLegacyNotificationProperties, bIsQuest) == 0x000028, "Member 'FLegacyNotificationProperties::bIsQuest' has a wrong offset!");

// ScriptStruct Altar.LegacyQuickKeysActionBinding
// 0x0038 (0x0038 - 0x0000)
struct FLegacyQuickKeysActionBinding final
{
public:
	struct FLegacyMenuActionBinding               PressData;                                         // 0x0000(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FLegacyMenuActionBinding               ReleaseData;                                       // 0x0018(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyQuickKeysActionBinding) == 0x000008, "Wrong alignment on FLegacyQuickKeysActionBinding");
static_assert(sizeof(FLegacyQuickKeysActionBinding) == 0x000038, "Wrong size on FLegacyQuickKeysActionBinding");
static_assert(offsetof(FLegacyQuickKeysActionBinding, PressData) == 0x000000, "Member 'FLegacyQuickKeysActionBinding::PressData' has a wrong offset!");
static_assert(offsetof(FLegacyQuickKeysActionBinding, ReleaseData) == 0x000018, "Member 'FLegacyQuickKeysActionBinding::ReleaseData' has a wrong offset!");

// ScriptStruct Altar.LegacyTextEditMenuProperties
// 0x0030 (0x0030 - 0x0000)
struct FLegacyTextEditMenuProperties final
{
public:
	class FText                                   Prompt;                                            // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DefaultText;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyTextEditMenuProperties) == 0x000008, "Wrong alignment on FLegacyTextEditMenuProperties");
static_assert(sizeof(FLegacyTextEditMenuProperties) == 0x000030, "Wrong size on FLegacyTextEditMenuProperties");
static_assert(offsetof(FLegacyTextEditMenuProperties, Prompt) == 0x000000, "Member 'FLegacyTextEditMenuProperties::Prompt' has a wrong offset!");
static_assert(offsetof(FLegacyTextEditMenuProperties, DefaultText) == 0x000018, "Member 'FLegacyTextEditMenuProperties::DefaultText' has a wrong offset!");

// ScriptStruct Altar.LegacyStatsMenuPlayerInfo
// 0x0070 (0x0070 - 0x0000)
struct FLegacyStatsMenuPlayerInfo final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Race;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Birthsign;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Class;                                             // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             ClassTexture;                                      // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyStatsMenuPlayerInfo) == 0x000008, "Wrong alignment on FLegacyStatsMenuPlayerInfo");
static_assert(sizeof(FLegacyStatsMenuPlayerInfo) == 0x000070, "Wrong size on FLegacyStatsMenuPlayerInfo");
static_assert(offsetof(FLegacyStatsMenuPlayerInfo, Name) == 0x000000, "Member 'FLegacyStatsMenuPlayerInfo::Name' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuPlayerInfo, Race) == 0x000018, "Member 'FLegacyStatsMenuPlayerInfo::Race' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuPlayerInfo, Birthsign) == 0x000030, "Member 'FLegacyStatsMenuPlayerInfo::Birthsign' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuPlayerInfo, Class) == 0x000048, "Member 'FLegacyStatsMenuPlayerInfo::Class' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuPlayerInfo, ClassTexture) == 0x000060, "Member 'FLegacyStatsMenuPlayerInfo::ClassTexture' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuPlayerInfo, Level) == 0x000068, "Member 'FLegacyStatsMenuPlayerInfo::Level' has a wrong offset!");

// ScriptStruct Altar.LegacyVideoSettings
// 0x00A0 (0x00A0 - 0x0000)
struct FLegacyVideoSettings final
{
public:
	TMap<EFLegacyVideoSettingsEnum, uint8>        UintSettings;                                      // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EFLegacyVideoSettingsEnum, float>        FloatSettings;                                     // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyVideoSettings) == 0x000008, "Wrong alignment on FLegacyVideoSettings");
static_assert(sizeof(FLegacyVideoSettings) == 0x0000A0, "Wrong size on FLegacyVideoSettings");
static_assert(offsetof(FLegacyVideoSettings, UintSettings) == 0x000000, "Member 'FLegacyVideoSettings::UintSettings' has a wrong offset!");
static_assert(offsetof(FLegacyVideoSettings, FloatSettings) == 0x000050, "Member 'FLegacyVideoSettings::FloatSettings' has a wrong offset!");

// ScriptStruct Altar.StaffAttackData
// 0x0008 (0x0008 - 0x0000)
struct FStaffAttackData final
{
public:
	class UAnimSequenceBase*                      Attack;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaffAttackData) == 0x000008, "Wrong alignment on FStaffAttackData");
static_assert(sizeof(FStaffAttackData) == 0x000008, "Wrong size on FStaffAttackData");
static_assert(offsetof(FStaffAttackData, Attack) == 0x000000, "Member 'FStaffAttackData::Attack' has a wrong offset!");

// ScriptStruct Altar.LegacyVideoTableRow
// 0x0030 (0x0038 - 0x0008)
struct FLegacyVideoTableRow final : public FTableRowBase
{
public:
	EFLegacyVideoSettingsEnum                     Setting;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Label;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UVLegacyVideoWidgetBase>    WidgetClass;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELegacyVideoMenuOptionType                    OptionType;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyVideoTableRow) == 0x000008, "Wrong alignment on FLegacyVideoTableRow");
static_assert(sizeof(FLegacyVideoTableRow) == 0x000038, "Wrong size on FLegacyVideoTableRow");
static_assert(offsetof(FLegacyVideoTableRow, Setting) == 0x000008, "Member 'FLegacyVideoTableRow::Setting' has a wrong offset!");
static_assert(offsetof(FLegacyVideoTableRow, Label) == 0x000010, "Member 'FLegacyVideoTableRow::Label' has a wrong offset!");
static_assert(offsetof(FLegacyVideoTableRow, WidgetClass) == 0x000028, "Member 'FLegacyVideoTableRow::WidgetClass' has a wrong offset!");
static_assert(offsetof(FLegacyVideoTableRow, OptionType) == 0x000030, "Member 'FLegacyVideoTableRow::OptionType' has a wrong offset!");

// ScriptStruct Altar.LegacyXControllerSettings
// 0x000C (0x000C - 0x0000)
struct FLegacyXControllerSettings final
{
public:
	float                                         VerticalSensitivity;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalSensitivity;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertY;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Vibration;                                         // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyXControllerSettings) == 0x000004, "Wrong alignment on FLegacyXControllerSettings");
static_assert(sizeof(FLegacyXControllerSettings) == 0x00000C, "Wrong size on FLegacyXControllerSettings");
static_assert(offsetof(FLegacyXControllerSettings, VerticalSensitivity) == 0x000000, "Member 'FLegacyXControllerSettings::VerticalSensitivity' has a wrong offset!");
static_assert(offsetof(FLegacyXControllerSettings, HorizontalSensitivity) == 0x000004, "Member 'FLegacyXControllerSettings::HorizontalSensitivity' has a wrong offset!");
static_assert(offsetof(FLegacyXControllerSettings, InvertY) == 0x000008, "Member 'FLegacyXControllerSettings::InvertY' has a wrong offset!");
static_assert(offsetof(FLegacyXControllerSettings, Vibration) == 0x000009, "Member 'FLegacyXControllerSettings::Vibration' has a wrong offset!");

// ScriptStruct Altar.LegacyStatsMenuSkillItemUpdatableProperties
// 0x0010 (0x0010 - 0x0000)
struct FLegacyStatsMenuSkillItemUpdatableProperties final
{
public:
	float                                         CurrentProgression;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentSkill;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillBase;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMajorSkill;                                      // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyStatsMenuSkillItemUpdatableProperties) == 0x000004, "Wrong alignment on FLegacyStatsMenuSkillItemUpdatableProperties");
static_assert(sizeof(FLegacyStatsMenuSkillItemUpdatableProperties) == 0x000010, "Wrong size on FLegacyStatsMenuSkillItemUpdatableProperties");
static_assert(offsetof(FLegacyStatsMenuSkillItemUpdatableProperties, CurrentProgression) == 0x000000, "Member 'FLegacyStatsMenuSkillItemUpdatableProperties::CurrentProgression' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSkillItemUpdatableProperties, CurrentSkill) == 0x000004, "Member 'FLegacyStatsMenuSkillItemUpdatableProperties::CurrentSkill' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSkillItemUpdatableProperties, SkillBase) == 0x000008, "Member 'FLegacyStatsMenuSkillItemUpdatableProperties::SkillBase' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSkillItemUpdatableProperties, IsMajorSkill) == 0x00000C, "Member 'FLegacyStatsMenuSkillItemUpdatableProperties::IsMajorSkill' has a wrong offset!");

// ScriptStruct Altar.LegacyStatsMenuSkillItemProperties
// 0x0090 (0x0090 - 0x0000)
struct FLegacyStatsMenuSkillItemProperties final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   LevelName;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLegacyStatsMenuSkillItemUpdatableProperties UpdateableProperties;                        // 0x0048(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxProgression;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BigIcon;                                           // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillIndex;                                        // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SkillNameLocalizationKey;                          // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyStatsMenuSkillItemProperties) == 0x000008, "Wrong alignment on FLegacyStatsMenuSkillItemProperties");
static_assert(sizeof(FLegacyStatsMenuSkillItemProperties) == 0x000090, "Wrong size on FLegacyStatsMenuSkillItemProperties");
static_assert(offsetof(FLegacyStatsMenuSkillItemProperties, Name) == 0x000000, "Member 'FLegacyStatsMenuSkillItemProperties::Name' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSkillItemProperties, LevelName) == 0x000018, "Member 'FLegacyStatsMenuSkillItemProperties::LevelName' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSkillItemProperties, Description) == 0x000030, "Member 'FLegacyStatsMenuSkillItemProperties::Description' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSkillItemProperties, UpdateableProperties) == 0x000048, "Member 'FLegacyStatsMenuSkillItemProperties::UpdateableProperties' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSkillItemProperties, MaxProgression) == 0x000058, "Member 'FLegacyStatsMenuSkillItemProperties::MaxProgression' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSkillItemProperties, Icon) == 0x000060, "Member 'FLegacyStatsMenuSkillItemProperties::Icon' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSkillItemProperties, BigIcon) == 0x000068, "Member 'FLegacyStatsMenuSkillItemProperties::BigIcon' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSkillItemProperties, SkillIndex) == 0x000070, "Member 'FLegacyStatsMenuSkillItemProperties::SkillIndex' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuSkillItemProperties, SkillNameLocalizationKey) == 0x000078, "Member 'FLegacyStatsMenuSkillItemProperties::SkillNameLocalizationKey' has a wrong offset!");

// ScriptStruct Altar.LevelUpMenuAttributeData
// 0x0020 (0x0020 - 0x0000)
struct FLevelUpMenuAttributeData final
{
public:
	class FString                                 Description;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseActorValue;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelUpBonus;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVAttribute                                   Attribute;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelUpMenuAttributeData) == 0x000008, "Wrong alignment on FLevelUpMenuAttributeData");
static_assert(sizeof(FLevelUpMenuAttributeData) == 0x000020, "Wrong size on FLevelUpMenuAttributeData");
static_assert(offsetof(FLevelUpMenuAttributeData, Description) == 0x000000, "Member 'FLevelUpMenuAttributeData::Description' has a wrong offset!");
static_assert(offsetof(FLevelUpMenuAttributeData, BaseActorValue) == 0x000010, "Member 'FLevelUpMenuAttributeData::BaseActorValue' has a wrong offset!");
static_assert(offsetof(FLevelUpMenuAttributeData, LevelUpBonus) == 0x000014, "Member 'FLevelUpMenuAttributeData::LevelUpBonus' has a wrong offset!");
static_assert(offsetof(FLevelUpMenuAttributeData, Attribute) == 0x000018, "Member 'FLevelUpMenuAttributeData::Attribute' has a wrong offset!");

// ScriptStruct Altar.LevelUpMenuInitializationData
// 0x0038 (0x0038 - 0x0000)
struct FLevelUpMenuInitializationData final
{
public:
	TArray<struct FLevelUpMenuAttributeData>      AttributesData;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 LevelUpTitle;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelUpText;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingCoinsNumber;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelUpMenuInitializationData) == 0x000008, "Wrong alignment on FLevelUpMenuInitializationData");
static_assert(sizeof(FLevelUpMenuInitializationData) == 0x000038, "Wrong size on FLevelUpMenuInitializationData");
static_assert(offsetof(FLevelUpMenuInitializationData, AttributesData) == 0x000000, "Member 'FLevelUpMenuInitializationData::AttributesData' has a wrong offset!");
static_assert(offsetof(FLevelUpMenuInitializationData, LevelUpTitle) == 0x000010, "Member 'FLevelUpMenuInitializationData::LevelUpTitle' has a wrong offset!");
static_assert(offsetof(FLevelUpMenuInitializationData, LevelUpText) == 0x000020, "Member 'FLevelUpMenuInitializationData::LevelUpText' has a wrong offset!");
static_assert(offsetof(FLevelUpMenuInitializationData, StartingCoinsNumber) == 0x000030, "Member 'FLevelUpMenuInitializationData::StartingCoinsNumber' has a wrong offset!");

// ScriptStruct Altar.SimpleInAirAnimationData
// 0x0010 (0x0010 - 0x0000)
struct FSimpleInAirAnimationData final
{
public:
	class UAnimSequence*                          InAirLoop;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Landing;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleInAirAnimationData) == 0x000008, "Wrong alignment on FSimpleInAirAnimationData");
static_assert(sizeof(FSimpleInAirAnimationData) == 0x000010, "Wrong size on FSimpleInAirAnimationData");
static_assert(offsetof(FSimpleInAirAnimationData, InAirLoop) == 0x000000, "Member 'FSimpleInAirAnimationData::InAirLoop' has a wrong offset!");
static_assert(offsetof(FSimpleInAirAnimationData, Landing) == 0x000008, "Member 'FSimpleInAirAnimationData::Landing' has a wrong offset!");

// ScriptStruct Altar.LevelUpMenuState
// 0x0018 (0x0018 - 0x0000)
struct FLevelUpMenuState final
{
public:
	int32                                         NumberCoins;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EVAttribute>                           SelectedAttributes;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelUpMenuState) == 0x000008, "Wrong alignment on FLevelUpMenuState");
static_assert(sizeof(FLevelUpMenuState) == 0x000018, "Wrong size on FLevelUpMenuState");
static_assert(offsetof(FLevelUpMenuState, NumberCoins) == 0x000000, "Member 'FLevelUpMenuState::NumberCoins' has a wrong offset!");
static_assert(offsetof(FLevelUpMenuState, SelectedAttributes) == 0x000008, "Member 'FLevelUpMenuState::SelectedAttributes' has a wrong offset!");

// ScriptStruct Altar.LevelUpAttributeParameters
// 0x0010 (0x0018 - 0x0008)
struct FLevelUpAttributeParameters final : public FTableRowBase
{
public:
	int32                                         MaxValue;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultBonus;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusCost;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBonus;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelUpAttributeParameters) == 0x000008, "Wrong alignment on FLevelUpAttributeParameters");
static_assert(sizeof(FLevelUpAttributeParameters) == 0x000018, "Wrong size on FLevelUpAttributeParameters");
static_assert(offsetof(FLevelUpAttributeParameters, MaxValue) == 0x000008, "Member 'FLevelUpAttributeParameters::MaxValue' has a wrong offset!");
static_assert(offsetof(FLevelUpAttributeParameters, DefaultBonus) == 0x00000C, "Member 'FLevelUpAttributeParameters::DefaultBonus' has a wrong offset!");
static_assert(offsetof(FLevelUpAttributeParameters, BonusCost) == 0x000010, "Member 'FLevelUpAttributeParameters::BonusCost' has a wrong offset!");
static_assert(offsetof(FLevelUpAttributeParameters, MaxBonus) == 0x000014, "Member 'FLevelUpAttributeParameters::MaxBonus' has a wrong offset!");

// ScriptStruct Altar.VPrePlacedGuidToAsyncFlowHashRow
// 0x0020 (0x0028 - 0x0008)
struct FVPrePlacedGuidToAsyncFlowHashRow final : public FTableRowBase
{
public:
	struct FGuid                                  Guid;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CellNameForAsyncFlow;                              // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVPrePlacedGuidToAsyncFlowHashRow) == 0x000008, "Wrong alignment on FVPrePlacedGuidToAsyncFlowHashRow");
static_assert(sizeof(FVPrePlacedGuidToAsyncFlowHashRow) == 0x000028, "Wrong size on FVPrePlacedGuidToAsyncFlowHashRow");
static_assert(offsetof(FVPrePlacedGuidToAsyncFlowHashRow, Guid) == 0x000008, "Member 'FVPrePlacedGuidToAsyncFlowHashRow::Guid' has a wrong offset!");
static_assert(offsetof(FVPrePlacedGuidToAsyncFlowHashRow, CellNameForAsyncFlow) == 0x000018, "Member 'FVPrePlacedGuidToAsyncFlowHashRow::CellNameForAsyncFlow' has a wrong offset!");

// ScriptStruct Altar.LoadingScreenImageData
// 0x0020 (0x0028 - 0x0008)
struct FLoadingScreenImageData final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        Image;                                             // 0x0008(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingScreenImageData) == 0x000008, "Wrong alignment on FLoadingScreenImageData");
static_assert(sizeof(FLoadingScreenImageData) == 0x000028, "Wrong size on FLoadingScreenImageData");
static_assert(offsetof(FLoadingScreenImageData, Image) == 0x000008, "Member 'FLoadingScreenImageData::Image' has a wrong offset!");

// ScriptStruct Altar.VLocalizationStringTable
// 0x0018 (0x0018 - 0x0000)
struct FVLocalizationStringTable final
{
public:
	class FString                                 KeyPrefix;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TableName;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVLocalizationStringTable) == 0x000008, "Wrong alignment on FVLocalizationStringTable");
static_assert(sizeof(FVLocalizationStringTable) == 0x000018, "Wrong size on FVLocalizationStringTable");
static_assert(offsetof(FVLocalizationStringTable, KeyPrefix) == 0x000000, "Member 'FVLocalizationStringTable::KeyPrefix' has a wrong offset!");
static_assert(offsetof(FVLocalizationStringTable, TableName) == 0x000010, "Member 'FVLocalizationStringTable::TableName' has a wrong offset!");

// ScriptStruct Altar.StandSwimMeleeAttackSimple
// 0x0028 (0x0028 - 0x0000)
struct FStandSwimMeleeAttackSimple final
{
public:
	class UAnimSequence*                          AttackRight;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AttackLeft;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PowerAttack;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SwimAttackRight;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SwimAttackLeft;                                    // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandSwimMeleeAttackSimple) == 0x000008, "Wrong alignment on FStandSwimMeleeAttackSimple");
static_assert(sizeof(FStandSwimMeleeAttackSimple) == 0x000028, "Wrong size on FStandSwimMeleeAttackSimple");
static_assert(offsetof(FStandSwimMeleeAttackSimple, AttackRight) == 0x000000, "Member 'FStandSwimMeleeAttackSimple::AttackRight' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackSimple, AttackLeft) == 0x000008, "Member 'FStandSwimMeleeAttackSimple::AttackLeft' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackSimple, PowerAttack) == 0x000010, "Member 'FStandSwimMeleeAttackSimple::PowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackSimple, SwimAttackRight) == 0x000018, "Member 'FStandSwimMeleeAttackSimple::SwimAttackRight' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackSimple, SwimAttackLeft) == 0x000020, "Member 'FStandSwimMeleeAttackSimple::SwimAttackLeft' has a wrong offset!");

// ScriptStruct Altar.LegacyLockpickMenuProperties
// 0x0010 (0x0010 - 0x0000)
struct FLegacyLockpickMenuProperties final
{
public:
	ELegacyLockpickMenuDifficulty                 Difficulty;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumLockpicks;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSkeletonKey;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SecurityLevel;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyLockpickMenuProperties) == 0x000004, "Wrong alignment on FLegacyLockpickMenuProperties");
static_assert(sizeof(FLegacyLockpickMenuProperties) == 0x000010, "Wrong size on FLegacyLockpickMenuProperties");
static_assert(offsetof(FLegacyLockpickMenuProperties, Difficulty) == 0x000000, "Member 'FLegacyLockpickMenuProperties::Difficulty' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuProperties, NumLockpicks) == 0x000004, "Member 'FLegacyLockpickMenuProperties::NumLockpicks' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuProperties, HasSkeletonKey) == 0x000008, "Member 'FLegacyLockpickMenuProperties::HasSkeletonKey' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuProperties, SecurityLevel) == 0x00000C, "Member 'FLegacyLockpickMenuProperties::SecurityLevel' has a wrong offset!");

// ScriptStruct Altar.LegacyLockpickMenuTumblerDefaultProperties
// 0x001C (0x001C - 0x0000)
struct FLegacyLockpickMenuTumblerDefaultProperties final
{
public:
	float                                         VelocityMin;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityMax;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustedVelocityMin;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PauseMin;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PauseMax;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAnimationTime;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyLockpickMenuTumblerDefaultProperties) == 0x000004, "Wrong alignment on FLegacyLockpickMenuTumblerDefaultProperties");
static_assert(sizeof(FLegacyLockpickMenuTumblerDefaultProperties) == 0x00001C, "Wrong size on FLegacyLockpickMenuTumblerDefaultProperties");
static_assert(offsetof(FLegacyLockpickMenuTumblerDefaultProperties, VelocityMin) == 0x000000, "Member 'FLegacyLockpickMenuTumblerDefaultProperties::VelocityMin' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuTumblerDefaultProperties, VelocityMax) == 0x000004, "Member 'FLegacyLockpickMenuTumblerDefaultProperties::VelocityMax' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuTumblerDefaultProperties, AdjustedVelocityMin) == 0x000008, "Member 'FLegacyLockpickMenuTumblerDefaultProperties::AdjustedVelocityMin' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuTumblerDefaultProperties, PauseMin) == 0x00000C, "Member 'FLegacyLockpickMenuTumblerDefaultProperties::PauseMin' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuTumblerDefaultProperties, PauseMax) == 0x000010, "Member 'FLegacyLockpickMenuTumblerDefaultProperties::PauseMax' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuTumblerDefaultProperties, Gravity) == 0x000014, "Member 'FLegacyLockpickMenuTumblerDefaultProperties::Gravity' has a wrong offset!");
static_assert(offsetof(FLegacyLockpickMenuTumblerDefaultProperties, MaxAnimationTime) == 0x000018, "Member 'FLegacyLockpickMenuTumblerDefaultProperties::MaxAnimationTime' has a wrong offset!");

// ScriptStruct Altar.VPreviewSpecificLocationRotationTableRow
// 0x0050 (0x0058 - 0x0008)
struct FVPreviewSpecificLocationRotationTableRow final : public FTableRowBase
{
public:
	int64                                         FormID;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVInventoryPreviewPositionOverride     DefaultParameters;                                 // 0x0010(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVPreviewSpecificLocationRotationTableRow) == 0x000008, "Wrong alignment on FVPreviewSpecificLocationRotationTableRow");
static_assert(sizeof(FVPreviewSpecificLocationRotationTableRow) == 0x000058, "Wrong size on FVPreviewSpecificLocationRotationTableRow");
static_assert(offsetof(FVPreviewSpecificLocationRotationTableRow, FormID) == 0x000008, "Member 'FVPreviewSpecificLocationRotationTableRow::FormID' has a wrong offset!");
static_assert(offsetof(FVPreviewSpecificLocationRotationTableRow, DefaultParameters) == 0x000010, "Member 'FVPreviewSpecificLocationRotationTableRow::DefaultParameters' has a wrong offset!");

// ScriptStruct Altar.VLocomotionHorseAnimInstanceProxy
// 0x0010 (0x0720 - 0x0710)
struct FVLocomotionHorseAnimInstanceProxy final : public FVLocomotionCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_710[0x10];                                     // 0x0710(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVLocomotionHorseAnimInstanceProxy) == 0x000010, "Wrong alignment on FVLocomotionHorseAnimInstanceProxy");
static_assert(sizeof(FVLocomotionHorseAnimInstanceProxy) == 0x000720, "Wrong size on FVLocomotionHorseAnimInstanceProxy");

// ScriptStruct Altar.SpellCastMultiAnimSet
// 0x0068 (0x0068 - 0x0000)
struct FSpellCastMultiAnimSet final
{
public:
	TArray<class UAnimSequenceBase*>              CastTouchLeft;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              CastTouchRight;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              CastSelfLeft;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              CastSelfRight;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              CastTargetLeft;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              CastTargetRight;                                   // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle;                                              // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpellCastMultiAnimSet) == 0x000008, "Wrong alignment on FSpellCastMultiAnimSet");
static_assert(sizeof(FSpellCastMultiAnimSet) == 0x000068, "Wrong size on FSpellCastMultiAnimSet");
static_assert(offsetof(FSpellCastMultiAnimSet, CastTouchLeft) == 0x000000, "Member 'FSpellCastMultiAnimSet::CastTouchLeft' has a wrong offset!");
static_assert(offsetof(FSpellCastMultiAnimSet, CastTouchRight) == 0x000010, "Member 'FSpellCastMultiAnimSet::CastTouchRight' has a wrong offset!");
static_assert(offsetof(FSpellCastMultiAnimSet, CastSelfLeft) == 0x000020, "Member 'FSpellCastMultiAnimSet::CastSelfLeft' has a wrong offset!");
static_assert(offsetof(FSpellCastMultiAnimSet, CastSelfRight) == 0x000030, "Member 'FSpellCastMultiAnimSet::CastSelfRight' has a wrong offset!");
static_assert(offsetof(FSpellCastMultiAnimSet, CastTargetLeft) == 0x000040, "Member 'FSpellCastMultiAnimSet::CastTargetLeft' has a wrong offset!");
static_assert(offsetof(FSpellCastMultiAnimSet, CastTargetRight) == 0x000050, "Member 'FSpellCastMultiAnimSet::CastTargetRight' has a wrong offset!");
static_assert(offsetof(FSpellCastMultiAnimSet, Idle) == 0x000060, "Member 'FSpellCastMultiAnimSet::Idle' has a wrong offset!");

// ScriptStruct Altar.VLocomotion
// 0x0008 (0x0008 - 0x0000)
struct FVLocomotion final
{
public:
	class UBlendSpace*                            BlendSpace_Moving;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVLocomotion) == 0x000008, "Wrong alignment on FVLocomotion");
static_assert(sizeof(FVLocomotion) == 0x000008, "Wrong size on FVLocomotion");
static_assert(offsetof(FVLocomotion, BlendSpace_Moving) == 0x000000, "Member 'FVLocomotion::BlendSpace_Moving' has a wrong offset!");

// ScriptStruct Altar.VSprinting
// 0x0008 (0x0008 - 0x0000)
struct FVSprinting final
{
public:
	class UAnimSequenceBase*                      Sprint;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSprinting) == 0x000008, "Wrong alignment on FVSprinting");
static_assert(sizeof(FVSprinting) == 0x000008, "Wrong size on FVSprinting");
static_assert(offsetof(FVSprinting, Sprint) == 0x000000, "Member 'FVSprinting::Sprint' has a wrong offset!");

// ScriptStruct Altar.VRaceSexMenuCustomisationOptions
// 0x00A8 (0x00A8 - 0x0000)
struct FVRaceSexMenuCustomisationOptions final
{
public:
	ELegacyRaceSexMenuToggleType                  Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                Portrait;                                          // 0x0020(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x0048(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVCharacterHairPieceBase> HairPiece;                                        // 0x0070(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVHairColorCustomisationOptions        HairColor;                                         // 0x0098(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EModernCharacterCreationGenderRequirement     GenderRequirement;                                 // 0x00A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInRandomization;                             // 0x00A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVRaceSexMenuCustomisationOptions) == 0x000008, "Wrong alignment on FVRaceSexMenuCustomisationOptions");
static_assert(sizeof(FVRaceSexMenuCustomisationOptions) == 0x0000A8, "Wrong size on FVRaceSexMenuCustomisationOptions");
static_assert(offsetof(FVRaceSexMenuCustomisationOptions, Type) == 0x000000, "Member 'FVRaceSexMenuCustomisationOptions::Type' has a wrong offset!");
static_assert(offsetof(FVRaceSexMenuCustomisationOptions, Name) == 0x000008, "Member 'FVRaceSexMenuCustomisationOptions::Name' has a wrong offset!");
static_assert(offsetof(FVRaceSexMenuCustomisationOptions, Portrait) == 0x000020, "Member 'FVRaceSexMenuCustomisationOptions::Portrait' has a wrong offset!");
static_assert(offsetof(FVRaceSexMenuCustomisationOptions, Material) == 0x000048, "Member 'FVRaceSexMenuCustomisationOptions::Material' has a wrong offset!");
static_assert(offsetof(FVRaceSexMenuCustomisationOptions, HairPiece) == 0x000070, "Member 'FVRaceSexMenuCustomisationOptions::HairPiece' has a wrong offset!");
static_assert(offsetof(FVRaceSexMenuCustomisationOptions, HairColor) == 0x000098, "Member 'FVRaceSexMenuCustomisationOptions::HairColor' has a wrong offset!");
static_assert(offsetof(FVRaceSexMenuCustomisationOptions, GenderRequirement) == 0x0000A4, "Member 'FVRaceSexMenuCustomisationOptions::GenderRequirement' has a wrong offset!");
static_assert(offsetof(FVRaceSexMenuCustomisationOptions, bAllowInRandomization) == 0x0000A5, "Member 'FVRaceSexMenuCustomisationOptions::bAllowInRandomization' has a wrong offset!");

// ScriptStruct Altar.LegacyRaceSexMenuToggleProperties
// 0x0020 (0x0020 - 0x0000)
struct FLegacyRaceSexMenuToggleProperties final
{
public:
	ELegacyRaceSexMenuToggleType                  Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxRow;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionIndex;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVRaceSexMenuCustomisationOptions> Options;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyRaceSexMenuToggleProperties) == 0x000008, "Wrong alignment on FLegacyRaceSexMenuToggleProperties");
static_assert(sizeof(FLegacyRaceSexMenuToggleProperties) == 0x000020, "Wrong size on FLegacyRaceSexMenuToggleProperties");
static_assert(offsetof(FLegacyRaceSexMenuToggleProperties, Type) == 0x000000, "Member 'FLegacyRaceSexMenuToggleProperties::Type' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuToggleProperties, MaxRow) == 0x000004, "Member 'FLegacyRaceSexMenuToggleProperties::MaxRow' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuToggleProperties, OptionIndex) == 0x000008, "Member 'FLegacyRaceSexMenuToggleProperties::OptionIndex' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuToggleProperties, Options) == 0x000010, "Member 'FLegacyRaceSexMenuToggleProperties::Options' has a wrong offset!");

// ScriptStruct Altar.VLocomotionTurn
// 0x0020 (0x0020 - 0x0000)
struct FVLocomotionTurn final
{
public:
	class UBlendSpace*                            BlendSpace_Moving;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Turn_Left;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Turn_Right;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpace_Turning;                                // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVLocomotionTurn) == 0x000008, "Wrong alignment on FVLocomotionTurn");
static_assert(sizeof(FVLocomotionTurn) == 0x000020, "Wrong size on FVLocomotionTurn");
static_assert(offsetof(FVLocomotionTurn, BlendSpace_Moving) == 0x000000, "Member 'FVLocomotionTurn::BlendSpace_Moving' has a wrong offset!");
static_assert(offsetof(FVLocomotionTurn, Turn_Left) == 0x000008, "Member 'FVLocomotionTurn::Turn_Left' has a wrong offset!");
static_assert(offsetof(FVLocomotionTurn, Turn_Right) == 0x000010, "Member 'FVLocomotionTurn::Turn_Right' has a wrong offset!");
static_assert(offsetof(FVLocomotionTurn, BlendSpace_Turning) == 0x000018, "Member 'FVLocomotionTurn::BlendSpace_Turning' has a wrong offset!");

// ScriptStruct Altar.Modern_StatMenuLevelTableRow
// 0x0038 (0x0040 - 0x0008)
struct FModern_StatMenuLevelTableRow final : public FTableRowBase
{
public:
	int32                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DescriptionText;                                   // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModern_StatMenuLevelTableRow) == 0x000008, "Wrong alignment on FModern_StatMenuLevelTableRow");
static_assert(sizeof(FModern_StatMenuLevelTableRow) == 0x000040, "Wrong size on FModern_StatMenuLevelTableRow");
static_assert(offsetof(FModern_StatMenuLevelTableRow, Value) == 0x000008, "Member 'FModern_StatMenuLevelTableRow::Value' has a wrong offset!");
static_assert(offsetof(FModern_StatMenuLevelTableRow, Name) == 0x000010, "Member 'FModern_StatMenuLevelTableRow::Name' has a wrong offset!");
static_assert(offsetof(FModern_StatMenuLevelTableRow, DescriptionText) == 0x000028, "Member 'FModern_StatMenuLevelTableRow::DescriptionText' has a wrong offset!");

// ScriptStruct Altar.VLookAtAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVLookAtAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVLookAtAnimInstanceProxy) == 0x000010, "Wrong alignment on FVLookAtAnimInstanceProxy");
static_assert(sizeof(FVLookAtAnimInstanceProxy) == 0x000710, "Wrong size on FVLookAtAnimInstanceProxy");

// ScriptStruct Altar.LegacyMagicMenuHeaderProperties
// 0x0020 (0x0020 - 0x0000)
struct FLegacyMagicMenuHeaderProperties final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ELegacyMagicMenuItemType                      Type;                                              // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyMagicMenuHeaderProperties) == 0x000008, "Wrong alignment on FLegacyMagicMenuHeaderProperties");
static_assert(sizeof(FLegacyMagicMenuHeaderProperties) == 0x000020, "Wrong size on FLegacyMagicMenuHeaderProperties");
static_assert(offsetof(FLegacyMagicMenuHeaderProperties, Title) == 0x000000, "Member 'FLegacyMagicMenuHeaderProperties::Title' has a wrong offset!");
static_assert(offsetof(FLegacyMagicMenuHeaderProperties, Type) == 0x000018, "Member 'FLegacyMagicMenuHeaderProperties::Type' has a wrong offset!");

// ScriptStruct Altar.LegacyMagicPopupEffectProperties
// 0x0020 (0x0020 - 0x0000)
struct FLegacyMagicPopupEffectProperties final
{
public:
	class UTexture2D*                             Icon;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyMagicPopupEffectProperties) == 0x000008, "Wrong alignment on FLegacyMagicPopupEffectProperties");
static_assert(sizeof(FLegacyMagicPopupEffectProperties) == 0x000020, "Wrong size on FLegacyMagicPopupEffectProperties");
static_assert(offsetof(FLegacyMagicPopupEffectProperties, Icon) == 0x000000, "Member 'FLegacyMagicPopupEffectProperties::Icon' has a wrong offset!");
static_assert(offsetof(FLegacyMagicPopupEffectProperties, Text) == 0x000008, "Member 'FLegacyMagicPopupEffectProperties::Text' has a wrong offset!");

// ScriptStruct Altar.CharacterPropertyLinkTable
// 0x0018 (0x0018 - 0x0000)
struct FCharacterPropertyLinkTable final
{
public:
	class FName                                   MapName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimInstance*                          AnimLayerInstance;                                 // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimLayerVariableName;                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPropertyLinkTable) == 0x000008, "Wrong alignment on FCharacterPropertyLinkTable");
static_assert(sizeof(FCharacterPropertyLinkTable) == 0x000018, "Wrong size on FCharacterPropertyLinkTable");
static_assert(offsetof(FCharacterPropertyLinkTable, MapName) == 0x000000, "Member 'FCharacterPropertyLinkTable::MapName' has a wrong offset!");
static_assert(offsetof(FCharacterPropertyLinkTable, AnimLayerInstance) == 0x000008, "Member 'FCharacterPropertyLinkTable::AnimLayerInstance' has a wrong offset!");
static_assert(offsetof(FCharacterPropertyLinkTable, AnimLayerVariableName) == 0x000010, "Member 'FCharacterPropertyLinkTable::AnimLayerVariableName' has a wrong offset!");

// ScriptStruct Altar.StandSneakStaffAttackData
// 0x0010 (0x0010 - 0x0000)
struct FStandSneakStaffAttackData final
{
public:
	class UAnimSequenceBase*                      Attack;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SneakAttack;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandSneakStaffAttackData) == 0x000008, "Wrong alignment on FStandSneakStaffAttackData");
static_assert(sizeof(FStandSneakStaffAttackData) == 0x000010, "Wrong size on FStandSneakStaffAttackData");
static_assert(offsetof(FStandSneakStaffAttackData, Attack) == 0x000000, "Member 'FStandSneakStaffAttackData::Attack' has a wrong offset!");
static_assert(offsetof(FStandSneakStaffAttackData, SneakAttack) == 0x000008, "Member 'FStandSneakStaffAttackData::SneakAttack' has a wrong offset!");

// ScriptStruct Altar.CharacterLayerLinkTable
// 0x0018 (0x0018 - 0x0000)
struct FCharacterLayerLinkTable final
{
public:
	class FName                                   StructName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              LayerClass;                                        // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimLayerVariableName;                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterLayerLinkTable) == 0x000008, "Wrong alignment on FCharacterLayerLinkTable");
static_assert(sizeof(FCharacterLayerLinkTable) == 0x000018, "Wrong size on FCharacterLayerLinkTable");
static_assert(offsetof(FCharacterLayerLinkTable, StructName) == 0x000000, "Member 'FCharacterLayerLinkTable::StructName' has a wrong offset!");
static_assert(offsetof(FCharacterLayerLinkTable, LayerClass) == 0x000008, "Member 'FCharacterLayerLinkTable::LayerClass' has a wrong offset!");
static_assert(offsetof(FCharacterLayerLinkTable, AnimLayerVariableName) == 0x000010, "Member 'FCharacterLayerLinkTable::AnimLayerVariableName' has a wrong offset!");

// ScriptStruct Altar.CharacterGSMActionRequest
// 0x0008 (0x0008 - 0x0000)
struct FCharacterGSMActionRequest final
{
public:
	float                                         ActionDuration;                                    // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionAnimIndex;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterGSMActionRequest) == 0x000004, "Wrong alignment on FCharacterGSMActionRequest");
static_assert(sizeof(FCharacterGSMActionRequest) == 0x000008, "Wrong size on FCharacterGSMActionRequest");
static_assert(offsetof(FCharacterGSMActionRequest, ActionDuration) == 0x000000, "Member 'FCharacterGSMActionRequest::ActionDuration' has a wrong offset!");
static_assert(offsetof(FCharacterGSMActionRequest, ActionAnimIndex) == 0x000004, "Member 'FCharacterGSMActionRequest::ActionAnimIndex' has a wrong offset!");

// ScriptStruct Altar.VHorseRiderLocomotionStanding
// 0x0050 (0x0050 - 0x0000)
struct FVHorseRiderLocomotionStanding final
{
public:
	class UAnimSequence*                          Idle;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpace_Walk;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpace_Trot;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpace_CanterGallop;                           // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpace_Lean;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            WalkBackward;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpace_Start;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpace_Stop;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  SpecialIdle;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVHorseRiderLocomotionStanding) == 0x000008, "Wrong alignment on FVHorseRiderLocomotionStanding");
static_assert(sizeof(FVHorseRiderLocomotionStanding) == 0x000050, "Wrong size on FVHorseRiderLocomotionStanding");
static_assert(offsetof(FVHorseRiderLocomotionStanding, Idle) == 0x000000, "Member 'FVHorseRiderLocomotionStanding::Idle' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionStanding, BlendSpace_Walk) == 0x000008, "Member 'FVHorseRiderLocomotionStanding::BlendSpace_Walk' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionStanding, BlendSpace_Trot) == 0x000010, "Member 'FVHorseRiderLocomotionStanding::BlendSpace_Trot' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionStanding, BlendSpace_CanterGallop) == 0x000018, "Member 'FVHorseRiderLocomotionStanding::BlendSpace_CanterGallop' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionStanding, BlendSpace_Lean) == 0x000020, "Member 'FVHorseRiderLocomotionStanding::BlendSpace_Lean' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionStanding, WalkBackward) == 0x000028, "Member 'FVHorseRiderLocomotionStanding::WalkBackward' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionStanding, BlendSpace_Start) == 0x000030, "Member 'FVHorseRiderLocomotionStanding::BlendSpace_Start' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionStanding, BlendSpace_Stop) == 0x000038, "Member 'FVHorseRiderLocomotionStanding::BlendSpace_Stop' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionStanding, SpecialIdle) == 0x000040, "Member 'FVHorseRiderLocomotionStanding::SpecialIdle' has a wrong offset!");

// ScriptStruct Altar.VHorseRiderLocomotionJump
// 0x0048 (0x0048 - 0x0000)
struct FVHorseRiderLocomotionJump final
{
public:
	class UAnimSequence*                          Rear;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Blendspace_InAir;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Trot_Start;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Trot_Land;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Canter_Start;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Canter_Land;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Gallop_Start;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Gallop_Land;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Base_Land;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVHorseRiderLocomotionJump) == 0x000008, "Wrong alignment on FVHorseRiderLocomotionJump");
static_assert(sizeof(FVHorseRiderLocomotionJump) == 0x000048, "Wrong size on FVHorseRiderLocomotionJump");
static_assert(offsetof(FVHorseRiderLocomotionJump, Rear) == 0x000000, "Member 'FVHorseRiderLocomotionJump::Rear' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionJump, Blendspace_InAir) == 0x000008, "Member 'FVHorseRiderLocomotionJump::Blendspace_InAir' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionJump, Trot_Start) == 0x000010, "Member 'FVHorseRiderLocomotionJump::Trot_Start' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionJump, Trot_Land) == 0x000018, "Member 'FVHorseRiderLocomotionJump::Trot_Land' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionJump, Canter_Start) == 0x000020, "Member 'FVHorseRiderLocomotionJump::Canter_Start' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionJump, Canter_Land) == 0x000028, "Member 'FVHorseRiderLocomotionJump::Canter_Land' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionJump, Gallop_Start) == 0x000030, "Member 'FVHorseRiderLocomotionJump::Gallop_Start' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionJump, Gallop_Land) == 0x000038, "Member 'FVHorseRiderLocomotionJump::Gallop_Land' has a wrong offset!");
static_assert(offsetof(FVHorseRiderLocomotionJump, Base_Land) == 0x000040, "Member 'FVHorseRiderLocomotionJump::Base_Land' has a wrong offset!");

// ScriptStruct Altar.LegacyMapMenuWorldMapProperties
// 0x0020 (0x0020 - 0x0000)
struct FLegacyMapMenuWorldMapProperties final
{
public:
	class UObject*                                Map;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MapSize;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMainWorld;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyMapMenuWorldMapProperties) == 0x000008, "Wrong alignment on FLegacyMapMenuWorldMapProperties");
static_assert(sizeof(FLegacyMapMenuWorldMapProperties) == 0x000020, "Wrong size on FLegacyMapMenuWorldMapProperties");
static_assert(offsetof(FLegacyMapMenuWorldMapProperties, Map) == 0x000000, "Member 'FLegacyMapMenuWorldMapProperties::Map' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuWorldMapProperties, MapSize) == 0x000008, "Member 'FLegacyMapMenuWorldMapProperties::MapSize' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuWorldMapProperties, bIsMainWorld) == 0x000018, "Member 'FLegacyMapMenuWorldMapProperties::bIsMainWorld' has a wrong offset!");

// ScriptStruct Altar.LegacyMapMenuIconProperties
// 0x0050 (0x0050 - 0x0000)
struct FLegacyMapMenuIconProperties final
{
public:
	struct FVector2D                              position;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Key;                                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ELegacyMapMenuIcon                            Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FastTravelEnabled;                                 // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DepthAdjustment;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTargetable;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsThroughLoadingDoor;                              // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerRotation;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconAddress;                                       // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyMapMenuIconProperties) == 0x000008, "Wrong alignment on FLegacyMapMenuIconProperties");
static_assert(sizeof(FLegacyMapMenuIconProperties) == 0x000050, "Wrong size on FLegacyMapMenuIconProperties");
static_assert(offsetof(FLegacyMapMenuIconProperties, position) == 0x000000, "Member 'FLegacyMapMenuIconProperties::position' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuIconProperties, Key) == 0x000010, "Member 'FLegacyMapMenuIconProperties::Key' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuIconProperties, Name) == 0x000018, "Member 'FLegacyMapMenuIconProperties::Name' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuIconProperties, Type) == 0x000030, "Member 'FLegacyMapMenuIconProperties::Type' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuIconProperties, FastTravelEnabled) == 0x000031, "Member 'FLegacyMapMenuIconProperties::FastTravelEnabled' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuIconProperties, DepthAdjustment) == 0x000034, "Member 'FLegacyMapMenuIconProperties::DepthAdjustment' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuIconProperties, IsTargetable) == 0x000038, "Member 'FLegacyMapMenuIconProperties::IsTargetable' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuIconProperties, IsThroughLoadingDoor) == 0x000039, "Member 'FLegacyMapMenuIconProperties::IsThroughLoadingDoor' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuIconProperties, PlayerRotation) == 0x00003C, "Member 'FLegacyMapMenuIconProperties::PlayerRotation' has a wrong offset!");
static_assert(offsetof(FLegacyMapMenuIconProperties, IconAddress) == 0x000040, "Member 'FLegacyMapMenuIconProperties::IconAddress' has a wrong offset!");

// ScriptStruct Altar.MeleeAttackComboAnimationData
// 0x0040 (0x0040 - 0x0000)
struct FMeleeAttackComboAnimationData final
{
public:
	TArray<class UAnimSequence*>                  ComboChain;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PowerAttack;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForwardPowerAttack;                                // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BackwardPowerAttack;                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RightPowerAttack;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LeftPowerAttack;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SneakPowerAttack;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeAttackComboAnimationData) == 0x000008, "Wrong alignment on FMeleeAttackComboAnimationData");
static_assert(sizeof(FMeleeAttackComboAnimationData) == 0x000040, "Wrong size on FMeleeAttackComboAnimationData");
static_assert(offsetof(FMeleeAttackComboAnimationData, ComboChain) == 0x000000, "Member 'FMeleeAttackComboAnimationData::ComboChain' has a wrong offset!");
static_assert(offsetof(FMeleeAttackComboAnimationData, PowerAttack) == 0x000010, "Member 'FMeleeAttackComboAnimationData::PowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackComboAnimationData, ForwardPowerAttack) == 0x000018, "Member 'FMeleeAttackComboAnimationData::ForwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackComboAnimationData, BackwardPowerAttack) == 0x000020, "Member 'FMeleeAttackComboAnimationData::BackwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackComboAnimationData, RightPowerAttack) == 0x000028, "Member 'FMeleeAttackComboAnimationData::RightPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackComboAnimationData, LeftPowerAttack) == 0x000030, "Member 'FMeleeAttackComboAnimationData::LeftPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackComboAnimationData, SneakPowerAttack) == 0x000038, "Member 'FMeleeAttackComboAnimationData::SneakPowerAttack' has a wrong offset!");

// ScriptStruct Altar.MeleeAttackMultiplePowerMultiple
// 0x0070 (0x0070 - 0x0000)
struct FMeleeAttackMultiplePowerMultiple final
{
public:
	TArray<class UAnimSequence*>                  AttackRight;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  AttackLeft;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   PowerAttack;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   ForwardPowerAttack;                                // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   BackwardPowerAttack;                               // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   RightPowerAttack;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   LeftPowerAttack;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeAttackMultiplePowerMultiple) == 0x000008, "Wrong alignment on FMeleeAttackMultiplePowerMultiple");
static_assert(sizeof(FMeleeAttackMultiplePowerMultiple) == 0x000070, "Wrong size on FMeleeAttackMultiplePowerMultiple");
static_assert(offsetof(FMeleeAttackMultiplePowerMultiple, AttackRight) == 0x000000, "Member 'FMeleeAttackMultiplePowerMultiple::AttackRight' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerMultiple, AttackLeft) == 0x000010, "Member 'FMeleeAttackMultiplePowerMultiple::AttackLeft' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerMultiple, PowerAttack) == 0x000020, "Member 'FMeleeAttackMultiplePowerMultiple::PowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerMultiple, ForwardPowerAttack) == 0x000030, "Member 'FMeleeAttackMultiplePowerMultiple::ForwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerMultiple, BackwardPowerAttack) == 0x000040, "Member 'FMeleeAttackMultiplePowerMultiple::BackwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerMultiple, RightPowerAttack) == 0x000050, "Member 'FMeleeAttackMultiplePowerMultiple::RightPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackMultiplePowerMultiple, LeftPowerAttack) == 0x000060, "Member 'FMeleeAttackMultiplePowerMultiple::LeftPowerAttack' has a wrong offset!");

// ScriptStruct Altar.LegacyMessageProperties
// 0x0030 (0x0030 - 0x0000)
struct FLegacyMessageProperties final
{
public:
	EModalMenuLayoutType                          MenuType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Message;                                           // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           ButtonText;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyMessageProperties) == 0x000008, "Wrong alignment on FLegacyMessageProperties");
static_assert(sizeof(FLegacyMessageProperties) == 0x000030, "Wrong size on FLegacyMessageProperties");
static_assert(offsetof(FLegacyMessageProperties, MenuType) == 0x000000, "Member 'FLegacyMessageProperties::MenuType' has a wrong offset!");
static_assert(offsetof(FLegacyMessageProperties, Message) == 0x000008, "Member 'FLegacyMessageProperties::Message' has a wrong offset!");
static_assert(offsetof(FLegacyMessageProperties, ButtonText) == 0x000020, "Member 'FLegacyMessageProperties::ButtonText' has a wrong offset!");

// ScriptStruct Altar.IconSelectionTableRow
// 0x0040 (0x0048 - 0x0008)
struct FIconSelectionTableRow final : public FTableRowBase
{
public:
	class FString                                 LocalizationKey;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputText                             InputText;                                         // 0x0018(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIconSelectionTableRow) == 0x000008, "Wrong alignment on FIconSelectionTableRow");
static_assert(sizeof(FIconSelectionTableRow) == 0x000048, "Wrong size on FIconSelectionTableRow");
static_assert(offsetof(FIconSelectionTableRow, LocalizationKey) == 0x000008, "Member 'FIconSelectionTableRow::LocalizationKey' has a wrong offset!");
static_assert(offsetof(FIconSelectionTableRow, InputText) == 0x000018, "Member 'FIconSelectionTableRow::InputText' has a wrong offset!");

// ScriptStruct Altar.OnboardingFlowTableRow
// 0x00F8 (0x0100 - 0x0008)
struct FOnboardingFlowTableRow final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   FlowPageClass;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PageBackground;                                    // 0x0030(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnboardingFlowTableRow) == 0x000010, "Wrong alignment on FOnboardingFlowTableRow");
static_assert(sizeof(FOnboardingFlowTableRow) == 0x000100, "Wrong size on FOnboardingFlowTableRow");
static_assert(offsetof(FOnboardingFlowTableRow, FlowPageClass) == 0x000008, "Member 'FOnboardingFlowTableRow::FlowPageClass' has a wrong offset!");
static_assert(offsetof(FOnboardingFlowTableRow, PageBackground) == 0x000030, "Member 'FOnboardingFlowTableRow::PageBackground' has a wrong offset!");

// ScriptStruct Altar.ModernSettingCategoryTableRow
// 0x0020 (0x0028 - 0x0008)
struct FModernSettingCategoryTableRow final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UVModernSettingTable*                   Settings;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernSettingCategoryTableRow) == 0x000008, "Wrong alignment on FModernSettingCategoryTableRow");
static_assert(sizeof(FModernSettingCategoryTableRow) == 0x000028, "Wrong size on FModernSettingCategoryTableRow");
static_assert(offsetof(FModernSettingCategoryTableRow, Name) == 0x000008, "Member 'FModernSettingCategoryTableRow::Name' has a wrong offset!");
static_assert(offsetof(FModernSettingCategoryTableRow, Settings) == 0x000020, "Member 'FModernSettingCategoryTableRow::Settings' has a wrong offset!");

// ScriptStruct Altar.ModernPairedRebindData
// 0x0010 (0x0010 - 0x0000)
struct FModernPairedRebindData final
{
public:
	class UInputMappingContext*                   MappingContext;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputAction*                           InputAction;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernPairedRebindData) == 0x000008, "Wrong alignment on FModernPairedRebindData");
static_assert(sizeof(FModernPairedRebindData) == 0x000010, "Wrong size on FModernPairedRebindData");
static_assert(offsetof(FModernPairedRebindData, MappingContext) == 0x000000, "Member 'FModernPairedRebindData::MappingContext' has a wrong offset!");
static_assert(offsetof(FModernPairedRebindData, InputAction) == 0x000008, "Member 'FModernPairedRebindData::InputAction' has a wrong offset!");

// ScriptStruct Altar.ModernRebindSettingTableRow
// 0x0090 (0x0098 - 0x0008)
struct FModernRebindSettingTableRow final : public FTableRowBase
{
public:
	class FText                                   Label;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EVModernRebindType                            Type;                                              // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModernRebindData                      RebindData;                                        // 0x0028(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FModernPairedRebindData                PairedRebindData;                                  // 0x0088(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernRebindSettingTableRow) == 0x000008, "Wrong alignment on FModernRebindSettingTableRow");
static_assert(sizeof(FModernRebindSettingTableRow) == 0x000098, "Wrong size on FModernRebindSettingTableRow");
static_assert(offsetof(FModernRebindSettingTableRow, Label) == 0x000008, "Member 'FModernRebindSettingTableRow::Label' has a wrong offset!");
static_assert(offsetof(FModernRebindSettingTableRow, Type) == 0x000020, "Member 'FModernRebindSettingTableRow::Type' has a wrong offset!");
static_assert(offsetof(FModernRebindSettingTableRow, RebindData) == 0x000028, "Member 'FModernRebindSettingTableRow::RebindData' has a wrong offset!");
static_assert(offsetof(FModernRebindSettingTableRow, PairedRebindData) == 0x000088, "Member 'FModernRebindSettingTableRow::PairedRebindData' has a wrong offset!");

// ScriptStruct Altar.ModernSettingButtonProperties
// 0x0028 (0x0028 - 0x0000)
struct FModernSettingButtonProperties final
{
public:
	class FText                                   Label;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FModernSettingCommand>          Commands;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernSettingButtonProperties) == 0x000008, "Wrong alignment on FModernSettingButtonProperties");
static_assert(sizeof(FModernSettingButtonProperties) == 0x000028, "Wrong size on FModernSettingButtonProperties");
static_assert(offsetof(FModernSettingButtonProperties, Label) == 0x000000, "Member 'FModernSettingButtonProperties::Label' has a wrong offset!");
static_assert(offsetof(FModernSettingButtonProperties, Commands) == 0x000018, "Member 'FModernSettingButtonProperties::Commands' has a wrong offset!");

// ScriptStruct Altar.ModernSettingSliderProperties
// 0x0030 (0x0030 - 0x0000)
struct FModernSettingSliderProperties final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CVAR;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumFractionalDigits;                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisualMaximumLabelFractionalDigits;                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLegacyScrollbarValueProperties        ScrollbarValueProperties;                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernSettingSliderProperties) == 0x000008, "Wrong alignment on FModernSettingSliderProperties");
static_assert(sizeof(FModernSettingSliderProperties) == 0x000030, "Wrong size on FModernSettingSliderProperties");
static_assert(offsetof(FModernSettingSliderProperties, Value) == 0x000000, "Member 'FModernSettingSliderProperties::Value' has a wrong offset!");
static_assert(offsetof(FModernSettingSliderProperties, DefaultValue) == 0x000004, "Member 'FModernSettingSliderProperties::DefaultValue' has a wrong offset!");
static_assert(offsetof(FModernSettingSliderProperties, CVAR) == 0x000008, "Member 'FModernSettingSliderProperties::CVAR' has a wrong offset!");
static_assert(offsetof(FModernSettingSliderProperties, MaximumFractionalDigits) == 0x000018, "Member 'FModernSettingSliderProperties::MaximumFractionalDigits' has a wrong offset!");
static_assert(offsetof(FModernSettingSliderProperties, VisualMaximumLabelFractionalDigits) == 0x00001C, "Member 'FModernSettingSliderProperties::VisualMaximumLabelFractionalDigits' has a wrong offset!");
static_assert(offsetof(FModernSettingSliderProperties, ScrollbarValueProperties) == 0x000020, "Member 'FModernSettingSliderProperties::ScrollbarValueProperties' has a wrong offset!");

// ScriptStruct Altar.ModernSettingPresetProperties
// 0x0020 (0x0020 - 0x0000)
struct FModernSettingPresetProperties final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultIndex;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomIndex;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FModernSettingMultiCommand>     Presets;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernSettingPresetProperties) == 0x000008, "Wrong alignment on FModernSettingPresetProperties");
static_assert(sizeof(FModernSettingPresetProperties) == 0x000020, "Wrong size on FModernSettingPresetProperties");
static_assert(offsetof(FModernSettingPresetProperties, Index) == 0x000000, "Member 'FModernSettingPresetProperties::Index' has a wrong offset!");
static_assert(offsetof(FModernSettingPresetProperties, DefaultIndex) == 0x000004, "Member 'FModernSettingPresetProperties::DefaultIndex' has a wrong offset!");
static_assert(offsetof(FModernSettingPresetProperties, CustomIndex) == 0x000008, "Member 'FModernSettingPresetProperties::CustomIndex' has a wrong offset!");
static_assert(offsetof(FModernSettingPresetProperties, Presets) == 0x000010, "Member 'FModernSettingPresetProperties::Presets' has a wrong offset!");

// ScriptStruct Altar.ModernSettingTableRow
// 0x0130 (0x0138 - 0x0008)
struct FModernSettingTableRow final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DescriptionImage;                                  // 0x0038(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                DescriptionObject;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModernSettingWidgetType                      Type;                                              // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlatformFlag;                                      // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FModernSettingButtonProperties         ButtonProperties;                                  // 0x0070(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FModernSettingStepProperties           StepProperties;                                    // 0x0098(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FModernSettingSliderProperties         SliderProperties;                                  // 0x00B0(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FModernSettingComboBoxProperties       ComboBoxProperties;                                // 0x00E0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FModernSettingPresetProperties         PresetProperties;                                  // 0x00F8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FModernSettingCustomProperties         CustomProperties;                                  // 0x0118(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bDoesNeedAutoRevertPopup;                          // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHiddenInUI;                                     // 0x0131(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModernSettingWidgetSubType                   SubType;                                           // 0x0132(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_133[0x5];                                      // 0x0133(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModernSettingTableRow) == 0x000008, "Wrong alignment on FModernSettingTableRow");
static_assert(sizeof(FModernSettingTableRow) == 0x000138, "Wrong size on FModernSettingTableRow");
static_assert(offsetof(FModernSettingTableRow, Name) == 0x000008, "Member 'FModernSettingTableRow::Name' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, Description) == 0x000020, "Member 'FModernSettingTableRow::Description' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, DescriptionImage) == 0x000038, "Member 'FModernSettingTableRow::DescriptionImage' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, DescriptionObject) == 0x000060, "Member 'FModernSettingTableRow::DescriptionObject' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, Type) == 0x000068, "Member 'FModernSettingTableRow::Type' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, PlatformFlag) == 0x00006C, "Member 'FModernSettingTableRow::PlatformFlag' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, ButtonProperties) == 0x000070, "Member 'FModernSettingTableRow::ButtonProperties' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, StepProperties) == 0x000098, "Member 'FModernSettingTableRow::StepProperties' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, SliderProperties) == 0x0000B0, "Member 'FModernSettingTableRow::SliderProperties' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, ComboBoxProperties) == 0x0000E0, "Member 'FModernSettingTableRow::ComboBoxProperties' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, PresetProperties) == 0x0000F8, "Member 'FModernSettingTableRow::PresetProperties' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, CustomProperties) == 0x000118, "Member 'FModernSettingTableRow::CustomProperties' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, bDoesNeedAutoRevertPopup) == 0x000130, "Member 'FModernSettingTableRow::bDoesNeedAutoRevertPopup' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, bIsHiddenInUI) == 0x000131, "Member 'FModernSettingTableRow::bIsHiddenInUI' has a wrong offset!");
static_assert(offsetof(FModernSettingTableRow, SubType) == 0x000132, "Member 'FModernSettingTableRow::SubType' has a wrong offset!");

// ScriptStruct Altar.VModularBodyPartRaceProperties
// 0x0010 (0x0010 - 0x0000)
struct FVModularBodyPartRaceProperties final
{
public:
	TArray<int32>                                 MaterialSlotToHide;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVModularBodyPartRaceProperties) == 0x000008, "Wrong alignment on FVModularBodyPartRaceProperties");
static_assert(sizeof(FVModularBodyPartRaceProperties) == 0x000010, "Wrong size on FVModularBodyPartRaceProperties");
static_assert(offsetof(FVModularBodyPartRaceProperties, MaterialSlotToHide) == 0x000000, "Member 'FVModularBodyPartRaceProperties::MaterialSlotToHide' has a wrong offset!");

// ScriptStruct Altar.NegotiateMenuInitializationData
// 0x0048 (0x0048 - 0x0000)
struct FNegotiateMenuInitializationData final
{
public:
	class FText                                   MerchantName;                                      // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   MerchantMercantileSkill;                           // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MerchantPlayerDisposition;                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingScrollBarPosition;                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxScrollbarValue;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseBuyValuePercentage;                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseSellValuePercentage;                           // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNegotiateMenuInitializationData) == 0x000008, "Wrong alignment on FNegotiateMenuInitializationData");
static_assert(sizeof(FNegotiateMenuInitializationData) == 0x000048, "Wrong size on FNegotiateMenuInitializationData");
static_assert(offsetof(FNegotiateMenuInitializationData, MerchantName) == 0x000000, "Member 'FNegotiateMenuInitializationData::MerchantName' has a wrong offset!");
static_assert(offsetof(FNegotiateMenuInitializationData, MerchantMercantileSkill) == 0x000018, "Member 'FNegotiateMenuInitializationData::MerchantMercantileSkill' has a wrong offset!");
static_assert(offsetof(FNegotiateMenuInitializationData, MerchantPlayerDisposition) == 0x000030, "Member 'FNegotiateMenuInitializationData::MerchantPlayerDisposition' has a wrong offset!");
static_assert(offsetof(FNegotiateMenuInitializationData, StartingScrollBarPosition) == 0x000034, "Member 'FNegotiateMenuInitializationData::StartingScrollBarPosition' has a wrong offset!");
static_assert(offsetof(FNegotiateMenuInitializationData, MaxScrollbarValue) == 0x000038, "Member 'FNegotiateMenuInitializationData::MaxScrollbarValue' has a wrong offset!");
static_assert(offsetof(FNegotiateMenuInitializationData, BaseBuyValuePercentage) == 0x00003C, "Member 'FNegotiateMenuInitializationData::BaseBuyValuePercentage' has a wrong offset!");
static_assert(offsetof(FNegotiateMenuInitializationData, BaseSellValuePercentage) == 0x000040, "Member 'FNegotiateMenuInitializationData::BaseSellValuePercentage' has a wrong offset!");

// ScriptStruct Altar.Original_InventoryFilterBackgroundTableRow
// 0x0028 (0x0030 - 0x0008)
struct FOriginal_InventoryFilterBackgroundTableRow final : public FTableRowBase
{
public:
	EOriginalInventoryFilterBackgrounds           EnumKey;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     TextureArray;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              TextureSize;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOriginal_InventoryFilterBackgroundTableRow) == 0x000008, "Wrong alignment on FOriginal_InventoryFilterBackgroundTableRow");
static_assert(sizeof(FOriginal_InventoryFilterBackgroundTableRow) == 0x000030, "Wrong size on FOriginal_InventoryFilterBackgroundTableRow");
static_assert(offsetof(FOriginal_InventoryFilterBackgroundTableRow, EnumKey) == 0x000008, "Member 'FOriginal_InventoryFilterBackgroundTableRow::EnumKey' has a wrong offset!");
static_assert(offsetof(FOriginal_InventoryFilterBackgroundTableRow, TextureArray) == 0x000010, "Member 'FOriginal_InventoryFilterBackgroundTableRow::TextureArray' has a wrong offset!");
static_assert(offsetof(FOriginal_InventoryFilterBackgroundTableRow, TextureSize) == 0x000020, "Member 'FOriginal_InventoryFilterBackgroundTableRow::TextureSize' has a wrong offset!");

// ScriptStruct Altar.VEntryPointData
// 0x0018 (0x0018 - 0x0000)
struct FVEntryPointData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      MountingAnimSequence;                              // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      DismountingAnimSequence;                           // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVEntryPointData) == 0x000008, "Wrong alignment on FVEntryPointData");
static_assert(sizeof(FVEntryPointData) == 0x000018, "Wrong size on FVEntryPointData");
static_assert(offsetof(FVEntryPointData, Name) == 0x000000, "Member 'FVEntryPointData::Name' has a wrong offset!");
static_assert(offsetof(FVEntryPointData, MountingAnimSequence) == 0x000008, "Member 'FVEntryPointData::MountingAnimSequence' has a wrong offset!");
static_assert(offsetof(FVEntryPointData, DismountingAnimSequence) == 0x000010, "Member 'FVEntryPointData::DismountingAnimSequence' has a wrong offset!");

// ScriptStruct Altar.VBufferedInputTag
// 0x000C (0x000C - 0x0000)
struct FVBufferedInputTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingTime;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVBufferedInputTag) == 0x000004, "Wrong alignment on FVBufferedInputTag");
static_assert(sizeof(FVBufferedInputTag) == 0x00000C, "Wrong size on FVBufferedInputTag");
static_assert(offsetof(FVBufferedInputTag, Tag) == 0x000000, "Member 'FVBufferedInputTag::Tag' has a wrong offset!");
static_assert(offsetof(FVBufferedInputTag, RemainingTime) == 0x000008, "Member 'FVBufferedInputTag::RemainingTime' has a wrong offset!");

// ScriptStruct Altar.VMovementInputThresholds
// 0x0050 (0x0050 - 0x0000)
struct FVMovementInputThresholds final
{
public:
	TMap<float, struct FGameplayTag>              MaxGaitForThresholds;                              // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVMovementInputThresholds) == 0x000008, "Wrong alignment on FVMovementInputThresholds");
static_assert(sizeof(FVMovementInputThresholds) == 0x000050, "Wrong size on FVMovementInputThresholds");
static_assert(offsetof(FVMovementInputThresholds, MaxGaitForThresholds) == 0x000000, "Member 'FVMovementInputThresholds::MaxGaitForThresholds' has a wrong offset!");

// ScriptStruct Altar.VOblivionAIPackageData
// 0x0068 (0x0068 - 0x0000)
struct FVOblivionAIPackageData final
{
public:
	int32                                         PackageFormID;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVOblivionAIPackageType                       PackageType;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UVTESObjectRefComponent> TargetRefComponent;                                // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPosition;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0xC];                                       // 0x0028(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UVTESObjectRefComponent> LocationRefComponent;                              // 0x0034(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationPosition;                                  // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x4];                                       // 0x0058(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAlwaysRun;                                        // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVOblivionAIPackageData) == 0x000008, "Wrong alignment on FVOblivionAIPackageData");
static_assert(sizeof(FVOblivionAIPackageData) == 0x000068, "Wrong size on FVOblivionAIPackageData");
static_assert(offsetof(FVOblivionAIPackageData, PackageFormID) == 0x000000, "Member 'FVOblivionAIPackageData::PackageFormID' has a wrong offset!");
static_assert(offsetof(FVOblivionAIPackageData, PackageType) == 0x000004, "Member 'FVOblivionAIPackageData::PackageType' has a wrong offset!");
static_assert(offsetof(FVOblivionAIPackageData, TargetRefComponent) == 0x000008, "Member 'FVOblivionAIPackageData::TargetRefComponent' has a wrong offset!");
static_assert(offsetof(FVOblivionAIPackageData, TargetPosition) == 0x000010, "Member 'FVOblivionAIPackageData::TargetPosition' has a wrong offset!");
static_assert(offsetof(FVOblivionAIPackageData, LocationRefComponent) == 0x000034, "Member 'FVOblivionAIPackageData::LocationRefComponent' has a wrong offset!");
static_assert(offsetof(FVOblivionAIPackageData, LocationPosition) == 0x000040, "Member 'FVOblivionAIPackageData::LocationPosition' has a wrong offset!");
static_assert(offsetof(FVOblivionAIPackageData, bAlwaysRun) == 0x00005C, "Member 'FVOblivionAIPackageData::bAlwaysRun' has a wrong offset!");
static_assert(offsetof(FVOblivionAIPackageData, Radius) == 0x000060, "Member 'FVOblivionAIPackageData::Radius' has a wrong offset!");

// ScriptStruct Altar.VMutiplePrimitivesSweepTraceResult
// 0x0018 (0x0018 - 0x0000)
struct FVMutiplePrimitivesSweepTraceResult final
{
public:
	TArray<struct FVSinglePrimitiveSweepTraceResult> PrimitiveSweepResults;                          // 0x0000(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ClosestHitIndex;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVMutiplePrimitivesSweepTraceResult) == 0x000008, "Wrong alignment on FVMutiplePrimitivesSweepTraceResult");
static_assert(sizeof(FVMutiplePrimitivesSweepTraceResult) == 0x000018, "Wrong size on FVMutiplePrimitivesSweepTraceResult");
static_assert(offsetof(FVMutiplePrimitivesSweepTraceResult, PrimitiveSweepResults) == 0x000000, "Member 'FVMutiplePrimitivesSweepTraceResult::PrimitiveSweepResults' has a wrong offset!");
static_assert(offsetof(FVMutiplePrimitivesSweepTraceResult, ClosestHitIndex) == 0x000010, "Member 'FVMutiplePrimitivesSweepTraceResult::ClosestHitIndex' has a wrong offset!");

// ScriptStruct Altar.VSoundPathRowBase
// 0x0030 (0x0038 - 0x0008)
struct FVSoundPathRowBase final : public FTableRowBase
{
public:
	class FString                                 Path;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayEvent;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSoundPathRowBase) == 0x000008, "Wrong alignment on FVSoundPathRowBase");
static_assert(sizeof(FVSoundPathRowBase) == 0x000038, "Wrong size on FVSoundPathRowBase");
static_assert(offsetof(FVSoundPathRowBase, Path) == 0x000008, "Member 'FVSoundPathRowBase::Path' has a wrong offset!");
static_assert(offsetof(FVSoundPathRowBase, Filename) == 0x000018, "Member 'FVSoundPathRowBase::Filename' has a wrong offset!");
static_assert(offsetof(FVSoundPathRowBase, PlayEvent) == 0x000028, "Member 'FVSoundPathRowBase::PlayEvent' has a wrong offset!");

// ScriptStruct Altar.VAttachComponentData
// 0x0070 (0x0070 - 0x0000)
struct FVAttachComponentData final
{
public:
	TWeakObjectPtr<class USceneComponent>         ParentComponent;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0010(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVAttachComponentData) == 0x000010, "Wrong alignment on FVAttachComponentData");
static_assert(sizeof(FVAttachComponentData) == 0x000070, "Wrong size on FVAttachComponentData");
static_assert(offsetof(FVAttachComponentData, ParentComponent) == 0x000000, "Member 'FVAttachComponentData::ParentComponent' has a wrong offset!");
static_assert(offsetof(FVAttachComponentData, LocalTransform) == 0x000010, "Member 'FVAttachComponentData::LocalTransform' has a wrong offset!");

// ScriptStruct Altar.VBuoyancySettings
// 0x000C (0x000C - 0x0000)
struct FVBuoyancySettings final
{
public:
	bool                                          bDoesGeneratePontoonsAtRuntime;                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedsOrientationAdjustment;                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GeneratedPontoonSizeScale;                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuoyancyCoefficient;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVBuoyancySettings) == 0x000004, "Wrong alignment on FVBuoyancySettings");
static_assert(sizeof(FVBuoyancySettings) == 0x00000C, "Wrong size on FVBuoyancySettings");
static_assert(offsetof(FVBuoyancySettings, bDoesGeneratePontoonsAtRuntime) == 0x000000, "Member 'FVBuoyancySettings::bDoesGeneratePontoonsAtRuntime' has a wrong offset!");
static_assert(offsetof(FVBuoyancySettings, bNeedsOrientationAdjustment) == 0x000001, "Member 'FVBuoyancySettings::bNeedsOrientationAdjustment' has a wrong offset!");
static_assert(offsetof(FVBuoyancySettings, GeneratedPontoonSizeScale) == 0x000004, "Member 'FVBuoyancySettings::GeneratedPontoonSizeScale' has a wrong offset!");
static_assert(offsetof(FVBuoyancySettings, BuoyancyCoefficient) == 0x000008, "Member 'FVBuoyancySettings::BuoyancyCoefficient' has a wrong offset!");

// ScriptStruct Altar.VPhysicsControlSettings
// 0x001C (0x001C - 0x0000)
struct FVPhysicsControlSettings final
{
public:
	bool                                          bIsGrabbable;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTelekinesisTargetable;                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnchored;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVPhysicsSimulationBehaviour                  PhysicsSimulationBehaviour;                        // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVPhysicsLoadingBehaviour                     PhysicsLoadingBehaviour;                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesRepositionOnLoad;                             // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesReattachOnLoad;                               // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesRestoreAttachmentAfterSimulation;             // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesUseCCD;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVBuoyancySettings                     BuoyancySettings;                                  // 0x000C(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDoesPlayCollisionSound;                           // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVDefaultSurfaceType                          DefaultSelfSurfaceType;                            // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSnapToEnvironment;                             // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVPhysicsControlSettings) == 0x000004, "Wrong alignment on FVPhysicsControlSettings");
static_assert(sizeof(FVPhysicsControlSettings) == 0x00001C, "Wrong size on FVPhysicsControlSettings");
static_assert(offsetof(FVPhysicsControlSettings, bIsGrabbable) == 0x000000, "Member 'FVPhysicsControlSettings::bIsGrabbable' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, bIsTelekinesisTargetable) == 0x000001, "Member 'FVPhysicsControlSettings::bIsTelekinesisTargetable' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, bIsAnchored) == 0x000002, "Member 'FVPhysicsControlSettings::bIsAnchored' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, PhysicsSimulationBehaviour) == 0x000003, "Member 'FVPhysicsControlSettings::PhysicsSimulationBehaviour' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, PhysicsLoadingBehaviour) == 0x000004, "Member 'FVPhysicsControlSettings::PhysicsLoadingBehaviour' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, bDoesRepositionOnLoad) == 0x000005, "Member 'FVPhysicsControlSettings::bDoesRepositionOnLoad' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, bDoesReattachOnLoad) == 0x000006, "Member 'FVPhysicsControlSettings::bDoesReattachOnLoad' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, bDoesRestoreAttachmentAfterSimulation) == 0x000007, "Member 'FVPhysicsControlSettings::bDoesRestoreAttachmentAfterSimulation' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, bDoesUseCCD) == 0x000008, "Member 'FVPhysicsControlSettings::bDoesUseCCD' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, BuoyancySettings) == 0x00000C, "Member 'FVPhysicsControlSettings::BuoyancySettings' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, bDoesPlayCollisionSound) == 0x000018, "Member 'FVPhysicsControlSettings::bDoesPlayCollisionSound' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, DefaultSelfSurfaceType) == 0x000019, "Member 'FVPhysicsControlSettings::DefaultSelfSurfaceType' has a wrong offset!");
static_assert(offsetof(FVPhysicsControlSettings, bCanSnapToEnvironment) == 0x00001A, "Member 'FVPhysicsControlSettings::bCanSnapToEnvironment' has a wrong offset!");

// ScriptStruct Altar.MeleeAttackPowerSingle
// 0x0038 (0x0038 - 0x0000)
struct FMeleeAttackPowerSingle final
{
public:
	class UAnimSequence*                          AttackRight;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AttackLeft;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PowerAttack;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForwardPowerAttack;                                // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BackwardPowerAttack;                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RightPowerAttack;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LeftPowerAttack;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeAttackPowerSingle) == 0x000008, "Wrong alignment on FMeleeAttackPowerSingle");
static_assert(sizeof(FMeleeAttackPowerSingle) == 0x000038, "Wrong size on FMeleeAttackPowerSingle");
static_assert(offsetof(FMeleeAttackPowerSingle, AttackRight) == 0x000000, "Member 'FMeleeAttackPowerSingle::AttackRight' has a wrong offset!");
static_assert(offsetof(FMeleeAttackPowerSingle, AttackLeft) == 0x000008, "Member 'FMeleeAttackPowerSingle::AttackLeft' has a wrong offset!");
static_assert(offsetof(FMeleeAttackPowerSingle, PowerAttack) == 0x000010, "Member 'FMeleeAttackPowerSingle::PowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackPowerSingle, ForwardPowerAttack) == 0x000018, "Member 'FMeleeAttackPowerSingle::ForwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackPowerSingle, BackwardPowerAttack) == 0x000020, "Member 'FMeleeAttackPowerSingle::BackwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackPowerSingle, RightPowerAttack) == 0x000028, "Member 'FMeleeAttackPowerSingle::RightPowerAttack' has a wrong offset!");
static_assert(offsetof(FMeleeAttackPowerSingle, LeftPowerAttack) == 0x000030, "Member 'FMeleeAttackPowerSingle::LeftPowerAttack' has a wrong offset!");

// ScriptStruct Altar.VPreviewClassTypeLocationRotationTableRow
// 0x0078 (0x0080 - 0x0008)
struct FVPreviewClassTypeLocationRotationTableRow final : public FTableRowBase
{
public:
	EPreviewDefaultObjectType                     TypeToCheck;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AVActor>                    ActorType;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StaticMesh;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkeletalMesh;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVInventoryPreviewPositionOverride     DefaultParameters;                                 // 0x0038(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVPreviewClassTypeLocationRotationTableRow) == 0x000008, "Wrong alignment on FVPreviewClassTypeLocationRotationTableRow");
static_assert(sizeof(FVPreviewClassTypeLocationRotationTableRow) == 0x000080, "Wrong size on FVPreviewClassTypeLocationRotationTableRow");
static_assert(offsetof(FVPreviewClassTypeLocationRotationTableRow, TypeToCheck) == 0x000008, "Member 'FVPreviewClassTypeLocationRotationTableRow::TypeToCheck' has a wrong offset!");
static_assert(offsetof(FVPreviewClassTypeLocationRotationTableRow, ActorType) == 0x000010, "Member 'FVPreviewClassTypeLocationRotationTableRow::ActorType' has a wrong offset!");
static_assert(offsetof(FVPreviewClassTypeLocationRotationTableRow, StaticMesh) == 0x000018, "Member 'FVPreviewClassTypeLocationRotationTableRow::StaticMesh' has a wrong offset!");
static_assert(offsetof(FVPreviewClassTypeLocationRotationTableRow, SkeletalMesh) == 0x000028, "Member 'FVPreviewClassTypeLocationRotationTableRow::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FVPreviewClassTypeLocationRotationTableRow, DefaultParameters) == 0x000038, "Member 'FVPreviewClassTypeLocationRotationTableRow::DefaultParameters' has a wrong offset!");

// ScriptStruct Altar.LegacyRaceSexMenuButtonProperties
// 0x0028 (0x0028 - 0x0000)
struct FLegacyRaceSexMenuButtonProperties final
{
public:
	ELegacyRaceSexMenuButtonType                  Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ButtonText;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ELegacyRaceSexMenuPage                        PageRedirect;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyRaceSexMenuButtonProperties) == 0x000008, "Wrong alignment on FLegacyRaceSexMenuButtonProperties");
static_assert(sizeof(FLegacyRaceSexMenuButtonProperties) == 0x000028, "Wrong size on FLegacyRaceSexMenuButtonProperties");
static_assert(offsetof(FLegacyRaceSexMenuButtonProperties, Type) == 0x000000, "Member 'FLegacyRaceSexMenuButtonProperties::Type' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuButtonProperties, ButtonText) == 0x000008, "Member 'FLegacyRaceSexMenuButtonProperties::ButtonText' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuButtonProperties, PageRedirect) == 0x000020, "Member 'FLegacyRaceSexMenuButtonProperties::PageRedirect' has a wrong offset!");

// ScriptStruct Altar.LegacyRaceSexMenuSliderProperties
// 0x0058 (0x0058 - 0x0000)
struct FLegacyRaceSexMenuSliderProperties final
{
public:
	ELegacyRaceSexMenuSliderType                  Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MorphTarget;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MinText;                                           // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   MaxText;                                           // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MaximumLabelFractionalDigits;                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLegacyScrollbarValueProperties        ScrollbarValueProperties;                          // 0x0044(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsInverted;                                       // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyRaceSexMenuSliderProperties) == 0x000008, "Wrong alignment on FLegacyRaceSexMenuSliderProperties");
static_assert(sizeof(FLegacyRaceSexMenuSliderProperties) == 0x000058, "Wrong size on FLegacyRaceSexMenuSliderProperties");
static_assert(offsetof(FLegacyRaceSexMenuSliderProperties, Type) == 0x000000, "Member 'FLegacyRaceSexMenuSliderProperties::Type' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuSliderProperties, MorphTarget) == 0x000004, "Member 'FLegacyRaceSexMenuSliderProperties::MorphTarget' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuSliderProperties, Value) == 0x00000C, "Member 'FLegacyRaceSexMenuSliderProperties::Value' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuSliderProperties, MinText) == 0x000010, "Member 'FLegacyRaceSexMenuSliderProperties::MinText' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuSliderProperties, MaxText) == 0x000028, "Member 'FLegacyRaceSexMenuSliderProperties::MaxText' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuSliderProperties, MaximumLabelFractionalDigits) == 0x000040, "Member 'FLegacyRaceSexMenuSliderProperties::MaximumLabelFractionalDigits' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuSliderProperties, ScrollbarValueProperties) == 0x000044, "Member 'FLegacyRaceSexMenuSliderProperties::ScrollbarValueProperties' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuSliderProperties, bIsInverted) == 0x000054, "Member 'FLegacyRaceSexMenuSliderProperties::bIsInverted' has a wrong offset!");

// ScriptStruct Altar.LegacyRaceSexMenuTableRow
// 0x0100 (0x0108 - 0x0008)
struct FLegacyRaceSexMenuTableRow final : public FTableRowBase
{
public:
	ELegacyRaceSexMenuWidgetType                  Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModernRaceSexPage                            Page;                                              // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CategoryKey;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CategoryLabel;                                     // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   WidgetLabel;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bShouldDisplayWidgetLabel;                         // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModernCharacterCreationGenderRequirement     GenderRequirement;                                 // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyRaceSexMenuToggleProperties     ToggleProperties;                                  // 0x0050(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FModernRaceSexMenuColorProperties      ColorProperties;                                   // 0x0070(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FModernRaceSexMenuEyebrowColorProperties EyebrowColorProperties;                          // 0x0090(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLegacyRaceSexMenuSliderProperties     SliderProperties;                                  // 0x00B0(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyRaceSexMenuTableRow) == 0x000008, "Wrong alignment on FLegacyRaceSexMenuTableRow");
static_assert(sizeof(FLegacyRaceSexMenuTableRow) == 0x000108, "Wrong size on FLegacyRaceSexMenuTableRow");
static_assert(offsetof(FLegacyRaceSexMenuTableRow, Type) == 0x000008, "Member 'FLegacyRaceSexMenuTableRow::Type' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuTableRow, Page) == 0x000009, "Member 'FLegacyRaceSexMenuTableRow::Page' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuTableRow, CategoryKey) == 0x00000C, "Member 'FLegacyRaceSexMenuTableRow::CategoryKey' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuTableRow, CategoryLabel) == 0x000018, "Member 'FLegacyRaceSexMenuTableRow::CategoryLabel' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuTableRow, WidgetLabel) == 0x000030, "Member 'FLegacyRaceSexMenuTableRow::WidgetLabel' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuTableRow, bShouldDisplayWidgetLabel) == 0x000048, "Member 'FLegacyRaceSexMenuTableRow::bShouldDisplayWidgetLabel' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuTableRow, GenderRequirement) == 0x000049, "Member 'FLegacyRaceSexMenuTableRow::GenderRequirement' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuTableRow, ToggleProperties) == 0x000050, "Member 'FLegacyRaceSexMenuTableRow::ToggleProperties' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuTableRow, ColorProperties) == 0x000070, "Member 'FLegacyRaceSexMenuTableRow::ColorProperties' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuTableRow, EyebrowColorProperties) == 0x000090, "Member 'FLegacyRaceSexMenuTableRow::EyebrowColorProperties' has a wrong offset!");
static_assert(offsetof(FLegacyRaceSexMenuTableRow, SliderProperties) == 0x0000B0, "Member 'FLegacyRaceSexMenuTableRow::SliderProperties' has a wrong offset!");

// ScriptStruct Altar.VRaceSexMenuStatsData
// 0x0050 (0x0058 - 0x0008)
struct FVRaceSexMenuStatsData final : public FTableRowBase
{
public:
	EStatGroupType                                Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FVAttributeStatDataStructure>   Attributes;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVSkillStatDataStructure>       Skills;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVResistStatDataStructure>      Resists;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVRaceSexMenuStatsData) == 0x000008, "Wrong alignment on FVRaceSexMenuStatsData");
static_assert(sizeof(FVRaceSexMenuStatsData) == 0x000058, "Wrong size on FVRaceSexMenuStatsData");
static_assert(offsetof(FVRaceSexMenuStatsData, Type) == 0x000008, "Member 'FVRaceSexMenuStatsData::Type' has a wrong offset!");
static_assert(offsetof(FVRaceSexMenuStatsData, Name) == 0x000010, "Member 'FVRaceSexMenuStatsData::Name' has a wrong offset!");
static_assert(offsetof(FVRaceSexMenuStatsData, Attributes) == 0x000028, "Member 'FVRaceSexMenuStatsData::Attributes' has a wrong offset!");
static_assert(offsetof(FVRaceSexMenuStatsData, Skills) == 0x000038, "Member 'FVRaceSexMenuStatsData::Skills' has a wrong offset!");
static_assert(offsetof(FVRaceSexMenuStatsData, Resists) == 0x000048, "Member 'FVRaceSexMenuStatsData::Resists' has a wrong offset!");

// ScriptStruct Altar.VStandSwimRecoil
// 0x0020 (0x0020 - 0x0000)
struct FVStandSwimRecoil final
{
public:
	class UAnimMontage*                           Recoil;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimRecoil;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleBlend;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SwimIdleBlend;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVStandSwimRecoil) == 0x000008, "Wrong alignment on FVStandSwimRecoil");
static_assert(sizeof(FVStandSwimRecoil) == 0x000020, "Wrong size on FVStandSwimRecoil");
static_assert(offsetof(FVStandSwimRecoil, Recoil) == 0x000000, "Member 'FVStandSwimRecoil::Recoil' has a wrong offset!");
static_assert(offsetof(FVStandSwimRecoil, SwimRecoil) == 0x000008, "Member 'FVStandSwimRecoil::SwimRecoil' has a wrong offset!");
static_assert(offsetof(FVStandSwimRecoil, IdleBlend) == 0x000010, "Member 'FVStandSwimRecoil::IdleBlend' has a wrong offset!");
static_assert(offsetof(FVStandSwimRecoil, SwimIdleBlend) == 0x000018, "Member 'FVStandSwimRecoil::SwimIdleBlend' has a wrong offset!");

// ScriptStruct Altar.ResurrectionData
// 0x0004 (0x0004 - 0x0000)
struct FResurrectionData final
{
public:
	float                                         OffsetLocation;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResurrectionData) == 0x000004, "Wrong alignment on FResurrectionData");
static_assert(sizeof(FResurrectionData) == 0x000004, "Wrong size on FResurrectionData");
static_assert(offsetof(FResurrectionData, OffsetLocation) == 0x000000, "Member 'FResurrectionData::OffsetLocation' has a wrong offset!");

// ScriptStruct Altar.ShieldHandPoseSetup
// 0x0018 (0x0018 - 0x0000)
struct FShieldHandPoseSetup final
{
public:
	class UAnimSequence*                          HandPoseShield;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HandBoneName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HandBlendDepth;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandBlendTime;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShieldHandPoseSetup) == 0x000008, "Wrong alignment on FShieldHandPoseSetup");
static_assert(sizeof(FShieldHandPoseSetup) == 0x000018, "Wrong size on FShieldHandPoseSetup");
static_assert(offsetof(FShieldHandPoseSetup, HandPoseShield) == 0x000000, "Member 'FShieldHandPoseSetup::HandPoseShield' has a wrong offset!");
static_assert(offsetof(FShieldHandPoseSetup, HandBoneName) == 0x000008, "Member 'FShieldHandPoseSetup::HandBoneName' has a wrong offset!");
static_assert(offsetof(FShieldHandPoseSetup, HandBlendDepth) == 0x000010, "Member 'FShieldHandPoseSetup::HandBlendDepth' has a wrong offset!");
static_assert(offsetof(FShieldHandPoseSetup, HandBlendTime) == 0x000014, "Member 'FShieldHandPoseSetup::HandBlendTime' has a wrong offset!");

// ScriptStruct Altar.ShowroomHDRIBackdropParams
// 0x0010 (0x0010 - 0x0000)
struct FShowroomHDRIBackdropParams final
{
public:
	class UTextureCube*                           HDRITexture;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkylightIntensity;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HDRIRotation;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShowroomHDRIBackdropParams) == 0x000008, "Wrong alignment on FShowroomHDRIBackdropParams");
static_assert(sizeof(FShowroomHDRIBackdropParams) == 0x000010, "Wrong size on FShowroomHDRIBackdropParams");
static_assert(offsetof(FShowroomHDRIBackdropParams, HDRITexture) == 0x000000, "Member 'FShowroomHDRIBackdropParams::HDRITexture' has a wrong offset!");
static_assert(offsetof(FShowroomHDRIBackdropParams, SkylightIntensity) == 0x000008, "Member 'FShowroomHDRIBackdropParams::SkylightIntensity' has a wrong offset!");
static_assert(offsetof(FShowroomHDRIBackdropParams, HDRIRotation) == 0x00000C, "Member 'FShowroomHDRIBackdropParams::HDRIRotation' has a wrong offset!");

// ScriptStruct Altar.VSimpleInAirCharacterAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVSimpleInAirCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVSimpleInAirCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVSimpleInAirCharacterAnimInstanceProxy");
static_assert(sizeof(FVSimpleInAirCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVSimpleInAirCharacterAnimInstanceProxy");

// ScriptStruct Altar.SkillsMenuItemProperties
// 0x0078 (0x0078 - 0x0000)
struct FSkillsMenuItemProperties final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   IdentifierName;                                    // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Picture;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Details;                                           // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Specialization;                                    // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESkillAndClassSpecialization                  SpecializationEnum;                                // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillStat                                    SkillStatEnum;                                     // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillsMenuItemProperties) == 0x000008, "Wrong alignment on FSkillsMenuItemProperties");
static_assert(sizeof(FSkillsMenuItemProperties) == 0x000078, "Wrong size on FSkillsMenuItemProperties");
static_assert(offsetof(FSkillsMenuItemProperties, DisplayName) == 0x000000, "Member 'FSkillsMenuItemProperties::DisplayName' has a wrong offset!");
static_assert(offsetof(FSkillsMenuItemProperties, IdentifierName) == 0x000018, "Member 'FSkillsMenuItemProperties::IdentifierName' has a wrong offset!");
static_assert(offsetof(FSkillsMenuItemProperties, Picture) == 0x000030, "Member 'FSkillsMenuItemProperties::Picture' has a wrong offset!");
static_assert(offsetof(FSkillsMenuItemProperties, Details) == 0x000038, "Member 'FSkillsMenuItemProperties::Details' has a wrong offset!");
static_assert(offsetof(FSkillsMenuItemProperties, Specialization) == 0x000050, "Member 'FSkillsMenuItemProperties::Specialization' has a wrong offset!");
static_assert(offsetof(FSkillsMenuItemProperties, SpecializationEnum) == 0x000068, "Member 'FSkillsMenuItemProperties::SpecializationEnum' has a wrong offset!");
static_assert(offsetof(FSkillsMenuItemProperties, bIsSelected) == 0x000069, "Member 'FSkillsMenuItemProperties::bIsSelected' has a wrong offset!");
static_assert(offsetof(FSkillsMenuItemProperties, ID) == 0x00006C, "Member 'FSkillsMenuItemProperties::ID' has a wrong offset!");
static_assert(offsetof(FSkillsMenuItemProperties, SkillStatEnum) == 0x000070, "Member 'FSkillsMenuItemProperties::SkillStatEnum' has a wrong offset!");

// ScriptStruct Altar.LegacySleepWaitMenuGameInfo
// 0x0030 (0x0030 - 0x0000)
struct FLegacySleepWaitMenuGameInfo final
{
public:
	class FText                                   GameInfo1;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GameInfo2;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySleepWaitMenuGameInfo) == 0x000008, "Wrong alignment on FLegacySleepWaitMenuGameInfo");
static_assert(sizeof(FLegacySleepWaitMenuGameInfo) == 0x000030, "Wrong size on FLegacySleepWaitMenuGameInfo");
static_assert(offsetof(FLegacySleepWaitMenuGameInfo, GameInfo1) == 0x000000, "Member 'FLegacySleepWaitMenuGameInfo::GameInfo1' has a wrong offset!");
static_assert(offsetof(FLegacySleepWaitMenuGameInfo, GameInfo2) == 0x000018, "Member 'FLegacySleepWaitMenuGameInfo::GameInfo2' has a wrong offset!");

// ScriptStruct Altar.VSpecialAndDynamicIdle
// 0x000C (0x000C - 0x0000)
struct FVSpecialAndDynamicIdle final
{
public:
	class FName                                   UpperBodyBoneName;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperBodyBlendDepth;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVSpecialAndDynamicIdle) == 0x000004, "Wrong alignment on FVSpecialAndDynamicIdle");
static_assert(sizeof(FVSpecialAndDynamicIdle) == 0x00000C, "Wrong size on FVSpecialAndDynamicIdle");
static_assert(offsetof(FVSpecialAndDynamicIdle, UpperBodyBoneName) == 0x000000, "Member 'FVSpecialAndDynamicIdle::UpperBodyBoneName' has a wrong offset!");
static_assert(offsetof(FVSpecialAndDynamicIdle, UpperBodyBlendDepth) == 0x000008, "Member 'FVSpecialAndDynamicIdle::UpperBodyBlendDepth' has a wrong offset!");

// ScriptStruct Altar.SpellCastSingleAnimSet
// 0x0038 (0x0038 - 0x0000)
struct FSpellCastSingleAnimSet final
{
public:
	class UAnimSequenceBase*                      CastTouchLeft;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      CastTouchRight;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      CastSelfLeft;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      CastSelfRight;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      CastTargetLeft;                                    // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      CastTargetRight;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpellCastSingleAnimSet) == 0x000008, "Wrong alignment on FSpellCastSingleAnimSet");
static_assert(sizeof(FSpellCastSingleAnimSet) == 0x000038, "Wrong size on FSpellCastSingleAnimSet");
static_assert(offsetof(FSpellCastSingleAnimSet, CastTouchLeft) == 0x000000, "Member 'FSpellCastSingleAnimSet::CastTouchLeft' has a wrong offset!");
static_assert(offsetof(FSpellCastSingleAnimSet, CastTouchRight) == 0x000008, "Member 'FSpellCastSingleAnimSet::CastTouchRight' has a wrong offset!");
static_assert(offsetof(FSpellCastSingleAnimSet, CastSelfLeft) == 0x000010, "Member 'FSpellCastSingleAnimSet::CastSelfLeft' has a wrong offset!");
static_assert(offsetof(FSpellCastSingleAnimSet, CastSelfRight) == 0x000018, "Member 'FSpellCastSingleAnimSet::CastSelfRight' has a wrong offset!");
static_assert(offsetof(FSpellCastSingleAnimSet, CastTargetLeft) == 0x000020, "Member 'FSpellCastSingleAnimSet::CastTargetLeft' has a wrong offset!");
static_assert(offsetof(FSpellCastSingleAnimSet, CastTargetRight) == 0x000028, "Member 'FSpellCastSingleAnimSet::CastTargetRight' has a wrong offset!");
static_assert(offsetof(FSpellCastSingleAnimSet, Idle) == 0x000030, "Member 'FSpellCastSingleAnimSet::Idle' has a wrong offset!");

// ScriptStruct Altar.LegacySpellPurchaseMenuNPCData
// 0x0020 (0x0020 - 0x0000)
struct FLegacySpellPurchaseMenuNPCData final
{
public:
	class FText                                   NPCName;                                           // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         NpcGold;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacySpellPurchaseMenuNPCData) == 0x000008, "Wrong alignment on FLegacySpellPurchaseMenuNPCData");
static_assert(sizeof(FLegacySpellPurchaseMenuNPCData) == 0x000020, "Wrong size on FLegacySpellPurchaseMenuNPCData");
static_assert(offsetof(FLegacySpellPurchaseMenuNPCData, NPCName) == 0x000000, "Member 'FLegacySpellPurchaseMenuNPCData::NPCName' has a wrong offset!");
static_assert(offsetof(FLegacySpellPurchaseMenuNPCData, NpcGold) == 0x000018, "Member 'FLegacySpellPurchaseMenuNPCData::NpcGold' has a wrong offset!");

// ScriptStruct Altar.VStagger
// 0x0008 (0x0008 - 0x0000)
struct FVStagger final
{
public:
	class UAnimMontage*                           Stagger;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVStagger) == 0x000008, "Wrong alignment on FVStagger");
static_assert(sizeof(FVStagger) == 0x000008, "Wrong size on FVStagger");
static_assert(offsetof(FVStagger, Stagger) == 0x000000, "Member 'FVStagger::Stagger' has a wrong offset!");

// ScriptStruct Altar.StandSneakMultiplePowerSingle
// 0x0068 (0x0068 - 0x0000)
struct FStandSneakMultiplePowerSingle final
{
public:
	TArray<class UAnimSequence*>                  AttackRight;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  AttackLeft;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PowerAttack;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForwardPowerAttack;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BackwardPowerAttack;                               // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RightPowerAttack;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LeftPowerAttack;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  SneakAttackRight;                                  // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SneakPowerAttack;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SneakPowerAttackPrepare;                           // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandSneakMultiplePowerSingle) == 0x000008, "Wrong alignment on FStandSneakMultiplePowerSingle");
static_assert(sizeof(FStandSneakMultiplePowerSingle) == 0x000068, "Wrong size on FStandSneakMultiplePowerSingle");
static_assert(offsetof(FStandSneakMultiplePowerSingle, AttackRight) == 0x000000, "Member 'FStandSneakMultiplePowerSingle::AttackRight' has a wrong offset!");
static_assert(offsetof(FStandSneakMultiplePowerSingle, AttackLeft) == 0x000010, "Member 'FStandSneakMultiplePowerSingle::AttackLeft' has a wrong offset!");
static_assert(offsetof(FStandSneakMultiplePowerSingle, PowerAttack) == 0x000020, "Member 'FStandSneakMultiplePowerSingle::PowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSneakMultiplePowerSingle, ForwardPowerAttack) == 0x000028, "Member 'FStandSneakMultiplePowerSingle::ForwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSneakMultiplePowerSingle, BackwardPowerAttack) == 0x000030, "Member 'FStandSneakMultiplePowerSingle::BackwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSneakMultiplePowerSingle, RightPowerAttack) == 0x000038, "Member 'FStandSneakMultiplePowerSingle::RightPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSneakMultiplePowerSingle, LeftPowerAttack) == 0x000040, "Member 'FStandSneakMultiplePowerSingle::LeftPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSneakMultiplePowerSingle, SneakAttackRight) == 0x000048, "Member 'FStandSneakMultiplePowerSingle::SneakAttackRight' has a wrong offset!");
static_assert(offsetof(FStandSneakMultiplePowerSingle, SneakPowerAttack) == 0x000058, "Member 'FStandSneakMultiplePowerSingle::SneakPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSneakMultiplePowerSingle, SneakPowerAttackPrepare) == 0x000060, "Member 'FStandSneakMultiplePowerSingle::SneakPowerAttackPrepare' has a wrong offset!");

// ScriptStruct Altar.StandSwimMeleeAttackMultiplePowerSingle
// 0x0080 (0x0080 - 0x0000)
struct FStandSwimMeleeAttackMultiplePowerSingle final
{
public:
	TArray<class UAnimSequence*>                  AttackRight;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  AttackLeft;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PowerAttack;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForwardPowerAttack;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BackwardPowerAttack;                               // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RightPowerAttack;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LeftPowerAttack;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SwimAttackRight;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SwimAttackLeft;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimPowerAttack;                                   // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimForwardPowerAttack;                            // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimBackwardPowerAttack;                           // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimRightPowerAttack;                              // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimLeftPowerAttack;                               // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandSwimMeleeAttackMultiplePowerSingle) == 0x000008, "Wrong alignment on FStandSwimMeleeAttackMultiplePowerSingle");
static_assert(sizeof(FStandSwimMeleeAttackMultiplePowerSingle) == 0x000080, "Wrong size on FStandSwimMeleeAttackMultiplePowerSingle");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, AttackRight) == 0x000000, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::AttackRight' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, AttackLeft) == 0x000010, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::AttackLeft' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, PowerAttack) == 0x000020, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::PowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, ForwardPowerAttack) == 0x000028, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::ForwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, BackwardPowerAttack) == 0x000030, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::BackwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, RightPowerAttack) == 0x000038, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::RightPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, LeftPowerAttack) == 0x000040, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::LeftPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, SwimAttackRight) == 0x000048, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::SwimAttackRight' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, SwimAttackLeft) == 0x000050, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::SwimAttackLeft' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, SwimPowerAttack) == 0x000058, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::SwimPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, SwimForwardPowerAttack) == 0x000060, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::SwimForwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, SwimBackwardPowerAttack) == 0x000068, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::SwimBackwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, SwimRightPowerAttack) == 0x000070, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::SwimRightPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackMultiplePowerSingle, SwimLeftPowerAttack) == 0x000078, "Member 'FStandSwimMeleeAttackMultiplePowerSingle::SwimLeftPowerAttack' has a wrong offset!");

// ScriptStruct Altar.StandSwimMeleeAttackPowerSingleSimple
// 0x0030 (0x0030 - 0x0000)
struct FStandSwimMeleeAttackPowerSingleSimple final
{
public:
	class UAnimMontage*                           PowerAttack;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForwardPowerAttack;                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimPowerAttack;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwimForwardPowerAttack;                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Idle;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SwimIdle;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandSwimMeleeAttackPowerSingleSimple) == 0x000008, "Wrong alignment on FStandSwimMeleeAttackPowerSingleSimple");
static_assert(sizeof(FStandSwimMeleeAttackPowerSingleSimple) == 0x000030, "Wrong size on FStandSwimMeleeAttackPowerSingleSimple");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingleSimple, PowerAttack) == 0x000000, "Member 'FStandSwimMeleeAttackPowerSingleSimple::PowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingleSimple, ForwardPowerAttack) == 0x000008, "Member 'FStandSwimMeleeAttackPowerSingleSimple::ForwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingleSimple, SwimPowerAttack) == 0x000010, "Member 'FStandSwimMeleeAttackPowerSingleSimple::SwimPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingleSimple, SwimForwardPowerAttack) == 0x000018, "Member 'FStandSwimMeleeAttackPowerSingleSimple::SwimForwardPowerAttack' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingleSimple, Idle) == 0x000020, "Member 'FStandSwimMeleeAttackPowerSingleSimple::Idle' has a wrong offset!");
static_assert(offsetof(FStandSwimMeleeAttackPowerSingleSimple, SwimIdle) == 0x000028, "Member 'FStandSwimMeleeAttackPowerSingleSimple::SwimIdle' has a wrong offset!");

// ScriptStruct Altar.LegacyStatsMenuPopupContent
// 0x0028 (0x0028 - 0x0000)
struct FLegacyStatsMenuPopupContent final
{
public:
	class UTexture2D*                             Image;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         HandToHandDamage;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyStatsMenuPopupContent) == 0x000008, "Wrong alignment on FLegacyStatsMenuPopupContent");
static_assert(sizeof(FLegacyStatsMenuPopupContent) == 0x000028, "Wrong size on FLegacyStatsMenuPopupContent");
static_assert(offsetof(FLegacyStatsMenuPopupContent, Image) == 0x000000, "Member 'FLegacyStatsMenuPopupContent::Image' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuPopupContent, Text) == 0x000008, "Member 'FLegacyStatsMenuPopupContent::Text' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuPopupContent, HandToHandDamage) == 0x000020, "Member 'FLegacyStatsMenuPopupContent::HandToHandDamage' has a wrong offset!");

// ScriptStruct Altar.LegacyStatsMenuPrimaryAttributeValues
// 0x000C (0x000C - 0x0000)
struct FLegacyStatsMenuPrimaryAttributeValues final
{
public:
	int32                                         CurrentValue;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxValue;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Modifier;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyStatsMenuPrimaryAttributeValues) == 0x000004, "Wrong alignment on FLegacyStatsMenuPrimaryAttributeValues");
static_assert(sizeof(FLegacyStatsMenuPrimaryAttributeValues) == 0x00000C, "Wrong size on FLegacyStatsMenuPrimaryAttributeValues");
static_assert(offsetof(FLegacyStatsMenuPrimaryAttributeValues, CurrentValue) == 0x000000, "Member 'FLegacyStatsMenuPrimaryAttributeValues::CurrentValue' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuPrimaryAttributeValues, MaxValue) == 0x000004, "Member 'FLegacyStatsMenuPrimaryAttributeValues::MaxValue' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuPrimaryAttributeValues, Modifier) == 0x000008, "Member 'FLegacyStatsMenuPrimaryAttributeValues::Modifier' has a wrong offset!");

// ScriptStruct Altar.LegacyStatsMenuLevelProgression
// 0x0008 (0x0008 - 0x0000)
struct FLegacyStatsMenuLevelProgression final
{
public:
	float                                         MaxProgression;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelProgression;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyStatsMenuLevelProgression) == 0x000004, "Wrong alignment on FLegacyStatsMenuLevelProgression");
static_assert(sizeof(FLegacyStatsMenuLevelProgression) == 0x000008, "Wrong size on FLegacyStatsMenuLevelProgression");
static_assert(offsetof(FLegacyStatsMenuLevelProgression, MaxProgression) == 0x000000, "Member 'FLegacyStatsMenuLevelProgression::MaxProgression' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuLevelProgression, LevelProgression) == 0x000004, "Member 'FLegacyStatsMenuLevelProgression::LevelProgression' has a wrong offset!");

// ScriptStruct Altar.LegacyStatsMenuMiscItemProperties
// 0x0020 (0x0020 - 0x0000)
struct FLegacyStatsMenuMiscItemProperties final
{
public:
	class FText                                   Label;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyStatsMenuMiscItemProperties) == 0x000008, "Wrong alignment on FLegacyStatsMenuMiscItemProperties");
static_assert(sizeof(FLegacyStatsMenuMiscItemProperties) == 0x000020, "Wrong size on FLegacyStatsMenuMiscItemProperties");
static_assert(offsetof(FLegacyStatsMenuMiscItemProperties, Label) == 0x000000, "Member 'FLegacyStatsMenuMiscItemProperties::Label' has a wrong offset!");
static_assert(offsetof(FLegacyStatsMenuMiscItemProperties, Value) == 0x000018, "Member 'FLegacyStatsMenuMiscItemProperties::Value' has a wrong offset!");

// ScriptStruct Altar.VTorchCharacterAnimInstanceProxy
// 0x0010 (0x0710 - 0x0700)
struct FVTorchCharacterAnimInstanceProxy final : public FVBaseCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVTorchCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FVTorchCharacterAnimInstanceProxy");
static_assert(sizeof(FVTorchCharacterAnimInstanceProxy) == 0x000710, "Wrong size on FVTorchCharacterAnimInstanceProxy");

// ScriptStruct Altar.VTSVector2f
// 0x0008 (0x0008 - 0x0000)
struct FVTSVector2f final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVTSVector2f) == 0x000004, "Wrong alignment on FVTSVector2f");
static_assert(sizeof(FVTSVector2f) == 0x000008, "Wrong size on FVTSVector2f");
static_assert(offsetof(FVTSVector2f, X) == 0x000000, "Member 'FVTSVector2f::X' has a wrong offset!");
static_assert(offsetof(FVTSVector2f, Y) == 0x000004, "Member 'FVTSVector2f::Y' has a wrong offset!");

// ScriptStruct Altar.VTurnInPlace
// 0x0028 (0x0028 - 0x0000)
struct FVTurnInPlace final
{
public:
	class UBlendSpace*                            StandingBlendSpace;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            SneakingBlendSpace;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpperBodyBone;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BowAimBlendSpace;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlockAimBlendSpace;                                // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVTurnInPlace) == 0x000008, "Wrong alignment on FVTurnInPlace");
static_assert(sizeof(FVTurnInPlace) == 0x000028, "Wrong size on FVTurnInPlace");
static_assert(offsetof(FVTurnInPlace, StandingBlendSpace) == 0x000000, "Member 'FVTurnInPlace::StandingBlendSpace' has a wrong offset!");
static_assert(offsetof(FVTurnInPlace, SneakingBlendSpace) == 0x000008, "Member 'FVTurnInPlace::SneakingBlendSpace' has a wrong offset!");
static_assert(offsetof(FVTurnInPlace, UpperBodyBone) == 0x000010, "Member 'FVTurnInPlace::UpperBodyBone' has a wrong offset!");
static_assert(offsetof(FVTurnInPlace, BowAimBlendSpace) == 0x000018, "Member 'FVTurnInPlace::BowAimBlendSpace' has a wrong offset!");
static_assert(offsetof(FVTurnInPlace, BlockAimBlendSpace) == 0x000020, "Member 'FVTurnInPlace::BlockAimBlendSpace' has a wrong offset!");

// ScriptStruct Altar.VTurnInPlaceCreature
// 0x0038 (0x0038 - 0x0000)
struct FVTurnInPlaceCreature final
{
public:
	float                                         TurnAngleThreshold;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeedMultiplier;                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPlayRate;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayRate;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimBlendTime;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SkeletalRootRotationOffset;                        // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   SkeletalRootName;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVTurnInPlaceCreature) == 0x000008, "Wrong alignment on FVTurnInPlaceCreature");
static_assert(sizeof(FVTurnInPlaceCreature) == 0x000038, "Wrong size on FVTurnInPlaceCreature");
static_assert(offsetof(FVTurnInPlaceCreature, TurnAngleThreshold) == 0x000000, "Member 'FVTurnInPlaceCreature::TurnAngleThreshold' has a wrong offset!");
static_assert(offsetof(FVTurnInPlaceCreature, RotationSpeedMultiplier) == 0x000004, "Member 'FVTurnInPlaceCreature::RotationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FVTurnInPlaceCreature, MinPlayRate) == 0x000008, "Member 'FVTurnInPlaceCreature::MinPlayRate' has a wrong offset!");
static_assert(offsetof(FVTurnInPlaceCreature, MaxPlayRate) == 0x00000C, "Member 'FVTurnInPlaceCreature::MaxPlayRate' has a wrong offset!");
static_assert(offsetof(FVTurnInPlaceCreature, AnimBlendTime) == 0x000010, "Member 'FVTurnInPlaceCreature::AnimBlendTime' has a wrong offset!");
static_assert(offsetof(FVTurnInPlaceCreature, SkeletalRootRotationOffset) == 0x000018, "Member 'FVTurnInPlaceCreature::SkeletalRootRotationOffset' has a wrong offset!");
static_assert(offsetof(FVTurnInPlaceCreature, SkeletalRootName) == 0x000030, "Member 'FVTurnInPlaceCreature::SkeletalRootName' has a wrong offset!");

// ScriptStruct Altar.ModernTutorialQueueProperties
// 0x0038 (0x0038 - 0x0000)
struct FModernTutorialQueueProperties final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ControllerText;                                    // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   MouseKeyboardText;                                 // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModernTutorialQueueProperties) == 0x000008, "Wrong alignment on FModernTutorialQueueProperties");
static_assert(sizeof(FModernTutorialQueueProperties) == 0x000038, "Wrong size on FModernTutorialQueueProperties");
static_assert(offsetof(FModernTutorialQueueProperties, Key) == 0x000000, "Member 'FModernTutorialQueueProperties::Key' has a wrong offset!");
static_assert(offsetof(FModernTutorialQueueProperties, ControllerText) == 0x000008, "Member 'FModernTutorialQueueProperties::ControllerText' has a wrong offset!");
static_assert(offsetof(FModernTutorialQueueProperties, MouseKeyboardText) == 0x000020, "Member 'FModernTutorialQueueProperties::MouseKeyboardText' has a wrong offset!");

}

