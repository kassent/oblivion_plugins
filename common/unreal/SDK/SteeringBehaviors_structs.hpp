#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SteeringBehaviors

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum SteeringBehaviors.EAvoidanceNavigationPathPointType
// NumValues: 0x0006
enum class EAvoidanceNavigationPathPointType : uint8
{
	StartPathPoint                           = 0,
	IntermediatePathPoint                    = 1,
	ParallelPathPoint                        = 2,
	AvoidancePathPoint                       = 3,
	NavigationPathPoint                      = 4,
	EAvoidanceNavigationPathPointType_MAX    = 5,
};

// Enum SteeringBehaviors.EPathFollowingStyle
// NumValues: 0x0003
enum class EPathFollowingStyle : uint8
{
	FollowClosely                            = 0,
	FollowLoosely                            = 1,
	EPathFollowingStyle_MAX                  = 2,
};

// ScriptStruct SteeringBehaviors.MoveRequestDestinationData
// 0x0020 (0x0020 - 0x0000)
struct FMoveRequestDestinationData final
{
public:
	class AAIController*                          AIController;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIRequestID                           MoveRequestId;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x14];                                       // 0x000C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoveRequestDestinationData) == 0x000008, "Wrong alignment on FMoveRequestDestinationData");
static_assert(sizeof(FMoveRequestDestinationData) == 0x000020, "Wrong size on FMoveRequestDestinationData");
static_assert(offsetof(FMoveRequestDestinationData, AIController) == 0x000000, "Member 'FMoveRequestDestinationData::AIController' has a wrong offset!");
static_assert(offsetof(FMoveRequestDestinationData, MoveRequestId) == 0x000008, "Member 'FMoveRequestDestinationData::MoveRequestId' has a wrong offset!");

// ScriptStruct SteeringBehaviors.SteeringBehaviorContextConfiguration
// 0x0004 (0x0004 - 0x0000)
struct FSteeringBehaviorContextConfiguration final
{
public:
	bool                                          bUseInterestMap;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDangerMap;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaxSpeedNormalizedMap;                         // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRotationMap;                                   // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSteeringBehaviorContextConfiguration) == 0x000001, "Wrong alignment on FSteeringBehaviorContextConfiguration");
static_assert(sizeof(FSteeringBehaviorContextConfiguration) == 0x000004, "Wrong size on FSteeringBehaviorContextConfiguration");
static_assert(offsetof(FSteeringBehaviorContextConfiguration, bUseInterestMap) == 0x000000, "Member 'FSteeringBehaviorContextConfiguration::bUseInterestMap' has a wrong offset!");
static_assert(offsetof(FSteeringBehaviorContextConfiguration, bUseDangerMap) == 0x000001, "Member 'FSteeringBehaviorContextConfiguration::bUseDangerMap' has a wrong offset!");
static_assert(offsetof(FSteeringBehaviorContextConfiguration, bUseMaxSpeedNormalizedMap) == 0x000002, "Member 'FSteeringBehaviorContextConfiguration::bUseMaxSpeedNormalizedMap' has a wrong offset!");
static_assert(offsetof(FSteeringBehaviorContextConfiguration, bUseRotationMap) == 0x000003, "Member 'FSteeringBehaviorContextConfiguration::bUseRotationMap' has a wrong offset!");

// ScriptStruct SteeringBehaviors.SteeringBehaviorContext
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FSteeringBehaviorContext final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSteeringBehaviorContext) == 0x000008, "Wrong alignment on FSteeringBehaviorContext");
static_assert(sizeof(FSteeringBehaviorContext) == 0x000080, "Wrong size on FSteeringBehaviorContext");

// ScriptStruct SteeringBehaviors.SteeringBehaviorContextDebugDrawConfiguration
// 0x0020 (0x0020 - 0x0000)
struct FSteeringBehaviorContextDebugDrawConfiguration final
{
public:
	double                                        DebugLineLength;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        DebugLineThickness;                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugInterestMapColor;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugDangerMapColor;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugMaxSpeedNormalizedMapColor;                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSteeringBehaviorContextDebugDrawConfiguration) == 0x000008, "Wrong alignment on FSteeringBehaviorContextDebugDrawConfiguration");
static_assert(sizeof(FSteeringBehaviorContextDebugDrawConfiguration) == 0x000020, "Wrong size on FSteeringBehaviorContextDebugDrawConfiguration");
static_assert(offsetof(FSteeringBehaviorContextDebugDrawConfiguration, DebugLineLength) == 0x000000, "Member 'FSteeringBehaviorContextDebugDrawConfiguration::DebugLineLength' has a wrong offset!");
static_assert(offsetof(FSteeringBehaviorContextDebugDrawConfiguration, DebugLineThickness) == 0x000008, "Member 'FSteeringBehaviorContextDebugDrawConfiguration::DebugLineThickness' has a wrong offset!");
static_assert(offsetof(FSteeringBehaviorContextDebugDrawConfiguration, DebugInterestMapColor) == 0x000010, "Member 'FSteeringBehaviorContextDebugDrawConfiguration::DebugInterestMapColor' has a wrong offset!");
static_assert(offsetof(FSteeringBehaviorContextDebugDrawConfiguration, DebugDangerMapColor) == 0x000014, "Member 'FSteeringBehaviorContextDebugDrawConfiguration::DebugDangerMapColor' has a wrong offset!");
static_assert(offsetof(FSteeringBehaviorContextDebugDrawConfiguration, DebugMaxSpeedNormalizedMapColor) == 0x000018, "Member 'FSteeringBehaviorContextDebugDrawConfiguration::DebugMaxSpeedNormalizedMapColor' has a wrong offset!");

// ScriptStruct SteeringBehaviors.SteeringBehaviorData
// 0x0010 (0x0010 - 0x0000)
struct FSteeringBehaviorData final
{
public:
	class USteeringBehavior*                      SteeringBehavior;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSteeringBehaviorData) == 0x000008, "Wrong alignment on FSteeringBehaviorData");
static_assert(sizeof(FSteeringBehaviorData) == 0x000010, "Wrong size on FSteeringBehaviorData");
static_assert(offsetof(FSteeringBehaviorData, SteeringBehavior) == 0x000000, "Member 'FSteeringBehaviorData::SteeringBehavior' has a wrong offset!");

// ScriptStruct SteeringBehaviors.AvoidanceTemporaryIgnoredActor
// 0x0010 (0x0010 - 0x0000)
struct FAvoidanceTemporaryIgnoredActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ActivationTime;                                    // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAvoidanceTemporaryIgnoredActor) == 0x000008, "Wrong alignment on FAvoidanceTemporaryIgnoredActor");
static_assert(sizeof(FAvoidanceTemporaryIgnoredActor) == 0x000010, "Wrong size on FAvoidanceTemporaryIgnoredActor");
static_assert(offsetof(FAvoidanceTemporaryIgnoredActor, Actor) == 0x000000, "Member 'FAvoidanceTemporaryIgnoredActor::Actor' has a wrong offset!");
static_assert(offsetof(FAvoidanceTemporaryIgnoredActor, ActivationTime) == 0x000008, "Member 'FAvoidanceTemporaryIgnoredActor::ActivationTime' has a wrong offset!");

// ScriptStruct SteeringBehaviors.DropOffLedgeSegmentCandidate
// 0x0028 (0x0028 - 0x0000)
struct FDropOffLedgeSegmentCandidate final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Distance;                                          // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathPointIndex;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDropOffLedgeSegmentCandidate) == 0x000008, "Wrong alignment on FDropOffLedgeSegmentCandidate");
static_assert(sizeof(FDropOffLedgeSegmentCandidate) == 0x000028, "Wrong size on FDropOffLedgeSegmentCandidate");
static_assert(offsetof(FDropOffLedgeSegmentCandidate, Location) == 0x000000, "Member 'FDropOffLedgeSegmentCandidate::Location' has a wrong offset!");
static_assert(offsetof(FDropOffLedgeSegmentCandidate, Distance) == 0x000018, "Member 'FDropOffLedgeSegmentCandidate::Distance' has a wrong offset!");
static_assert(offsetof(FDropOffLedgeSegmentCandidate, PathPointIndex) == 0x000020, "Member 'FDropOffLedgeSegmentCandidate::PathPointIndex' has a wrong offset!");

// ScriptStruct SteeringBehaviors.DropOffLedgeTargetLocation
// 0x0038 (0x0038 - 0x0000)
struct FDropOffLedgeTargetLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        PathTimestamp;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoveRequestDestination;                         // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x17];                                      // 0x0021(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDropOffLedgeTargetLocation) == 0x000008, "Wrong alignment on FDropOffLedgeTargetLocation");
static_assert(sizeof(FDropOffLedgeTargetLocation) == 0x000038, "Wrong size on FDropOffLedgeTargetLocation");
static_assert(offsetof(FDropOffLedgeTargetLocation, Location) == 0x000000, "Member 'FDropOffLedgeTargetLocation::Location' has a wrong offset!");
static_assert(offsetof(FDropOffLedgeTargetLocation, PathTimestamp) == 0x000018, "Member 'FDropOffLedgeTargetLocation::PathTimestamp' has a wrong offset!");
static_assert(offsetof(FDropOffLedgeTargetLocation, bIsMoveRequestDestination) == 0x000020, "Member 'FDropOffLedgeTargetLocation::bIsMoveRequestDestination' has a wrong offset!");

// ScriptStruct SteeringBehaviors.PawnDetectedEvasion
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FPawnDetectedEvasion final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnDetectedEvasion) == 0x000008, "Wrong alignment on FPawnDetectedEvasion");
static_assert(sizeof(FPawnDetectedEvasion) == 0x000030, "Wrong size on FPawnDetectedEvasion");

// ScriptStruct SteeringBehaviors.AdjustedPathPoint
// 0x0028 (0x0028 - 0x0000)
struct FAdjustedPathPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        NextPathPointDistance2D;                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAvoidanceNavigationPathPointType             PathPointType;                                     // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAdjustedPathPoint) == 0x000008, "Wrong alignment on FAdjustedPathPoint");
static_assert(sizeof(FAdjustedPathPoint) == 0x000028, "Wrong size on FAdjustedPathPoint");
static_assert(offsetof(FAdjustedPathPoint, Location) == 0x000000, "Member 'FAdjustedPathPoint::Location' has a wrong offset!");
static_assert(offsetof(FAdjustedPathPoint, NextPathPointDistance2D) == 0x000018, "Member 'FAdjustedPathPoint::NextPathPointDistance2D' has a wrong offset!");
static_assert(offsetof(FAdjustedPathPoint, PathPointType) == 0x000020, "Member 'FAdjustedPathPoint::PathPointType' has a wrong offset!");

// ScriptStruct SteeringBehaviors.PawnAvoidanceBox
// 0x0378 (0x0378 - 0x0000)
struct FPawnAvoidanceBox final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Box;                                               // 0x0030(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               BoxRotation;                                       // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                EntryLocation;                                     // 0x0080(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        EntryLocationPathDistance2D;                       // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExitLocation;                                      // 0x00A0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ExitLocationPathDistance2D;                        // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftPathStartIndex;                                // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x2B4];                                     // 0x00C4(0x02B4)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnAvoidanceBox) == 0x000008, "Wrong alignment on FPawnAvoidanceBox");
static_assert(sizeof(FPawnAvoidanceBox) == 0x000378, "Wrong size on FPawnAvoidanceBox");
static_assert(offsetof(FPawnAvoidanceBox, Box) == 0x000030, "Member 'FPawnAvoidanceBox::Box' has a wrong offset!");
static_assert(offsetof(FPawnAvoidanceBox, BoxRotation) == 0x000068, "Member 'FPawnAvoidanceBox::BoxRotation' has a wrong offset!");
static_assert(offsetof(FPawnAvoidanceBox, EntryLocation) == 0x000080, "Member 'FPawnAvoidanceBox::EntryLocation' has a wrong offset!");
static_assert(offsetof(FPawnAvoidanceBox, EntryLocationPathDistance2D) == 0x000098, "Member 'FPawnAvoidanceBox::EntryLocationPathDistance2D' has a wrong offset!");
static_assert(offsetof(FPawnAvoidanceBox, ExitLocation) == 0x0000A0, "Member 'FPawnAvoidanceBox::ExitLocation' has a wrong offset!");
static_assert(offsetof(FPawnAvoidanceBox, ExitLocationPathDistance2D) == 0x0000B8, "Member 'FPawnAvoidanceBox::ExitLocationPathDistance2D' has a wrong offset!");
static_assert(offsetof(FPawnAvoidanceBox, LeftPathStartIndex) == 0x0000C0, "Member 'FPawnAvoidanceBox::LeftPathStartIndex' has a wrong offset!");

// ScriptStruct SteeringBehaviors.PawnAvoidancePersistence
// 0x0028 (0x0028 - 0x0000)
struct FPawnAvoidancePersistence final
{
public:
	double                                        ObstacleDetectionTime;                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AvoidDecisionTime;                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GiveWayStartTime;                                  // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AvoidancePathSelectionTime;                        // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnAvoidancePersistence) == 0x000008, "Wrong alignment on FPawnAvoidancePersistence");
static_assert(sizeof(FPawnAvoidancePersistence) == 0x000028, "Wrong size on FPawnAvoidancePersistence");
static_assert(offsetof(FPawnAvoidancePersistence, ObstacleDetectionTime) == 0x000000, "Member 'FPawnAvoidancePersistence::ObstacleDetectionTime' has a wrong offset!");
static_assert(offsetof(FPawnAvoidancePersistence, AvoidDecisionTime) == 0x000008, "Member 'FPawnAvoidancePersistence::AvoidDecisionTime' has a wrong offset!");
static_assert(offsetof(FPawnAvoidancePersistence, GiveWayStartTime) == 0x000010, "Member 'FPawnAvoidancePersistence::GiveWayStartTime' has a wrong offset!");
static_assert(offsetof(FPawnAvoidancePersistence, AvoidancePathSelectionTime) == 0x000018, "Member 'FPawnAvoidancePersistence::AvoidancePathSelectionTime' has a wrong offset!");

// ScriptStruct SteeringBehaviors.AvoidanceNavigationPathPoint
// 0x0020 (0x0020 - 0x0000)
struct FAvoidanceNavigationPathPoint final
{
public:
	struct FVector                                PathPointLocation;                                 // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAvoidanceNavigationPathPointType             PathPointType;                                     // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvoidanceNavigationPathPoint) == 0x000008, "Wrong alignment on FAvoidanceNavigationPathPoint");
static_assert(sizeof(FAvoidanceNavigationPathPoint) == 0x000020, "Wrong size on FAvoidanceNavigationPathPoint");
static_assert(offsetof(FAvoidanceNavigationPathPoint, PathPointLocation) == 0x000000, "Member 'FAvoidanceNavigationPathPoint::PathPointLocation' has a wrong offset!");
static_assert(offsetof(FAvoidanceNavigationPathPoint, PathPointType) == 0x000018, "Member 'FAvoidanceNavigationPathPoint::PathPointType' has a wrong offset!");

// ScriptStruct SteeringBehaviors.NavigationPathTargetPathPoint
// 0x0010 (0x0010 - 0x0000)
struct FNavigationPathTargetPathPoint final
{
public:
	int32                                         PathPointIndex;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        PathTimestamp;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavigationPathTargetPathPoint) == 0x000008, "Wrong alignment on FNavigationPathTargetPathPoint");
static_assert(sizeof(FNavigationPathTargetPathPoint) == 0x000010, "Wrong size on FNavigationPathTargetPathPoint");
static_assert(offsetof(FNavigationPathTargetPathPoint, PathPointIndex) == 0x000000, "Member 'FNavigationPathTargetPathPoint::PathPointIndex' has a wrong offset!");
static_assert(offsetof(FNavigationPathTargetPathPoint, PathTimestamp) == 0x000008, "Member 'FNavigationPathTargetPathPoint::PathTimestamp' has a wrong offset!");

// ScriptStruct SteeringBehaviors.SkipPathSegmentAreaConfiguration
// 0x0018 (0x0018 - 0x0000)
struct FSkipPathSegmentAreaConfiguration final
{
public:
	TSubclassOf<class UNavArea>                   NavAreaClass;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UNavArea>>           IncludedNavAreaClasses;                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkipPathSegmentAreaConfiguration) == 0x000008, "Wrong alignment on FSkipPathSegmentAreaConfiguration");
static_assert(sizeof(FSkipPathSegmentAreaConfiguration) == 0x000018, "Wrong size on FSkipPathSegmentAreaConfiguration");
static_assert(offsetof(FSkipPathSegmentAreaConfiguration, NavAreaClass) == 0x000000, "Member 'FSkipPathSegmentAreaConfiguration::NavAreaClass' has a wrong offset!");
static_assert(offsetof(FSkipPathSegmentAreaConfiguration, IncludedNavAreaClasses) == 0x000008, "Member 'FSkipPathSegmentAreaConfiguration::IncludedNavAreaClasses' has a wrong offset!");

}

