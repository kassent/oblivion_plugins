#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Altar

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "EnhancedInput_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "Water_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "VActorStateMachine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Altar_structs.hpp"
#include "CommonUI_classes.hpp"
#include "InputCore_structs.hpp"
#include "SlateCore_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "CommonInput_structs.hpp"
#include "ModelViewViewModel_classes.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"
#include "VCommonUIEnhancedInputNavigation_classes.hpp"
#include "LevelSequence_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "MotionWarping_classes.hpp"
#include "SteeringBehaviors_classes.hpp"
#include "AtmosphericToolRuntime_classes.hpp"
#include "AIModule_classes.hpp"
#include "AnimationBudgetAllocator_classes.hpp"
#include "Slate_structs.hpp"


namespace SDK
{

// Class Altar.NifType
// 0x0008 (0x0030 - 0x0028)
class UNifType : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NifType">();
	}
	static class UNifType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNifType>();
	}
};
static_assert(alignof(UNifType) == 0x000008, "Wrong alignment on UNifType");
static_assert(sizeof(UNifType) == 0x000030, "Wrong size on UNifType");

// Class Altar.NiObject
// 0x0008 (0x0038 - 0x0030)
class UNiObject : public UNifType
{
public:
	int64                                         GroupID;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiObject">();
	}
	static class UNiObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiObject>();
	}
};
static_assert(alignof(UNiObject) == 0x000008, "Wrong alignment on UNiObject");
static_assert(sizeof(UNiObject) == 0x000038, "Wrong size on UNiObject");
static_assert(offsetof(UNiObject, GroupID) == 0x000030, "Member 'UNiObject::GroupID' has a wrong offset!");

// Class Altar.NiPixelFormat
// 0x0070 (0x00A8 - 0x0038)
class UNiPixelFormat final : public UNiObject
{
public:
	Altar::EPixelFormat                           PixelFormatFlags;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RedMask;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         GreenMask;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BlueMask;                                          // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AlphaMask;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BitsPerPixeluint;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 OldFastCompare;                                    // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	EPixelTiling                                  Tiling;                                            // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BitsPerPixelbyte;                                  // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RendererHint;                                      // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ExtraData;                                         // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Flags_0;                                           // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          sRGBSpace;                                         // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPixelFormatComponent*>          Channels;                                          // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPixelFormat">();
	}
	static class UNiPixelFormat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPixelFormat>();
	}
};
static_assert(alignof(UNiPixelFormat) == 0x000008, "Wrong alignment on UNiPixelFormat");
static_assert(sizeof(UNiPixelFormat) == 0x0000A8, "Wrong size on UNiPixelFormat");
static_assert(offsetof(UNiPixelFormat, PixelFormatFlags) == 0x000038, "Member 'UNiPixelFormat::PixelFormatFlags' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, RedMask) == 0x000040, "Member 'UNiPixelFormat::RedMask' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, GreenMask) == 0x000048, "Member 'UNiPixelFormat::GreenMask' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, BlueMask) == 0x000050, "Member 'UNiPixelFormat::BlueMask' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, AlphaMask) == 0x000058, "Member 'UNiPixelFormat::AlphaMask' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, BitsPerPixeluint) == 0x000060, "Member 'UNiPixelFormat::BitsPerPixeluint' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, OldFastCompare) == 0x000068, "Member 'UNiPixelFormat::OldFastCompare' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, Tiling) == 0x000078, "Member 'UNiPixelFormat::Tiling' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, BitsPerPixelbyte) == 0x00007C, "Member 'UNiPixelFormat::BitsPerPixelbyte' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, RendererHint) == 0x000080, "Member 'UNiPixelFormat::RendererHint' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, ExtraData) == 0x000088, "Member 'UNiPixelFormat::ExtraData' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, Flags_0) == 0x000090, "Member 'UNiPixelFormat::Flags_0' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, sRGBSpace) == 0x000091, "Member 'UNiPixelFormat::sRGBSpace' has a wrong offset!");
static_assert(offsetof(UNiPixelFormat, Channels) == 0x000098, "Member 'UNiPixelFormat::Channels' has a wrong offset!");

// Class Altar.bhkRefObject
// 0x0000 (0x0038 - 0x0038)
class UbhkRefObject : public UNiObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkRefObject">();
	}
	static class UbhkRefObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkRefObject>();
	}
};
static_assert(alignof(UbhkRefObject) == 0x000008, "Wrong alignment on UbhkRefObject");
static_assert(sizeof(UbhkRefObject) == 0x000038, "Wrong size on UbhkRefObject");

// Class Altar.bhkSerializable
// 0x0000 (0x0038 - 0x0038)
class UbhkSerializable : public UbhkRefObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkSerializable">();
	}
	static class UbhkSerializable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkSerializable>();
	}
};
static_assert(alignof(UbhkSerializable) == 0x000008, "Wrong alignment on UbhkSerializable");
static_assert(sizeof(UbhkSerializable) == 0x000038, "Wrong size on UbhkSerializable");

// Class Altar.bhkShape
// 0x0000 (0x0038 - 0x0038)
class UbhkShape : public UbhkSerializable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkShape">();
	}
	static class UbhkShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkShape>();
	}
};
static_assert(alignof(UbhkShape) == 0x000008, "Wrong alignment on UbhkShape");
static_assert(sizeof(UbhkShape) == 0x000038, "Wrong size on UbhkShape");

// Class Altar.VBaseCharacterAnimInstance
// 0x0010 (0x0360 - 0x0350)
#pragma pack(push, 0x1)
class alignas(0x10) UVBaseCharacterAnimInstance : public UAnimInstance
{
public:
	class AVPairedPawn*                           PairedPawn;                                        // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBaseCharacterAnimInstance">();
	}
	static class UVBaseCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBaseCharacterAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVBaseCharacterAnimInstance) == 0x000010, "Wrong alignment on UVBaseCharacterAnimInstance");
static_assert(sizeof(UVBaseCharacterAnimInstance) == 0x000360, "Wrong size on UVBaseCharacterAnimInstance");
static_assert(offsetof(UVBaseCharacterAnimInstance, PairedPawn) == 0x000348, "Member 'UVBaseCharacterAnimInstance::PairedPawn' has a wrong offset!");

// Class Altar.VLayerCharacterAnimInstance
// 0x0040 (0x03A0 - 0x0360)
class UVLayerCharacterAnimInstance : public UVBaseCharacterAnimInstance
{
public:
	class UVMainCharacterAnimInstance*            MainAnimInstance;                                  // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AnimLayerIndex;                                    // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimLayerPlayRate;                                 // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPoseSnapshot                          SavedPoseSnapshot;                                 // 0x0368(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	class UVMainCharacterAnimInstance* GetMainAnimInstance();
	class UAnimMontage* GetMontageFromArrayWithGivenIndexIfValid(int32 GameplayArrayIndex, const TArray<class UAnimMontage*>& MontageArray);
	class UAnimSequenceBase* GetSequenceFromArrayWithGivenIndexIfValid(int32 GameplayArrayIndex, const TArray<class UAnimSequenceBase*>& ActionAnim);
	void ScheduledPlayMontage(class UAnimMontage* MontageToPlay, float InPlayRate, class UAnimInstance* AnimInstance, EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages);
	void UpdateActionData(const struct FGameplayTag& ActionTag, const class UAnimSequenceBase* ActionAnim);
	void UpdateActionDataFromArray(const struct FGameplayTag& ActionTag, const TArray<class UAnimSequenceBase*>& ActionAnims);

	bool IsInCombat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLayerCharacterAnimInstance">();
	}
	static class UVLayerCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLayerCharacterAnimInstance>();
	}
};
static_assert(alignof(UVLayerCharacterAnimInstance) == 0x000010, "Wrong alignment on UVLayerCharacterAnimInstance");
static_assert(sizeof(UVLayerCharacterAnimInstance) == 0x0003A0, "Wrong size on UVLayerCharacterAnimInstance");
static_assert(offsetof(UVLayerCharacterAnimInstance, MainAnimInstance) == 0x000358, "Member 'UVLayerCharacterAnimInstance::MainAnimInstance' has a wrong offset!");
static_assert(offsetof(UVLayerCharacterAnimInstance, AnimLayerIndex) == 0x000360, "Member 'UVLayerCharacterAnimInstance::AnimLayerIndex' has a wrong offset!");
static_assert(offsetof(UVLayerCharacterAnimInstance, AnimLayerPlayRate) == 0x000364, "Member 'UVLayerCharacterAnimInstance::AnimLayerPlayRate' has a wrong offset!");
static_assert(offsetof(UVLayerCharacterAnimInstance, SavedPoseSnapshot) == 0x000368, "Member 'UVLayerCharacterAnimInstance::SavedPoseSnapshot' has a wrong offset!");

// Class Altar.VHumanoidLowerAndUpperCharacterAnimInstance
// 0x00E0 (0x0480 - 0x03A0)
class UVHumanoidLowerAndUpperCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	struct FVHumanoidLowerAndUpperBodySetup       TurnInPlaceBlendSettings;                          // 0x03A0(0x0038)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  MovingTags;                                        // 0x03D8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           RecoilTag;                                         // 0x03F8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DedicatedSneakActionTags;                          // 0x0400(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  LeftArmCastingTags;                                // 0x0420(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FName                                   LandCurveName;                                     // 0x0440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftCastAnchorName;                                // 0x0448(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightCastAnchorName;                               // 0x0450(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMovingOrRecoiling;                              // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasDedicatedSneakAnim;                            // 0x0459(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStaffAttacking;                                   // 0x045A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45B[0x5];                                      // 0x045B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MagicNodePosition;                                 // 0x0460(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsSneaking() const;
	bool IsSwimming() const;
	bool IsUsingBow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHumanoidLowerAndUpperCharacterAnimInstance">();
	}
	static class UVHumanoidLowerAndUpperCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHumanoidLowerAndUpperCharacterAnimInstance>();
	}
};
static_assert(alignof(UVHumanoidLowerAndUpperCharacterAnimInstance) == 0x000010, "Wrong alignment on UVHumanoidLowerAndUpperCharacterAnimInstance");
static_assert(sizeof(UVHumanoidLowerAndUpperCharacterAnimInstance) == 0x000480, "Wrong size on UVHumanoidLowerAndUpperCharacterAnimInstance");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, TurnInPlaceBlendSettings) == 0x0003A0, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::TurnInPlaceBlendSettings' has a wrong offset!");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, MovingTags) == 0x0003D8, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::MovingTags' has a wrong offset!");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, RecoilTag) == 0x0003F8, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::RecoilTag' has a wrong offset!");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, DedicatedSneakActionTags) == 0x000400, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::DedicatedSneakActionTags' has a wrong offset!");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, LeftArmCastingTags) == 0x000420, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::LeftArmCastingTags' has a wrong offset!");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, LandCurveName) == 0x000440, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::LandCurveName' has a wrong offset!");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, LeftCastAnchorName) == 0x000448, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::LeftCastAnchorName' has a wrong offset!");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, RightCastAnchorName) == 0x000450, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::RightCastAnchorName' has a wrong offset!");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, bIsMovingOrRecoiling) == 0x000458, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::bIsMovingOrRecoiling' has a wrong offset!");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, bHasDedicatedSneakAnim) == 0x000459, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::bHasDedicatedSneakAnim' has a wrong offset!");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, bStaffAttacking) == 0x00045A, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::bStaffAttacking' has a wrong offset!");
static_assert(offsetof(UVHumanoidLowerAndUpperCharacterAnimInstance, MagicNodePosition) == 0x000460, "Member 'UVHumanoidLowerAndUpperCharacterAnimInstance::MagicNodePosition' has a wrong offset!");

// Class Altar.VStatusEffectTarget
// 0x0048 (0x02E0 - 0x0298)
class AVStatusEffectTarget : public AActor
{
public:
	bool                                          bIsVFXLocatedOnSkeletalMesh;                       // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   VFXLocationStaticMesh;                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 VFXLocationSkeletalMesh;                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTESEffectShader* form, const TArray<struct FLinearColor>& VFXColors, const TArray<class UStaticMeshComponent*>& MeshIgnoreList, float StatusEffectValue)> OnTextureEffectStart; // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTextureEffectStop;                               // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTextureEffectReset;                              // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStatusEffectTarget">();
	}
	static class AVStatusEffectTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVStatusEffectTarget>();
	}
};
static_assert(alignof(AVStatusEffectTarget) == 0x000008, "Wrong alignment on AVStatusEffectTarget");
static_assert(sizeof(AVStatusEffectTarget) == 0x0002E0, "Wrong size on AVStatusEffectTarget");
static_assert(offsetof(AVStatusEffectTarget, bIsVFXLocatedOnSkeletalMesh) == 0x000298, "Member 'AVStatusEffectTarget::bIsVFXLocatedOnSkeletalMesh' has a wrong offset!");
static_assert(offsetof(AVStatusEffectTarget, VFXLocationStaticMesh) == 0x0002A0, "Member 'AVStatusEffectTarget::VFXLocationStaticMesh' has a wrong offset!");
static_assert(offsetof(AVStatusEffectTarget, VFXLocationSkeletalMesh) == 0x0002A8, "Member 'AVStatusEffectTarget::VFXLocationSkeletalMesh' has a wrong offset!");
static_assert(offsetof(AVStatusEffectTarget, OnTextureEffectStart) == 0x0002B0, "Member 'AVStatusEffectTarget::OnTextureEffectStart' has a wrong offset!");
static_assert(offsetof(AVStatusEffectTarget, OnTextureEffectStop) == 0x0002C0, "Member 'AVStatusEffectTarget::OnTextureEffectStop' has a wrong offset!");
static_assert(offsetof(AVStatusEffectTarget, OnTextureEffectReset) == 0x0002D0, "Member 'AVStatusEffectTarget::OnTextureEffectReset' has a wrong offset!");

// Class Altar.VAltarStateConditionBase
// 0x0008 (0x0038 - 0x0030)
class UVAltarStateConditionBase : public UVStateCondition
{
public:
	class AVPairedPawn*                           PairedPawn;                                        // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarStateConditionBase">();
	}
	static class UVAltarStateConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarStateConditionBase>();
	}
};
static_assert(alignof(UVAltarStateConditionBase) == 0x000008, "Wrong alignment on UVAltarStateConditionBase");
static_assert(sizeof(UVAltarStateConditionBase) == 0x000038, "Wrong size on UVAltarStateConditionBase");
static_assert(offsetof(UVAltarStateConditionBase, PairedPawn) == 0x000030, "Member 'UVAltarStateConditionBase::PairedPawn' has a wrong offset!");

// Class Altar.VAltarStateConditionCheckActionTags
// 0x0020 (0x0058 - 0x0038)
class UVAltarStateConditionCheckActionTags : public UVAltarStateConditionBase
{
public:
	struct FGameplayTagContainer                  ActionTags;                                        // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarStateConditionCheckActionTags">();
	}
	static class UVAltarStateConditionCheckActionTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarStateConditionCheckActionTags>();
	}
};
static_assert(alignof(UVAltarStateConditionCheckActionTags) == 0x000008, "Wrong alignment on UVAltarStateConditionCheckActionTags");
static_assert(sizeof(UVAltarStateConditionCheckActionTags) == 0x000058, "Wrong size on UVAltarStateConditionCheckActionTags");
static_assert(offsetof(UVAltarStateConditionCheckActionTags, ActionTags) == 0x000038, "Member 'UVAltarStateConditionCheckActionTags::ActionTags' has a wrong offset!");

// Class Altar.VActor
// 0x0010 (0x02F0 - 0x02E0)
class AVActor : public AVStatusEffectTarget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemStackCount;                                    // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastSparseDelegateProperty_             OnHiddenInGameChanged;                             // 0x02EC(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindVariantUpdates();
	void OnActivateAnimation(const class FString& AnimationName);
	void OnResetAnimation(const class FString& AnimationName, float FramePosRatio, bool _bIsDestroyed);

	ECharacterSex GetDroppedItemSexVariant() const;
	int32 GetItemStackCount() const;
	class AVPairedCharacter* GetVariantReferenceCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VActor">();
	}
	static class AVActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVActor>();
	}
};
static_assert(alignof(AVActor) == 0x000008, "Wrong alignment on AVActor");
static_assert(sizeof(AVActor) == 0x0002F0, "Wrong size on AVActor");
static_assert(offsetof(AVActor, ItemStackCount) == 0x0002E8, "Member 'AVActor::ItemStackCount' has a wrong offset!");
static_assert(offsetof(AVActor, OnHiddenInGameChanged) == 0x0002EC, "Member 'AVActor::OnHiddenInGameChanged' has a wrong offset!");

// Class Altar.TESBaseFormComponent
// 0x0000 (0x0028 - 0x0028)
class UTESBaseFormComponent : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESBaseFormComponent">();
	}
	static class UTESBaseFormComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESBaseFormComponent>();
	}
};
static_assert(alignof(UTESBaseFormComponent) == 0x000008, "Wrong alignment on UTESBaseFormComponent");
static_assert(sizeof(UTESBaseFormComponent) == 0x000028, "Wrong size on UTESBaseFormComponent");

// Class Altar.TESForm
// 0x00B0 (0x00D8 - 0x0028)
class UTESForm : public UTESBaseFormComponent
{
public:
	int64                                         m_formID;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 m_formEditorID;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFormID                                       m_formType;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         m_formFlags;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBlueprint>              Blueprint;                                         // 0x0050(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BlueprintClass;                                    // 0x0078(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeUsedAsPropItem;                              // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         BSXFlags;                                          // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UBlueprint>>      BlueprintVariants;                                 // 0x00B0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           BlueprintVariantClasses;                           // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static EFormID GetFormTypeFromFormString(int64 formString);

	class UClass* GetComponent();
	bool GetDelete();
	TSoftClassPtr<class UClass> GetEquipableBlueprintClass();
	class FString GetFormDetailedString();
	void UpdateBlueprintClassesPostEdit();

	bool CanFormBeUsedAsPropItem() const;
	int64 GetBPFormID() const;
	class FString GetFormEditorID() const;
	int64 GetFormFlags() const;
	EFormID GetFormType() const;
	class FString GetFormTypeString() const;
	class FString GetFormTypeStringFromFlags() const;
	class FString GetHexFormID() const;
	bool GetMaster() const;
	bool GetTemporary() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESForm">();
	}
	static class UTESForm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESForm>();
	}
};
static_assert(alignof(UTESForm) == 0x000008, "Wrong alignment on UTESForm");
static_assert(sizeof(UTESForm) == 0x0000D8, "Wrong size on UTESForm");
static_assert(offsetof(UTESForm, m_formID) == 0x000028, "Member 'UTESForm::m_formID' has a wrong offset!");
static_assert(offsetof(UTESForm, m_formEditorID) == 0x000030, "Member 'UTESForm::m_formEditorID' has a wrong offset!");
static_assert(offsetof(UTESForm, m_formType) == 0x000040, "Member 'UTESForm::m_formType' has a wrong offset!");
static_assert(offsetof(UTESForm, m_formFlags) == 0x000048, "Member 'UTESForm::m_formFlags' has a wrong offset!");
static_assert(offsetof(UTESForm, Blueprint) == 0x000050, "Member 'UTESForm::Blueprint' has a wrong offset!");
static_assert(offsetof(UTESForm, BlueprintClass) == 0x000078, "Member 'UTESForm::BlueprintClass' has a wrong offset!");
static_assert(offsetof(UTESForm, bCanBeUsedAsPropItem) == 0x0000A0, "Member 'UTESForm::bCanBeUsedAsPropItem' has a wrong offset!");
static_assert(offsetof(UTESForm, BSXFlags) == 0x0000A8, "Member 'UTESForm::BSXFlags' has a wrong offset!");
static_assert(offsetof(UTESForm, BlueprintVariants) == 0x0000B0, "Member 'UTESForm::BlueprintVariants' has a wrong offset!");
static_assert(offsetof(UTESForm, BlueprintVariantClasses) == 0x0000C0, "Member 'UTESForm::BlueprintVariantClasses' has a wrong offset!");

// Class Altar.TESFaction
// 0x0000 (0x00D8 - 0x00D8)
class UTESFaction final : public UTESForm
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESFaction">();
	}
	static class UTESFaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESFaction>();
	}
};
static_assert(alignof(UTESFaction) == 0x000008, "Wrong alignment on UTESFaction");
static_assert(sizeof(UTESFaction) == 0x0000D8, "Wrong size on UTESFaction");

// Class Altar.AltarGameModeBase
// 0x0090 (0x03C8 - 0x0338)
class AAltarGameModeBase : public AGameModeBase
{
public:
	bool                                          bShouldUseUnrealDebugTool;                         // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavMeshBoundsVolume*                   BackupNavMeshBoundsVolumeActor;                    // 0x0340(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x30];                                     // 0x0348(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 NewValue)> OnClothQualityChanged;                            // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 NewValue)> OnViewDistanceQualityChanged;                     // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bShouldUseDetourCrowdBehaviour;                    // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AVPhysicsDebugPanel>     PhysicsDebugPanel;                                 // 0x03A0(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AltarGameModeBase">();
	}
	static class AAltarGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAltarGameModeBase>();
	}
};
static_assert(alignof(AAltarGameModeBase) == 0x000008, "Wrong alignment on AAltarGameModeBase");
static_assert(sizeof(AAltarGameModeBase) == 0x0003C8, "Wrong size on AAltarGameModeBase");
static_assert(offsetof(AAltarGameModeBase, bShouldUseUnrealDebugTool) == 0x000338, "Member 'AAltarGameModeBase::bShouldUseUnrealDebugTool' has a wrong offset!");
static_assert(offsetof(AAltarGameModeBase, BackupNavMeshBoundsVolumeActor) == 0x000340, "Member 'AAltarGameModeBase::BackupNavMeshBoundsVolumeActor' has a wrong offset!");
static_assert(offsetof(AAltarGameModeBase, OnClothQualityChanged) == 0x000378, "Member 'AAltarGameModeBase::OnClothQualityChanged' has a wrong offset!");
static_assert(offsetof(AAltarGameModeBase, OnViewDistanceQualityChanged) == 0x000388, "Member 'AAltarGameModeBase::OnViewDistanceQualityChanged' has a wrong offset!");
static_assert(offsetof(AAltarGameModeBase, bShouldUseDetourCrowdBehaviour) == 0x000398, "Member 'AAltarGameModeBase::bShouldUseDetourCrowdBehaviour' has a wrong offset!");
static_assert(offsetof(AAltarGameModeBase, PhysicsDebugPanel) == 0x0003A0, "Member 'AAltarGameModeBase::PhysicsDebugPanel' has a wrong offset!");

// Class Altar.VActivable
// 0x00A8 (0x0398 - 0x02F0)
class AVActivable : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAnimationObjectPairingComponent*      AnimationObjectPairingComponent;                   // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesDetonateItsProjectilesAsSoonAsTheyAppear;     // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeNavModifierAreaOnOpenCloseState;            // 0x0361(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_362[0x6];                                      // 0x0362(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavArea>                   OpenNavArea;                                       // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   CloseNavArea;                                      // 0x0370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPhysicsWaitForCustomTrigger;                // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPortalStartsOpened;                               // 0x0379(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForwardAnimationOpensPortal;                      // 0x037A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPortalOpened;                                   // 0x037B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavModifierComponent*                  OwnedNavModifierComponent;                         // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAltarAkPortalComponent*               PortalComponent;                                   // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivableSimulationStart();
	void OnActivableSimulationStop();
	void TriggerActivateForPhysics();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VActivable">();
	}
	static class AVActivable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVActivable>();
	}
};
static_assert(alignof(AVActivable) == 0x000008, "Wrong alignment on AVActivable");
static_assert(sizeof(AVActivable) == 0x000398, "Wrong size on AVActivable");
static_assert(offsetof(AVActivable, TESRefComponent) == 0x000330, "Member 'AVActivable::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVActivable, TransformPairingComponent) == 0x000338, "Member 'AVActivable::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVActivable, AnimationObjectPairingComponent) == 0x000340, "Member 'AVActivable::AnimationObjectPairingComponent' has a wrong offset!");
static_assert(offsetof(AVActivable, SkeletalMeshComponent) == 0x000348, "Member 'AVActivable::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AVActivable, PhysicsControllerComponent) == 0x000350, "Member 'AVActivable::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVActivable, AkAudioComponent) == 0x000358, "Member 'AVActivable::AkAudioComponent' has a wrong offset!");
static_assert(offsetof(AVActivable, bDoesDetonateItsProjectilesAsSoonAsTheyAppear) == 0x000360, "Member 'AVActivable::bDoesDetonateItsProjectilesAsSoonAsTheyAppear' has a wrong offset!");
static_assert(offsetof(AVActivable, bChangeNavModifierAreaOnOpenCloseState) == 0x000361, "Member 'AVActivable::bChangeNavModifierAreaOnOpenCloseState' has a wrong offset!");
static_assert(offsetof(AVActivable, OpenNavArea) == 0x000368, "Member 'AVActivable::OpenNavArea' has a wrong offset!");
static_assert(offsetof(AVActivable, CloseNavArea) == 0x000370, "Member 'AVActivable::CloseNavArea' has a wrong offset!");
static_assert(offsetof(AVActivable, bShouldPhysicsWaitForCustomTrigger) == 0x000378, "Member 'AVActivable::bShouldPhysicsWaitForCustomTrigger' has a wrong offset!");
static_assert(offsetof(AVActivable, bPortalStartsOpened) == 0x000379, "Member 'AVActivable::bPortalStartsOpened' has a wrong offset!");
static_assert(offsetof(AVActivable, bForwardAnimationOpensPortal) == 0x00037A, "Member 'AVActivable::bForwardAnimationOpensPortal' has a wrong offset!");
static_assert(offsetof(AVActivable, bIsPortalOpened) == 0x00037B, "Member 'AVActivable::bIsPortalOpened' has a wrong offset!");
static_assert(offsetof(AVActivable, OwnedNavModifierComponent) == 0x000380, "Member 'AVActivable::OwnedNavModifierComponent' has a wrong offset!");
static_assert(offsetof(AVActivable, PortalComponent) == 0x000388, "Member 'AVActivable::PortalComponent' has a wrong offset!");

// Class Altar.VModularBodyPartBase
// 0x0060 (0x0340 - 0x02E0)
class AVModularBodyPartBase : public AVStatusEffectTarget
{
public:
	TSoftObjectPtr<class USkeletalMesh>           MaleMesh;                                          // 0x02E0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           FemaleMesh;                                        // 0x0308(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 RootSkeletalMeshComponent;                         // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaleBodySectionHidden;                             // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        FemaleBodySectionHidden;                           // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static TSubclassOf<class AVModularBodyPartBase> GetModularBodyPartClassFromSlot(EBipedModularBodySlot Slot);

	void OnAttachedInFirstPerson();
	void OnAttachedToPhenotype(class UVCharacterPhenotypeData* PhenotypeData, class UTESRace* CharacterRace, ECharacterSex CharacterSex);
	void OnAttachToLeaderComponent(class USkeletalMeshComponent* MasterComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModularBodyPartBase">();
	}
	static class AVModularBodyPartBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVModularBodyPartBase>();
	}
};
static_assert(alignof(AVModularBodyPartBase) == 0x000008, "Wrong alignment on AVModularBodyPartBase");
static_assert(sizeof(AVModularBodyPartBase) == 0x000340, "Wrong size on AVModularBodyPartBase");
static_assert(offsetof(AVModularBodyPartBase, MaleMesh) == 0x0002E0, "Member 'AVModularBodyPartBase::MaleMesh' has a wrong offset!");
static_assert(offsetof(AVModularBodyPartBase, FemaleMesh) == 0x000308, "Member 'AVModularBodyPartBase::FemaleMesh' has a wrong offset!");
static_assert(offsetof(AVModularBodyPartBase, RootSkeletalMeshComponent) == 0x000330, "Member 'AVModularBodyPartBase::RootSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AVModularBodyPartBase, MaleBodySectionHidden) == 0x000338, "Member 'AVModularBodyPartBase::MaleBodySectionHidden' has a wrong offset!");
static_assert(offsetof(AVModularBodyPartBase, FemaleBodySectionHidden) == 0x00033C, "Member 'AVModularBodyPartBase::FemaleBodySectionHidden' has a wrong offset!");

// Class Altar.VHelmetModularBodyPart
// 0x0040 (0x0380 - 0x0340)
class AVHelmetModularBodyPart : public AVModularBodyPartBase
{
public:
	bool                                          ShouldHideHair;                                    // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldHideHead;                                    // 0x0341(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_342[0x6];                                      // 0x0342(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UVHelmetHeadMorphDataAsset*             HeadMorphLimitsData;                               // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpscaleMultiplier;                                 // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DownscaleMultiplier;                               // 0x0368(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHelmetModularBodyPart">();
	}
	static class AVHelmetModularBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVHelmetModularBodyPart>();
	}
};
static_assert(alignof(AVHelmetModularBodyPart) == 0x000008, "Wrong alignment on AVHelmetModularBodyPart");
static_assert(sizeof(AVHelmetModularBodyPart) == 0x000380, "Wrong size on AVHelmetModularBodyPart");
static_assert(offsetof(AVHelmetModularBodyPart, ShouldHideHair) == 0x000340, "Member 'AVHelmetModularBodyPart::ShouldHideHair' has a wrong offset!");
static_assert(offsetof(AVHelmetModularBodyPart, ShouldHideHead) == 0x000341, "Member 'AVHelmetModularBodyPart::ShouldHideHead' has a wrong offset!");
static_assert(offsetof(AVHelmetModularBodyPart, HeadMorphLimitsData) == 0x000348, "Member 'AVHelmetModularBodyPart::HeadMorphLimitsData' has a wrong offset!");
static_assert(offsetof(AVHelmetModularBodyPart, UpscaleMultiplier) == 0x000350, "Member 'AVHelmetModularBodyPart::UpscaleMultiplier' has a wrong offset!");
static_assert(offsetof(AVHelmetModularBodyPart, DownscaleMultiplier) == 0x000368, "Member 'AVHelmetModularBodyPart::DownscaleMultiplier' has a wrong offset!");

// Class Altar.VAIProcedureExecution_Base
// 0x0018 (0x0040 - 0x0028)
class UVAIProcedureExecution_Base : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AVPairedPawnAIController*               AIController;                                      // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_Base">();
	}
	static class UVAIProcedureExecution_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_Base>();
	}
};
static_assert(alignof(UVAIProcedureExecution_Base) == 0x000008, "Wrong alignment on UVAIProcedureExecution_Base");
static_assert(sizeof(UVAIProcedureExecution_Base) == 0x000040, "Wrong size on UVAIProcedureExecution_Base");
static_assert(offsetof(UVAIProcedureExecution_Base, AIController) == 0x000030, "Member 'UVAIProcedureExecution_Base::AIController' has a wrong offset!");

// Class Altar.VAIProcedureExecution_FOLLOW
// 0x0030 (0x0070 - 0x0040)
class UVAIProcedureExecution_FOLLOW final : public UVAIProcedureExecution_Base
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     NavigationQueryFilterClass;                        // 0x0050(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetFollowDistance() const;
	class AActor* GetTargetActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_FOLLOW">();
	}
	static class UVAIProcedureExecution_FOLLOW* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_FOLLOW>();
	}
};
static_assert(alignof(UVAIProcedureExecution_FOLLOW) == 0x000008, "Wrong alignment on UVAIProcedureExecution_FOLLOW");
static_assert(sizeof(UVAIProcedureExecution_FOLLOW) == 0x000070, "Wrong size on UVAIProcedureExecution_FOLLOW");
static_assert(offsetof(UVAIProcedureExecution_FOLLOW, NavigationQueryFilterClass) == 0x000050, "Member 'UVAIProcedureExecution_FOLLOW::NavigationQueryFilterClass' has a wrong offset!");

// Class Altar.NiCollisionObject
// 0x0008 (0x0040 - 0x0038)
class UNiCollisionObject : public UNiObject
{
public:
	class UNiAvObject*                            Target;                                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiCollisionObject">();
	}
	static class UNiCollisionObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiCollisionObject>();
	}
};
static_assert(alignof(UNiCollisionObject) == 0x000008, "Wrong alignment on UNiCollisionObject");
static_assert(sizeof(UNiCollisionObject) == 0x000040, "Wrong size on UNiCollisionObject");
static_assert(offsetof(UNiCollisionObject, Target) == 0x000038, "Member 'UNiCollisionObject::Target' has a wrong offset!");

// Class Altar.bhkNiCollisionObject
// 0x0010 (0x0050 - 0x0040)
class UbhkNiCollisionObject : public UNiCollisionObject
{
public:
	EbhkCOFlags                                   Flags_0;                                           // 0x0040(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UbhkWorldObject*                        Body;                                              // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkNiCollisionObject">();
	}
	static class UbhkNiCollisionObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkNiCollisionObject>();
	}
};
static_assert(alignof(UbhkNiCollisionObject) == 0x000008, "Wrong alignment on UbhkNiCollisionObject");
static_assert(sizeof(UbhkNiCollisionObject) == 0x000050, "Wrong size on UbhkNiCollisionObject");
static_assert(offsetof(UbhkNiCollisionObject, Flags_0) == 0x000040, "Member 'UbhkNiCollisionObject::Flags_0' has a wrong offset!");
static_assert(offsetof(UbhkNiCollisionObject, Body) == 0x000048, "Member 'UbhkNiCollisionObject::Body' has a wrong offset!");

// Class Altar.bhkCollisionObject
// 0x0000 (0x0050 - 0x0050)
class UbhkCollisionObject : public UbhkNiCollisionObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkCollisionObject">();
	}
	static class UbhkCollisionObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkCollisionObject>();
	}
};
static_assert(alignof(UbhkCollisionObject) == 0x000008, "Wrong alignment on UbhkCollisionObject");
static_assert(sizeof(UbhkCollisionObject) == 0x000050, "Wrong size on UbhkCollisionObject");

// Class Altar.bhkBlendCollisionObject
// 0x0010 (0x0060 - 0x0050)
class UbhkBlendCollisionObject final : public UbhkCollisionObject
{
public:
	float                                         HeirGain;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelGain;                                           // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkBlendCollisionObject">();
	}
	static class UbhkBlendCollisionObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkBlendCollisionObject>();
	}
};
static_assert(alignof(UbhkBlendCollisionObject) == 0x000008, "Wrong alignment on UbhkBlendCollisionObject");
static_assert(sizeof(UbhkBlendCollisionObject) == 0x000060, "Wrong size on UbhkBlendCollisionObject");
static_assert(offsetof(UbhkBlendCollisionObject, HeirGain) == 0x000050, "Member 'UbhkBlendCollisionObject::HeirGain' has a wrong offset!");
static_assert(offsetof(UbhkBlendCollisionObject, VelGain) == 0x000054, "Member 'UbhkBlendCollisionObject::VelGain' has a wrong offset!");

// Class Altar.TESObject
// 0x0000 (0x00D8 - 0x00D8)
class UTESObject : public UTESForm
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObject">();
	}
	static class UTESObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObject>();
	}
};
static_assert(alignof(UTESObject) == 0x000008, "Wrong alignment on UTESObject");
static_assert(sizeof(UTESObject) == 0x0000D8, "Wrong size on UTESObject");

// Class Altar.TESBoundObject
// 0x00B8 (0x0190 - 0x00D8)
class UTESBoundObject : public UTESObject
{
public:
	TSoftClassPtr<class UClass>                   ImpactSystemVFXBlueprintClass;                     // 0x00D8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactSystemDuration;                              // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPhysicsAsset>           PhysicsAsset;                                      // 0x0108(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsingCustomPhysicsControlSettings;              // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVPhysicsControlSettings               PhysicsControlSettingsOverride;                    // 0x0134(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UTESModel*                              InheritedModel;                                    // 0x0150(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PropBlueprintClassOverride;                        // 0x0158(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVEnchantSaveData*                      EnchantSaveData;                                   // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnchantedObject;                                // 0x0188(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UClass* GetPropBlueprintClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESBoundObject">();
	}
	static class UTESBoundObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESBoundObject>();
	}
};
static_assert(alignof(UTESBoundObject) == 0x000008, "Wrong alignment on UTESBoundObject");
static_assert(sizeof(UTESBoundObject) == 0x000190, "Wrong size on UTESBoundObject");
static_assert(offsetof(UTESBoundObject, ImpactSystemVFXBlueprintClass) == 0x0000D8, "Member 'UTESBoundObject::ImpactSystemVFXBlueprintClass' has a wrong offset!");
static_assert(offsetof(UTESBoundObject, ImpactSystemDuration) == 0x000100, "Member 'UTESBoundObject::ImpactSystemDuration' has a wrong offset!");
static_assert(offsetof(UTESBoundObject, Mass) == 0x000104, "Member 'UTESBoundObject::Mass' has a wrong offset!");
static_assert(offsetof(UTESBoundObject, PhysicsAsset) == 0x000108, "Member 'UTESBoundObject::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(UTESBoundObject, bIsUsingCustomPhysicsControlSettings) == 0x000130, "Member 'UTESBoundObject::bIsUsingCustomPhysicsControlSettings' has a wrong offset!");
static_assert(offsetof(UTESBoundObject, PhysicsControlSettingsOverride) == 0x000134, "Member 'UTESBoundObject::PhysicsControlSettingsOverride' has a wrong offset!");
static_assert(offsetof(UTESBoundObject, InheritedModel) == 0x000150, "Member 'UTESBoundObject::InheritedModel' has a wrong offset!");
static_assert(offsetof(UTESBoundObject, PropBlueprintClassOverride) == 0x000158, "Member 'UTESBoundObject::PropBlueprintClassOverride' has a wrong offset!");
static_assert(offsetof(UTESBoundObject, EnchantSaveData) == 0x000180, "Member 'UTESBoundObject::EnchantSaveData' has a wrong offset!");
static_assert(offsetof(UTESBoundObject, bIsEnchantedObject) == 0x000188, "Member 'UTESBoundObject::bIsEnchantedObject' has a wrong offset!");

// Class Altar.TESObjectWEAP
// 0x00C0 (0x0250 - 0x0190)
class UTESObjectWEAP final : public UTESBoundObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TextureIcon;                                       // 0x01A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOblivionWeaponType                           Type;                                              // 0x01C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01D0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStreamableRenderAsset>  NewScabbardMesh;                                   // 0x01F8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStreamableRenderAsset>  NewWeaponOnlyMesh;                                 // 0x0220(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESIcon*                               InheritedIcon;                                     // 0x0248(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectWEAP">();
	}
	static class UTESObjectWEAP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectWEAP>();
	}
};
static_assert(alignof(UTESObjectWEAP) == 0x000008, "Wrong alignment on UTESObjectWEAP");
static_assert(sizeof(UTESObjectWEAP) == 0x000250, "Wrong size on UTESObjectWEAP");
static_assert(offsetof(UTESObjectWEAP, FullName) == 0x000190, "Member 'UTESObjectWEAP::FullName' has a wrong offset!");
static_assert(offsetof(UTESObjectWEAP, TextureIcon) == 0x0001A0, "Member 'UTESObjectWEAP::TextureIcon' has a wrong offset!");
static_assert(offsetof(UTESObjectWEAP, Type) == 0x0001C8, "Member 'UTESObjectWEAP::Type' has a wrong offset!");
static_assert(offsetof(UTESObjectWEAP, Speed) == 0x0001CC, "Member 'UTESObjectWEAP::Speed' has a wrong offset!");
static_assert(offsetof(UTESObjectWEAP, NewMesh) == 0x0001D0, "Member 'UTESObjectWEAP::NewMesh' has a wrong offset!");
static_assert(offsetof(UTESObjectWEAP, NewScabbardMesh) == 0x0001F8, "Member 'UTESObjectWEAP::NewScabbardMesh' has a wrong offset!");
static_assert(offsetof(UTESObjectWEAP, NewWeaponOnlyMesh) == 0x000220, "Member 'UTESObjectWEAP::NewWeaponOnlyMesh' has a wrong offset!");
static_assert(offsetof(UTESObjectWEAP, InheritedIcon) == 0x000248, "Member 'UTESObjectWEAP::InheritedIcon' has a wrong offset!");

// Class Altar.VEquippable
// 0x0020 (0x0310 - 0x02F0)
class AVEquippable : public AVActor
{
public:
	uint8                                         Pad_2F0[0x18];                                     // 0x02F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEquipped;                                       // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEquipped() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEquippable">();
	}
	static class AVEquippable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVEquippable>();
	}
};
static_assert(alignof(AVEquippable) == 0x000008, "Wrong alignment on AVEquippable");
static_assert(sizeof(AVEquippable) == 0x000310, "Wrong size on AVEquippable");
static_assert(offsetof(AVEquippable, bIsEquipped) == 0x000308, "Member 'AVEquippable::bIsEquipped' has a wrong offset!");

// Class Altar.NiTimeController
// 0x0030 (0x0068 - 0x0038)
class UNiTimeController : public UNiObject
{
public:
	class UNiTimeController*                      NextController;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimeControllerFlags                   Flags_0;                                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase;                                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTime;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiObjectNet*                           Target;                                            // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTimeController">();
	}
	static class UNiTimeController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTimeController>();
	}
};
static_assert(alignof(UNiTimeController) == 0x000008, "Wrong alignment on UNiTimeController");
static_assert(sizeof(UNiTimeController) == 0x000068, "Wrong size on UNiTimeController");
static_assert(offsetof(UNiTimeController, NextController) == 0x000038, "Member 'UNiTimeController::NextController' has a wrong offset!");
static_assert(offsetof(UNiTimeController, Flags_0) == 0x000040, "Member 'UNiTimeController::Flags_0' has a wrong offset!");
static_assert(offsetof(UNiTimeController, Frequency) == 0x000044, "Member 'UNiTimeController::Frequency' has a wrong offset!");
static_assert(offsetof(UNiTimeController, Phase) == 0x000048, "Member 'UNiTimeController::Phase' has a wrong offset!");
static_assert(offsetof(UNiTimeController, StartTime) == 0x00004C, "Member 'UNiTimeController::StartTime' has a wrong offset!");
static_assert(offsetof(UNiTimeController, StopTime) == 0x000050, "Member 'UNiTimeController::StopTime' has a wrong offset!");
static_assert(offsetof(UNiTimeController, Target) == 0x000058, "Member 'UNiTimeController::Target' has a wrong offset!");

// Class Altar.VPhysicsHorseAnimInstance
// 0x0190 (0x0530 - 0x03A0)
class UVPhysicsHorseAnimInstance final : public UVLayerCharacterAnimInstance
{
public:
	class AVPairedCreature*                       Horse;                                             // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVHorsePhysicsData                     LayerData;                                         // 0x03A8(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TransformBoneAlpha;                                // 0x0520(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReinsTransfromBoneAlpha;                           // 0x0524(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_528[0x8];                                      // 0x0528(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPhysicsHorseAnimInstance">();
	}
	static class UVPhysicsHorseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPhysicsHorseAnimInstance>();
	}
};
static_assert(alignof(UVPhysicsHorseAnimInstance) == 0x000010, "Wrong alignment on UVPhysicsHorseAnimInstance");
static_assert(sizeof(UVPhysicsHorseAnimInstance) == 0x000530, "Wrong size on UVPhysicsHorseAnimInstance");
static_assert(offsetof(UVPhysicsHorseAnimInstance, Horse) == 0x0003A0, "Member 'UVPhysicsHorseAnimInstance::Horse' has a wrong offset!");
static_assert(offsetof(UVPhysicsHorseAnimInstance, LayerData) == 0x0003A8, "Member 'UVPhysicsHorseAnimInstance::LayerData' has a wrong offset!");
static_assert(offsetof(UVPhysicsHorseAnimInstance, TransformBoneAlpha) == 0x000520, "Member 'UVPhysicsHorseAnimInstance::TransformBoneAlpha' has a wrong offset!");
static_assert(offsetof(UVPhysicsHorseAnimInstance, ReinsTransfromBoneAlpha) == 0x000524, "Member 'UVPhysicsHorseAnimInstance::ReinsTransfromBoneAlpha' has a wrong offset!");

// Class Altar.VAmmunition
// 0x0168 (0x0478 - 0x0310)
class AVAmmunition : public AVEquippable
{
public:
	uint8                                         Pad_310[0x28];                                     // 0x0310(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVHitBoxComponent*                      HitBoxComponent;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OblivionArrowAge;                                  // 0x0370(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x104];                                    // 0x0374(0x0104)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginPlay();
	void Collide(const struct FHitResult& HitResult, const struct FVProjectilePenetrationSettings& PenetrationSettings, const class AActor* TargetActor, const struct FVector& ImpactVelocity);
	void Despawn();
	void OnArrowLoadedInLevel();
	void OnBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void OnStaticMeshBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnStaticMeshEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SendCollide(float ArrowAgeMaxOnceCollided, class AActor* CollidedActor);
	void ShootAmunition(class AVPairedPawn* Shooter, const struct FVector& Direction, float Speed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAmmunition">();
	}
	static class AVAmmunition* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAmmunition>();
	}
};
static_assert(alignof(AVAmmunition) == 0x000008, "Wrong alignment on AVAmmunition");
static_assert(sizeof(AVAmmunition) == 0x000478, "Wrong size on AVAmmunition");
static_assert(offsetof(AVAmmunition, TESRefComponent) == 0x000338, "Member 'AVAmmunition::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVAmmunition, TransformPairingComponent) == 0x000340, "Member 'AVAmmunition::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVAmmunition, StaticMeshComponent) == 0x000348, "Member 'AVAmmunition::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVAmmunition, HitBoxComponent) == 0x000350, "Member 'AVAmmunition::HitBoxComponent' has a wrong offset!");
static_assert(offsetof(AVAmmunition, ProjectileMovementComponent) == 0x000358, "Member 'AVAmmunition::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(AVAmmunition, PhysicsControllerComponent) == 0x000360, "Member 'AVAmmunition::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVAmmunition, AkAudioComponent) == 0x000368, "Member 'AVAmmunition::AkAudioComponent' has a wrong offset!");
static_assert(offsetof(AVAmmunition, OblivionArrowAge) == 0x000370, "Member 'AVAmmunition::OblivionArrowAge' has a wrong offset!");

// Class Altar.VAltarBlockHitTriggerVibration
// 0x0000 (0x00C0 - 0x00C0)
class UVAltarBlockHitTriggerVibration final : public UInputDeviceTriggerVibrationProperty
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarBlockHitTriggerVibration">();
	}
	static class UVAltarBlockHitTriggerVibration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarBlockHitTriggerVibration>();
	}
};
static_assert(alignof(UVAltarBlockHitTriggerVibration) == 0x000008, "Wrong alignment on UVAltarBlockHitTriggerVibration");
static_assert(sizeof(UVAltarBlockHitTriggerVibration) == 0x0000C0, "Wrong size on UVAltarBlockHitTriggerVibration");

// Class Altar.VApparatus
// 0x0068 (0x0358 - 0x02F0)
class AVApparatus : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VApparatus">();
	}
	static class AVApparatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVApparatus>();
	}
};
static_assert(alignof(AVApparatus) == 0x000008, "Wrong alignment on AVApparatus");
static_assert(sizeof(AVApparatus) == 0x000358, "Wrong size on AVApparatus");
static_assert(offsetof(AVApparatus, TESRefComponent) == 0x000330, "Member 'AVApparatus::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVApparatus, TransformPairingComponent) == 0x000338, "Member 'AVApparatus::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVApparatus, StaticMeshComponent) == 0x000340, "Member 'AVApparatus::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVApparatus, PhysicsControllerComponent) == 0x000348, "Member 'AVApparatus::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVApparatus, AkAudioComponent) == 0x000350, "Member 'AVApparatus::AkAudioComponent' has a wrong offset!");

// Class Altar.VActorPairingComponent
// 0x0018 (0x00B8 - 0x00A0)
class UVActorPairingComponent : public UActorComponent
{
public:
	bool                                          bDisableTickOptimization;                          // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldReenableTickWhenUnfrozen;                   // 0x00A1(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                ObjectRefComponent;                                // 0x00A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFeaturePaired;                                  // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeFeaturePairing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VActorPairingComponent">();
	}
	static class UVActorPairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVActorPairingComponent>();
	}
};
static_assert(alignof(UVActorPairingComponent) == 0x000008, "Wrong alignment on UVActorPairingComponent");
static_assert(sizeof(UVActorPairingComponent) == 0x0000B8, "Wrong size on UVActorPairingComponent");
static_assert(offsetof(UVActorPairingComponent, bDisableTickOptimization) == 0x0000A0, "Member 'UVActorPairingComponent::bDisableTickOptimization' has a wrong offset!");
static_assert(offsetof(UVActorPairingComponent, bShouldReenableTickWhenUnfrozen) == 0x0000A1, "Member 'UVActorPairingComponent::bShouldReenableTickWhenUnfrozen' has a wrong offset!");
static_assert(offsetof(UVActorPairingComponent, ObjectRefComponent) == 0x0000A8, "Member 'UVActorPairingComponent::ObjectRefComponent' has a wrong offset!");
static_assert(offsetof(UVActorPairingComponent, bIsFeaturePaired) == 0x0000B0, "Member 'UVActorPairingComponent::bIsFeaturePaired' has a wrong offset!");

// Class Altar.VPawnSoundPairingComponent
// 0x00A8 (0x0160 - 0x00B8)
class UVPawnSoundPairingComponent final : public UVActorPairingComponent
{
public:
	uint8                                         Pad_B8[0x78];                                      // 0x00B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAltarAkComponent*                     DialogueComponent;                                 // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVHumanoidHeadComponent*                HeadComponent;                                     // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          TorchEquipEvent;                                   // 0x0140(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          TorchHoldEvent;                                    // 0x0148(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          TorchUnequipEvent;                                 // 0x0150(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UnloadNonPlayingDialogues();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPawnSoundPairingComponent">();
	}
	static class UVPawnSoundPairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPawnSoundPairingComponent>();
	}
};
static_assert(alignof(UVPawnSoundPairingComponent) == 0x000008, "Wrong alignment on UVPawnSoundPairingComponent");
static_assert(sizeof(UVPawnSoundPairingComponent) == 0x000160, "Wrong size on UVPawnSoundPairingComponent");
static_assert(offsetof(UVPawnSoundPairingComponent, DialogueComponent) == 0x000130, "Member 'UVPawnSoundPairingComponent::DialogueComponent' has a wrong offset!");
static_assert(offsetof(UVPawnSoundPairingComponent, HeadComponent) == 0x000138, "Member 'UVPawnSoundPairingComponent::HeadComponent' has a wrong offset!");
static_assert(offsetof(UVPawnSoundPairingComponent, TorchEquipEvent) == 0x000140, "Member 'UVPawnSoundPairingComponent::TorchEquipEvent' has a wrong offset!");
static_assert(offsetof(UVPawnSoundPairingComponent, TorchHoldEvent) == 0x000148, "Member 'UVPawnSoundPairingComponent::TorchHoldEvent' has a wrong offset!");
static_assert(offsetof(UVPawnSoundPairingComponent, TorchUnequipEvent) == 0x000150, "Member 'UVPawnSoundPairingComponent::TorchUnequipEvent' has a wrong offset!");

// Class Altar.VArmor
// 0x0060 (0x0370 - 0x0310)
class AVArmor : public AVEquippable
{
public:
	uint8                                         Pad_310[0x28];                                     // 0x0310(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReferenceCharacterSexChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VArmor">();
	}
	static class AVArmor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVArmor>();
	}
};
static_assert(alignof(AVArmor) == 0x000008, "Wrong alignment on AVArmor");
static_assert(sizeof(AVArmor) == 0x000370, "Wrong size on AVArmor");
static_assert(offsetof(AVArmor, TESRefComponent) == 0x000338, "Member 'AVArmor::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVArmor, TransformPairingComponent) == 0x000340, "Member 'AVArmor::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVArmor, StaticMeshComponent) == 0x000348, "Member 'AVArmor::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVArmor, PhysicsControllerComponent) == 0x000350, "Member 'AVArmor::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVArmor, AkAudioComponent) == 0x000358, "Member 'AVArmor::AkAudioComponent' has a wrong offset!");

// Class Altar.AbstractAdditionalGeometryData
// 0x0000 (0x0038 - 0x0038)
class UAbstractAdditionalGeometryData : public UNiObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbstractAdditionalGeometryData">();
	}
	static class UAbstractAdditionalGeometryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbstractAdditionalGeometryData>();
	}
};
static_assert(alignof(UAbstractAdditionalGeometryData) == 0x000008, "Wrong alignment on UAbstractAdditionalGeometryData");
static_assert(sizeof(UAbstractAdditionalGeometryData) == 0x000038, "Wrong size on UAbstractAdditionalGeometryData");

// Class Altar.VBook
// 0x0068 (0x0358 - 0x02F0)
class AVBook : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBook">();
	}
	static class AVBook* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVBook>();
	}
};
static_assert(alignof(AVBook) == 0x000008, "Wrong alignment on AVBook");
static_assert(sizeof(AVBook) == 0x000358, "Wrong size on AVBook");
static_assert(offsetof(AVBook, TESRefComponent) == 0x000330, "Member 'AVBook::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVBook, TransformPairingComponent) == 0x000338, "Member 'AVBook::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVBook, StaticMeshComponent) == 0x000340, "Member 'AVBook::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVBook, PhysicsControllerComponent) == 0x000348, "Member 'AVBook::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVBook, AkAudioComponent) == 0x000350, "Member 'AVBook::AkAudioComponent' has a wrong offset!");

// Class Altar.VAICombatMovement_DIRECTION
// 0x0020 (0x0060 - 0x0040)
class UVAICombatMovement_DIRECTION final : public UVAIProcedureExecution_Base
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USteeringBehavior_Direction*            DirectionSteeringBehavior;                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAICombatMovement_DIRECTION">();
	}
	static class UVAICombatMovement_DIRECTION* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAICombatMovement_DIRECTION>();
	}
};
static_assert(alignof(UVAICombatMovement_DIRECTION) == 0x000008, "Wrong alignment on UVAICombatMovement_DIRECTION");
static_assert(sizeof(UVAICombatMovement_DIRECTION) == 0x000060, "Wrong size on UVAICombatMovement_DIRECTION");
static_assert(offsetof(UVAICombatMovement_DIRECTION, DirectionSteeringBehavior) == 0x000058, "Member 'UVAICombatMovement_DIRECTION::DirectionSteeringBehavior' has a wrong offset!");

// Class Altar.VCloth
// 0x0078 (0x0368 - 0x02F0)
class AVCloth : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0x10];                                     // 0x0358(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReferenceCharacterSexChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCloth">();
	}
	static class AVCloth* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVCloth>();
	}
};
static_assert(alignof(AVCloth) == 0x000008, "Wrong alignment on AVCloth");
static_assert(sizeof(AVCloth) == 0x000368, "Wrong size on AVCloth");
static_assert(offsetof(AVCloth, TESRefComponent) == 0x000330, "Member 'AVCloth::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVCloth, TransformPairingComponent) == 0x000338, "Member 'AVCloth::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVCloth, StaticMeshComponent) == 0x000340, "Member 'AVCloth::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVCloth, PhysicsControllerComponent) == 0x000348, "Member 'AVCloth::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVCloth, AkAudioComponent) == 0x000350, "Member 'AVCloth::AkAudioComponent' has a wrong offset!");

// Class Altar.NiPSysModifier
// 0x0028 (0x0060 - 0x0038)
class UNiPSysModifier : public UNiObject
{
public:
	struct FNifString                             Name_0;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	ENiPSysModifierOrder                          Order;                                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiParticleSystem*                      Target;                                            // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Active;                                            // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysModifier">();
	}
	static class UNiPSysModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysModifier>();
	}
};
static_assert(alignof(UNiPSysModifier) == 0x000008, "Wrong alignment on UNiPSysModifier");
static_assert(sizeof(UNiPSysModifier) == 0x000060, "Wrong size on UNiPSysModifier");
static_assert(offsetof(UNiPSysModifier, Name_0) == 0x000038, "Member 'UNiPSysModifier::Name_0' has a wrong offset!");
static_assert(offsetof(UNiPSysModifier, Order) == 0x000048, "Member 'UNiPSysModifier::Order' has a wrong offset!");
static_assert(offsetof(UNiPSysModifier, Target) == 0x000050, "Member 'UNiPSysModifier::Target' has a wrong offset!");
static_assert(offsetof(UNiPSysModifier, Active) == 0x000058, "Member 'UNiPSysModifier::Active' has a wrong offset!");

// Class Altar.NiPSysGrowFadeModifier
// 0x0018 (0x0078 - 0x0060)
class UNiPSysGrowFadeModifier final : public UNiPSysModifier
{
public:
	float                                         GrowTime;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrowGeneration;                                    // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FadeGeneration;                                    // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseScale;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysGrowFadeModifier">();
	}
	static class UNiPSysGrowFadeModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysGrowFadeModifier>();
	}
};
static_assert(alignof(UNiPSysGrowFadeModifier) == 0x000008, "Wrong alignment on UNiPSysGrowFadeModifier");
static_assert(sizeof(UNiPSysGrowFadeModifier) == 0x000078, "Wrong size on UNiPSysGrowFadeModifier");
static_assert(offsetof(UNiPSysGrowFadeModifier, GrowTime) == 0x000060, "Member 'UNiPSysGrowFadeModifier::GrowTime' has a wrong offset!");
static_assert(offsetof(UNiPSysGrowFadeModifier, GrowGeneration) == 0x000064, "Member 'UNiPSysGrowFadeModifier::GrowGeneration' has a wrong offset!");
static_assert(offsetof(UNiPSysGrowFadeModifier, FadeTime) == 0x000068, "Member 'UNiPSysGrowFadeModifier::FadeTime' has a wrong offset!");
static_assert(offsetof(UNiPSysGrowFadeModifier, FadeGeneration) == 0x00006C, "Member 'UNiPSysGrowFadeModifier::FadeGeneration' has a wrong offset!");
static_assert(offsetof(UNiPSysGrowFadeModifier, BaseScale) == 0x000070, "Member 'UNiPSysGrowFadeModifier::BaseScale' has a wrong offset!");

// Class Altar.VDockingPairingComponent
// 0x00F0 (0x01A8 - 0x00B8)
class UVDockingPairingComponent final : public UVActorPairingComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisplayDockingDebug;                              // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x2];                                      // 0x0109(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDockToSleep;                                      // 0x010B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MarkerPosition;                                    // 0x0110(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MarkerRotation;                                    // 0x0128(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DockingPosition;                                   // 0x0140(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DockingRotation;                                   // 0x0158(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UTESIdleForm*                           DockingSpecialIdle;                                // 0x0170(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedMarkerNumber;                                  // 0x0178(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedMarkerIndex;                                   // 0x017C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVEntryPointData                       HorseEntryPointData;                               // 0x0180(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESitSleepState GetSitSleepState() const;
	class AActor* GetUsedDockActor() const;
	bool HasPendingDockingTransition() const;
	bool IsDocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDockingPairingComponent">();
	}
	static class UVDockingPairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDockingPairingComponent>();
	}
};
static_assert(alignof(UVDockingPairingComponent) == 0x000008, "Wrong alignment on UVDockingPairingComponent");
static_assert(sizeof(UVDockingPairingComponent) == 0x0001A8, "Wrong size on UVDockingPairingComponent");
static_assert(offsetof(UVDockingPairingComponent, bDisplayDockingDebug) == 0x000108, "Member 'UVDockingPairingComponent::bDisplayDockingDebug' has a wrong offset!");
static_assert(offsetof(UVDockingPairingComponent, bDockToSleep) == 0x00010B, "Member 'UVDockingPairingComponent::bDockToSleep' has a wrong offset!");
static_assert(offsetof(UVDockingPairingComponent, MarkerPosition) == 0x000110, "Member 'UVDockingPairingComponent::MarkerPosition' has a wrong offset!");
static_assert(offsetof(UVDockingPairingComponent, MarkerRotation) == 0x000128, "Member 'UVDockingPairingComponent::MarkerRotation' has a wrong offset!");
static_assert(offsetof(UVDockingPairingComponent, DockingPosition) == 0x000140, "Member 'UVDockingPairingComponent::DockingPosition' has a wrong offset!");
static_assert(offsetof(UVDockingPairingComponent, DockingRotation) == 0x000158, "Member 'UVDockingPairingComponent::DockingRotation' has a wrong offset!");
static_assert(offsetof(UVDockingPairingComponent, DockingSpecialIdle) == 0x000170, "Member 'UVDockingPairingComponent::DockingSpecialIdle' has a wrong offset!");
static_assert(offsetof(UVDockingPairingComponent, UsedMarkerNumber) == 0x000178, "Member 'UVDockingPairingComponent::UsedMarkerNumber' has a wrong offset!");
static_assert(offsetof(UVDockingPairingComponent, UsedMarkerIndex) == 0x00017C, "Member 'UVDockingPairingComponent::UsedMarkerIndex' has a wrong offset!");
static_assert(offsetof(UVDockingPairingComponent, HorseEntryPointData) == 0x000180, "Member 'UVDockingPairingComponent::HorseEntryPointData' has a wrong offset!");

// Class Altar.VContainer
// 0x0088 (0x0378 - 0x02F0)
class AVContainer : public AVActor
{
public:
	uint8                                         Pad_2F0[0x48];                                     // 0x02F0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          OpenSoundEvent;                                    // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          CloseSoundEvent;                                   // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x2];                                      // 0x0370(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAnimated;                                       // 0x0372(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_373[0x5];                                      // 0x0373(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnContainerOpenChanged();
	void OnContainerUnlockedChanged();

	bool IsContainerOpen() const;
	bool IsContainerUnlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VContainer">();
	}
	static class AVContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVContainer>();
	}
};
static_assert(alignof(AVContainer) == 0x000008, "Wrong alignment on AVContainer");
static_assert(sizeof(AVContainer) == 0x000378, "Wrong size on AVContainer");
static_assert(offsetof(AVContainer, TESRefComponent) == 0x000338, "Member 'AVContainer::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVContainer, TransformPairingComponent) == 0x000340, "Member 'AVContainer::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVContainer, MeshComponent) == 0x000348, "Member 'AVContainer::MeshComponent' has a wrong offset!");
static_assert(offsetof(AVContainer, PhysicsControllerComponent) == 0x000350, "Member 'AVContainer::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVContainer, AkAudioComponent) == 0x000358, "Member 'AVContainer::AkAudioComponent' has a wrong offset!");
static_assert(offsetof(AVContainer, OpenSoundEvent) == 0x000360, "Member 'AVContainer::OpenSoundEvent' has a wrong offset!");
static_assert(offsetof(AVContainer, CloseSoundEvent) == 0x000368, "Member 'AVContainer::CloseSoundEvent' has a wrong offset!");
static_assert(offsetof(AVContainer, bIsAnimated) == 0x000372, "Member 'AVContainer::bIsAnimated' has a wrong offset!");

// Class Altar.TESBipedModelForm
// 0x0060 (0x0088 - 0x0028)
class UTESBipedModelForm final : public UTESBaseFormComponent
{
public:
	int32                                         BipedObjectSlots;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Flags_0;                                           // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVModularBodyPartBase>      BodyPartActorClass;                                // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UStreamableRenderAsset>> NewWorldModels;                             // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture2D>>      NewInventoryIcons;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UTESModel*>                      BipedModel;                                        // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UTESModel*>                      WorldModel;                                        // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UTESIcon*>                       InventoryIcon;                                     // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESBipedModelForm">();
	}
	static class UTESBipedModelForm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESBipedModelForm>();
	}
};
static_assert(alignof(UTESBipedModelForm) == 0x000008, "Wrong alignment on UTESBipedModelForm");
static_assert(sizeof(UTESBipedModelForm) == 0x000088, "Wrong size on UTESBipedModelForm");
static_assert(offsetof(UTESBipedModelForm, BipedObjectSlots) == 0x000028, "Member 'UTESBipedModelForm::BipedObjectSlots' has a wrong offset!");
static_assert(offsetof(UTESBipedModelForm, Flags_0) == 0x00002C, "Member 'UTESBipedModelForm::Flags_0' has a wrong offset!");
static_assert(offsetof(UTESBipedModelForm, BodyPartActorClass) == 0x000030, "Member 'UTESBipedModelForm::BodyPartActorClass' has a wrong offset!");
static_assert(offsetof(UTESBipedModelForm, NewWorldModels) == 0x000038, "Member 'UTESBipedModelForm::NewWorldModels' has a wrong offset!");
static_assert(offsetof(UTESBipedModelForm, NewInventoryIcons) == 0x000048, "Member 'UTESBipedModelForm::NewInventoryIcons' has a wrong offset!");
static_assert(offsetof(UTESBipedModelForm, BipedModel) == 0x000058, "Member 'UTESBipedModelForm::BipedModel' has a wrong offset!");
static_assert(offsetof(UTESBipedModelForm, WorldModel) == 0x000068, "Member 'UTESBipedModelForm::WorldModel' has a wrong offset!");
static_assert(offsetof(UTESBipedModelForm, InventoryIcon) == 0x000078, "Member 'UTESBipedModelForm::InventoryIcon' has a wrong offset!");

// Class Altar.VDebugCell
// 0x0000 (0x09E0 - 0x09E0)
class AVDebugCell final : public APostProcessVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDebugCell">();
	}
	static class AVDebugCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVDebugCell>();
	}
};
static_assert(alignof(AVDebugCell) == 0x000010, "Wrong alignment on AVDebugCell");
static_assert(sizeof(AVDebugCell) == 0x0009E0, "Wrong size on AVDebugCell");

// Class Altar.VLevelChangeData
// 0x0200 (0x0228 - 0x0028)
class UVLevelChangeData final : public UObject
{
public:
	TMulticastInlineDelegate<void()>              OnFadeToBlackBeginEvent;                           // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EVFadeTransitionType InType)> OnFadeToBlackEndEvent;               // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFadeToGameBeginEvent;                            // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFadeToGameEndEvent;                              // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EVFadeTransitionType InType, float InDuration)> OnFadeOutExtraDurationBegin; // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          PersistentTravelActors;                            // 0x0090(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPostSeamlessTravelEvent;                         // 0x00A0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bIsFastTravelling;                                 // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSeamlessTravelling;                             // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UVAssociatedAltarCellToPrePlacedActors*> AltarCellToPrePlacedActors;   // 0x00B8(0x0050)(NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVLevelStreaming>        CurrentSubLevel;                                   // 0x0108(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentSubLevelLoaded;                          // 0x0130(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 PersistentLevel;                                   // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0xE8];                                     // 0x0140(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVLevelChangeData* GetLevelChangeData(const class UWorld* InWorld);

	void AfterFadeToBlackFromMoveTo();
	void GoToMainMenuAfterFadeToBlack();
	void OnEndOfFadeToBlackInPlace();
	void OnFadeToBlackAnimationOverAttach();
	void OnFadeToBlackAnimationOverSeamless();
	void OnFadeToBlackBeginEventReceived();
	void OnFadeToBlackEndEventReceived(EVFadeTransitionType InType);
	void OnFadeToBlackInPlace();
	void OnFadeToBlackOverBeforeFastTravel();
	void OnFadeToBlackThroughDoorOver();
	void OnFadeToGameAnimationOver();
	void OnFadeToGameBeginEventReceived();
	void OnFadeToGameEndEventReceived();
	void QuickLoadSaveAfterFadeToBlack();
	void ReloadSaveAfterFadeToBlack();
	void UpdateWeatherAudioTexture();

	void CompleteShadowCacheRefresh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLevelChangeData">();
	}
	static class UVLevelChangeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLevelChangeData>();
	}
};
static_assert(alignof(UVLevelChangeData) == 0x000008, "Wrong alignment on UVLevelChangeData");
static_assert(sizeof(UVLevelChangeData) == 0x000228, "Wrong size on UVLevelChangeData");
static_assert(offsetof(UVLevelChangeData, OnFadeToBlackBeginEvent) == 0x000028, "Member 'UVLevelChangeData::OnFadeToBlackBeginEvent' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, OnFadeToBlackEndEvent) == 0x000038, "Member 'UVLevelChangeData::OnFadeToBlackEndEvent' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, OnFadeToGameBeginEvent) == 0x000048, "Member 'UVLevelChangeData::OnFadeToGameBeginEvent' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, OnFadeToGameEndEvent) == 0x000058, "Member 'UVLevelChangeData::OnFadeToGameEndEvent' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, OnFadeOutExtraDurationBegin) == 0x000068, "Member 'UVLevelChangeData::OnFadeOutExtraDurationBegin' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, PersistentTravelActors) == 0x000090, "Member 'UVLevelChangeData::PersistentTravelActors' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, OnPostSeamlessTravelEvent) == 0x0000A0, "Member 'UVLevelChangeData::OnPostSeamlessTravelEvent' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, bIsFastTravelling) == 0x0000B0, "Member 'UVLevelChangeData::bIsFastTravelling' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, bIsSeamlessTravelling) == 0x0000B1, "Member 'UVLevelChangeData::bIsSeamlessTravelling' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, AltarCellToPrePlacedActors) == 0x0000B8, "Member 'UVLevelChangeData::AltarCellToPrePlacedActors' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, CurrentSubLevel) == 0x000108, "Member 'UVLevelChangeData::CurrentSubLevel' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, bIsCurrentSubLevelLoaded) == 0x000130, "Member 'UVLevelChangeData::bIsCurrentSubLevelLoaded' has a wrong offset!");
static_assert(offsetof(UVLevelChangeData, PersistentLevel) == 0x000138, "Member 'UVLevelChangeData::PersistentLevel' has a wrong offset!");

// Class Altar.VDoor
// 0x0110 (0x0400 - 0x02F0)
class AVDoor : public AVActor
{
public:
	uint8                                         Pad_2F0[0x50];                                     // 0x02F0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAnimationObjectPairingComponent*      AnimationObjectPairingComponent;                   // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVNavModifierComponent*                 NavModifierComponent;                              // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          PortalBoxComponent;                                // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkPortalComponent*               AkPortalComponent;                                 // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          LoadingBoxComponent;                               // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          OpenSoundEvent;                                    // 0x0390(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          CloseSoundEvent;                                   // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBeforeTeleportation;                          // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavlinkLength;                                     // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOpened;                                         // 0x03A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x23];                                     // 0x03A9(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsDestroyed;                                      // 0x03CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRefreshNavigationDataInBeginPlay;                 // 0x03CD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CE[0x2];                                      // 0x03CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OpeningDirection;                                  // 0x03D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x14];                                     // 0x03E8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedOcclusionInterpolationDuration;               // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlapPreLoadBox(class UPrimitiveComponent* SourceComp, class AActor* TargetActor, class UPrimitiveComponent* TargetComp, int32 UnusedOtherBox, bool UnusedSweep, const struct FHitResult& EmptyHitResult);
	void OnClose();
	void OnEndOverlapPreLoadBox(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnOpen();
	void OnPlayerTeleportationRequested();
	void SetAnimationTickEnable_Delegate(bool bEnable);
	void SetClosed();
	void SetDestroyed();
	void SetOpened();

	bool IsAnimated() const;
	bool IsDestroyed() const;
	bool IsDoorToExitSewers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDoor">();
	}
	static class AVDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVDoor>();
	}
};
static_assert(alignof(AVDoor) == 0x000008, "Wrong alignment on AVDoor");
static_assert(sizeof(AVDoor) == 0x000400, "Wrong size on AVDoor");
static_assert(offsetof(AVDoor, TESRefComponent) == 0x000340, "Member 'AVDoor::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVDoor, TransformPairingComponent) == 0x000348, "Member 'AVDoor::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVDoor, AnimationObjectPairingComponent) == 0x000350, "Member 'AVDoor::AnimationObjectPairingComponent' has a wrong offset!");
static_assert(offsetof(AVDoor, SkeletalMeshComponent) == 0x000358, "Member 'AVDoor::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AVDoor, PhysicsControllerComponent) == 0x000360, "Member 'AVDoor::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVDoor, NavModifierComponent) == 0x000368, "Member 'AVDoor::NavModifierComponent' has a wrong offset!");
static_assert(offsetof(AVDoor, PortalBoxComponent) == 0x000370, "Member 'AVDoor::PortalBoxComponent' has a wrong offset!");
static_assert(offsetof(AVDoor, AkAudioComponent) == 0x000378, "Member 'AVDoor::AkAudioComponent' has a wrong offset!");
static_assert(offsetof(AVDoor, AkPortalComponent) == 0x000380, "Member 'AVDoor::AkPortalComponent' has a wrong offset!");
static_assert(offsetof(AVDoor, LoadingBoxComponent) == 0x000388, "Member 'AVDoor::LoadingBoxComponent' has a wrong offset!");
static_assert(offsetof(AVDoor, OpenSoundEvent) == 0x000390, "Member 'AVDoor::OpenSoundEvent' has a wrong offset!");
static_assert(offsetof(AVDoor, CloseSoundEvent) == 0x000398, "Member 'AVDoor::CloseSoundEvent' has a wrong offset!");
static_assert(offsetof(AVDoor, DelayBeforeTeleportation) == 0x0003A0, "Member 'AVDoor::DelayBeforeTeleportation' has a wrong offset!");
static_assert(offsetof(AVDoor, NavlinkLength) == 0x0003A4, "Member 'AVDoor::NavlinkLength' has a wrong offset!");
static_assert(offsetof(AVDoor, bIsOpened) == 0x0003A8, "Member 'AVDoor::bIsOpened' has a wrong offset!");
static_assert(offsetof(AVDoor, bIsDestroyed) == 0x0003CC, "Member 'AVDoor::bIsDestroyed' has a wrong offset!");
static_assert(offsetof(AVDoor, bRefreshNavigationDataInBeginPlay) == 0x0003CD, "Member 'AVDoor::bRefreshNavigationDataInBeginPlay' has a wrong offset!");
static_assert(offsetof(AVDoor, OpeningDirection) == 0x0003D0, "Member 'AVDoor::OpeningDirection' has a wrong offset!");
static_assert(offsetof(AVDoor, FixedOcclusionInterpolationDuration) == 0x0003FC, "Member 'AVDoor::FixedOcclusionInterpolationDuration' has a wrong offset!");

// Class Altar.VFlora
// 0x0058 (0x0348 - 0x02F0)
class AVFlora : public AVActor
{
public:
	uint8                                         Pad_2F0[0x38];                                     // 0x02F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEmpty;                                          // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnActivated(class AVPairedPawn* ActivatorPawn, bool bSuccessfullyPicked);
	void OnEmptyFlagChanged();

	bool CanBePicked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFlora">();
	}
	static class AVFlora* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVFlora>();
	}
};
static_assert(alignof(AVFlora) == 0x000008, "Wrong alignment on AVFlora");
static_assert(sizeof(AVFlora) == 0x000348, "Wrong size on AVFlora");
static_assert(offsetof(AVFlora, bIsEmpty) == 0x000328, "Member 'AVFlora::bIsEmpty' has a wrong offset!");
static_assert(offsetof(AVFlora, TESRefComponent) == 0x000330, "Member 'AVFlora::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVFlora, MeshComponent) == 0x000338, "Member 'AVFlora::MeshComponent' has a wrong offset!");
static_assert(offsetof(AVFlora, PhysicsControllerComponent) == 0x000340, "Member 'AVFlora::PhysicsControllerComponent' has a wrong offset!");

// Class Altar.NiSkinData
// 0x0030 (0x0068 - 0x0038)
class UNiSkinData final : public UNiObject
{
public:
	class UNiTransform*                           SkinTransform;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumBones;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiSkinPartition*                       SkinPartition;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HasVertexWeights;                                  // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBoneData*>                      BoneList;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiSkinData">();
	}
	static class UNiSkinData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiSkinData>();
	}
};
static_assert(alignof(UNiSkinData) == 0x000008, "Wrong alignment on UNiSkinData");
static_assert(sizeof(UNiSkinData) == 0x000068, "Wrong size on UNiSkinData");
static_assert(offsetof(UNiSkinData, SkinTransform) == 0x000038, "Member 'UNiSkinData::SkinTransform' has a wrong offset!");
static_assert(offsetof(UNiSkinData, NumBones) == 0x000040, "Member 'UNiSkinData::NumBones' has a wrong offset!");
static_assert(offsetof(UNiSkinData, SkinPartition) == 0x000048, "Member 'UNiSkinData::SkinPartition' has a wrong offset!");
static_assert(offsetof(UNiSkinData, HasVertexWeights) == 0x000050, "Member 'UNiSkinData::HasVertexWeights' has a wrong offset!");
static_assert(offsetof(UNiSkinData, BoneList) == 0x000058, "Member 'UNiSkinData::BoneList' has a wrong offset!");

// Class Altar.VEnhancedLocomotionSystemCharacterAnimInstance
// 0x0290 (0x0630 - 0x03A0)
class UVEnhancedLocomotionSystemCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	class UCharacterMovementComponent*            CharacterMoveComp;                                 // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AVOblivionPlayerCharacter> PlayerCharacter;                                 // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  PrevAnimTags;                                      // 0x03B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsMoving;                                         // 0x03D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HorizontalSpeed;                                   // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalSpeed;                                     // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0xC];                                      // 0x03DC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnhancedLocomotionSystemData          LayerData;                                         // 0x03E8(0x0050)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsLayerActive;                                    // 0x0438(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UVTurnInPlaceCharacterAnimInstance> TurnInPlaceAnimInstanceClass;              // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0xC];                                      // 0x0448(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampedAxis;                                       // 0x0454(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasMovingTags;                                    // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x4B];                                     // 0x0459(0x004B)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartStateMachineName;                             // 0x04A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StartStateName;                                    // 0x04AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartingToMove;                                 // 0x04B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartingToRun;                                  // 0x04B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B6[0x2];                                      // 0x04B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartPoseAlpha;                                    // 0x04B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartCompleted;                                 // 0x04BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BD[0x3];                                      // 0x04BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StopSpeedThreshold;                                // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanFootLock;                                      // 0x04C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C5[0x2];                                      // 0x04C5(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSwitchToStand;                                    // 0x04C7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwitchToSneak;                                    // 0x04C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseStandSneakTransition;                    // 0x04C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInStandSneakTransition;                           // 0x04CA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CB[0x1];                                      // 0x04CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StandSneakTransitionStartPos;                      // 0x04CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x4];                                      // 0x04D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UpperBodyOrientationCurve;                         // 0x04D4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinMaxForwardAngle;                                // 0x04DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinMaxBackwardAngle;                               // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentOrientationAngle;                           // 0x04E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpperBodyAngle;                                    // 0x04E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanUseOrientationWarping;                         // 0x04EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4ED[0x43];                                     // 0x04ED(0x0043)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StrideDirection;                                   // 0x0530(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StrideScale;                                       // 0x0548(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanVertical;                                      // 0x054C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanHorizontal;                                    // 0x0550(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CombatLeanVertical;                                // 0x0554(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CombatLeanHorizontal;                              // 0x0558(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanPoseAlpha;                                     // 0x055C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_560[0x8];                                      // 0x0560(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RightFootLockAlpha;                                // 0x0568(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeftFootLockAlpha;                                 // 0x056C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RightFootLockPosition;                             // 0x0570(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LeftFootLockPosition;                              // 0x0588(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RightFootLockRotation;                             // 0x05A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               LeftFootLockRotation;                              // 0x05B8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   LeftFootLockCurveName;                             // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightFootLockCurveName;                            // 0x05D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftFootLockBone;                                  // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightFootLockBone;                                 // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x40];                                     // 0x05F0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnterStartState(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnLeftStartState(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStandSneakTransitionFinished(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStandSneakTransitionUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEnhancedLocomotionSystemCharacterAnimInstance">();
	}
	static class UVEnhancedLocomotionSystemCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEnhancedLocomotionSystemCharacterAnimInstance>();
	}
};
static_assert(alignof(UVEnhancedLocomotionSystemCharacterAnimInstance) == 0x000010, "Wrong alignment on UVEnhancedLocomotionSystemCharacterAnimInstance");
static_assert(sizeof(UVEnhancedLocomotionSystemCharacterAnimInstance) == 0x000630, "Wrong size on UVEnhancedLocomotionSystemCharacterAnimInstance");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, CharacterMoveComp) == 0x0003A0, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::CharacterMoveComp' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, PlayerCharacter) == 0x0003A8, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, PrevAnimTags) == 0x0003B0, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::PrevAnimTags' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bIsMoving) == 0x0003D0, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bIsMoving' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, HorizontalSpeed) == 0x0003D4, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::HorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, VerticalSpeed) == 0x0003D8, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::VerticalSpeed' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, LayerData) == 0x0003E8, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::LayerData' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bIsLayerActive) == 0x000438, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bIsLayerActive' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, TurnInPlaceAnimInstanceClass) == 0x000440, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::TurnInPlaceAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, ClampedAxis) == 0x000454, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::ClampedAxis' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bHasMovingTags) == 0x000458, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bHasMovingTags' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, StartStateMachineName) == 0x0004A4, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::StartStateMachineName' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, StartStateName) == 0x0004AC, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::StartStateName' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bIsStartingToMove) == 0x0004B4, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bIsStartingToMove' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bIsStartingToRun) == 0x0004B5, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bIsStartingToRun' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, StartPoseAlpha) == 0x0004B8, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::StartPoseAlpha' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bIsStartCompleted) == 0x0004BC, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bIsStartCompleted' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, StopSpeedThreshold) == 0x0004C0, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::StopSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bCanFootLock) == 0x0004C4, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bCanFootLock' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bSwitchToStand) == 0x0004C7, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bSwitchToStand' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bSwitchToSneak) == 0x0004C8, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bSwitchToSneak' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bShouldUseStandSneakTransition) == 0x0004C9, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bShouldUseStandSneakTransition' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bInStandSneakTransition) == 0x0004CA, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bInStandSneakTransition' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, StandSneakTransitionStartPos) == 0x0004CC, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::StandSneakTransitionStartPos' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, UpperBodyOrientationCurve) == 0x0004D4, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::UpperBodyOrientationCurve' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, MinMaxForwardAngle) == 0x0004DC, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::MinMaxForwardAngle' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, MinMaxBackwardAngle) == 0x0004E0, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::MinMaxBackwardAngle' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, CurrentOrientationAngle) == 0x0004E4, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::CurrentOrientationAngle' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, UpperBodyAngle) == 0x0004E8, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::UpperBodyAngle' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, bCanUseOrientationWarping) == 0x0004EC, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::bCanUseOrientationWarping' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, StrideDirection) == 0x000530, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::StrideDirection' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, StrideScale) == 0x000548, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::StrideScale' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, LeanVertical) == 0x00054C, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::LeanVertical' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, LeanHorizontal) == 0x000550, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::LeanHorizontal' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, CombatLeanVertical) == 0x000554, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::CombatLeanVertical' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, CombatLeanHorizontal) == 0x000558, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::CombatLeanHorizontal' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, LeanPoseAlpha) == 0x00055C, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::LeanPoseAlpha' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, RightFootLockAlpha) == 0x000568, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::RightFootLockAlpha' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, LeftFootLockAlpha) == 0x00056C, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::LeftFootLockAlpha' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, RightFootLockPosition) == 0x000570, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::RightFootLockPosition' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, LeftFootLockPosition) == 0x000588, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::LeftFootLockPosition' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, RightFootLockRotation) == 0x0005A0, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::RightFootLockRotation' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, LeftFootLockRotation) == 0x0005B8, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::LeftFootLockRotation' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, LeftFootLockCurveName) == 0x0005D0, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::LeftFootLockCurveName' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, RightFootLockCurveName) == 0x0005D8, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::RightFootLockCurveName' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, LeftFootLockBone) == 0x0005E0, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::LeftFootLockBone' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionSystemCharacterAnimInstance, RightFootLockBone) == 0x0005E8, "Member 'UVEnhancedLocomotionSystemCharacterAnimInstance::RightFootLockBone' has a wrong offset!");

// Class Altar.VFurniture
// 0x0070 (0x0360 - 0x02F0)
class AVFurniture final : public AVActor
{
public:
	uint8                                         Pad_2F0[0x48];                                     // 0x02F0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool ShouldUseLowLyingAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFurniture">();
	}
	static class AVFurniture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVFurniture>();
	}
};
static_assert(alignof(AVFurniture) == 0x000008, "Wrong alignment on AVFurniture");
static_assert(sizeof(AVFurniture) == 0x000360, "Wrong size on AVFurniture");
static_assert(offsetof(AVFurniture, TESRefComponent) == 0x000338, "Member 'AVFurniture::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVFurniture, TransformPairingComponent) == 0x000340, "Member 'AVFurniture::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVFurniture, StaticMeshComponent) == 0x000348, "Member 'AVFurniture::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVFurniture, PhysicsControllerComponent) == 0x000350, "Member 'AVFurniture::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVFurniture, AkAudioComponent) == 0x000358, "Member 'AVFurniture::AkAudioComponent' has a wrong offset!");

// Class Altar.VImmediateSound
// 0x0030 (0x0320 - 0x02F0)
class AVImmediateSound final : public AVActor
{
public:
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        AudioComponent;                                    // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             SoundWaveRef;                                      // 0x0310(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             DefaultSoundCue;                                   // 0x0318(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VImmediateSound">();
	}
	static class AVImmediateSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVImmediateSound>();
	}
};
static_assert(alignof(AVImmediateSound) == 0x000008, "Wrong alignment on AVImmediateSound");
static_assert(sizeof(AVImmediateSound) == 0x000320, "Wrong size on AVImmediateSound");
static_assert(offsetof(AVImmediateSound, TESRefComponent) == 0x0002F8, "Member 'AVImmediateSound::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVImmediateSound, TransformPairingComponent) == 0x000300, "Member 'AVImmediateSound::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVImmediateSound, AudioComponent) == 0x000308, "Member 'AVImmediateSound::AudioComponent' has a wrong offset!");
static_assert(offsetof(AVImmediateSound, SoundWaveRef) == 0x000310, "Member 'AVImmediateSound::SoundWaveRef' has a wrong offset!");
static_assert(offsetof(AVImmediateSound, DefaultSoundCue) == 0x000318, "Member 'AVImmediateSound::DefaultSoundCue' has a wrong offset!");

// Class Altar.VAICombatMovement_POSITION
// 0x0028 (0x0068 - 0x0040)
class UVAICombatMovement_POSITION final : public UVAIProcedureExecution_Base
{
public:
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAICombatMovement_POSITION">();
	}
	static class UVAICombatMovement_POSITION* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAICombatMovement_POSITION>();
	}
};
static_assert(alignof(UVAICombatMovement_POSITION) == 0x000008, "Wrong alignment on UVAICombatMovement_POSITION");
static_assert(sizeof(UVAICombatMovement_POSITION) == 0x000068, "Wrong size on UVAICombatMovement_POSITION");

// Class Altar.VIngredient
// 0x0070 (0x0360 - 0x02F0)
class AVIngredient : public AVActor
{
public:
	uint8                                         Pad_2F0[0x48];                                     // 0x02F0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIngredient">();
	}
	static class AVIngredient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVIngredient>();
	}
};
static_assert(alignof(AVIngredient) == 0x000008, "Wrong alignment on AVIngredient");
static_assert(sizeof(AVIngredient) == 0x000360, "Wrong size on AVIngredient");
static_assert(offsetof(AVIngredient, TESRefComponent) == 0x000338, "Member 'AVIngredient::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVIngredient, TransformPairingComponent) == 0x000340, "Member 'AVIngredient::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVIngredient, StaticMeshComponent) == 0x000348, "Member 'AVIngredient::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVIngredient, PhysicsControllerComponent) == 0x000350, "Member 'AVIngredient::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVIngredient, AkAudioComponent) == 0x000358, "Member 'AVIngredient::AkAudioComponent' has a wrong offset!");

// Class Altar.VAltarWidget
// 0x0008 (0x04C8 - 0x04C0)
class UVAltarWidget : public UVNavigableActivatableWidgetBase
{
public:
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceSynchronizeProperties();
	void OnSynchronizeProperties();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarWidget">();
	}
	static class UVAltarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarWidget>();
	}
};
static_assert(alignof(UVAltarWidget) == 0x000008, "Wrong alignment on UVAltarWidget");
static_assert(sizeof(UVAltarWidget) == 0x0004C8, "Wrong size on UVAltarWidget");

// Class Altar.VModernRebindSettingWidget
// 0x0150 (0x0618 - 0x04C8)
class UVModernRebindSettingWidget : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(int32 Index)>   OnChangeNavigationIndexDelegate;                   // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UVNavigableInputKeySelector*            LastFocussedWidget;                                // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E0[0x138];                                    // 0x04E0(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeErrorState(bool bErrorState);
	void Deinitialize();
	TArray<class UVAltarNavigableInputKeySelector*> GetAllSelector();
	void Init(const struct FModernRebindSettingTableRow& Value);
	void OnRefreshWidgetRequested();
	void OnSelectorFocussed(class UVNavigableInputKeySelector* FocussedSelector, int32 SelectorIndex);
	void OnSelectorListenStateChanged(class UVNavigableInputKeySelector* Target, bool NewState);
	void OnUpdateWidgetBinding(const struct FKey& NewPrimaryKeyboard, const struct FKey& NewSecondaryKeyboard, const struct FKey& NewPrimaryGamepad);
	void RevertBindingSavedState();
	void RevertBindingToDefault(bool bSpreadChange);
	void SaveRebind();
	void SetCurrentWidgetIndex(int32 NewValue);
	void SetNavigationIndex(int32 Value);
	void SetRebindData(const struct FModernRebindSettingTableRow& Value);

	bool DoesHaveAEmptyPrimaryBinding() const;
	int32 GetCurrentWidgetIndex() const;
	int32 GetNavigationIndex() const;
	const struct FModernRebindSettingTableRow GetRebindData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernRebindSettingWidget">();
	}
	static class UVModernRebindSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernRebindSettingWidget>();
	}
};
static_assert(alignof(UVModernRebindSettingWidget) == 0x000008, "Wrong alignment on UVModernRebindSettingWidget");
static_assert(sizeof(UVModernRebindSettingWidget) == 0x000618, "Wrong size on UVModernRebindSettingWidget");
static_assert(offsetof(UVModernRebindSettingWidget, OnChangeNavigationIndexDelegate) == 0x0004C8, "Member 'UVModernRebindSettingWidget::OnChangeNavigationIndexDelegate' has a wrong offset!");
static_assert(offsetof(UVModernRebindSettingWidget, LastFocussedWidget) == 0x0004D8, "Member 'UVModernRebindSettingWidget::LastFocussedWidget' has a wrong offset!");

// Class Altar.TESMagicItemObject
// 0x0020 (0x01B0 - 0x0190)
class UTESMagicItemObject : public UTESBoundObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTESEffectSetting>> EffectSettings;                                  // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESMagicItemObject">();
	}
	static class UTESMagicItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESMagicItemObject>();
	}
};
static_assert(alignof(UTESMagicItemObject) == 0x000008, "Wrong alignment on UTESMagicItemObject");
static_assert(sizeof(UTESMagicItemObject) == 0x0001B0, "Wrong size on UTESMagicItemObject");
static_assert(offsetof(UTESMagicItemObject, FullName) == 0x000190, "Member 'UTESMagicItemObject::FullName' has a wrong offset!");
static_assert(offsetof(UTESMagicItemObject, EffectSettings) == 0x0001A0, "Member 'UTESMagicItemObject::EffectSettings' has a wrong offset!");

// Class Altar.TESAlchemyItem
// 0x0028 (0x01D8 - 0x01B0)
class UTESAlchemyItem final : public UTESMagicItemObject
{
public:
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01B0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESAlchemyItem">();
	}
	static class UTESAlchemyItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESAlchemyItem>();
	}
};
static_assert(alignof(UTESAlchemyItem) == 0x000008, "Wrong alignment on UTESAlchemyItem");
static_assert(sizeof(UTESAlchemyItem) == 0x0001D8, "Wrong size on UTESAlchemyItem");
static_assert(offsetof(UTESAlchemyItem, NewMesh) == 0x0001B0, "Member 'UTESAlchemyItem::NewMesh' has a wrong offset!");

// Class Altar.VKey
// 0x0068 (0x0358 - 0x02F0)
class AVKey : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VKey">();
	}
	static class AVKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVKey>();
	}
};
static_assert(alignof(AVKey) == 0x000008, "Wrong alignment on AVKey");
static_assert(sizeof(AVKey) == 0x000358, "Wrong size on AVKey");
static_assert(offsetof(AVKey, TESRefComponent) == 0x000330, "Member 'AVKey::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVKey, TransformPairingComponent) == 0x000338, "Member 'AVKey::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVKey, StaticMeshComponent) == 0x000340, "Member 'AVKey::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVKey, PhysicsControllerComponent) == 0x000348, "Member 'AVKey::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVKey, AkAudioComponent) == 0x000350, "Member 'AVKey::AkAudioComponent' has a wrong offset!");

// Class Altar.VLeveledCreature
// 0x0010 (0x0300 - 0x02F0)
class AVLeveledCreature final : public AVActor
{
public:
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TArray<class FString> GetNameOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLeveledCreature">();
	}
	static class AVLeveledCreature* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVLeveledCreature>();
	}
};
static_assert(alignof(AVLeveledCreature) == 0x000008, "Wrong alignment on AVLeveledCreature");
static_assert(sizeof(AVLeveledCreature) == 0x000300, "Wrong size on AVLeveledCreature");
static_assert(offsetof(AVLeveledCreature, TESRefComponent) == 0x0002F0, "Member 'AVLeveledCreature::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVLeveledCreature, AkAudioComponent) == 0x0002F8, "Member 'AVLeveledCreature::AkAudioComponent' has a wrong offset!");

// Class Altar.VMagicProjectile
// 0x0030 (0x02C8 - 0x0298)
class AVMagicProjectile final : public AActor
{
public:
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMagicProjectile">();
	}
	static class AVMagicProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVMagicProjectile>();
	}
};
static_assert(alignof(AVMagicProjectile) == 0x000008, "Wrong alignment on AVMagicProjectile");
static_assert(sizeof(AVMagicProjectile) == 0x0002C8, "Wrong size on AVMagicProjectile");
static_assert(offsetof(AVMagicProjectile, TESRefComponent) == 0x0002B8, "Member 'AVMagicProjectile::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVMagicProjectile, TransformPairingComponent) == 0x0002C0, "Member 'AVMagicProjectile::TransformPairingComponent' has a wrong offset!");

// Class Altar.VPrimaryGameLayout
// 0x0088 (0x0370 - 0x02E8)
class UVPrimaryGameLayout : public UCommonUserWidget
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayTag& LayerTag, class UCommonActivatableWidget* TopMostWidget)> OnTopmostWidgetUpdated; // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UBackgroundBlur*                        Blur;                                              // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class UVActivatableWidgetStack*> Layers;                               // 0x0310(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   LayersTagStack;                                    // 0x0360(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static void ResumeInputForPlayer(class APlayerController* PlayerController, class FName SuspendToken);
	static class FName SuspendInputForPlayer(class APlayerController* PlayerController, class FName SuspendReason);

	void EndLayersRegistration();
	void RegisterLayer(const struct FGameplayTag& LayerTag, class UVActivatableWidgetStack* LayerWidget);
	void SetInputMode();

	class UVBackgroundWidgetBase* GetBackgroundWidget() const;
	bool IsLayerActive(const struct FGameplayTag& LayerTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPrimaryGameLayout">();
	}
	static class UVPrimaryGameLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPrimaryGameLayout>();
	}
};
static_assert(alignof(UVPrimaryGameLayout) == 0x000008, "Wrong alignment on UVPrimaryGameLayout");
static_assert(sizeof(UVPrimaryGameLayout) == 0x000370, "Wrong size on UVPrimaryGameLayout");
static_assert(offsetof(UVPrimaryGameLayout, OnTopmostWidgetUpdated) == 0x0002E8, "Member 'UVPrimaryGameLayout::OnTopmostWidgetUpdated' has a wrong offset!");
static_assert(offsetof(UVPrimaryGameLayout, Blur) == 0x0002F8, "Member 'UVPrimaryGameLayout::Blur' has a wrong offset!");
static_assert(offsetof(UVPrimaryGameLayout, Layers) == 0x000310, "Member 'UVPrimaryGameLayout::Layers' has a wrong offset!");
static_assert(offsetof(UVPrimaryGameLayout, LayersTagStack) == 0x000360, "Member 'UVPrimaryGameLayout::LayersTagStack' has a wrong offset!");

// Class Altar.VMagicSpellVFX
// 0x00E0 (0x0378 - 0x0298)
class AVMagicSpellVFX final : public AActor
{
public:
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVHitBoxComponent*                      HitBoxComponent;                                   // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESEffectSetting*                      form;                                              // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AVMagicSpellVFXBlueprint*>       MagicBlueprints;                                   // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AVActivable>             ActivableCaster;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsCastingManager;                                 // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAreaEffectManager;                              // 0x02F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDestructionOrderdedByVFX;                       // 0x02FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDestructionOrderdedByOblivion;                  // 0x02FB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantizeNormal              AreaEffectImpactNormal;                            // 0x0300(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector_NetQuantizeNormal              AreaEffectNormal;                                  // 0x0318(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  SpellCasterActor;                                  // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                ProjectileVelocity;                                // 0x0338(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVVFXType                                     KindOfVFX;                                         // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  CollidedActor;                                     // 0x0354(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UPrimitiveComponent>     CollidedComponent;                                 // 0x035C(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TimerHandle;                                       // 0x0368(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandleFogProjectile;                          // 0x0370(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void SendVFXEndSignal(class AActor* Blueprint);

	void OnSpellProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMagicSpellVFX">();
	}
	static class AVMagicSpellVFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVMagicSpellVFX>();
	}
};
static_assert(alignof(AVMagicSpellVFX) == 0x000008, "Wrong alignment on AVMagicSpellVFX");
static_assert(sizeof(AVMagicSpellVFX) == 0x000378, "Wrong size on AVMagicSpellVFX");
static_assert(offsetof(AVMagicSpellVFX, TESRefComponent) == 0x0002B8, "Member 'AVMagicSpellVFX::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, TransformPairingComponent) == 0x0002C0, "Member 'AVMagicSpellVFX::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, HitBoxComponent) == 0x0002C8, "Member 'AVMagicSpellVFX::HitBoxComponent' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, ProjectileMovementComponent) == 0x0002D0, "Member 'AVMagicSpellVFX::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, form) == 0x0002D8, "Member 'AVMagicSpellVFX::form' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, MagicBlueprints) == 0x0002E0, "Member 'AVMagicSpellVFX::MagicBlueprints' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, ActivableCaster) == 0x0002F0, "Member 'AVMagicSpellVFX::ActivableCaster' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, bIsCastingManager) == 0x0002F8, "Member 'AVMagicSpellVFX::bIsCastingManager' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, bIsAreaEffectManager) == 0x0002F9, "Member 'AVMagicSpellVFX::bIsAreaEffectManager' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, bIsDestructionOrderdedByVFX) == 0x0002FA, "Member 'AVMagicSpellVFX::bIsDestructionOrderdedByVFX' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, bIsDestructionOrderdedByOblivion) == 0x0002FB, "Member 'AVMagicSpellVFX::bIsDestructionOrderdedByOblivion' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, AreaEffectImpactNormal) == 0x000300, "Member 'AVMagicSpellVFX::AreaEffectImpactNormal' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, AreaEffectNormal) == 0x000318, "Member 'AVMagicSpellVFX::AreaEffectNormal' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, SpellCasterActor) == 0x000330, "Member 'AVMagicSpellVFX::SpellCasterActor' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, ProjectileVelocity) == 0x000338, "Member 'AVMagicSpellVFX::ProjectileVelocity' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, KindOfVFX) == 0x000350, "Member 'AVMagicSpellVFX::KindOfVFX' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, CollidedActor) == 0x000354, "Member 'AVMagicSpellVFX::CollidedActor' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, CollidedComponent) == 0x00035C, "Member 'AVMagicSpellVFX::CollidedComponent' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, TimerHandle) == 0x000368, "Member 'AVMagicSpellVFX::TimerHandle' has a wrong offset!");
static_assert(offsetof(AVMagicSpellVFX, TimerHandleFogProjectile) == 0x000370, "Member 'AVMagicSpellVFX::TimerHandleFogProjectile' has a wrong offset!");

// Class Altar.AVObject
// 0x0018 (0x0048 - 0x0030)
class UAVObject final : public UNifType
{
public:
	class FString                                 Name_0;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiAvObject*                            AVObject;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AVObject">();
	}
	static class UAVObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAVObject>();
	}
};
static_assert(alignof(UAVObject) == 0x000008, "Wrong alignment on UAVObject");
static_assert(sizeof(UAVObject) == 0x000048, "Wrong size on UAVObject");
static_assert(offsetof(UAVObject, Name_0) == 0x000030, "Member 'UAVObject::Name_0' has a wrong offset!");
static_assert(offsetof(UAVObject, AVObject) == 0x000040, "Member 'UAVObject::AVObject' has a wrong offset!");

// Class Altar.VMisc
// 0x0068 (0x0358 - 0x02F0)
class AVMisc : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMisc">();
	}
	static class AVMisc* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVMisc>();
	}
};
static_assert(alignof(AVMisc) == 0x000008, "Wrong alignment on AVMisc");
static_assert(sizeof(AVMisc) == 0x000358, "Wrong size on AVMisc");
static_assert(offsetof(AVMisc, TESRefComponent) == 0x000330, "Member 'AVMisc::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVMisc, TransformPairingComponent) == 0x000338, "Member 'AVMisc::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVMisc, StaticMeshComponent) == 0x000340, "Member 'AVMisc::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVMisc, PhysicsControllerComponent) == 0x000348, "Member 'AVMisc::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVMisc, AkAudioComponent) == 0x000350, "Member 'AVMisc::AkAudioComponent' has a wrong offset!");

// Class Altar.VAIProcedureExecution_ACTIVATE
// 0x0030 (0x0070 - 0x0040)
class UVAIProcedureExecution_ACTIVATE final : public UVAIProcedureExecution_Base
{
public:
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAIProcedureExecution_TRAVEL*          InternalTravelProcedure;                           // 0x0068(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSpecialIdleEnded();

	float GetActivationRadius() const;
	class AActor* GetTargetActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_ACTIVATE">();
	}
	static class UVAIProcedureExecution_ACTIVATE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_ACTIVATE>();
	}
};
static_assert(alignof(UVAIProcedureExecution_ACTIVATE) == 0x000008, "Wrong alignment on UVAIProcedureExecution_ACTIVATE");
static_assert(sizeof(UVAIProcedureExecution_ACTIVATE) == 0x000070, "Wrong size on UVAIProcedureExecution_ACTIVATE");
static_assert(offsetof(UVAIProcedureExecution_ACTIVATE, InternalTravelProcedure) == 0x000068, "Member 'UVAIProcedureExecution_ACTIVATE::InternalTravelProcedure' has a wrong offset!");

// Class Altar.AltarAnimationFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UAltarAnimationFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool DoesBlendspaceHaveAnimationForBlendValue(class UBlendSpace* BlendspaceAsset, const struct FVector& BlendValues);
	static class UAnimSequence* GetMostRelevantAnimationForBlendspaceBlendValues(class UBlendSpace* BlendspaceAsset, const struct FVector& BlendValues);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AltarAnimationFunctionLibrary">();
	}
	static class UAltarAnimationFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAltarAnimationFunctionLibrary>();
	}
};
static_assert(alignof(UAltarAnimationFunctionLibrary) == 0x000008, "Wrong alignment on UAltarAnimationFunctionLibrary");
static_assert(sizeof(UAltarAnimationFunctionLibrary) == 0x000028, "Wrong size on UAltarAnimationFunctionLibrary");

// Class Altar.VPairedPawn
// 0x07B0 (0x0E30 - 0x0680)
class AVPairedPawn : public ACharacter
{
public:
	uint8                                         Pad_678[0x50];                                     // 0x0678(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceAngleThreshold;                         // 0x06C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorForwardPoseOffset;                            // 0x06CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtPoint;                                       // 0x06D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E8[0x8];                                      // 0x06E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEnterLowFatigueState;                            // 0x06F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnExitLowFatigueState;                             // 0x0700(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_710[0x10];                                     // 0x0710(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        FakeRoot;                                          // 0x0720(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            SecondaryColliders;                                // 0x0728(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      PhysicsBodyCollider;                               // 0x0738(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          WorldLimitDetectionBox;                            // 0x0740(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MainSkeletalMeshComponent;                         // 0x0748(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DrawnArrowMeshComponent;                           // 0x0750(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPairedPawnStateMachineComponent*      StateMachineComponent;                             // 0x0758(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVMergedSkeletalMeshComponent*          MergedMeshComponent;                               // 0x0760(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        StatusEffectComponent;                             // 0x0768(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPairedPawnMovementComponent*          PairedPawnMovementComponent;                       // 0x0770(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetComponent*                       PawnDebugInfoWidgetComponent;                      // 0x0778(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetComponent*                       EntityDetailsDebugWidgetComponent;                 // 0x0780(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0788(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0790(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalAnimationComponent*            PhysicalAnimationComponent;                        // 0x0798(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVCharacterFadeInOutComponent*          CharacterFadeInOutComponent;                       // 0x07A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRequestLinkDynamicAnimLayers;                    // 0x07A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x07B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x07C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAnimationPairingComponent*            AnimationPairingComponent;                         // 0x07C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPawnSoundPairingComponent*            PawnSoundPairingComponent;                         // 0x07D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVWeaponsPairingComponent*              WeaponsPairingComponent;                           // 0x07D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVCharacterStatePairingComponent*       OblivionActorStatePairingComponent;                // 0x07E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVActorValuesPairingComponent*          ActorValuesPairingComponent;                       // 0x07E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVActiveEffectsPairingComponent*        ActiveEffectsPairingComponent;                     // 0x07F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightingUpdateFrequency;                           // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentLightingValue;                              // 0x07FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentLightingValueWithTorch;                     // 0x0800(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesDetectionLightingAllowShadowOcclusionTests;   // 0x0804(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_805[0x3];                                      // 0x0805(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             HitSoundCue;                                       // 0x0808(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCombatStance;                                   // 0x0810(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsImmuneToShieldBashEffect;                       // 0x0811(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_812[0x6];                                      // 0x0812(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           AllowedMeleeTargets;                               // 0x0818(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	bool                                          bRestrictedMeleeTargeting;                         // 0x0868(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_869[0x3];                                      // 0x0869(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawRotationDelta;                                  // 0x086C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SpecialAnimSequence;                               // 0x0870(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          DynamicAnimSequence;                               // 0x0878(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPoseSnapshot                          LastPoseSnapshot;                                  // 0x0880(0x0038)(Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	bool                                          bIsRagdollFacingUp;                                // 0x08B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOblivionAnimGroup                            CurrentSpellCastAnimGroup;                         // 0x08B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLanding;                                        // 0x08BA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRotationSpeedCurve;                            // 0x08BB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8BC[0x4];                                      // 0x08BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotationSpeedCurve;                                // 0x08C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FVMovementInputThresholds> MovementInputThresholdsPerMaxGait;   // 0x08C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTESEffectShader* form, const TArray<struct FLinearColor>& VFXColors, const TArray<class UStaticMeshComponent*>& MeshIgnoreList, float StatusEffectValue)> OnTextureEffectStart; // 0x0918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTextureEffectStop;                               // 0x0928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTextureEffectReset;                              // 0x0938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_948[0x18];                                     // 0x0948(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           AgainstBorderRegionTimerHandle;                    // 0x0960(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_968[0x50];                                     // 0x0968(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShouldersHeight;                                   // 0x09B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShouldersHalfWidth;                                // 0x09BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionLightingBottomPointHeight;                // 0x09C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionLightingCenterHeight;                     // 0x09C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpolateFakeRootLocation;                      // 0x09C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayFakeRootLocationDebug;                     // 0x09C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInterpolateFakeRootOnlyZAxis;                     // 0x09CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9CB[0x5];                                      // 0x09CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             FakeRootDistanceInterpSpeedFactorCurve;            // 0x09D0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             FakeRootVelocityInterpSpeedFactorCurve;            // 0x09F8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFakeRootDistanceFromCapsule;                    // 0x0A20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToRejoinRootWhenStoppingFakeRootInterp;        // 0x0A24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TagsPreventingFakeRootInterp;                      // 0x0A28(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A48[0x50];                                     // 0x0A48(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ChangeMaterialEffectTimerHandle;                   // 0x0A98(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           SendAttackFollowThroughTimerHandle;                // 0x0AA0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA8[0x18];                                     // 0x0AA8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UVPawnAnimatedAction* Action)> OnAnimatedActionStarted;      // 0x0AC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UVPawnAnimatedAction*                   CurrentAnimatedAction;                             // 0x0AD0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  HitReactIgnoredTags;                               // 0x0AD8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class AVPropItem*>                     CurrentPropItemsInUse;                             // 0x0AF8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bCanEverRun;                                       // 0x0B08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGroundMaterialType                           GroundMaterialType;                                // 0x0B09(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0A[0x6];                                      // 0x0B0A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LightingUpdateTimerHandle;                         // 0x0B10(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B18[0xA];                                      // 0x0B18(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	EVLifeState                                   LifeState;                                         // 0x0B22(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B23[0x19];                                     // 0x0B23(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	EVAnimAction                                  OblivionAnimAction;                                // 0x0B3C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B3D[0x33];                                     // 0x0B3D(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInDebugPerceptionMode;                            // 0x0B70(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B71[0x7];                                      // 0x0B71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAltarAIBlackboard*                    AIBlackboard;                                      // 0x0B78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPhysicsSimulationStarted;                        // 0x0B80(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPhysicsSimulationStopped;                        // 0x0B90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0BA0(0x0020)(Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVBufferedInputTag>             BufferedInputTags;                                 // 0x0BC0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AnimTags;                                          // 0x0BD0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  LastAnimTags;                                      // 0x0BF0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BehaviorMap;                                       // 0x0C10(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UnarmedAttackReach;                                // 0x0C38(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PerceptionUpdateFrequency;                         // 0x0C3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           PerceptionUpdateTimerHandle;                       // 0x0C40(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C48[0x8];                                      // 0x0C48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsStickyCollisionStateEnabled;                    // 0x0C50(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C51[0xF];                                      // 0x0C51(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldBePushedOnImpactWithPawn;                   // 0x0C60(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C61[0x1F];                                     // 0x0C61(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AVPairedPawn*, struct FVPerceptionState> PerceptionStateList;                         // 0x0C80(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UVStatusEffectOnPawn*>           StatusEffectsList;                                 // 0x0CD0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UVStatusEffectToDelete*>         StatusEffectsToDeleteList;                         // 0x0CE0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UVStatusEffectOnPawn*                   HighestPriorityStatusEffect;                       // 0x0CF0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVStatusEffectOnPawn*                   SecondPriorityStatusEffect;                        // 0x0CF8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVStatusEffectOnPawn*                   EnchantPriorityStatusEffect;                       // 0x0D00(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVSkinType                                    SkinType;                                          // 0x0D08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D09[0x2];                                      // 0x0D09(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCastingSpellWithStaff;                          // 0x0D0B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0C[0x4];                                      // 0x0D0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActorBlinkDelayMin;                                // 0x0D10(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActorBlinkDelayMax;                                // 0x0D14(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActorBlinkDuration;                                // 0x0D18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1C[0x4];                                      // 0x0D1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PainEvent;                                         // 0x0D20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          FootstepEvent;                                     // 0x0D28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          BlockEvent;                                        // 0x0D30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ImpactEvent;                                       // 0x0D38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          WhooshEvent;                                       // 0x0D40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          EquipEvent;                                        // 0x0D48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          UnequipEvent;                                      // 0x0D50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DamageRumbleEvent;                                 // 0x0D58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrengthEncumbranceMult;                           // 0x0D60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D64[0xCC];                                     // 0x0D64(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetPawnMeleeHitboxFromBase(const struct FVector& AimingStartPoint, float CapsuleRadius, const struct FVector& StartPointOffset, const struct FVector& AimingDirection, float ReachMultiplier, const struct FBox& LocalSpaceBaseHitbox, struct FVector* OutHitboxCenter, struct FVector* OutHitboxHalfExtent, struct FQuat* OutHitboxQuat);

	void ActivateFatigueFreeze();
	void ActivatePerceptionDebugMode();
	void AddBufferedInputTag(const struct FGameplayTag& TagToAdd);
	void AddBufferedInputTagWithCustomTime(const struct FGameplayTag& TagToAdd, float CustomBufferTime);
	void AddGameplayTag(const struct FGameplayTag& TagToAdd);
	void AddGameplayTags(const struct FGameplayTagContainer& GameplayTagsToAdd);
	void ApplyAndSaveConstraintProfile(const class FName ProfileName);
	void CancelAnimatedAction();
	void ConsumeDodgeFatigueCost();
	void ConsumeKnockdownRequest(struct FVPawnKnockdownRequest* LatestRequestData);
	void ConsumeMeleeAttackFatigue(bool bIsPowerAttack);
	void ConsumeShieldBashFatigueCost();
	void DeactivatePerceptionDebugMode();
	void DisableFatigueFreeze(float FatigueRestorationPercentage);
	void DoRagdoll(EVRagdollSetup Setup);
	class UVActorBehaviorBase* GetBehaviorForTag(const struct FGameplayTag& Tag);
	EGroundMaterialType GetGroundMaterialType();
	bool GroundMaterialTypeIsValid();
	void HideEntityDetailsWidget();
	bool IsValidTargetForStickyCollision(class AActor* OtherActor);
	void OnActionStateEntered(const struct FGameplayTag& InStateBaseTag);
	void OnActorValueChanged_Paralysis(EVActorValues ActorValue, float PreviousBaseValue, float PreviousModifiedValue, float NewBaseValue, float NewModifiedValue);
	void OnBeginOverlapWithBorder(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnCapsuleHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnCombatHitDealt(const struct FPairedOblivionHitEvent& HitEvent);
	void OnCombatHitTaken(const struct FPairedOblivionHitEvent& HitEvent);
	void OnCombatMiss();
	void OnDeathVFX();
	void OnEndOverlapWithBorder(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnGhostStateChanged(bool bIsGhost);
	void OnHitReaction(float ReceivedDamage, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& HitDirection);
	void OnLoadFinished();
	void OnPerceptionDebugModeActivated();
	void OnPerceptionDebugModeDeactivated();
	void OnPropItemEndingPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void OnShieldChanged(const class AVShield* ShieldActor, bool bEquipping);
	void OnSpecialBloodVFX();
	void OnSummonPawn(bool bIsSummoned);
	void OnTorchVisibilityChanged(const class AActor* TorchActor, bool bEquipping);
	void OnUpdateOverEncumbrance(EVActorValues ActorValue, float PreviousBaseValue, float PreviousModifiedValue, float NewBaseValue, float NewModifiedValue);
	void OnWaterWalkingValueChanged(EVActorValues ActorValue, float PreviousBaseValue, float PreviousModifiedValue, float NewBaseValue, float NewModifiedValue);
	void OnWeaponChanged(const class AVWeapon* WeaponForm);
	void RemoveGameplayTag(const struct FGameplayTag& TagToRemove, bool bIncludeChildTags);
	void RemoveGameplayTags(const struct FGameplayTagContainer& GameplayTagsToRemove, bool bIncludeChildTags);
	void RequestActiveEffectsFromOG();
	void RequestApplyKnockForce(const struct FVPawnKnockdownRequest& RequestData, bool bCanSwitchToKnockdownState);
	void RequestFootstepActionToWwise(class FName Action);
	void ResetGameplayTags();
	TArray<class AVPairedPawn*> RunPawnMeleeHitDetection(const struct FBox& LocalSpaceBaseHitbox, const struct FVector& CenterOffset, float MaxHorizontalAngleDegrees, float MaxVerticalAngleDegrees);
	void SendAttack(EVActionType AttackType, float AttackDuration);
	void SendAttackStartedEvent();
	void SendBlock(bool bIsBlocking);
	void SendBlockHit();
	void SendBowAttack(float DrawDuration, bool bIsSwimming);
	void SendDrawWeaponSwitch(bool bShouldDrawWeapon);
	void SendKnockState(bool bIsKnockedOut);
	void SendKnockStateGetUp();
	void SendMeleeHitOnPairedPawn(class AVPairedPawn* StruckPawn, bool bIsPowerAttack, float SneakDamageMultiplier);
	void SendRecoil();
	void SendShieldBashHitOnPairedPawn(class AVPairedPawn* StruckPawn);
	void SendSpellCast();
	void SendSpellReleaseCast(bool bIsStaffCast);
	void SendStagger();
	void SendVampireFeed();
	void SetIsPlayerCharacter(bool NewIsPlayer);
	void SetLifeState(EVLifeState NewLifeState);
	void SetOblivionAnimAction(EVAnimAction AnimAction);
	void SetRagdollConstraints(EVConstrainingMode PawnRagdollConstrainingMode);
	void SetSneak(bool bShouldSneak);
	void SetStickyCollisionStateEnabled(bool bEnableStickyCollision);
	void ShowEntityDetailsWidget(int32 DebugIndex);
	void SpawnDrawnArrowMeshComponent();
	void StartDodgeCooldown();
	void SwitchRagdollState();
	void SwitchToCombatMoveset();
	void SwitchToPassiveMoveset();
	void TryLinkConversationIdle();
	void TryLinkTorch();
	void UndoRagdoll();
	void UpdateDrawnArrowVisibility();

	bool CanBlink() const;
	bool CanFly() const;
	bool CanOnlySwim() const;
	bool CanSwim() const;
	bool CanUseAimOffset() const;
	struct FGameplayTag FindFirstGameplayTagMatching(const struct FGameplayTag& TagToMatch) const;
	float GetActorBlinkDelayMax() const;
	float GetActorBlinkDelayMin() const;
	float GetActorBlinkDuration() const;
	struct FVector GetAimingStartPosition() const;
	class FName GetAliveProfileName() const;
	TArray<struct FVBufferedInputTag> GetAllBufferedInputTags() const;
	TArray<class UMeshComponent*> GetAllVisibleMeshComponents(bool bNeedToBeVisible) const;
	float GetBaseSneakDamageMultiplierForCurrentWeapon() const;
	class USkeletalMeshComponent* GetBodyMesh() const;
	struct FVector GetCombatAimingDirectionVector() const;
	class UPhysicsAsset* GetCurrentPhysicsAsset() const;
	EVOblivionAIProcedureType GetCurrentProcedureType() const;
	float GetEquippedWeaponSpeed() const;
	struct FVector GetInteractionAimingDirectionVector() const;
	bool GetIsStickyCollisionStateEnable() const;
	struct FVector GetLastFakeRootUpdateVelocity() const;
	EVLifeState GetLifeState() const;
	void GetMeleeHitboxFromBase(const struct FBox& LocalSpaceBaseHitbox, const struct FVector& StartPointOffset, struct FVector* OutHitboxCenter, struct FVector* OutHitboxHalfExtent, struct FQuat* OutHitboxQuat) const;
	EVAnimAction GetOblivionAnimAction() const;
	struct FVector GetProjectileDirectionVector(const struct FVector& SpawnLocation) const;
	struct FVector GetSpellProjectileSpawnLocation(class FName CastingSocketName) const;
	class FName GetUnconsciousProfileName() const;
	bool HasAllGameplayTags(const struct FGameplayTagContainer& CheckTags) const;
	bool HasAnyGameplayTag(const struct FGameplayTagContainer& CheckTags) const;
	bool HasGameplayTag(const struct FGameplayTag& Tag) const;
	bool HasValidLookAtPoint() const;
	bool IsAliveFromResurrection() const;
	bool IsAliveFromSpawn() const;
	bool IsAliveFromUnconscious() const;
	bool IsAttacking() const;
	bool IsDead() const;
	bool IsDeadFromKilled() const;
	bool IsDeadFromSpawn() const;
	bool IsHorse() const;
	bool IsMeleeObstructed(const class AVPairedPawn* Target) const;
	bool IsOverEncumbered() const;
	bool IsPlayerCharacter() const;
	bool IsPlayingAnimatedAction() const;
	bool IsRagdolling() const;
	bool IsUnconscious() const;
	bool IsUnderStatusEffect(class FName StatusEffectName) const;
	bool IsWeaponDrawn() const;
	bool IsWeaponEquipped() const;
	void OnChangeActionState(EVActionType ActionState) const;
	void RequestPowerAttackVocalization() const;
	void SendJump() const;
	void SendPuppetAnimAction(EVAnimAction AnimationAction) const;
	void SendPuppetAnimGroup(EVAnimGroupSection Section, EVAnimGroupAction Action, EVAnimGroup AnimGroup) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPairedPawn">();
	}
	static class AVPairedPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPairedPawn>();
	}
};
static_assert(alignof(AVPairedPawn) == 0x000010, "Wrong alignment on AVPairedPawn");
static_assert(sizeof(AVPairedPawn) == 0x000E30, "Wrong size on AVPairedPawn");
static_assert(offsetof(AVPairedPawn, TurnInPlaceAngleThreshold) == 0x0006C8, "Member 'AVPairedPawn::TurnInPlaceAngleThreshold' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, ActorForwardPoseOffset) == 0x0006CC, "Member 'AVPairedPawn::ActorForwardPoseOffset' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, LookAtPoint) == 0x0006D0, "Member 'AVPairedPawn::LookAtPoint' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, OnEnterLowFatigueState) == 0x0006F0, "Member 'AVPairedPawn::OnEnterLowFatigueState' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, OnExitLowFatigueState) == 0x000700, "Member 'AVPairedPawn::OnExitLowFatigueState' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, FakeRoot) == 0x000720, "Member 'AVPairedPawn::FakeRoot' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, SecondaryColliders) == 0x000728, "Member 'AVPairedPawn::SecondaryColliders' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, PhysicsBodyCollider) == 0x000738, "Member 'AVPairedPawn::PhysicsBodyCollider' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, WorldLimitDetectionBox) == 0x000740, "Member 'AVPairedPawn::WorldLimitDetectionBox' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, MainSkeletalMeshComponent) == 0x000748, "Member 'AVPairedPawn::MainSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, DrawnArrowMeshComponent) == 0x000750, "Member 'AVPairedPawn::DrawnArrowMeshComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, StateMachineComponent) == 0x000758, "Member 'AVPairedPawn::StateMachineComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, MergedMeshComponent) == 0x000760, "Member 'AVPairedPawn::MergedMeshComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, StatusEffectComponent) == 0x000768, "Member 'AVPairedPawn::StatusEffectComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, PairedPawnMovementComponent) == 0x000770, "Member 'AVPairedPawn::PairedPawnMovementComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, PawnDebugInfoWidgetComponent) == 0x000778, "Member 'AVPairedPawn::PawnDebugInfoWidgetComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, EntityDetailsDebugWidgetComponent) == 0x000780, "Member 'AVPairedPawn::EntityDetailsDebugWidgetComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, PhysicsControllerComponent) == 0x000788, "Member 'AVPairedPawn::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, AkAudioComponent) == 0x000790, "Member 'AVPairedPawn::AkAudioComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, PhysicalAnimationComponent) == 0x000798, "Member 'AVPairedPawn::PhysicalAnimationComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, CharacterFadeInOutComponent) == 0x0007A0, "Member 'AVPairedPawn::CharacterFadeInOutComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, OnRequestLinkDynamicAnimLayers) == 0x0007A8, "Member 'AVPairedPawn::OnRequestLinkDynamicAnimLayers' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, TESRefComponent) == 0x0007B8, "Member 'AVPairedPawn::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, TransformPairingComponent) == 0x0007C0, "Member 'AVPairedPawn::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, AnimationPairingComponent) == 0x0007C8, "Member 'AVPairedPawn::AnimationPairingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, PawnSoundPairingComponent) == 0x0007D0, "Member 'AVPairedPawn::PawnSoundPairingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, WeaponsPairingComponent) == 0x0007D8, "Member 'AVPairedPawn::WeaponsPairingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, OblivionActorStatePairingComponent) == 0x0007E0, "Member 'AVPairedPawn::OblivionActorStatePairingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, ActorValuesPairingComponent) == 0x0007E8, "Member 'AVPairedPawn::ActorValuesPairingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, ActiveEffectsPairingComponent) == 0x0007F0, "Member 'AVPairedPawn::ActiveEffectsPairingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, LightingUpdateFrequency) == 0x0007F8, "Member 'AVPairedPawn::LightingUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, CurrentLightingValue) == 0x0007FC, "Member 'AVPairedPawn::CurrentLightingValue' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, CurrentLightingValueWithTorch) == 0x000800, "Member 'AVPairedPawn::CurrentLightingValueWithTorch' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bDoesDetectionLightingAllowShadowOcclusionTests) == 0x000804, "Member 'AVPairedPawn::bDoesDetectionLightingAllowShadowOcclusionTests' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, HitSoundCue) == 0x000808, "Member 'AVPairedPawn::HitSoundCue' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bInCombatStance) == 0x000810, "Member 'AVPairedPawn::bInCombatStance' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bIsImmuneToShieldBashEffect) == 0x000811, "Member 'AVPairedPawn::bIsImmuneToShieldBashEffect' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, AllowedMeleeTargets) == 0x000818, "Member 'AVPairedPawn::AllowedMeleeTargets' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bRestrictedMeleeTargeting) == 0x000868, "Member 'AVPairedPawn::bRestrictedMeleeTargeting' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, YawRotationDelta) == 0x00086C, "Member 'AVPairedPawn::YawRotationDelta' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, SpecialAnimSequence) == 0x000870, "Member 'AVPairedPawn::SpecialAnimSequence' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, DynamicAnimSequence) == 0x000878, "Member 'AVPairedPawn::DynamicAnimSequence' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, LastPoseSnapshot) == 0x000880, "Member 'AVPairedPawn::LastPoseSnapshot' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bIsRagdollFacingUp) == 0x0008B8, "Member 'AVPairedPawn::bIsRagdollFacingUp' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, CurrentSpellCastAnimGroup) == 0x0008B9, "Member 'AVPairedPawn::CurrentSpellCastAnimGroup' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bIsLanding) == 0x0008BA, "Member 'AVPairedPawn::bIsLanding' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bUseRotationSpeedCurve) == 0x0008BB, "Member 'AVPairedPawn::bUseRotationSpeedCurve' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, RotationSpeedCurve) == 0x0008C0, "Member 'AVPairedPawn::RotationSpeedCurve' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, MovementInputThresholdsPerMaxGait) == 0x0008C8, "Member 'AVPairedPawn::MovementInputThresholdsPerMaxGait' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, OnTextureEffectStart) == 0x000918, "Member 'AVPairedPawn::OnTextureEffectStart' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, OnTextureEffectStop) == 0x000928, "Member 'AVPairedPawn::OnTextureEffectStop' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, OnTextureEffectReset) == 0x000938, "Member 'AVPairedPawn::OnTextureEffectReset' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, AgainstBorderRegionTimerHandle) == 0x000960, "Member 'AVPairedPawn::AgainstBorderRegionTimerHandle' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, ShouldersHeight) == 0x0009B8, "Member 'AVPairedPawn::ShouldersHeight' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, ShouldersHalfWidth) == 0x0009BC, "Member 'AVPairedPawn::ShouldersHalfWidth' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, DetectionLightingBottomPointHeight) == 0x0009C0, "Member 'AVPairedPawn::DetectionLightingBottomPointHeight' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, DetectionLightingCenterHeight) == 0x0009C4, "Member 'AVPairedPawn::DetectionLightingCenterHeight' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bInterpolateFakeRootLocation) == 0x0009C8, "Member 'AVPairedPawn::bInterpolateFakeRootLocation' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bDisplayFakeRootLocationDebug) == 0x0009C9, "Member 'AVPairedPawn::bDisplayFakeRootLocationDebug' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bInterpolateFakeRootOnlyZAxis) == 0x0009CA, "Member 'AVPairedPawn::bInterpolateFakeRootOnlyZAxis' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, FakeRootDistanceInterpSpeedFactorCurve) == 0x0009D0, "Member 'AVPairedPawn::FakeRootDistanceInterpSpeedFactorCurve' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, FakeRootVelocityInterpSpeedFactorCurve) == 0x0009F8, "Member 'AVPairedPawn::FakeRootVelocityInterpSpeedFactorCurve' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, MaxFakeRootDistanceFromCapsule) == 0x000A20, "Member 'AVPairedPawn::MaxFakeRootDistanceFromCapsule' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, TimeToRejoinRootWhenStoppingFakeRootInterp) == 0x000A24, "Member 'AVPairedPawn::TimeToRejoinRootWhenStoppingFakeRootInterp' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, TagsPreventingFakeRootInterp) == 0x000A28, "Member 'AVPairedPawn::TagsPreventingFakeRootInterp' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, ChangeMaterialEffectTimerHandle) == 0x000A98, "Member 'AVPairedPawn::ChangeMaterialEffectTimerHandle' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, SendAttackFollowThroughTimerHandle) == 0x000AA0, "Member 'AVPairedPawn::SendAttackFollowThroughTimerHandle' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, OnAnimatedActionStarted) == 0x000AC0, "Member 'AVPairedPawn::OnAnimatedActionStarted' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, CurrentAnimatedAction) == 0x000AD0, "Member 'AVPairedPawn::CurrentAnimatedAction' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, HitReactIgnoredTags) == 0x000AD8, "Member 'AVPairedPawn::HitReactIgnoredTags' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, CurrentPropItemsInUse) == 0x000AF8, "Member 'AVPairedPawn::CurrentPropItemsInUse' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bCanEverRun) == 0x000B08, "Member 'AVPairedPawn::bCanEverRun' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, GroundMaterialType) == 0x000B09, "Member 'AVPairedPawn::GroundMaterialType' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, LightingUpdateTimerHandle) == 0x000B10, "Member 'AVPairedPawn::LightingUpdateTimerHandle' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, LifeState) == 0x000B22, "Member 'AVPairedPawn::LifeState' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, OblivionAnimAction) == 0x000B3C, "Member 'AVPairedPawn::OblivionAnimAction' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bInDebugPerceptionMode) == 0x000B70, "Member 'AVPairedPawn::bInDebugPerceptionMode' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, AIBlackboard) == 0x000B78, "Member 'AVPairedPawn::AIBlackboard' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, OnPhysicsSimulationStarted) == 0x000B80, "Member 'AVPairedPawn::OnPhysicsSimulationStarted' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, OnPhysicsSimulationStopped) == 0x000B90, "Member 'AVPairedPawn::OnPhysicsSimulationStopped' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, GameplayTags) == 0x000BA0, "Member 'AVPairedPawn::GameplayTags' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, BufferedInputTags) == 0x000BC0, "Member 'AVPairedPawn::BufferedInputTags' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, AnimTags) == 0x000BD0, "Member 'AVPairedPawn::AnimTags' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, LastAnimTags) == 0x000BF0, "Member 'AVPairedPawn::LastAnimTags' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, BehaviorMap) == 0x000C10, "Member 'AVPairedPawn::BehaviorMap' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, UnarmedAttackReach) == 0x000C38, "Member 'AVPairedPawn::UnarmedAttackReach' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, PerceptionUpdateFrequency) == 0x000C3C, "Member 'AVPairedPawn::PerceptionUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, PerceptionUpdateTimerHandle) == 0x000C40, "Member 'AVPairedPawn::PerceptionUpdateTimerHandle' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bIsStickyCollisionStateEnabled) == 0x000C50, "Member 'AVPairedPawn::bIsStickyCollisionStateEnabled' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bShouldBePushedOnImpactWithPawn) == 0x000C60, "Member 'AVPairedPawn::bShouldBePushedOnImpactWithPawn' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, PerceptionStateList) == 0x000C80, "Member 'AVPairedPawn::PerceptionStateList' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, StatusEffectsList) == 0x000CD0, "Member 'AVPairedPawn::StatusEffectsList' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, StatusEffectsToDeleteList) == 0x000CE0, "Member 'AVPairedPawn::StatusEffectsToDeleteList' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, HighestPriorityStatusEffect) == 0x000CF0, "Member 'AVPairedPawn::HighestPriorityStatusEffect' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, SecondPriorityStatusEffect) == 0x000CF8, "Member 'AVPairedPawn::SecondPriorityStatusEffect' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, EnchantPriorityStatusEffect) == 0x000D00, "Member 'AVPairedPawn::EnchantPriorityStatusEffect' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, SkinType) == 0x000D08, "Member 'AVPairedPawn::SkinType' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, bIsCastingSpellWithStaff) == 0x000D0B, "Member 'AVPairedPawn::bIsCastingSpellWithStaff' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, ActorBlinkDelayMin) == 0x000D10, "Member 'AVPairedPawn::ActorBlinkDelayMin' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, ActorBlinkDelayMax) == 0x000D14, "Member 'AVPairedPawn::ActorBlinkDelayMax' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, ActorBlinkDuration) == 0x000D18, "Member 'AVPairedPawn::ActorBlinkDuration' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, PainEvent) == 0x000D20, "Member 'AVPairedPawn::PainEvent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, FootstepEvent) == 0x000D28, "Member 'AVPairedPawn::FootstepEvent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, BlockEvent) == 0x000D30, "Member 'AVPairedPawn::BlockEvent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, ImpactEvent) == 0x000D38, "Member 'AVPairedPawn::ImpactEvent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, WhooshEvent) == 0x000D40, "Member 'AVPairedPawn::WhooshEvent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, EquipEvent) == 0x000D48, "Member 'AVPairedPawn::EquipEvent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, UnequipEvent) == 0x000D50, "Member 'AVPairedPawn::UnequipEvent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, DamageRumbleEvent) == 0x000D58, "Member 'AVPairedPawn::DamageRumbleEvent' has a wrong offset!");
static_assert(offsetof(AVPairedPawn, StrengthEncumbranceMult) == 0x000D60, "Member 'AVPairedPawn::StrengthEncumbranceMult' has a wrong offset!");

// Class Altar.VPathGridComponent
// 0x0030 (0x0600 - 0x05D0)
class UVPathGridComponent final : public UDebugDrawComponent
{
public:
	TArray<struct FPathGridPointData>             PathGridPointsData;                                // 0x05C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FIntergridConnection>           IntergridConnections;                              // 0x05D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FPathGridPointData>             LinkedPoints;                                      // 0x05E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPathGridComponent">();
	}
	static class UVPathGridComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPathGridComponent>();
	}
};
static_assert(alignof(UVPathGridComponent) == 0x000010, "Wrong alignment on UVPathGridComponent");
static_assert(sizeof(UVPathGridComponent) == 0x000600, "Wrong size on UVPathGridComponent");
static_assert(offsetof(UVPathGridComponent, PathGridPointsData) == 0x0005C8, "Member 'UVPathGridComponent::PathGridPointsData' has a wrong offset!");
static_assert(offsetof(UVPathGridComponent, IntergridConnections) == 0x0005D8, "Member 'UVPathGridComponent::IntergridConnections' has a wrong offset!");
static_assert(offsetof(UVPathGridComponent, LinkedPoints) == 0x0005E8, "Member 'UVPathGridComponent::LinkedPoints' has a wrong offset!");

// Class Altar.VViewModelBase
// 0x0068 (0x00D0 - 0x0068)
class UVViewModelBase : public UMVVMViewModelBase
{
public:
	uint8                                         Pad_68[0x68];                                      // 0x0068(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetGamertagText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VViewModelBase">();
	}
	static class UVViewModelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVViewModelBase>();
	}
};
static_assert(alignof(UVViewModelBase) == 0x000008, "Wrong alignment on UVViewModelBase");
static_assert(sizeof(UVViewModelBase) == 0x0000D0, "Wrong size on UVViewModelBase");

// Class Altar.VPairedCreature
// 0x0060 (0x0E90 - 0x0E30)
class AVPairedCreature final : public AVPairedPawn
{
public:
	class AVPairedCharacter*                      Rider;                                             // 0x0E30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarSpringArmComponent*              MountCameraSpringArmComponent;                     // 0x0E38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVEntryPointData>               EntryPoints;                                       // 0x0E40(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                FirstPersonRiderAttachmentOffset;                  // 0x0E50(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E68[0x18];                                     // 0x0E68(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        TurningAnimationsYawDeltaThreshold;                // 0x0E80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E88[0x8];                                      // 0x0E88(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPairedCreature">();
	}
	static class AVPairedCreature* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPairedCreature>();
	}
};
static_assert(alignof(AVPairedCreature) == 0x000010, "Wrong alignment on AVPairedCreature");
static_assert(sizeof(AVPairedCreature) == 0x000E90, "Wrong size on AVPairedCreature");
static_assert(offsetof(AVPairedCreature, Rider) == 0x000E30, "Member 'AVPairedCreature::Rider' has a wrong offset!");
static_assert(offsetof(AVPairedCreature, MountCameraSpringArmComponent) == 0x000E38, "Member 'AVPairedCreature::MountCameraSpringArmComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCreature, EntryPoints) == 0x000E40, "Member 'AVPairedCreature::EntryPoints' has a wrong offset!");
static_assert(offsetof(AVPairedCreature, FirstPersonRiderAttachmentOffset) == 0x000E50, "Member 'AVPairedCreature::FirstPersonRiderAttachmentOffset' has a wrong offset!");
static_assert(offsetof(AVPairedCreature, TurningAnimationsYawDeltaThreshold) == 0x000E80, "Member 'AVPairedCreature::TurningAnimationsYawDeltaThreshold' has a wrong offset!");

// Class Altar.VPairedCharacter
// 0x01B0 (0x0FE0 - 0x0E30)
class AVPairedCharacter : public AVPairedPawn
{
public:
	uint8                                         Pad_E30[0x58];                                     // 0x0E30(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DockWarpTargetName;                                // 0x0E88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTESRace*                               Race;                                              // 0x0E90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECharacterSex                                 Sex;                                               // 0x0E98(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVVoiceType                                   VoiceType;                                         // 0x0E99(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9A[0x1E];                                     // 0x0E9A(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnCharacterRaceChanged;                            // 0x0EB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCharacterSexChanged;                             // 0x0EC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAppearanceRefreshedEnd;                          // 0x0ED8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultRaceAndSexPreset;                       // 0x0EE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EE9[0x7];                                      // 0x0EE9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVCharacterPhenotypeData*               PhenotypeData;                                     // 0x0EF0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVHumanoidHeadComponent*                HumanoidHeadComponent;                             // 0x0EF8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   HeadwearChildActorComponent;                       // 0x0F00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   UpperBodyChildActorComponent;                      // 0x0F08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   LowerBodyChildActorComponent;                      // 0x0F10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   HandsChildActorComponent;                          // 0x0F18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   FeetChildActorComponent;                           // 0x0F20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   AmuletChildActorComponent;                         // 0x0F28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   RightRingChildActorComponent;                      // 0x0F30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   LeftRingChildActorComponent;                       // 0x0F38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVCharacterBodyPairingComponent*        CharacterBodyPairingComponent;                     // 0x0F40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVDockingPairingComponent*              DockingPairingComponent;                           // 0x0F48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMotionWarpingComponent*                HumanoidMotionWarpingComponent;                    // 0x0F50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVCharacterAppearancePairingComponent*  CharacterAppearancePairingComponent;               // 0x0F58(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmotionBlendValueMultiplier;                       // 0x0F60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasUndockingQueued;                               // 0x0F64(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F65[0x3];                                      // 0x0F65(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBipedModularBodySlot, struct FInitialEquipmentInfo> InitialEquipmentMap;                   // 0x0F68(0x0050)(Edit, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           RefreshMergedMeshTimerHandle;                      // 0x0FB8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC0[0x20];                                     // 0x0FC0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyBodyPartPropertiesToChildActor(EBipedModularBodySlot Slot, const struct FVCharacterBodyPartProperties& Properties);
	void CallTextureEffectBroadcastDelegate();
	void ClearAllDockingTags();
	void FinishDockingToRequestedDockActor(bool bSnapTransform);
	bool InitializeAppearanceFromForm();
	void OnBodyPartPropertiesChanged(EBipedModularBodySlot Slot, const struct FVCharacterBodyPartProperties& Properties);
	void OnFacialAnimationMontageDone(class UAnimMontage* Montage, bool bInterrupted);
	void OnRaceOrSexChanged();
	void OnWeaponDrawnStateChanged(bool bIsWeaponDrawn);
	void ProcessPendingUndockingRequest();
	void RefreshAppearance(EVCharacterRefreshSelector Selector);
	void RefreshAppearanceAsync(EVCharacterRefreshSelector Selector);
	void SetBodySectionsOnMesh(class USkeletalMeshComponent* Components);
	void SetRace(const class UTESRace* NewRace);
	void SetSex(const ECharacterSex NewSex);
	void SetVoiceType(const EVVoiceType NewVoiceType);
	void SnapToStandingPosition(bool bUpdatePairedDockingState, bool bSnapToMarker);
	void UpdateGenderAudioSwitch();
	void UpdateRaceAudioSwitch();
	void WaitForRefreshAppearanceToComplete(float Timeout);
	void WarpToDockingPosition();

	EVBloodColor GetBloodColor() const;
	float GetBoneScale(const class FName& Name_0) const;
	TMap<class FName, float> GetBonesScale(const TArray<class FName>& Names) const;
	class UChildActorComponent* GetChildActorFromSlot(EBipedModularBodySlot Slot) const;
	class AVPairedCreature* GetHorse() const;
	TMap<EBipedModularBodySlot, class UTESForm*> GetInitialEquipmentMap() const;
	class UTESRace* GetRace() const;
	ECharacterSex GetSex() const;
	class AActor* GetUsedDockActor() const;
	EVVoiceType GetVoiceType() const;
	bool IsDocked() const;
	bool IsInDockingProcess() const;
	void OnStartDockingToHorse() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPairedCharacter">();
	}
	static class AVPairedCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPairedCharacter>();
	}
};
static_assert(alignof(AVPairedCharacter) == 0x000010, "Wrong alignment on AVPairedCharacter");
static_assert(sizeof(AVPairedCharacter) == 0x000FE0, "Wrong size on AVPairedCharacter");
static_assert(offsetof(AVPairedCharacter, DockWarpTargetName) == 0x000E88, "Member 'AVPairedCharacter::DockWarpTargetName' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, Race) == 0x000E90, "Member 'AVPairedCharacter::Race' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, Sex) == 0x000E98, "Member 'AVPairedCharacter::Sex' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, VoiceType) == 0x000E99, "Member 'AVPairedCharacter::VoiceType' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, OnCharacterRaceChanged) == 0x000EB8, "Member 'AVPairedCharacter::OnCharacterRaceChanged' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, OnCharacterSexChanged) == 0x000EC8, "Member 'AVPairedCharacter::OnCharacterSexChanged' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, OnAppearanceRefreshedEnd) == 0x000ED8, "Member 'AVPairedCharacter::OnAppearanceRefreshedEnd' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, bUseDefaultRaceAndSexPreset) == 0x000EE8, "Member 'AVPairedCharacter::bUseDefaultRaceAndSexPreset' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, PhenotypeData) == 0x000EF0, "Member 'AVPairedCharacter::PhenotypeData' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, HumanoidHeadComponent) == 0x000EF8, "Member 'AVPairedCharacter::HumanoidHeadComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, HeadwearChildActorComponent) == 0x000F00, "Member 'AVPairedCharacter::HeadwearChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, UpperBodyChildActorComponent) == 0x000F08, "Member 'AVPairedCharacter::UpperBodyChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, LowerBodyChildActorComponent) == 0x000F10, "Member 'AVPairedCharacter::LowerBodyChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, HandsChildActorComponent) == 0x000F18, "Member 'AVPairedCharacter::HandsChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, FeetChildActorComponent) == 0x000F20, "Member 'AVPairedCharacter::FeetChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, AmuletChildActorComponent) == 0x000F28, "Member 'AVPairedCharacter::AmuletChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, RightRingChildActorComponent) == 0x000F30, "Member 'AVPairedCharacter::RightRingChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, LeftRingChildActorComponent) == 0x000F38, "Member 'AVPairedCharacter::LeftRingChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, CharacterBodyPairingComponent) == 0x000F40, "Member 'AVPairedCharacter::CharacterBodyPairingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, DockingPairingComponent) == 0x000F48, "Member 'AVPairedCharacter::DockingPairingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, HumanoidMotionWarpingComponent) == 0x000F50, "Member 'AVPairedCharacter::HumanoidMotionWarpingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, CharacterAppearancePairingComponent) == 0x000F58, "Member 'AVPairedCharacter::CharacterAppearancePairingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, EmotionBlendValueMultiplier) == 0x000F60, "Member 'AVPairedCharacter::EmotionBlendValueMultiplier' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, bHasUndockingQueued) == 0x000F64, "Member 'AVPairedCharacter::bHasUndockingQueued' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, InitialEquipmentMap) == 0x000F68, "Member 'AVPairedCharacter::InitialEquipmentMap' has a wrong offset!");
static_assert(offsetof(AVPairedCharacter, RefreshMergedMeshTimerHandle) == 0x000FB8, "Member 'AVPairedCharacter::RefreshMergedMeshTimerHandle' has a wrong offset!");

// Class Altar.VModernMessageMenuSpecific
// 0x0010 (0x04D8 - 0x04C8)
class UVModernMessageMenuSpecific : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(int32 InButtonIndex)> OnButtonClicked;                             // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void UpdateButtons(const TArray<class FText>& InNewButtonData);
	void UpdateMessage(const class FText& InNewMessage);
	void UpdateTitle(const class FText& InNewTitle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernMessageMenuSpecific">();
	}
	static class UVModernMessageMenuSpecific* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernMessageMenuSpecific>();
	}
};
static_assert(alignof(UVModernMessageMenuSpecific) == 0x000008, "Wrong alignment on UVModernMessageMenuSpecific");
static_assert(sizeof(UVModernMessageMenuSpecific) == 0x0004D8, "Wrong size on UVModernMessageMenuSpecific");
static_assert(offsetof(UVModernMessageMenuSpecific, OnButtonClicked) == 0x0004C8, "Member 'UVModernMessageMenuSpecific::OnButtonClicked' has a wrong offset!");

// Class Altar.NiQuatTransform
// 0x0060 (0x0090 - 0x0030)
class UNiQuatTransform final : public UNifType
{
public:
	struct FVector                                Translation;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0050(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  TRSValid;                                          // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiQuatTransform">();
	}
	static class UNiQuatTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiQuatTransform>();
	}
};
static_assert(alignof(UNiQuatTransform) == 0x000010, "Wrong alignment on UNiQuatTransform");
static_assert(sizeof(UNiQuatTransform) == 0x000090, "Wrong size on UNiQuatTransform");
static_assert(offsetof(UNiQuatTransform, Translation) == 0x000030, "Member 'UNiQuatTransform::Translation' has a wrong offset!");
static_assert(offsetof(UNiQuatTransform, Rotation) == 0x000050, "Member 'UNiQuatTransform::Rotation' has a wrong offset!");
static_assert(offsetof(UNiQuatTransform, Scale) == 0x000070, "Member 'UNiQuatTransform::Scale' has a wrong offset!");
static_assert(offsetof(UNiQuatTransform, TRSValid) == 0x000078, "Member 'UNiQuatTransform::TRSValid' has a wrong offset!");

// Class Altar.VPathGrid
// 0x0010 (0x0300 - 0x02F0)
class AVPathGrid final : public AVActor
{
public:
	int64                                         FormID;                                            // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPathGridComponent*                    PathGridComponent;                                 // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPathGrid">();
	}
	static class AVPathGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPathGrid>();
	}
};
static_assert(alignof(AVPathGrid) == 0x000008, "Wrong alignment on AVPathGrid");
static_assert(sizeof(AVPathGrid) == 0x000300, "Wrong size on AVPathGrid");
static_assert(offsetof(AVPathGrid, FormID) == 0x0002F0, "Member 'AVPathGrid::FormID' has a wrong offset!");
static_assert(offsetof(AVPathGrid, PathGridComponent) == 0x0002F8, "Member 'AVPathGrid::PathGridComponent' has a wrong offset!");

// Class Altar.VLocomotionCharacterAnimInstance
// 0x00C0 (0x0460 - 0x03A0)
class UVLocomotionCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	class UVPairedPawnMovementComponent*          PairedPawnMoveComp;                                // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x50];                                     // 0x03A8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardSpeed;                                      // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LateralSpeed;                                      // 0x03FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionPlayRate;                                // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BlendValues;                                       // 0x0408(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_420[0x40];                                     // 0x0420(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpecialJumpStarted(const struct FVector& Velocity);

	bool GetIsMovingBackward() const;
	bool IsMoving() const;
	bool IsSprinting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLocomotionCharacterAnimInstance">();
	}
	static class UVLocomotionCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLocomotionCharacterAnimInstance>();
	}
};
static_assert(alignof(UVLocomotionCharacterAnimInstance) == 0x000010, "Wrong alignment on UVLocomotionCharacterAnimInstance");
static_assert(sizeof(UVLocomotionCharacterAnimInstance) == 0x000460, "Wrong size on UVLocomotionCharacterAnimInstance");
static_assert(offsetof(UVLocomotionCharacterAnimInstance, PairedPawnMoveComp) == 0x0003A0, "Member 'UVLocomotionCharacterAnimInstance::PairedPawnMoveComp' has a wrong offset!");
static_assert(offsetof(UVLocomotionCharacterAnimInstance, ForwardSpeed) == 0x0003F8, "Member 'UVLocomotionCharacterAnimInstance::ForwardSpeed' has a wrong offset!");
static_assert(offsetof(UVLocomotionCharacterAnimInstance, LateralSpeed) == 0x0003FC, "Member 'UVLocomotionCharacterAnimInstance::LateralSpeed' has a wrong offset!");
static_assert(offsetof(UVLocomotionCharacterAnimInstance, LocomotionPlayRate) == 0x000400, "Member 'UVLocomotionCharacterAnimInstance::LocomotionPlayRate' has a wrong offset!");
static_assert(offsetof(UVLocomotionCharacterAnimInstance, BlendValues) == 0x000408, "Member 'UVLocomotionCharacterAnimInstance::BlendValues' has a wrong offset!");

// Class Altar.VAltarUserInterfaceSettings
// 0x0308 (0x0330 - 0x0028)
class UVAltarUserInterfaceSettings final : public UObject
{
public:
	struct FSoftObjectPath                        SepiaMenuBackgroundMaterial;                       // 0x0028(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   LayersToApplyOn;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CommonCharacterModificationsDataTablePath;         // 0x0058(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RaceModificationPropertiesDataTablePath;           // 0x0078(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SettingsDataTablePath;                             // 0x0098(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        KeyboardBindingDataTablePath;                      // 0x00B8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        KeyboardBindingFrDataTablePath;                    // 0x00D8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GamepadBindingDataTablePath;                       // 0x00F8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HelpDataTablePath;                                 // 0x0118(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconSelectionDataTablePath;                        // 0x0138(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserInterfaceIconsTexturesRootPath;                // 0x0158(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserInterfaceGameDataIconsTexturesRootPath;        // 0x0168(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadAxisDeadZone;                               // 0x0178(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThumbstickPressedTreshold;                         // 0x017C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SmallFontSizeDelta;                                // 0x0180(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LargeFontSizeDelta;                                // 0x0184(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDuration;                                    // 0x0188(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x018C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInExtraDurationInterior;                       // 0x0190(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInExtraDurationSeamless;                       // 0x0194(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInExtraDurationFastTransition;                 // 0x0198(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInExtraDurationPSOCompilation;                 // 0x019C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDurationUntilUnfreeze;                       // 0x01A0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChangeListNumber;                                  // 0x01A8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FromMainCL;                                        // 0x01B8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StreamName;                                        // 0x01C8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProjectMajor;                                      // 0x01D8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProjectMinor;                                      // 0x01E8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UWorld>>          BackgroundLevelsToLoad;                            // 0x01F8(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UInputMappingContext>> UserInterfaceSpecificMappingContext;          // 0x0208(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureRenderTarget2D>  FogOfWarRenderTarget;                              // 0x0218(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               FogOfWarMaterial;                                  // 0x0240(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureRenderTarget2D>  SceneDepthRenderTarget;                            // 0x0268(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureRenderTarget2D>  SecondPassRenderTarget;                            // 0x0290(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureRenderTarget2D>  BaseColorRenderTarget;                             // 0x02B8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               LocalMapMaterial;                                  // 0x02E0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               LocalMapSobelMaterial;                             // 0x0308(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarUserInterfaceSettings">();
	}
	static class UVAltarUserInterfaceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarUserInterfaceSettings>();
	}
};
static_assert(alignof(UVAltarUserInterfaceSettings) == 0x000008, "Wrong alignment on UVAltarUserInterfaceSettings");
static_assert(sizeof(UVAltarUserInterfaceSettings) == 0x000330, "Wrong size on UVAltarUserInterfaceSettings");
static_assert(offsetof(UVAltarUserInterfaceSettings, SepiaMenuBackgroundMaterial) == 0x000028, "Member 'UVAltarUserInterfaceSettings::SepiaMenuBackgroundMaterial' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, LayersToApplyOn) == 0x000048, "Member 'UVAltarUserInterfaceSettings::LayersToApplyOn' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, CommonCharacterModificationsDataTablePath) == 0x000058, "Member 'UVAltarUserInterfaceSettings::CommonCharacterModificationsDataTablePath' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, RaceModificationPropertiesDataTablePath) == 0x000078, "Member 'UVAltarUserInterfaceSettings::RaceModificationPropertiesDataTablePath' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, SettingsDataTablePath) == 0x000098, "Member 'UVAltarUserInterfaceSettings::SettingsDataTablePath' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, KeyboardBindingDataTablePath) == 0x0000B8, "Member 'UVAltarUserInterfaceSettings::KeyboardBindingDataTablePath' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, KeyboardBindingFrDataTablePath) == 0x0000D8, "Member 'UVAltarUserInterfaceSettings::KeyboardBindingFrDataTablePath' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, GamepadBindingDataTablePath) == 0x0000F8, "Member 'UVAltarUserInterfaceSettings::GamepadBindingDataTablePath' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, HelpDataTablePath) == 0x000118, "Member 'UVAltarUserInterfaceSettings::HelpDataTablePath' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, IconSelectionDataTablePath) == 0x000138, "Member 'UVAltarUserInterfaceSettings::IconSelectionDataTablePath' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, UserInterfaceIconsTexturesRootPath) == 0x000158, "Member 'UVAltarUserInterfaceSettings::UserInterfaceIconsTexturesRootPath' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, UserInterfaceGameDataIconsTexturesRootPath) == 0x000168, "Member 'UVAltarUserInterfaceSettings::UserInterfaceGameDataIconsTexturesRootPath' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, GamepadAxisDeadZone) == 0x000178, "Member 'UVAltarUserInterfaceSettings::GamepadAxisDeadZone' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, ThumbstickPressedTreshold) == 0x00017C, "Member 'UVAltarUserInterfaceSettings::ThumbstickPressedTreshold' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, SmallFontSizeDelta) == 0x000180, "Member 'UVAltarUserInterfaceSettings::SmallFontSizeDelta' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, LargeFontSizeDelta) == 0x000184, "Member 'UVAltarUserInterfaceSettings::LargeFontSizeDelta' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, FadeInDuration) == 0x000188, "Member 'UVAltarUserInterfaceSettings::FadeInDuration' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, FadeOutDuration) == 0x00018C, "Member 'UVAltarUserInterfaceSettings::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, FadeInExtraDurationInterior) == 0x000190, "Member 'UVAltarUserInterfaceSettings::FadeInExtraDurationInterior' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, FadeInExtraDurationSeamless) == 0x000194, "Member 'UVAltarUserInterfaceSettings::FadeInExtraDurationSeamless' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, FadeInExtraDurationFastTransition) == 0x000198, "Member 'UVAltarUserInterfaceSettings::FadeInExtraDurationFastTransition' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, FadeInExtraDurationPSOCompilation) == 0x00019C, "Member 'UVAltarUserInterfaceSettings::FadeInExtraDurationPSOCompilation' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, FadeInDurationUntilUnfreeze) == 0x0001A0, "Member 'UVAltarUserInterfaceSettings::FadeInDurationUntilUnfreeze' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, ChangeListNumber) == 0x0001A8, "Member 'UVAltarUserInterfaceSettings::ChangeListNumber' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, FromMainCL) == 0x0001B8, "Member 'UVAltarUserInterfaceSettings::FromMainCL' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, StreamName) == 0x0001C8, "Member 'UVAltarUserInterfaceSettings::StreamName' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, ProjectMajor) == 0x0001D8, "Member 'UVAltarUserInterfaceSettings::ProjectMajor' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, ProjectMinor) == 0x0001E8, "Member 'UVAltarUserInterfaceSettings::ProjectMinor' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, BackgroundLevelsToLoad) == 0x0001F8, "Member 'UVAltarUserInterfaceSettings::BackgroundLevelsToLoad' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, UserInterfaceSpecificMappingContext) == 0x000208, "Member 'UVAltarUserInterfaceSettings::UserInterfaceSpecificMappingContext' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, FogOfWarRenderTarget) == 0x000218, "Member 'UVAltarUserInterfaceSettings::FogOfWarRenderTarget' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, FogOfWarMaterial) == 0x000240, "Member 'UVAltarUserInterfaceSettings::FogOfWarMaterial' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, SceneDepthRenderTarget) == 0x000268, "Member 'UVAltarUserInterfaceSettings::SceneDepthRenderTarget' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, SecondPassRenderTarget) == 0x000290, "Member 'UVAltarUserInterfaceSettings::SecondPassRenderTarget' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, BaseColorRenderTarget) == 0x0002B8, "Member 'UVAltarUserInterfaceSettings::BaseColorRenderTarget' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, LocalMapMaterial) == 0x0002E0, "Member 'UVAltarUserInterfaceSettings::LocalMapMaterial' has a wrong offset!");
static_assert(offsetof(UVAltarUserInterfaceSettings, LocalMapSobelMaterial) == 0x000308, "Member 'UVAltarUserInterfaceSettings::LocalMapSobelMaterial' has a wrong offset!");

// Class Altar.VLegacyMagicMenuItem
// 0x0060 (0x0088 - 0x0028)
class UVLegacyMagicMenuItem final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const struct FLegacyMagicMenuItemProperties& Value);

	int32 GetInventoryIndex() const;
	const struct FLegacyMagicMenuItemProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMagicMenuItem">();
	}
	static class UVLegacyMagicMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMagicMenuItem>();
	}
};
static_assert(alignof(UVLegacyMagicMenuItem) == 0x000008, "Wrong alignment on UVLegacyMagicMenuItem");
static_assert(sizeof(UVLegacyMagicMenuItem) == 0x000088, "Wrong size on UVLegacyMagicMenuItem");

// Class Altar.VPointLight
// 0x0068 (0x0358 - 0x02F0)
class AVPointLight : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        MeshComponent;                                     // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnLightStatusChanged(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPointLight">();
	}
	static class AVPointLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPointLight>();
	}
};
static_assert(alignof(AVPointLight) == 0x000008, "Wrong alignment on AVPointLight");
static_assert(sizeof(AVPointLight) == 0x000358, "Wrong size on AVPointLight");
static_assert(offsetof(AVPointLight, TESRefComponent) == 0x000330, "Member 'AVPointLight::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVPointLight, TransformPairingComponent) == 0x000338, "Member 'AVPointLight::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVPointLight, MeshComponent) == 0x000340, "Member 'AVPointLight::MeshComponent' has a wrong offset!");
static_assert(offsetof(AVPointLight, PhysicsControllerComponent) == 0x000348, "Member 'AVPointLight::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVPointLight, AkAudioComponent) == 0x000350, "Member 'AVPointLight::AkAudioComponent' has a wrong offset!");

// Class Altar.VPotion
// 0x0068 (0x0358 - 0x02F0)
class AVPotion : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPotion">();
	}
	static class AVPotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPotion>();
	}
};
static_assert(alignof(AVPotion) == 0x000008, "Wrong alignment on AVPotion");
static_assert(sizeof(AVPotion) == 0x000358, "Wrong size on AVPotion");
static_assert(offsetof(AVPotion, TESRefComponent) == 0x000330, "Member 'AVPotion::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVPotion, TransformPairingComponent) == 0x000338, "Member 'AVPotion::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVPotion, StaticMeshComponent) == 0x000340, "Member 'AVPotion::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVPotion, PhysicsControllerComponent) == 0x000348, "Member 'AVPotion::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVPotion, AkAudioComponent) == 0x000350, "Member 'AVPotion::AkAudioComponent' has a wrong offset!");

// Class Altar.NiObjectNet
// 0x0030 (0x0068 - 0x0038)
class UNiObjectNet : public UNiObject
{
public:
	struct FNifString                             Name_0;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumExtraDataList;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiExtraData*>                   ExtraDataList;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UNiTimeController*                      Controller;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiObjectNet">();
	}
	static class UNiObjectNet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiObjectNet>();
	}
};
static_assert(alignof(UNiObjectNet) == 0x000008, "Wrong alignment on UNiObjectNet");
static_assert(sizeof(UNiObjectNet) == 0x000068, "Wrong size on UNiObjectNet");
static_assert(offsetof(UNiObjectNet, Name_0) == 0x000038, "Member 'UNiObjectNet::Name_0' has a wrong offset!");
static_assert(offsetof(UNiObjectNet, NumExtraDataList) == 0x000048, "Member 'UNiObjectNet::NumExtraDataList' has a wrong offset!");
static_assert(offsetof(UNiObjectNet, ExtraDataList) == 0x000050, "Member 'UNiObjectNet::ExtraDataList' has a wrong offset!");
static_assert(offsetof(UNiObjectNet, Controller) == 0x000060, "Member 'UNiObjectNet::Controller' has a wrong offset!");

// Class Altar.NiAvObject
// 0x0048 (0x00B0 - 0x0068)
class UNiAvObject : public UNiObjectNet
{
public:
	int32                                         Flags_0;                                           // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Translation;                                       // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UMatrix33*                              Rotation;                                          // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumProperties;                                     // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiProperty*>                    Properties;                                        // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UNiCollisionObject*                     CollisionObject;                                   // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiAvObject">();
	}
	static class UNiAvObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiAvObject>();
	}
};
static_assert(alignof(UNiAvObject) == 0x000008, "Wrong alignment on UNiAvObject");
static_assert(sizeof(UNiAvObject) == 0x0000B0, "Wrong size on UNiAvObject");
static_assert(offsetof(UNiAvObject, Flags_0) == 0x000068, "Member 'UNiAvObject::Flags_0' has a wrong offset!");
static_assert(offsetof(UNiAvObject, Translation) == 0x000070, "Member 'UNiAvObject::Translation' has a wrong offset!");
static_assert(offsetof(UNiAvObject, Rotation) == 0x000080, "Member 'UNiAvObject::Rotation' has a wrong offset!");
static_assert(offsetof(UNiAvObject, NumProperties) == 0x000088, "Member 'UNiAvObject::NumProperties' has a wrong offset!");
static_assert(offsetof(UNiAvObject, Scale) == 0x000090, "Member 'UNiAvObject::Scale' has a wrong offset!");
static_assert(offsetof(UNiAvObject, Properties) == 0x000098, "Member 'UNiAvObject::Properties' has a wrong offset!");
static_assert(offsetof(UNiAvObject, CollisionObject) == 0x0000A8, "Member 'UNiAvObject::CollisionObject' has a wrong offset!");

// Class Altar.NiGeometry
// 0x0010 (0x00C0 - 0x00B0)
class UNiGeometry : public UNiAvObject
{
public:
	class UNiGeometryData*                        Data;                                              // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiSkinInstance*                        SkinInstance;                                      // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiGeometry">();
	}
	static class UNiGeometry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiGeometry>();
	}
};
static_assert(alignof(UNiGeometry) == 0x000008, "Wrong alignment on UNiGeometry");
static_assert(sizeof(UNiGeometry) == 0x0000C0, "Wrong size on UNiGeometry");
static_assert(offsetof(UNiGeometry, Data) == 0x0000B0, "Member 'UNiGeometry::Data' has a wrong offset!");
static_assert(offsetof(UNiGeometry, SkinInstance) == 0x0000B8, "Member 'UNiGeometry::SkinInstance' has a wrong offset!");

// Class Altar.NiTriBasedGeom
// 0x0000 (0x00C0 - 0x00C0)
class UNiTriBasedGeom : public UNiGeometry
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTriBasedGeom">();
	}
	static class UNiTriBasedGeom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTriBasedGeom>();
	}
};
static_assert(alignof(UNiTriBasedGeom) == 0x000008, "Wrong alignment on UNiTriBasedGeom");
static_assert(sizeof(UNiTriBasedGeom) == 0x0000C0, "Wrong size on UNiTriBasedGeom");

// Class Altar.VBaseAltarSaveData
// 0x0008 (0x0030 - 0x0028)
class UVBaseAltarSaveData : public UObject
{
public:
	uint16                                        Version;                                           // 0x0028(0x0002)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBaseAltarSaveData">();
	}
	static class UVBaseAltarSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBaseAltarSaveData>();
	}
};
static_assert(alignof(UVBaseAltarSaveData) == 0x000008, "Wrong alignment on UVBaseAltarSaveData");
static_assert(sizeof(UVBaseAltarSaveData) == 0x000030, "Wrong size on UVBaseAltarSaveData");
static_assert(offsetof(UVBaseAltarSaveData, Version) == 0x000028, "Member 'UVBaseAltarSaveData::Version' has a wrong offset!");

// Class Altar.VCharacterPhenotypeData
// 0x02F0 (0x0320 - 0x0030)
class UVCharacterPhenotypeData final : public UVBaseAltarSaveData
{
public:
	class UVCharacterFaceMorphsSource*            FaceMorphsSource;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          FaceBaseMesh;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      FaceMorphValuesMap;                                // 0x0040(0x0050)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	class UVCharacterHairPiece_Hair*              Hair;                                              // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomisationHairIndex;                            // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVCharacterHairPiece_Eyebrows*          Eyebrows;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomisationEyebrowsIndex;                        // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVCharacterHairPiece_Mustache*          Mustache;                                          // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomisationMustacheIndex;                        // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVCharacterHairPiece_Beard*             Beard;                                             // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomisationBeardIndex;                           // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EVFacialHairType, struct FColor>         HairColors;                                        // 0x00D0(0x0050)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	TMap<EVFacialHairType, struct FLinearColor>   HairColorsL;                                       // 0x0120(0x0050)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	class UVCharacterSkinParameterDefinitions*    SkinParameterDefinitions;                          // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBodyProperties                        BodyProperties;                                    // 0x0178(0x0050)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, class UMaterialInterface*>  FaceMaterialSlotOverrides;                         // 0x01C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      SkinParametersMap;                                 // 0x0218(0x0050)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              SkinColorsMap;                                     // 0x0268(0x0050)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        SkinColorsMapL;                                    // 0x02B8(0x0050)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	int32                                         SenescenceLevel;                                   // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     EyeMaterial;                                       // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomisationEyeMaterialIndex;                     // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterPhenotypeData">();
	}
	static class UVCharacterPhenotypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterPhenotypeData>();
	}
};
static_assert(alignof(UVCharacterPhenotypeData) == 0x000008, "Wrong alignment on UVCharacterPhenotypeData");
static_assert(sizeof(UVCharacterPhenotypeData) == 0x000320, "Wrong size on UVCharacterPhenotypeData");
static_assert(offsetof(UVCharacterPhenotypeData, FaceMorphsSource) == 0x000030, "Member 'UVCharacterPhenotypeData::FaceMorphsSource' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, FaceBaseMesh) == 0x000038, "Member 'UVCharacterPhenotypeData::FaceBaseMesh' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, FaceMorphValuesMap) == 0x000040, "Member 'UVCharacterPhenotypeData::FaceMorphValuesMap' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, Hair) == 0x000090, "Member 'UVCharacterPhenotypeData::Hair' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, CustomisationHairIndex) == 0x000098, "Member 'UVCharacterPhenotypeData::CustomisationHairIndex' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, Eyebrows) == 0x0000A0, "Member 'UVCharacterPhenotypeData::Eyebrows' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, CustomisationEyebrowsIndex) == 0x0000A8, "Member 'UVCharacterPhenotypeData::CustomisationEyebrowsIndex' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, Mustache) == 0x0000B0, "Member 'UVCharacterPhenotypeData::Mustache' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, CustomisationMustacheIndex) == 0x0000B8, "Member 'UVCharacterPhenotypeData::CustomisationMustacheIndex' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, Beard) == 0x0000C0, "Member 'UVCharacterPhenotypeData::Beard' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, CustomisationBeardIndex) == 0x0000C8, "Member 'UVCharacterPhenotypeData::CustomisationBeardIndex' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, HairColors) == 0x0000D0, "Member 'UVCharacterPhenotypeData::HairColors' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, HairColorsL) == 0x000120, "Member 'UVCharacterPhenotypeData::HairColorsL' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, SkinParameterDefinitions) == 0x000170, "Member 'UVCharacterPhenotypeData::SkinParameterDefinitions' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, BodyProperties) == 0x000178, "Member 'UVCharacterPhenotypeData::BodyProperties' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, FaceMaterialSlotOverrides) == 0x0001C8, "Member 'UVCharacterPhenotypeData::FaceMaterialSlotOverrides' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, SkinParametersMap) == 0x000218, "Member 'UVCharacterPhenotypeData::SkinParametersMap' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, SkinColorsMap) == 0x000268, "Member 'UVCharacterPhenotypeData::SkinColorsMap' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, SkinColorsMapL) == 0x0002B8, "Member 'UVCharacterPhenotypeData::SkinColorsMapL' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, SenescenceLevel) == 0x000308, "Member 'UVCharacterPhenotypeData::SenescenceLevel' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, EyeMaterial) == 0x000310, "Member 'UVCharacterPhenotypeData::EyeMaterial' has a wrong offset!");
static_assert(offsetof(UVCharacterPhenotypeData, CustomisationEyeMaterialIndex) == 0x000318, "Member 'UVCharacterPhenotypeData::CustomisationEyeMaterialIndex' has a wrong offset!");

// Class Altar.VSigilStone
// 0x0068 (0x0358 - 0x02F0)
class AVSigilStone final : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSigilStone">();
	}
	static class AVSigilStone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVSigilStone>();
	}
};
static_assert(alignof(AVSigilStone) == 0x000008, "Wrong alignment on AVSigilStone");
static_assert(sizeof(AVSigilStone) == 0x000358, "Wrong size on AVSigilStone");
static_assert(offsetof(AVSigilStone, TESRefComponent) == 0x000330, "Member 'AVSigilStone::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVSigilStone, TransformPairingComponent) == 0x000338, "Member 'AVSigilStone::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVSigilStone, StaticMeshComponent) == 0x000340, "Member 'AVSigilStone::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVSigilStone, PhysicsControllerComponent) == 0x000348, "Member 'AVSigilStone::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVSigilStone, AkAudioComponent) == 0x000350, "Member 'AVSigilStone::AkAudioComponent' has a wrong offset!");

// Class Altar.VAIProcedureExecution_ESCORT
// 0x0008 (0x0048 - 0x0040)
class UVAIProcedureExecution_ESCORT final : public UVAIProcedureExecution_Base
{
public:
	class UVAIProcedureExecution_TRAVEL*          InternalTravelProcedure;                           // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_ESCORT">();
	}
	static class UVAIProcedureExecution_ESCORT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_ESCORT>();
	}
};
static_assert(alignof(UVAIProcedureExecution_ESCORT) == 0x000008, "Wrong alignment on UVAIProcedureExecution_ESCORT");
static_assert(sizeof(UVAIProcedureExecution_ESCORT) == 0x000048, "Wrong size on UVAIProcedureExecution_ESCORT");
static_assert(offsetof(UVAIProcedureExecution_ESCORT, InternalTravelProcedure) == 0x000040, "Member 'UVAIProcedureExecution_ESCORT::InternalTravelProcedure' has a wrong offset!");

// Class Altar.AnimationBlendUserData
// 0x0008 (0x0030 - 0x0028)
class UAnimationBlendUserData final : public UAssetUserData
{
public:
	int32                                         BlendFrame;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationBlendUserData">();
	}
	static class UAnimationBlendUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationBlendUserData>();
	}
};
static_assert(alignof(UAnimationBlendUserData) == 0x000008, "Wrong alignment on UAnimationBlendUserData");
static_assert(sizeof(UAnimationBlendUserData) == 0x000030, "Wrong size on UAnimationBlendUserData");
static_assert(offsetof(UAnimationBlendUserData, BlendFrame) == 0x000028, "Member 'UAnimationBlendUserData::BlendFrame' has a wrong offset!");

// Class Altar.VSoulGem
// 0x0068 (0x0358 - 0x02F0)
class AVSoulGem : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSoulGem">();
	}
	static class AVSoulGem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVSoulGem>();
	}
};
static_assert(alignof(AVSoulGem) == 0x000008, "Wrong alignment on AVSoulGem");
static_assert(sizeof(AVSoulGem) == 0x000358, "Wrong size on AVSoulGem");
static_assert(offsetof(AVSoulGem, TESRefComponent) == 0x000330, "Member 'AVSoulGem::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVSoulGem, TransformPairingComponent) == 0x000338, "Member 'AVSoulGem::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVSoulGem, StaticMeshComponent) == 0x000340, "Member 'AVSoulGem::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVSoulGem, PhysicsControllerComponent) == 0x000348, "Member 'AVSoulGem::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVSoulGem, AkAudioComponent) == 0x000350, "Member 'AVSoulGem::AkAudioComponent' has a wrong offset!");

// Class Altar.TESObjectSTAT
// 0x0050 (0x01E0 - 0x0190)
class UTESObjectSTAT final : public UTESBoundObject
{
public:
	TSoftObjectPtr<class UAnimBlueprint>          PosePairingAnimBlueprint;                          // 0x0190(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01B8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectSTAT">();
	}
	static class UTESObjectSTAT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectSTAT>();
	}
};
static_assert(alignof(UTESObjectSTAT) == 0x000008, "Wrong alignment on UTESObjectSTAT");
static_assert(sizeof(UTESObjectSTAT) == 0x0001E0, "Wrong size on UTESObjectSTAT");
static_assert(offsetof(UTESObjectSTAT, PosePairingAnimBlueprint) == 0x000190, "Member 'UTESObjectSTAT::PosePairingAnimBlueprint' has a wrong offset!");
static_assert(offsetof(UTESObjectSTAT, NewMesh) == 0x0001B8, "Member 'UTESObjectSTAT::NewMesh' has a wrong offset!");

// Class Altar.VSound
// 0x0060 (0x0350 - 0x02F0)
class AVSound final : public AVActor
{
public:
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        AudioComponent;                                    // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTESSoundData                          SoundData;                                         // 0x0310(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bOverrideSoundData;                                // 0x0328(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         OverridenMinAttenuationDistance;                   // 0x0329(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         OverridenMaxAttenuationDistance;                   // 0x032A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32B[0x5];                                      // 0x032B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         OverridenFlags;                                    // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OverridenAttenuation;                              // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundWave*                             SoundWaveRef;                                      // 0x0340(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             DefaultAmbientSoundCue;                            // 0x0348(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ResetSoundData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSound">();
	}
	static class AVSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVSound>();
	}
};
static_assert(alignof(AVSound) == 0x000008, "Wrong alignment on AVSound");
static_assert(sizeof(AVSound) == 0x000350, "Wrong size on AVSound");
static_assert(offsetof(AVSound, TESRefComponent) == 0x0002F8, "Member 'AVSound::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVSound, TransformPairingComponent) == 0x000300, "Member 'AVSound::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVSound, AudioComponent) == 0x000308, "Member 'AVSound::AudioComponent' has a wrong offset!");
static_assert(offsetof(AVSound, SoundData) == 0x000310, "Member 'AVSound::SoundData' has a wrong offset!");
static_assert(offsetof(AVSound, bOverrideSoundData) == 0x000328, "Member 'AVSound::bOverrideSoundData' has a wrong offset!");
static_assert(offsetof(AVSound, OverridenMinAttenuationDistance) == 0x000329, "Member 'AVSound::OverridenMinAttenuationDistance' has a wrong offset!");
static_assert(offsetof(AVSound, OverridenMaxAttenuationDistance) == 0x00032A, "Member 'AVSound::OverridenMaxAttenuationDistance' has a wrong offset!");
static_assert(offsetof(AVSound, OverridenFlags) == 0x000330, "Member 'AVSound::OverridenFlags' has a wrong offset!");
static_assert(offsetof(AVSound, OverridenAttenuation) == 0x000338, "Member 'AVSound::OverridenAttenuation' has a wrong offset!");
static_assert(offsetof(AVSound, SoundWaveRef) == 0x000340, "Member 'AVSound::SoundWaveRef' has a wrong offset!");
static_assert(offsetof(AVSound, DefaultAmbientSoundCue) == 0x000348, "Member 'AVSound::DefaultAmbientSoundCue' has a wrong offset!");

// Class Altar.VLegacyXboxHintContainer
// 0x0000 (0x04C8 - 0x04C8)
class UVLegacyXboxHintContainer final : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyXboxHintContainer">();
	}
	static class UVLegacyXboxHintContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyXboxHintContainer>();
	}
};
static_assert(alignof(UVLegacyXboxHintContainer) == 0x000008, "Wrong alignment on UVLegacyXboxHintContainer");
static_assert(sizeof(UVLegacyXboxHintContainer) == 0x0004C8, "Wrong size on UVLegacyXboxHintContainer");

// Class Altar.NiPSysEmitter
// 0x0030 (0x0090 - 0x0060)
class UNiPSysEmitter : public UNiPSysModifier
{
public:
	float                                         Speed;                                             // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedVariation;                                    // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Declination;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeclinationVariation;                              // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlanarAngle;                                       // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlanarAngleVariation;                              // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 InitialColor;                                      // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusVariation;                                   // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpanVariation;                                 // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysEmitter">();
	}
	static class UNiPSysEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysEmitter>();
	}
};
static_assert(alignof(UNiPSysEmitter) == 0x000008, "Wrong alignment on UNiPSysEmitter");
static_assert(sizeof(UNiPSysEmitter) == 0x000090, "Wrong size on UNiPSysEmitter");
static_assert(offsetof(UNiPSysEmitter, Speed) == 0x000060, "Member 'UNiPSysEmitter::Speed' has a wrong offset!");
static_assert(offsetof(UNiPSysEmitter, SpeedVariation) == 0x000064, "Member 'UNiPSysEmitter::SpeedVariation' has a wrong offset!");
static_assert(offsetof(UNiPSysEmitter, Declination) == 0x000068, "Member 'UNiPSysEmitter::Declination' has a wrong offset!");
static_assert(offsetof(UNiPSysEmitter, DeclinationVariation) == 0x00006C, "Member 'UNiPSysEmitter::DeclinationVariation' has a wrong offset!");
static_assert(offsetof(UNiPSysEmitter, PlanarAngle) == 0x000070, "Member 'UNiPSysEmitter::PlanarAngle' has a wrong offset!");
static_assert(offsetof(UNiPSysEmitter, PlanarAngleVariation) == 0x000074, "Member 'UNiPSysEmitter::PlanarAngleVariation' has a wrong offset!");
static_assert(offsetof(UNiPSysEmitter, InitialColor) == 0x000078, "Member 'UNiPSysEmitter::InitialColor' has a wrong offset!");
static_assert(offsetof(UNiPSysEmitter, Radius) == 0x00007C, "Member 'UNiPSysEmitter::Radius' has a wrong offset!");
static_assert(offsetof(UNiPSysEmitter, RadiusVariation) == 0x000080, "Member 'UNiPSysEmitter::RadiusVariation' has a wrong offset!");
static_assert(offsetof(UNiPSysEmitter, LifeSpan) == 0x000084, "Member 'UNiPSysEmitter::LifeSpan' has a wrong offset!");
static_assert(offsetof(UNiPSysEmitter, LifeSpanVariation) == 0x000088, "Member 'UNiPSysEmitter::LifeSpanVariation' has a wrong offset!");

// Class Altar.NiPSysVolumeEmitter
// 0x0008 (0x0098 - 0x0090)
class UNiPSysVolumeEmitter : public UNiPSysEmitter
{
public:
	class UNiNode*                                EmitterObject;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysVolumeEmitter">();
	}
	static class UNiPSysVolumeEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysVolumeEmitter>();
	}
};
static_assert(alignof(UNiPSysVolumeEmitter) == 0x000008, "Wrong alignment on UNiPSysVolumeEmitter");
static_assert(sizeof(UNiPSysVolumeEmitter) == 0x000098, "Wrong size on UNiPSysVolumeEmitter");
static_assert(offsetof(UNiPSysVolumeEmitter, EmitterObject) == 0x000090, "Member 'UNiPSysVolumeEmitter::EmitterObject' has a wrong offset!");

// Class Altar.NiPSysSphereEmitter
// 0x0008 (0x00A0 - 0x0098)
class UNiPSysSphereEmitter final : public UNiPSysVolumeEmitter
{
public:
	float                                         EmitterRadius;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysSphereEmitter">();
	}
	static class UNiPSysSphereEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysSphereEmitter>();
	}
};
static_assert(alignof(UNiPSysSphereEmitter) == 0x000008, "Wrong alignment on UNiPSysSphereEmitter");
static_assert(sizeof(UNiPSysSphereEmitter) == 0x0000A0, "Wrong size on UNiPSysSphereEmitter");
static_assert(offsetof(UNiPSysSphereEmitter, EmitterRadius) == 0x000098, "Member 'UNiPSysSphereEmitter::EmitterRadius' has a wrong offset!");

// Class Altar.VStatic
// 0x0058 (0x0348 - 0x02F0)
class AVStatic : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        MeshComponent;                                     // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnMagicEffectOnMarker(const class FString& VFXName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStatic">();
	}
	static class AVStatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVStatic>();
	}
};
static_assert(alignof(AVStatic) == 0x000008, "Wrong alignment on AVStatic");
static_assert(sizeof(AVStatic) == 0x000348, "Wrong size on AVStatic");
static_assert(offsetof(AVStatic, TESRefComponent) == 0x000330, "Member 'AVStatic::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVStatic, MeshComponent) == 0x000338, "Member 'AVStatic::MeshComponent' has a wrong offset!");
static_assert(offsetof(AVStatic, PhysicsControllerComponent) == 0x000340, "Member 'AVStatic::PhysicsControllerComponent' has a wrong offset!");

// Class Altar.VSubSpace
// 0x0010 (0x0300 - 0x02F0)
class AVSubSpace final : public AVActor
{
public:
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVSubSpaceComponent*                    SubSpaceComponent;                                 // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSubSpace">();
	}
	static class AVSubSpace* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVSubSpace>();
	}
};
static_assert(alignof(AVSubSpace) == 0x000008, "Wrong alignment on AVSubSpace");
static_assert(sizeof(AVSubSpace) == 0x000300, "Wrong size on AVSubSpace");
static_assert(offsetof(AVSubSpace, TESRefComponent) == 0x0002F0, "Member 'AVSubSpace::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVSubSpace, SubSpaceComponent) == 0x0002F8, "Member 'AVSubSpace::SubSpaceComponent' has a wrong offset!");

// Class Altar.VAltarPlayerController
// 0x01F8 (0x0A50 - 0x0858)
class AVAltarPlayerController : public APlayerController
{
public:
	float                                         FirstPersonViewSensitivity;                        // 0x0858(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonViewSensitivity;                        // 0x085C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewSensitivity;                                   // 0x0860(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CursorSensitivity;                                 // 0x0864(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadSensitivityScale;                           // 0x0868(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstPersonCameraVerticalSensitivityScale;         // 0x086C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonCameraVerticalSensitivityScale;         // 0x0870(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstPersonCameraHorizontalSensitivityScale;       // 0x0874(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonCameraHorizontalSensitivityScale;       // 0x0878(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocomotionDebugModeEnabled;                     // 0x087C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87D[0x1B];                                     // 0x087D(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AVPairedPawn*>                     HostileAIs;                                        // 0x0898(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               FirstPersonRotationRate;                           // 0x08E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               ThirdPersonRotationRate;                           // 0x0900(0x0018)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   LookAtHeadSocketName1;                             // 0x0918(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LookAtHeadSocketName2;                             // 0x0920(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AVPairedPawn>            CameraTrackingTarget;                              // 0x0928(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraTrackingPeriod;                              // 0x0930(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraTrackingDuration;                            // 0x0934(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraTrackingRampUpEndThreshold;                  // 0x0938(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraTrackingRampDownStartThreshold;              // 0x093C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UCurveFloat>             CameraTrackingRampUpSpeedMultiplierCurve;          // 0x0940(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UCurveFloat>             CameraTrackingRampDownSpeedMultiplierCurve;        // 0x0948(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraTrackingExtraSpeedMultiplier;                // 0x0950(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseAllAxisOnCameraTracking;                       // 0x0954(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_955[0x3];                                      // 0x0955(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraTrackingBaseSpeed;                           // 0x0958(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_95C[0x14];                                     // 0x095C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UDebugMenuWidget*                       DebugMenuWidget;                                   // 0x0970(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPOVChangeLocked;                                // 0x0978(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInputBridgePuppetting;                            // 0x0979(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVPlayerPOVType                               POV;                                               // 0x097A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_97B[0x1];                                      // 0x097B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EVPlayerPOVType                               WantedPOV;                                         // 0x097C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_97D[0x93];                                     // 0x097D(0x0093)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TrackedTargets[0x5];                               // 0x0A10(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A38[0x8];                                      // 0x0A38(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDebugMenuWidget>           DamageLogWidgetClass;                              // 0x0A40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugMenuWidget*                       DamageLogWidget;                                   // 0x0A48(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ActivateUITexturePairing();
	void DeactivateUITexturePairing();
	void DisplayPerformanceDebugInfo();
	void EnterVanityCamera();
	void ExitVanityCamera();
	class AVPairedPawn* FindCameraTrackingTarget(float MaxAngleDegrees, float MinDistance, float MaxDistance, const TArray<class AVPairedPawn*>& PotentialTargets);
	void ForceAndLockPOV(EVPlayerPOVType TargetPOV);
	void OnConsoleActivationStateChanged(bool Activated);
	void OnJumpPressed(const struct FInputActionValue& Value);
	void OnLocomotionDebugModeActivated();
	void OnLocomotionDebugModeDeactivated();
	void OnUITexturePairingActivated();
	void OnUITexturePairingDeactivated();
	void RequestQuickLoad();
	void SetControllerDesiredRotationRate(const struct FRotator& FirstPersonDesiredRotationRate, const struct FRotator& ThirdPersonDesiredRotationRate);
	void SetIsNewGameLoadingFromMainMenu(bool bShouldBeNewGameLoadingFromMainMenu);
	void SetLeftThumbStickPressed();
	void SetLeftThumbStickReleased();
	void SetRightThumbStickPressed();
	void SetRightThumbStickReleased();
	void StartAimingCrosshairAnimation(bool bIsDrawing);
	void StartCameraTrackingOnPawn(class AVPairedPawn* Target, float Duration, float SpeedMultiplier, float RampUpEndThreshold, float RampDownStartThreshold, class UCurveFloat* RampUpSpeedMultiplierCurve, class UCurveFloat* RampDownSpeedMultiplierCurve, bool AllAxis);
	void StopCameraTracking();
	void SwitchPOV(EVPlayerPOVType TargetPOV, bool bSetToNewDefaultState);
	void ToggleDoCsvProfile();
	void ToggleFPSChart();
	void ToggleOblivionWindow();
	void TogglePrimaryGameLayoutDisplay();
	void ToggleShowFPSDebugInfo(bool bShow);
	void ToggleShowVRAMDebugInfo(bool bShow);
	void ToggleUITexturePairing();
	void UnlockAndRestorePOV();

	float GetDesiredFOVDialogue() const;
	class AActor* GetGameplayCamera() const;
	struct FRotator GetLastInputRotation() const;
	struct FRotator GetLookAtRotationDialogue() const;
	class AVOblivionPlayerCharacter* GetPlayerCharacter() const;
	bool IsHorseRiding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarPlayerController">();
	}
	static class AVAltarPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAltarPlayerController>();
	}
};
static_assert(alignof(AVAltarPlayerController) == 0x000008, "Wrong alignment on AVAltarPlayerController");
static_assert(sizeof(AVAltarPlayerController) == 0x000A50, "Wrong size on AVAltarPlayerController");
static_assert(offsetof(AVAltarPlayerController, FirstPersonViewSensitivity) == 0x000858, "Member 'AVAltarPlayerController::FirstPersonViewSensitivity' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, ThirdPersonViewSensitivity) == 0x00085C, "Member 'AVAltarPlayerController::ThirdPersonViewSensitivity' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, ViewSensitivity) == 0x000860, "Member 'AVAltarPlayerController::ViewSensitivity' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, CursorSensitivity) == 0x000864, "Member 'AVAltarPlayerController::CursorSensitivity' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, GamepadSensitivityScale) == 0x000868, "Member 'AVAltarPlayerController::GamepadSensitivityScale' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, FirstPersonCameraVerticalSensitivityScale) == 0x00086C, "Member 'AVAltarPlayerController::FirstPersonCameraVerticalSensitivityScale' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, ThirdPersonCameraVerticalSensitivityScale) == 0x000870, "Member 'AVAltarPlayerController::ThirdPersonCameraVerticalSensitivityScale' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, FirstPersonCameraHorizontalSensitivityScale) == 0x000874, "Member 'AVAltarPlayerController::FirstPersonCameraHorizontalSensitivityScale' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, ThirdPersonCameraHorizontalSensitivityScale) == 0x000878, "Member 'AVAltarPlayerController::ThirdPersonCameraHorizontalSensitivityScale' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, bIsLocomotionDebugModeEnabled) == 0x00087C, "Member 'AVAltarPlayerController::bIsLocomotionDebugModeEnabled' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, HostileAIs) == 0x000898, "Member 'AVAltarPlayerController::HostileAIs' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, FirstPersonRotationRate) == 0x0008E8, "Member 'AVAltarPlayerController::FirstPersonRotationRate' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, ThirdPersonRotationRate) == 0x000900, "Member 'AVAltarPlayerController::ThirdPersonRotationRate' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, LookAtHeadSocketName1) == 0x000918, "Member 'AVAltarPlayerController::LookAtHeadSocketName1' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, LookAtHeadSocketName2) == 0x000920, "Member 'AVAltarPlayerController::LookAtHeadSocketName2' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, CameraTrackingTarget) == 0x000928, "Member 'AVAltarPlayerController::CameraTrackingTarget' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, CameraTrackingPeriod) == 0x000930, "Member 'AVAltarPlayerController::CameraTrackingPeriod' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, CameraTrackingDuration) == 0x000934, "Member 'AVAltarPlayerController::CameraTrackingDuration' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, CameraTrackingRampUpEndThreshold) == 0x000938, "Member 'AVAltarPlayerController::CameraTrackingRampUpEndThreshold' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, CameraTrackingRampDownStartThreshold) == 0x00093C, "Member 'AVAltarPlayerController::CameraTrackingRampDownStartThreshold' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, CameraTrackingRampUpSpeedMultiplierCurve) == 0x000940, "Member 'AVAltarPlayerController::CameraTrackingRampUpSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, CameraTrackingRampDownSpeedMultiplierCurve) == 0x000948, "Member 'AVAltarPlayerController::CameraTrackingRampDownSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, CameraTrackingExtraSpeedMultiplier) == 0x000950, "Member 'AVAltarPlayerController::CameraTrackingExtraSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, bUseAllAxisOnCameraTracking) == 0x000954, "Member 'AVAltarPlayerController::bUseAllAxisOnCameraTracking' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, CameraTrackingBaseSpeed) == 0x000958, "Member 'AVAltarPlayerController::CameraTrackingBaseSpeed' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, DebugMenuWidget) == 0x000970, "Member 'AVAltarPlayerController::DebugMenuWidget' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, bIsPOVChangeLocked) == 0x000978, "Member 'AVAltarPlayerController::bIsPOVChangeLocked' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, bInputBridgePuppetting) == 0x000979, "Member 'AVAltarPlayerController::bInputBridgePuppetting' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, POV) == 0x00097A, "Member 'AVAltarPlayerController::POV' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, WantedPOV) == 0x00097C, "Member 'AVAltarPlayerController::WantedPOV' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, TrackedTargets) == 0x000A10, "Member 'AVAltarPlayerController::TrackedTargets' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, DamageLogWidgetClass) == 0x000A40, "Member 'AVAltarPlayerController::DamageLogWidgetClass' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerController, DamageLogWidget) == 0x000A48, "Member 'AVAltarPlayerController::DamageLogWidget' has a wrong offset!");

// Class Altar.VEnhancedAltarPlayerController
// 0x0368 (0x0DB8 - 0x0A50)
class AVEnhancedAltarPlayerController : public AVAltarPlayerController
{
public:
	uint8                                         Pad_A50[0x10];                                     // 0x0A50(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CurrentRawMoveAxis;                                // 0x0A60(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentRawMoveInputLength;                         // 0x0A70(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A74[0x4];                                      // 0x0A74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CurrentMoveAxis;                                   // 0x0A78(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CurrentMoveInputDirection;                         // 0x0A88(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentMoveInputLength;                            // 0x0A98(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentMoveInputLengthBeforeScaling;               // 0x0A9C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA0[0x4];                                      // 0x0AA0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PowerAttackInputTime;                              // 0x0AA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAlignCameraTurnSpeedScale;                     // 0x0AA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorseAutoAlignCameraAngleThreshold;                // 0x0AAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorseAutoAlignCameraDelay;                         // 0x0AB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB4[0x4];                                      // 0x0AB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnSwitchToUserInterfaceMappings;                   // 0x0AB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSwitchToGameInputMappings;                       // 0x0AC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	float                                         SprintMinYMovementInput;                           // 0x0AD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintMaxYMovementInput;                           // 0x0ADC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintMinXMovementInput;                           // 0x0AE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintXThresholdToForceDeactivation;               // 0x0AE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveInputReleaseTimerBeforeDisablingSprintAndGallop; // 0x0AE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GallopMinYMovementInput;                           // 0x0AEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GallopMaxYMovementInput;                           // 0x0AF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GallopMinXMovementInput;                           // 0x0AF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GallopXThresholdToForceDeactivation;               // 0x0AF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AFC[0x4];                                      // 0x0AFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          QuickSaveLoadEvent;                                // 0x0B00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputMappingContext*                   DefaultMappingContext;                             // 0x0B08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           MouseWheelInputAction;                             // 0x0B10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ToggleCharacterMenuInputAction;                    // 0x0B18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           OpenRestMenuInputAction;                           // 0x0B20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           OpenOptionsMenuInputAction;                        // 0x0B28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           OpenStatsMenuInputAction;                          // 0x0B30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           OpenInventoryMenuInputAction;                      // 0x0B38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           OpenMagicMenuInputAction;                          // 0x0B40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           OpenMapMenuInputAction;                            // 0x0B48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           OpenQuestMenuInputAction;                          // 0x0B50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           OpenHelpMenuInputAction;                           // 0x0B58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           QuickSaveInputAction;                              // 0x0B60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           QuickLoadInputAction;                              // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputMappingContext*                   MovementMappingContext;                            // 0x0B70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           MovementForwardInputAction;                        // 0x0B78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           MovementBackwardInputAction;                       // 0x0B80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           MovementLeftInputAction;                           // 0x0B88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           MovementRightInputAction;                          // 0x0B90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           TurnInputAction;                                   // 0x0B98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           LookUpInputAction;                                 // 0x0BA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           AutoMoveInputAction;                               // 0x0BA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           JumpInputAction;                                   // 0x0BB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           CrouchInputAction;                                 // 0x0BB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ToggleWalkInputAction;                             // 0x0BC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           SprintInputAction;                                 // 0x0BC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           HorseWalkInputAction;                              // 0x0BD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           HorseGallopInputAction;                            // 0x0BD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ShiftKeyInputAction;                               // 0x0BE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputMappingContext*                   CombatActionsMappingContext;                       // 0x0BE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           AttackInputAction;                                 // 0x0BF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           BlockInputAction;                                  // 0x0BF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           CastInputAction;                                   // 0x0C00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ReadyItemInputAction;                              // 0x0C08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           UndrawBowInputAction;                              // 0x0C10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputMappingContext*                   TelekinesisMappingContext;                         // 0x0C18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           PushItemInputAction;                               // 0x0C20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           PullItemInputAction;                               // 0x0C28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ReleaseItemInputAction;                            // 0x0C30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           LaunchItemInputAction;                             // 0x0C38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           DrawWhileTelekinesisInputAction;                   // 0x0C40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           UndrawWhileTelekinesisInputAction;                 // 0x0C48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputMappingContext*                   ActionsMappingContext;                             // 0x0C50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ActivateInputAction;                               // 0x0C58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           TogglePOVInputAction;                              // 0x0C60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           GrabInputAction;                                   // 0x0C68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputMappingContext*                   QuickKeysMappingContext;                           // 0x0C70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           QuickMenuInputAction;                              // 0x0C78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick1InputAction_Gamepad;                         // 0x0C80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick2InputAction_Gamepad;                         // 0x0C88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick3InputAction_Gamepad;                         // 0x0C90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick4InputAction_Gamepad;                         // 0x0C98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick5InputAction_Gamepad;                         // 0x0CA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick6InputAction_Gamepad;                         // 0x0CA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick7InputAction_Gamepad;                         // 0x0CB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick8InputAction_Gamepad;                         // 0x0CB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick1InputAction_Keyboard;                        // 0x0CC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick2InputAction_Keyboard;                        // 0x0CC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick3InputAction_Keyboard;                        // 0x0CD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick4InputAction_Keyboard;                        // 0x0CD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick5InputAction_Keyboard;                        // 0x0CE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick6InputAction_Keyboard;                        // 0x0CE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick7InputAction_Keyboard;                        // 0x0CF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           Quick8InputAction_Keyboard;                        // 0x0CF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputMappingContext*                   DebugMappingContext;                               // 0x0D00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ToggleUITexturePairingInputAction;                 // 0x0D08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           TogglePrimaryGameLayoutDisplayInputAction;         // 0x0D10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ShowDebugMenuInputAction;                          // 0x0D18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ShowPerformanceDebugInfoAction;                    // 0x0D20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ToggleDoCsvProfileAction;                          // 0x0D28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputAction*                           ToggleFPSChartAction;                              // 0x0D30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D38[0x80];                                     // 0x0D38(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateInput_Pressed();
	void ActivateInput_Released();
	void AttackInput_Pressed();
	void AttackInput_Released();
	void AutoMoveInput_Pressed();
	void BlockInput_Pressed();
	void BlockInput_Released();
	void BP_FlushPressedKeys();
	void CastInput_Pressed();
	void CastInput_Released();
	void CrouchInput_Pressed();
	void CrouchInput_Released();
	void DisableAutoMoveToggle();
	void DisableGallopToggle();
	void DisableSneakToggle();
	void DisableSprintToggle();
	void DisableWalkToggle();
	void HandleDeviceConnectionChange(EInputDeviceConnectionState NewConnectionState, const struct FPlatformUserId& PlatformUserId, const struct FInputDeviceId& InputDeviceId);
	bool IsWalking();
	void LookUpInput(const struct FInputActionValue& Value);
	void LookUpInputCompleted();
	void MouseWheelUpInput(const struct FInputActionValue& Value);
	void MovementBackwardInput_Pressed(const struct FInputActionValue& Value);
	void MovementBackwardInput_Released();
	void MovementForwardInput_Pressed(const struct FInputActionValue& Value);
	void MovementForwardInput_Released();
	void MovementLeftInput_Pressed(const struct FInputActionValue& Value);
	void MovementLeftInput_Released();
	void MovementRightInput_Pressed(const struct FInputActionValue& Value);
	void MovementRightInput_Released();
	void OnAttackRequestPressed();
	void OnAttackRequestReleased();
	void OnDrawWeaponReleased();
	void OnLoadFinished();
	void OnLoadStarted();
	void OnUndrawBowReleased();
	void OpenHelpMenuInput_Pressed();
	void OpenHelpMenuInput_Released();
	void OpenInventoryMenuInput_Pressed();
	void OpenInventoryMenuInput_Released();
	void OpenMagicMenuInput_Pressed();
	void OpenMagicMenuInput_Released();
	void OpenMapMenuInput_Pressed();
	void OpenMapMenuInput_Released();
	void OpenOptionsMenuInput_Pressed();
	void OpenOptionsMenuInput_Released();
	void OpenQuestMenuInput_Pressed();
	void OpenQuestMenuInput_Released();
	void OpenRestMenuInput_Pressed();
	void OpenRestMenuInput_Released();
	void OpenStatsMenuInput_Pressed();
	void OpenStatsMenuInput_Released();
	void Quick1Input_Pressed();
	void Quick1Input_Released();
	void Quick2Input_Pressed();
	void Quick2Input_Released();
	void Quick3Input_Pressed();
	void Quick3Input_Released();
	void Quick4Input_Pressed();
	void Quick4Input_Released();
	void Quick5Input_Pressed();
	void Quick5Input_Released();
	void Quick6Input_Pressed();
	void Quick6Input_Released();
	void Quick7Input_Pressed();
	void Quick7Input_Released();
	void Quick8Input_Pressed();
	void Quick8Input_Released();
	void QuickLoadInput_Pressed();
	void QuickLoadInput_Released();
	void QuickMenuInput_Pressed();
	void QuickMenuInput_Released();
	void QuickSaveInput_Pressed();
	void QuickSaveInput_Released();
	void ReadyItemInput_Pressed();
	void ReadyItemInput_Released();
	void ReleaseAllQuickInputs();
	void ReleaseGrab();
	void SetBlockFlushPressedKeys(bool NewBlockFlushPressedKeys);
	void ShiftKeyInput_Pressed();
	void ShiftKeyInput_Released();
	void ShowDebugMenu();
	void SwitchToGameInputMappings();
	void SwitchToUserInterfaceInputMapping(bool bDoRemoveQuickKeysInputMapping);
	void TelekinesisLaunchItem();
	void TelekinesisReleaseItem();
	void TelekinesisTryToPullItem_Pressed();
	void TelekinesisTryToPullItem_Released();
	void TelekinesisTryToPushItem_Pressed();
	void TelekinesisTryToPushItem_Released();
	void ToggleBlockPressed();
	void ToggleBlockReleased();
	void ToggleCharacterMenuInput_Pressed();
	void ToggleCharacterMenuInput_Released();
	void ToggleDrawWeaponPressed();
	void ToggleDrawWeaponReleased();
	void ToggleGallop(const struct FInputActionValue& Value);
	void ToggleGrabPressed();
	void ToggleHorseWalk(const struct FInputActionValue& Value);
	void TogglePOVInput_Pressed();
	void TogglePOVInput_Released();
	void ToggleSneak(const struct FInputActionValue& Value);
	void ToggleSpellCastPressed();
	void ToggleSprint(const struct FInputActionValue& Value);
	void ToggleWalk(const struct FInputActionValue& Value);
	void TurnInput(const struct FInputActionValue& Value);
	void TurnInputCompleted();

	bool GetWantsToGallop() const;
	bool GetWantsToSprint() const;
	bool IsInGameConfiguration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEnhancedAltarPlayerController">();
	}
	static class AVEnhancedAltarPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVEnhancedAltarPlayerController>();
	}
};
static_assert(alignof(AVEnhancedAltarPlayerController) == 0x000008, "Wrong alignment on AVEnhancedAltarPlayerController");
static_assert(sizeof(AVEnhancedAltarPlayerController) == 0x000DB8, "Wrong size on AVEnhancedAltarPlayerController");
static_assert(offsetof(AVEnhancedAltarPlayerController, CurrentRawMoveAxis) == 0x000A60, "Member 'AVEnhancedAltarPlayerController::CurrentRawMoveAxis' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, CurrentRawMoveInputLength) == 0x000A70, "Member 'AVEnhancedAltarPlayerController::CurrentRawMoveInputLength' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, CurrentMoveAxis) == 0x000A78, "Member 'AVEnhancedAltarPlayerController::CurrentMoveAxis' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, CurrentMoveInputDirection) == 0x000A88, "Member 'AVEnhancedAltarPlayerController::CurrentMoveInputDirection' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, CurrentMoveInputLength) == 0x000A98, "Member 'AVEnhancedAltarPlayerController::CurrentMoveInputLength' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, CurrentMoveInputLengthBeforeScaling) == 0x000A9C, "Member 'AVEnhancedAltarPlayerController::CurrentMoveInputLengthBeforeScaling' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, PowerAttackInputTime) == 0x000AA4, "Member 'AVEnhancedAltarPlayerController::PowerAttackInputTime' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, AutoAlignCameraTurnSpeedScale) == 0x000AA8, "Member 'AVEnhancedAltarPlayerController::AutoAlignCameraTurnSpeedScale' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, HorseAutoAlignCameraAngleThreshold) == 0x000AAC, "Member 'AVEnhancedAltarPlayerController::HorseAutoAlignCameraAngleThreshold' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, HorseAutoAlignCameraDelay) == 0x000AB0, "Member 'AVEnhancedAltarPlayerController::HorseAutoAlignCameraDelay' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, OnSwitchToUserInterfaceMappings) == 0x000AB8, "Member 'AVEnhancedAltarPlayerController::OnSwitchToUserInterfaceMappings' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, OnSwitchToGameInputMappings) == 0x000AC8, "Member 'AVEnhancedAltarPlayerController::OnSwitchToGameInputMappings' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, SprintMinYMovementInput) == 0x000AD8, "Member 'AVEnhancedAltarPlayerController::SprintMinYMovementInput' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, SprintMaxYMovementInput) == 0x000ADC, "Member 'AVEnhancedAltarPlayerController::SprintMaxYMovementInput' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, SprintMinXMovementInput) == 0x000AE0, "Member 'AVEnhancedAltarPlayerController::SprintMinXMovementInput' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, SprintXThresholdToForceDeactivation) == 0x000AE4, "Member 'AVEnhancedAltarPlayerController::SprintXThresholdToForceDeactivation' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, MoveInputReleaseTimerBeforeDisablingSprintAndGallop) == 0x000AE8, "Member 'AVEnhancedAltarPlayerController::MoveInputReleaseTimerBeforeDisablingSprintAndGallop' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, GallopMinYMovementInput) == 0x000AEC, "Member 'AVEnhancedAltarPlayerController::GallopMinYMovementInput' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, GallopMaxYMovementInput) == 0x000AF0, "Member 'AVEnhancedAltarPlayerController::GallopMaxYMovementInput' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, GallopMinXMovementInput) == 0x000AF4, "Member 'AVEnhancedAltarPlayerController::GallopMinXMovementInput' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, GallopXThresholdToForceDeactivation) == 0x000AF8, "Member 'AVEnhancedAltarPlayerController::GallopXThresholdToForceDeactivation' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, QuickSaveLoadEvent) == 0x000B00, "Member 'AVEnhancedAltarPlayerController::QuickSaveLoadEvent' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, DefaultMappingContext) == 0x000B08, "Member 'AVEnhancedAltarPlayerController::DefaultMappingContext' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, MouseWheelInputAction) == 0x000B10, "Member 'AVEnhancedAltarPlayerController::MouseWheelInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ToggleCharacterMenuInputAction) == 0x000B18, "Member 'AVEnhancedAltarPlayerController::ToggleCharacterMenuInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, OpenRestMenuInputAction) == 0x000B20, "Member 'AVEnhancedAltarPlayerController::OpenRestMenuInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, OpenOptionsMenuInputAction) == 0x000B28, "Member 'AVEnhancedAltarPlayerController::OpenOptionsMenuInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, OpenStatsMenuInputAction) == 0x000B30, "Member 'AVEnhancedAltarPlayerController::OpenStatsMenuInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, OpenInventoryMenuInputAction) == 0x000B38, "Member 'AVEnhancedAltarPlayerController::OpenInventoryMenuInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, OpenMagicMenuInputAction) == 0x000B40, "Member 'AVEnhancedAltarPlayerController::OpenMagicMenuInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, OpenMapMenuInputAction) == 0x000B48, "Member 'AVEnhancedAltarPlayerController::OpenMapMenuInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, OpenQuestMenuInputAction) == 0x000B50, "Member 'AVEnhancedAltarPlayerController::OpenQuestMenuInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, OpenHelpMenuInputAction) == 0x000B58, "Member 'AVEnhancedAltarPlayerController::OpenHelpMenuInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, QuickSaveInputAction) == 0x000B60, "Member 'AVEnhancedAltarPlayerController::QuickSaveInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, QuickLoadInputAction) == 0x000B68, "Member 'AVEnhancedAltarPlayerController::QuickLoadInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, MovementMappingContext) == 0x000B70, "Member 'AVEnhancedAltarPlayerController::MovementMappingContext' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, MovementForwardInputAction) == 0x000B78, "Member 'AVEnhancedAltarPlayerController::MovementForwardInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, MovementBackwardInputAction) == 0x000B80, "Member 'AVEnhancedAltarPlayerController::MovementBackwardInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, MovementLeftInputAction) == 0x000B88, "Member 'AVEnhancedAltarPlayerController::MovementLeftInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, MovementRightInputAction) == 0x000B90, "Member 'AVEnhancedAltarPlayerController::MovementRightInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, TurnInputAction) == 0x000B98, "Member 'AVEnhancedAltarPlayerController::TurnInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, LookUpInputAction) == 0x000BA0, "Member 'AVEnhancedAltarPlayerController::LookUpInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, AutoMoveInputAction) == 0x000BA8, "Member 'AVEnhancedAltarPlayerController::AutoMoveInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, JumpInputAction) == 0x000BB0, "Member 'AVEnhancedAltarPlayerController::JumpInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, CrouchInputAction) == 0x000BB8, "Member 'AVEnhancedAltarPlayerController::CrouchInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ToggleWalkInputAction) == 0x000BC0, "Member 'AVEnhancedAltarPlayerController::ToggleWalkInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, SprintInputAction) == 0x000BC8, "Member 'AVEnhancedAltarPlayerController::SprintInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, HorseWalkInputAction) == 0x000BD0, "Member 'AVEnhancedAltarPlayerController::HorseWalkInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, HorseGallopInputAction) == 0x000BD8, "Member 'AVEnhancedAltarPlayerController::HorseGallopInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ShiftKeyInputAction) == 0x000BE0, "Member 'AVEnhancedAltarPlayerController::ShiftKeyInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, CombatActionsMappingContext) == 0x000BE8, "Member 'AVEnhancedAltarPlayerController::CombatActionsMappingContext' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, AttackInputAction) == 0x000BF0, "Member 'AVEnhancedAltarPlayerController::AttackInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, BlockInputAction) == 0x000BF8, "Member 'AVEnhancedAltarPlayerController::BlockInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, CastInputAction) == 0x000C00, "Member 'AVEnhancedAltarPlayerController::CastInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ReadyItemInputAction) == 0x000C08, "Member 'AVEnhancedAltarPlayerController::ReadyItemInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, UndrawBowInputAction) == 0x000C10, "Member 'AVEnhancedAltarPlayerController::UndrawBowInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, TelekinesisMappingContext) == 0x000C18, "Member 'AVEnhancedAltarPlayerController::TelekinesisMappingContext' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, PushItemInputAction) == 0x000C20, "Member 'AVEnhancedAltarPlayerController::PushItemInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, PullItemInputAction) == 0x000C28, "Member 'AVEnhancedAltarPlayerController::PullItemInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ReleaseItemInputAction) == 0x000C30, "Member 'AVEnhancedAltarPlayerController::ReleaseItemInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, LaunchItemInputAction) == 0x000C38, "Member 'AVEnhancedAltarPlayerController::LaunchItemInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, DrawWhileTelekinesisInputAction) == 0x000C40, "Member 'AVEnhancedAltarPlayerController::DrawWhileTelekinesisInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, UndrawWhileTelekinesisInputAction) == 0x000C48, "Member 'AVEnhancedAltarPlayerController::UndrawWhileTelekinesisInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ActionsMappingContext) == 0x000C50, "Member 'AVEnhancedAltarPlayerController::ActionsMappingContext' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ActivateInputAction) == 0x000C58, "Member 'AVEnhancedAltarPlayerController::ActivateInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, TogglePOVInputAction) == 0x000C60, "Member 'AVEnhancedAltarPlayerController::TogglePOVInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, GrabInputAction) == 0x000C68, "Member 'AVEnhancedAltarPlayerController::GrabInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, QuickKeysMappingContext) == 0x000C70, "Member 'AVEnhancedAltarPlayerController::QuickKeysMappingContext' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, QuickMenuInputAction) == 0x000C78, "Member 'AVEnhancedAltarPlayerController::QuickMenuInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick1InputAction_Gamepad) == 0x000C80, "Member 'AVEnhancedAltarPlayerController::Quick1InputAction_Gamepad' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick2InputAction_Gamepad) == 0x000C88, "Member 'AVEnhancedAltarPlayerController::Quick2InputAction_Gamepad' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick3InputAction_Gamepad) == 0x000C90, "Member 'AVEnhancedAltarPlayerController::Quick3InputAction_Gamepad' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick4InputAction_Gamepad) == 0x000C98, "Member 'AVEnhancedAltarPlayerController::Quick4InputAction_Gamepad' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick5InputAction_Gamepad) == 0x000CA0, "Member 'AVEnhancedAltarPlayerController::Quick5InputAction_Gamepad' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick6InputAction_Gamepad) == 0x000CA8, "Member 'AVEnhancedAltarPlayerController::Quick6InputAction_Gamepad' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick7InputAction_Gamepad) == 0x000CB0, "Member 'AVEnhancedAltarPlayerController::Quick7InputAction_Gamepad' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick8InputAction_Gamepad) == 0x000CB8, "Member 'AVEnhancedAltarPlayerController::Quick8InputAction_Gamepad' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick1InputAction_Keyboard) == 0x000CC0, "Member 'AVEnhancedAltarPlayerController::Quick1InputAction_Keyboard' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick2InputAction_Keyboard) == 0x000CC8, "Member 'AVEnhancedAltarPlayerController::Quick2InputAction_Keyboard' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick3InputAction_Keyboard) == 0x000CD0, "Member 'AVEnhancedAltarPlayerController::Quick3InputAction_Keyboard' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick4InputAction_Keyboard) == 0x000CD8, "Member 'AVEnhancedAltarPlayerController::Quick4InputAction_Keyboard' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick5InputAction_Keyboard) == 0x000CE0, "Member 'AVEnhancedAltarPlayerController::Quick5InputAction_Keyboard' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick6InputAction_Keyboard) == 0x000CE8, "Member 'AVEnhancedAltarPlayerController::Quick6InputAction_Keyboard' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick7InputAction_Keyboard) == 0x000CF0, "Member 'AVEnhancedAltarPlayerController::Quick7InputAction_Keyboard' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, Quick8InputAction_Keyboard) == 0x000CF8, "Member 'AVEnhancedAltarPlayerController::Quick8InputAction_Keyboard' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, DebugMappingContext) == 0x000D00, "Member 'AVEnhancedAltarPlayerController::DebugMappingContext' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ToggleUITexturePairingInputAction) == 0x000D08, "Member 'AVEnhancedAltarPlayerController::ToggleUITexturePairingInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, TogglePrimaryGameLayoutDisplayInputAction) == 0x000D10, "Member 'AVEnhancedAltarPlayerController::TogglePrimaryGameLayoutDisplayInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ShowDebugMenuInputAction) == 0x000D18, "Member 'AVEnhancedAltarPlayerController::ShowDebugMenuInputAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ShowPerformanceDebugInfoAction) == 0x000D20, "Member 'AVEnhancedAltarPlayerController::ShowPerformanceDebugInfoAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ToggleDoCsvProfileAction) == 0x000D28, "Member 'AVEnhancedAltarPlayerController::ToggleDoCsvProfileAction' has a wrong offset!");
static_assert(offsetof(AVEnhancedAltarPlayerController, ToggleFPSChartAction) == 0x000D30, "Member 'AVEnhancedAltarPlayerController::ToggleFPSChartAction' has a wrong offset!");

// Class Altar.VAIProcedureExecution_ACCOMPANY
// 0x0008 (0x0048 - 0x0040)
class UVAIProcedureExecution_ACCOMPANY final : public UVAIProcedureExecution_Base
{
public:
	class UVAIProcedureExecution_FOLLOW*          InternalFollowProcedure;                           // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_ACCOMPANY">();
	}
	static class UVAIProcedureExecution_ACCOMPANY* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_ACCOMPANY>();
	}
};
static_assert(alignof(UVAIProcedureExecution_ACCOMPANY) == 0x000008, "Wrong alignment on UVAIProcedureExecution_ACCOMPANY");
static_assert(sizeof(UVAIProcedureExecution_ACCOMPANY) == 0x000048, "Wrong size on UVAIProcedureExecution_ACCOMPANY");
static_assert(offsetof(UVAIProcedureExecution_ACCOMPANY, InternalFollowProcedure) == 0x000040, "Member 'UVAIProcedureExecution_ACCOMPANY::InternalFollowProcedure' has a wrong offset!");

// Class Altar.VWater
// 0x0008 (0x02F8 - 0x02F0)
class AVWater final : public AVActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWater">();
	}
	static class AVWater* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWater>();
	}
};
static_assert(alignof(AVWater) == 0x000008, "Wrong alignment on AVWater");
static_assert(sizeof(AVWater) == 0x0002F8, "Wrong size on AVWater");
static_assert(offsetof(AVWater, StaticMeshComponent) == 0x0002F0, "Member 'AVWater::StaticMeshComponent' has a wrong offset!");

// Class Altar.AltarQMPSubsytemInterface
// 0x0000 (0x0000 - 0x0000)
class IAltarQMPSubsytemInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AltarQMPSubsytemInterface">();
	}
	static class IAltarQMPSubsytemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAltarQMPSubsytemInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAltarQMPSubsytemInterface) == 0x000001, "Wrong alignment on IAltarQMPSubsytemInterface");
static_assert(sizeof(IAltarQMPSubsytemInterface) == 0x000001, "Wrong size on IAltarQMPSubsytemInterface");

// Class Altar.VModdableBlueprintGeneratedClass
// 0x0000 (0x0368 - 0x0368)
class UVModdableBlueprintGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModdableBlueprintGeneratedClass">();
	}
	static class UVModdableBlueprintGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModdableBlueprintGeneratedClass>();
	}
};
static_assert(alignof(UVModdableBlueprintGeneratedClass) == 0x000008, "Wrong alignment on UVModdableBlueprintGeneratedClass");
static_assert(sizeof(UVModdableBlueprintGeneratedClass) == 0x000368, "Wrong size on UVModdableBlueprintGeneratedClass");

// Class Altar.VWeapon
// 0x0080 (0x0390 - 0x0310)
class AVWeapon : public AVEquippable
{
public:
	uint8                                         Pad_310[0x28];                                     // 0x0310(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WeaponTypeTag;                                     // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LocomotionMovesetTag;                              // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVAttribute                                   WeaponScalingAttribute;                            // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x27];                                     // 0x0369(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateWeaponShadows();
	void DeactivateWeaponShadows();
	void OnAttachmentUpdate(class USkeletalMeshComponent* TargetSkeletalMeshComponent, bool bIsDrawn);

	class FName GetDrawnAttachmentSocketName() const;
	struct FGameplayTag GetLocomotionMovesetTag() const;
	class FName GetSheathedAttachmentSocketName() const;
	EVAttribute GetWeaponScalingAttribute() const;
	struct FGameplayTag GetWeaponTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWeapon">();
	}
	static class AVWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWeapon>();
	}
};
static_assert(alignof(AVWeapon) == 0x000008, "Wrong alignment on AVWeapon");
static_assert(sizeof(AVWeapon) == 0x000390, "Wrong size on AVWeapon");
static_assert(offsetof(AVWeapon, TESRefComponent) == 0x000338, "Member 'AVWeapon::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVWeapon, TransformPairingComponent) == 0x000340, "Member 'AVWeapon::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVWeapon, PhysicsControllerComponent) == 0x000348, "Member 'AVWeapon::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVWeapon, AkAudioComponent) == 0x000350, "Member 'AVWeapon::AkAudioComponent' has a wrong offset!");
static_assert(offsetof(AVWeapon, WeaponTypeTag) == 0x000358, "Member 'AVWeapon::WeaponTypeTag' has a wrong offset!");
static_assert(offsetof(AVWeapon, LocomotionMovesetTag) == 0x000360, "Member 'AVWeapon::LocomotionMovesetTag' has a wrong offset!");
static_assert(offsetof(AVWeapon, WeaponScalingAttribute) == 0x000368, "Member 'AVWeapon::WeaponScalingAttribute' has a wrong offset!");

// Class Altar.TESSync
// 0x0150 (0x0178 - 0x0028)
class UTESSync final : public UObject
{
public:
	TMap<uint32, class FString>                   AllForms;                                          // 0x0028(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, uint8>                    FileCompileIndexes;                                // 0x0078(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, uint8>                    FileRuntimeCompileIndexes;                         // 0x00C8(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<uint32, class UTESForm*>                 DynamicForms;                                      // 0x0118(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESSync">();
	}
	static class UTESSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESSync>();
	}
};
static_assert(alignof(UTESSync) == 0x000008, "Wrong alignment on UTESSync");
static_assert(sizeof(UTESSync) == 0x000178, "Wrong size on UTESSync");
static_assert(offsetof(UTESSync, AllForms) == 0x000028, "Member 'UTESSync::AllForms' has a wrong offset!");
static_assert(offsetof(UTESSync, FileCompileIndexes) == 0x000078, "Member 'UTESSync::FileCompileIndexes' has a wrong offset!");
static_assert(offsetof(UTESSync, FileRuntimeCompileIndexes) == 0x0000C8, "Member 'UTESSync::FileRuntimeCompileIndexes' has a wrong offset!");
static_assert(offsetof(UTESSync, DynamicForms) == 0x000118, "Member 'UTESSync::DynamicForms' has a wrong offset!");

// Class Altar.bhkBallAndSocketConstraintCInfo
// 0x0020 (0x0050 - 0x0030)
class UbhkBallAndSocketConstraintCInfo final : public UNifType
{
public:
	struct FVTSVector4f                           PivotA;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PivotB;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkBallAndSocketConstraintCInfo">();
	}
	static class UbhkBallAndSocketConstraintCInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkBallAndSocketConstraintCInfo>();
	}
};
static_assert(alignof(UbhkBallAndSocketConstraintCInfo) == 0x000008, "Wrong alignment on UbhkBallAndSocketConstraintCInfo");
static_assert(sizeof(UbhkBallAndSocketConstraintCInfo) == 0x000050, "Wrong size on UbhkBallAndSocketConstraintCInfo");
static_assert(offsetof(UbhkBallAndSocketConstraintCInfo, PivotA) == 0x000030, "Member 'UbhkBallAndSocketConstraintCInfo::PivotA' has a wrong offset!");
static_assert(offsetof(UbhkBallAndSocketConstraintCInfo, PivotB) == 0x000040, "Member 'UbhkBallAndSocketConstraintCInfo::PivotB' has a wrong offset!");

// Class Altar.VDroppedAmmo
// 0x0080 (0x0370 - 0x02F0)
class AVDroppedAmmo : public AVActor
{
public:
	uint8                                         Pad_2F0[0x40];                                     // 0x02F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UVTESObjectRefComponent*                TESRefComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVTransformPairingComponent*            TransformPairingComponent;                         // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RootArrowStaticMeshComponent;                      // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           PhysicsControllerComponent;                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           ArrowStaticMeshComponents;                         // 0x0358(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   QuiverStaticMeshComponent;                         // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ReinitializePhysicsSimulationState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDroppedAmmo">();
	}
	static class AVDroppedAmmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVDroppedAmmo>();
	}
};
static_assert(alignof(AVDroppedAmmo) == 0x000008, "Wrong alignment on AVDroppedAmmo");
static_assert(sizeof(AVDroppedAmmo) == 0x000370, "Wrong size on AVDroppedAmmo");
static_assert(offsetof(AVDroppedAmmo, TESRefComponent) == 0x000330, "Member 'AVDroppedAmmo::TESRefComponent' has a wrong offset!");
static_assert(offsetof(AVDroppedAmmo, TransformPairingComponent) == 0x000338, "Member 'AVDroppedAmmo::TransformPairingComponent' has a wrong offset!");
static_assert(offsetof(AVDroppedAmmo, RootArrowStaticMeshComponent) == 0x000340, "Member 'AVDroppedAmmo::RootArrowStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVDroppedAmmo, PhysicsControllerComponent) == 0x000348, "Member 'AVDroppedAmmo::PhysicsControllerComponent' has a wrong offset!");
static_assert(offsetof(AVDroppedAmmo, AkAudioComponent) == 0x000350, "Member 'AVDroppedAmmo::AkAudioComponent' has a wrong offset!");
static_assert(offsetof(AVDroppedAmmo, ArrowStaticMeshComponents) == 0x000358, "Member 'AVDroppedAmmo::ArrowStaticMeshComponents' has a wrong offset!");
static_assert(offsetof(AVDroppedAmmo, QuiverStaticMeshComponent) == 0x000368, "Member 'AVDroppedAmmo::QuiverStaticMeshComponent' has a wrong offset!");

// Class Altar.VAIPackageExecutionOverride
// 0x0000 (0x0028 - 0x0028)
class UVAIPackageExecutionOverride : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIPackageExecutionOverride">();
	}
	static class UVAIPackageExecutionOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIPackageExecutionOverride>();
	}
};
static_assert(alignof(UVAIPackageExecutionOverride) == 0x000008, "Wrong alignment on UVAIPackageExecutionOverride");
static_assert(sizeof(UVAIPackageExecutionOverride) == 0x000028, "Wrong size on UVAIPackageExecutionOverride");

// Class Altar.AltarCheatManager
// 0x0018 (0x00A0 - 0x0088)
class UAltarCheatManager final : public UCheatManager
{
public:
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                GraphicsDebugWidget;                               // 0x0090(0x0008)(ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsGraphicsDebugWidgetShown;                       // 0x0098(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AltarSpawn(class FString& Race);
	void CrashGame();
	void DebugMenuCommand(class FString& Command);
	void GiveViolence();
	void ObvConselect(class FString& Arg);
	void ObvConsole(class FString& Arg);
	void ObvGodMode();
	void SendMultipleOblivionCommand(const TArray<class FString>& CommandeLists);
	void SkipTutorialQuest();
	void ToggleLocalMapMode();
	void XSXC();

	bool IsInGodMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AltarCheatManager">();
	}
	static class UAltarCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAltarCheatManager>();
	}
};
static_assert(alignof(UAltarCheatManager) == 0x000008, "Wrong alignment on UAltarCheatManager");
static_assert(sizeof(UAltarCheatManager) == 0x0000A0, "Wrong size on UAltarCheatManager");
static_assert(offsetof(UAltarCheatManager, GraphicsDebugWidget) == 0x000090, "Member 'UAltarCheatManager::GraphicsDebugWidget' has a wrong offset!");
static_assert(offsetof(UAltarCheatManager, bIsGraphicsDebugWidgetShown) == 0x000098, "Member 'UAltarCheatManager::bIsGraphicsDebugWidgetShown' has a wrong offset!");

// Class Altar.VModernOnboardingMenu
// 0x00C8 (0x0590 - 0x04C8)
class UVModernOnboardingMenu : public UVAltarWidget
{
public:
	TSoftObjectPtr<class UVModernOnboardingFlowTable> FlowTable;                                     // 0x04C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStartDelegate;                                   // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Outcome)>  OnRunDelegate;                                     // 0x0500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEndDelegate;                                     // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TScriptInterface<class IVOnboardingPageInterface> Page, int32 PageIndex)> OnPageEnterDelegate; // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TScriptInterface<class IVOnboardingPageInterface> Page, int32 PageIndex)> OnPageExitDelegate; // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bDoesCleanOnEnd;                                   // 0x0540(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_541[0x37];                                     // 0x0541(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               Panel;                                             // 0x0578(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Background;                                        // 0x0580(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x8];                                      // 0x0588(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Back();
	void CleanOnboarding();
	void OnAnimationEnded(TScriptInterface<class IVOnboardingPageInterface> Caller);
	void OnEnd();
	void OnPageChanged(int32 NewIndex);
	void OnRun(bool Outcome);
	void OnStart();
	bool Skip();

	TScriptInterface<class IVOnboardingPageInterface> GetCurrentPage() const;
	int32 GetNextUnskipableIndex(int32 StartIndex) const;
	TScriptInterface<class IVOnboardingPageInterface> GetOffsetedNextPage(int32 Offset) const;
	TScriptInterface<class IVOnboardingPageInterface> GetPage(int32 Index_0) const;
	bool IsOnboardingFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernOnboardingMenu">();
	}
	static class UVModernOnboardingMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernOnboardingMenu>();
	}
};
static_assert(alignof(UVModernOnboardingMenu) == 0x000008, "Wrong alignment on UVModernOnboardingMenu");
static_assert(sizeof(UVModernOnboardingMenu) == 0x000590, "Wrong size on UVModernOnboardingMenu");
static_assert(offsetof(UVModernOnboardingMenu, FlowTable) == 0x0004C8, "Member 'UVModernOnboardingMenu::FlowTable' has a wrong offset!");
static_assert(offsetof(UVModernOnboardingMenu, OnStartDelegate) == 0x0004F0, "Member 'UVModernOnboardingMenu::OnStartDelegate' has a wrong offset!");
static_assert(offsetof(UVModernOnboardingMenu, OnRunDelegate) == 0x000500, "Member 'UVModernOnboardingMenu::OnRunDelegate' has a wrong offset!");
static_assert(offsetof(UVModernOnboardingMenu, OnEndDelegate) == 0x000510, "Member 'UVModernOnboardingMenu::OnEndDelegate' has a wrong offset!");
static_assert(offsetof(UVModernOnboardingMenu, OnPageEnterDelegate) == 0x000520, "Member 'UVModernOnboardingMenu::OnPageEnterDelegate' has a wrong offset!");
static_assert(offsetof(UVModernOnboardingMenu, OnPageExitDelegate) == 0x000530, "Member 'UVModernOnboardingMenu::OnPageExitDelegate' has a wrong offset!");
static_assert(offsetof(UVModernOnboardingMenu, bDoesCleanOnEnd) == 0x000540, "Member 'UVModernOnboardingMenu::bDoesCleanOnEnd' has a wrong offset!");
static_assert(offsetof(UVModernOnboardingMenu, Panel) == 0x000578, "Member 'UVModernOnboardingMenu::Panel' has a wrong offset!");
static_assert(offsetof(UVModernOnboardingMenu, Background) == 0x000580, "Member 'UVModernOnboardingMenu::Background' has a wrong offset!");

// Class Altar.VAIPackageExecutionOverride_207639
// 0x0008 (0x0030 - 0x0028)
class UVAIPackageExecutionOverride_207639 final : public UVAIPackageExecutionOverride
{
public:
	class AVPairedPawn*                           Glenroy;                                           // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIPackageExecutionOverride_207639">();
	}
	static class UVAIPackageExecutionOverride_207639* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIPackageExecutionOverride_207639>();
	}
};
static_assert(alignof(UVAIPackageExecutionOverride_207639) == 0x000008, "Wrong alignment on UVAIPackageExecutionOverride_207639");
static_assert(sizeof(UVAIPackageExecutionOverride_207639) == 0x000030, "Wrong size on UVAIPackageExecutionOverride_207639");
static_assert(offsetof(UVAIPackageExecutionOverride_207639, Glenroy) == 0x000028, "Member 'UVAIPackageExecutionOverride_207639::Glenroy' has a wrong offset!");

// Class Altar.AltarCommonGameViewportClient
// 0x0010 (0x0400 - 0x03F0)
class UAltarCommonGameViewportClient final : public UCommonGameViewportClient
{
public:
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AltarCommonGameViewportClient">();
	}
	static class UAltarCommonGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAltarCommonGameViewportClient>();
	}
};
static_assert(alignof(UAltarCommonGameViewportClient) == 0x000008, "Wrong alignment on UAltarCommonGameViewportClient");
static_assert(sizeof(UAltarCommonGameViewportClient) == 0x000400, "Wrong size on UAltarCommonGameViewportClient");

// Class Altar.VAIHelpersFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAIHelpersFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void SortActorsByGameTime(const TArray<class AActor*>& InActors, TArray<class AActor*>* SortedActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIHelpersFunctionLibrary">();
	}
	static class UVAIHelpersFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIHelpersFunctionLibrary>();
	}
};
static_assert(alignof(UVAIHelpersFunctionLibrary) == 0x000008, "Wrong alignment on UVAIHelpersFunctionLibrary");
static_assert(sizeof(UVAIHelpersFunctionLibrary) == 0x000028, "Wrong size on UVAIHelpersFunctionLibrary");

// Class Altar.VLegacyStatsMenuSkillHeader
// 0x0018 (0x0040 - 0x0028)
class UVLegacyStatsMenuSkillHeader final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const class FText& Value);

	const class FText GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyStatsMenuSkillHeader">();
	}
	static class UVLegacyStatsMenuSkillHeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyStatsMenuSkillHeader>();
	}
};
static_assert(alignof(UVLegacyStatsMenuSkillHeader) == 0x000008, "Wrong alignment on UVLegacyStatsMenuSkillHeader");
static_assert(sizeof(UVLegacyStatsMenuSkillHeader) == 0x000040, "Wrong size on UVLegacyStatsMenuSkillHeader");

// Class Altar.AltarGameUserSetting
// 0x02A0 (0x03E8 - 0x0148)
class UAltarGameUserSetting final : public UGameUserSettings
{
public:
	uint8                                         Pad_148[0x60];                                     // 0x0148(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VersionNumber;                                     // 0x01A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPerformanceMode                              PerformanceMode;                                   // 0x01AC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            SavedSettings;                                     // 0x01B0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class FString>            DefaultSavedSettings;                              // 0x0200(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, int32>                    SettingsPlatformLookup;                            // 0x0250(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UVAltarGraphicsSettingManager*          GraphicsSettingManager;                            // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, struct FVAltarRebindMap>  SavedRebind;                                       // 0x02A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FVAltarRebindMap>  DefaultSavedRebind;                                // 0x02F8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsOnboardingBrighnessSettingsDone;                // 0x0348(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOnboardingGameplaySettingsDone;                 // 0x0349(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOnboardingSoundSettingsDone;                    // 0x034A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEULAAccepted;                                   // 0x034B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDoFirstTimeAutoDetect;                      // 0x034C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34D[0x3];                                      // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnhancedActionKeyMapping              EmptyActionKeyMapping;                             // 0x0350(0x0050)(Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EmptyReturnString;                                 // 0x03A0(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKey                                   EmptyKey;                                          // 0x03B0(0x0018)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVModernSettingPageTable*               SettingPageTable;                                  // 0x03C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BNetPersistentUserId;                              // 0x03D0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAltarGameUserSetting* GetInstance();

	void AcceptEULA();
	void AddOrUpdateRebindToSave(class UInputMappingContext* MappingContext, class UInputAction* InputAction, const struct FKey& Key, ERebindSaveSlot Slot);
	void AddOrUpdateSettingsToSave(const struct FModernSettingCommand& Settings);
	void ApplyAltarCVARSettings(bool bForce);
	void ApplyAltarRebind();
	void DoAutoDetect(bool bForceSync);
	const struct FEnhancedActionKeyMapping GetOrAddRebindFromSaved(class UInputMappingContext* MappingContext, class UInputAction* InputAction, ERebindSaveSlot Slot);
	class FString GetOrAddValueFromSavedSettings(const class FString& Command);
	const struct FKey GetSavedKeyForBind(class UInputMappingContext* MappingContext, class UInputAction* InputAction, ERebindSaveSlot Slot);
	void ResetBindingsToDefault();
	void ResetSettingsToDefault();
	void ValidateOnboardingBrighnessSettings();
	void ValidateOnboardingGameplaySettings();
	void ValidateOnboardingSoundSettings();

	const TMap<class FString, struct FVAltarRebindMap> GetDefaultSavedRebind() const;
	const TMap<class FString, class FString> GetDefaultSavedSettings() const;
	const TMap<class FString, class FString> GetSavedSettings() const;
	class UVModernSettingPageTable* GetSettingPageTable() const;
	bool IsEULAAccepted() const;
	bool IsOnboardingSettingsDone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AltarGameUserSetting">();
	}
	static class UAltarGameUserSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAltarGameUserSetting>();
	}
};
static_assert(alignof(UAltarGameUserSetting) == 0x000008, "Wrong alignment on UAltarGameUserSetting");
static_assert(sizeof(UAltarGameUserSetting) == 0x0003E8, "Wrong size on UAltarGameUserSetting");
static_assert(offsetof(UAltarGameUserSetting, VersionNumber) == 0x0001A8, "Member 'UAltarGameUserSetting::VersionNumber' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, PerformanceMode) == 0x0001AC, "Member 'UAltarGameUserSetting::PerformanceMode' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, SavedSettings) == 0x0001B0, "Member 'UAltarGameUserSetting::SavedSettings' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, DefaultSavedSettings) == 0x000200, "Member 'UAltarGameUserSetting::DefaultSavedSettings' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, SettingsPlatformLookup) == 0x000250, "Member 'UAltarGameUserSetting::SettingsPlatformLookup' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, GraphicsSettingManager) == 0x0002A0, "Member 'UAltarGameUserSetting::GraphicsSettingManager' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, SavedRebind) == 0x0002A8, "Member 'UAltarGameUserSetting::SavedRebind' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, DefaultSavedRebind) == 0x0002F8, "Member 'UAltarGameUserSetting::DefaultSavedRebind' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, bIsOnboardingBrighnessSettingsDone) == 0x000348, "Member 'UAltarGameUserSetting::bIsOnboardingBrighnessSettingsDone' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, bIsOnboardingGameplaySettingsDone) == 0x000349, "Member 'UAltarGameUserSetting::bIsOnboardingGameplaySettingsDone' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, bIsOnboardingSoundSettingsDone) == 0x00034A, "Member 'UAltarGameUserSetting::bIsOnboardingSoundSettingsDone' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, bIsEULAAccepted) == 0x00034B, "Member 'UAltarGameUserSetting::bIsEULAAccepted' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, bShouldDoFirstTimeAutoDetect) == 0x00034C, "Member 'UAltarGameUserSetting::bShouldDoFirstTimeAutoDetect' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, EmptyActionKeyMapping) == 0x000350, "Member 'UAltarGameUserSetting::EmptyActionKeyMapping' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, EmptyReturnString) == 0x0003A0, "Member 'UAltarGameUserSetting::EmptyReturnString' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, EmptyKey) == 0x0003B0, "Member 'UAltarGameUserSetting::EmptyKey' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, SettingPageTable) == 0x0003C8, "Member 'UAltarGameUserSetting::SettingPageTable' has a wrong offset!");
static_assert(offsetof(UAltarGameUserSetting, BNetPersistentUserId) == 0x0003D0, "Member 'UAltarGameUserSetting::BNetPersistentUserId' has a wrong offset!");

// Class Altar.AltarGraphicsSettingsDebugInfo
// 0x0018 (0x02D8 - 0x02C0)
class UAltarGraphicsSettingsDebugInfo : public UUserWidget
{
public:
	class UTextBlock*                             FPSTextBlock;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             VRAMTextBlock;                                     // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AltarGraphicsSettingsDebugInfo">();
	}
	static class UAltarGraphicsSettingsDebugInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAltarGraphicsSettingsDebugInfo>();
	}
};
static_assert(alignof(UAltarGraphicsSettingsDebugInfo) == 0x000008, "Wrong alignment on UAltarGraphicsSettingsDebugInfo");
static_assert(sizeof(UAltarGraphicsSettingsDebugInfo) == 0x0002D8, "Wrong size on UAltarGraphicsSettingsDebugInfo");
static_assert(offsetof(UAltarGraphicsSettingsDebugInfo, FPSTextBlock) == 0x0002C0, "Member 'UAltarGraphicsSettingsDebugInfo::FPSTextBlock' has a wrong offset!");
static_assert(offsetof(UAltarGraphicsSettingsDebugInfo, VRAMTextBlock) == 0x0002C8, "Member 'UAltarGraphicsSettingsDebugInfo::VRAMTextBlock' has a wrong offset!");

// Class Altar.VModernScrollbar
// 0x0030 (0x04F8 - 0x04C8)
class UVModernScrollbar : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(float Value)>   OnScrollbarValueChanged;                           // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FModernScrollbarProperties             ScrollbarProperties;                               // 0x04D8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	class UWidget*                                Handle;                                            // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnalogSlider*                          Slider;                                            // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnPropertiesChanged(const struct FModernScrollbarProperties& Values);
	void OnValueUpdated(float Value);
	void SetProperties(const struct FModernScrollbarProperties& NewProperties);
	void SetValue(float NewValue);
	void UpdateValueFromSlider(float Value);

	class UWidget* GetHandle() const;
	const struct FModernScrollbarProperties GetProperties() const;
	class UAnalogSlider* GetSlider() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernScrollbar">();
	}
	static class UVModernScrollbar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernScrollbar>();
	}
};
static_assert(alignof(UVModernScrollbar) == 0x000008, "Wrong alignment on UVModernScrollbar");
static_assert(sizeof(UVModernScrollbar) == 0x0004F8, "Wrong size on UVModernScrollbar");
static_assert(offsetof(UVModernScrollbar, OnScrollbarValueChanged) == 0x0004C8, "Member 'UVModernScrollbar::OnScrollbarValueChanged' has a wrong offset!");
static_assert(offsetof(UVModernScrollbar, ScrollbarProperties) == 0x0004D8, "Member 'UVModernScrollbar::ScrollbarProperties' has a wrong offset!");
static_assert(offsetof(UVModernScrollbar, Handle) == 0x0004E8, "Member 'UVModernScrollbar::Handle' has a wrong offset!");
static_assert(offsetof(UVModernScrollbar, Slider) == 0x0004F0, "Member 'UVModernScrollbar::Slider' has a wrong offset!");

// Class Altar.VAIProcedureExecution_SummonCreatureDefend
// 0x0018 (0x0058 - 0x0040)
class UVAIProcedureExecution_SummonCreatureDefend final : public UVAIProcedureExecution_Base
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAIProcedureExecution_FOLLOW*          InternalFollowProcedure;                           // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAIProcedureExecution_ACCOMPANY*       InternalAccompanyProcedure;                        // 0x0050(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UVAIProcedureExecution_ACCOMPANY* GetAccompanyProcedure() const;
	class UVAIProcedureExecution_FOLLOW* GetFollowProcedure() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_SummonCreatureDefend">();
	}
	static class UVAIProcedureExecution_SummonCreatureDefend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_SummonCreatureDefend>();
	}
};
static_assert(alignof(UVAIProcedureExecution_SummonCreatureDefend) == 0x000008, "Wrong alignment on UVAIProcedureExecution_SummonCreatureDefend");
static_assert(sizeof(UVAIProcedureExecution_SummonCreatureDefend) == 0x000058, "Wrong size on UVAIProcedureExecution_SummonCreatureDefend");
static_assert(offsetof(UVAIProcedureExecution_SummonCreatureDefend, InternalFollowProcedure) == 0x000048, "Member 'UVAIProcedureExecution_SummonCreatureDefend::InternalFollowProcedure' has a wrong offset!");
static_assert(offsetof(UVAIProcedureExecution_SummonCreatureDefend, InternalAccompanyProcedure) == 0x000050, "Member 'UVAIProcedureExecution_SummonCreatureDefend::InternalAccompanyProcedure' has a wrong offset!");

// Class Altar.AltarWorldSettings
// 0x0048 (0x0500 - 0x04B8)
class AAltarWorldSettings final : public AWorldSettings
{
public:
	class FString                                 OblivionNameMap;                                   // 0x04B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              AutoLoadSave;                                      // 0x04C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveSynchroLoadingLevel;                        // 0x04D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartupCommand;                                    // 0x04E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetSpecificPlayerPostion;                         // 0x04F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F1[0x3];                                      // 0x04F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExternCellX;                                       // 0x04F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExternCellY;                                       // 0x04F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipUIPopups;                                     // 0x04FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FD[0x3];                                      // 0x04FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AltarWorldSettings">();
	}
	static class AAltarWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAltarWorldSettings>();
	}
};
static_assert(alignof(AAltarWorldSettings) == 0x000008, "Wrong alignment on AAltarWorldSettings");
static_assert(sizeof(AAltarWorldSettings) == 0x000500, "Wrong size on AAltarWorldSettings");
static_assert(offsetof(AAltarWorldSettings, OblivionNameMap) == 0x0004B8, "Member 'AAltarWorldSettings::OblivionNameMap' has a wrong offset!");
static_assert(offsetof(AAltarWorldSettings, AutoLoadSave) == 0x0004C8, "Member 'AAltarWorldSettings::AutoLoadSave' has a wrong offset!");
static_assert(offsetof(AAltarWorldSettings, bActiveSynchroLoadingLevel) == 0x0004D8, "Member 'AAltarWorldSettings::bActiveSynchroLoadingLevel' has a wrong offset!");
static_assert(offsetof(AAltarWorldSettings, StartupCommand) == 0x0004E0, "Member 'AAltarWorldSettings::StartupCommand' has a wrong offset!");
static_assert(offsetof(AAltarWorldSettings, bSetSpecificPlayerPostion) == 0x0004F0, "Member 'AAltarWorldSettings::bSetSpecificPlayerPostion' has a wrong offset!");
static_assert(offsetof(AAltarWorldSettings, ExternCellX) == 0x0004F4, "Member 'AAltarWorldSettings::ExternCellX' has a wrong offset!");
static_assert(offsetof(AAltarWorldSettings, ExternCellY) == 0x0004F8, "Member 'AAltarWorldSettings::ExternCellY' has a wrong offset!");
static_assert(offsetof(AAltarWorldSettings, bSkipUIPopups) == 0x0004FC, "Member 'AAltarWorldSettings::bSkipUIPopups' has a wrong offset!");

// Class Altar.AnimatableRetainerBox
// 0x00D8 (0x02A0 - 0x01C8)
class UAnimatableRetainerBox final : public URetainerBox
{
public:
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x01D0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatableRetainerBox">();
	}
	static class UAnimatableRetainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimatableRetainerBox>();
	}
};
static_assert(alignof(UAnimatableRetainerBox) == 0x000010, "Wrong alignment on UAnimatableRetainerBox");
static_assert(sizeof(UAnimatableRetainerBox) == 0x0002A0, "Wrong size on UAnimatableRetainerBox");
static_assert(offsetof(UAnimatableRetainerBox, Brush) == 0x0001D0, "Member 'UAnimatableRetainerBox::Brush' has a wrong offset!");

// Class Altar.VPauseMenuViewModel
// 0x0008 (0x00D8 - 0x00D0)
class UVPauseMenuViewModel final : public UVViewModelBase
{
public:
	bool                                          bIsDisplayed;                                      // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifySaveLoadMenuIsClosing();
	void RegisterSendClickedButton(ELegacyPauseButtonsIDs InButtonIndex);
	void RegisterSendClickedQuickSaveButton();
	void RegisterSendClickedQuitGameButton();
	void RegisterSendClickedReturnToMainMenuButton();
	void SetIsDisplayed(bool bNewValue);
	void SetIsMenuClosing(bool bNewValue);
	void SetIsOpeningSaveLoadMenu(bool bNewValue);

	class FText GetBuildInfo() const;
	bool GetIsDisplayed() const;
	bool GetIsMenuClosing() const;
	bool GetIsOpeningSaveLoadMenu() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPauseMenuViewModel">();
	}
	static class UVPauseMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPauseMenuViewModel>();
	}
};
static_assert(alignof(UVPauseMenuViewModel) == 0x000008, "Wrong alignment on UVPauseMenuViewModel");
static_assert(sizeof(UVPauseMenuViewModel) == 0x0000D8, "Wrong size on UVPauseMenuViewModel");
static_assert(offsetof(UVPauseMenuViewModel, bIsDisplayed) == 0x0000D0, "Member 'UVPauseMenuViewModel::bIsDisplayed' has a wrong offset!");

// Class Altar.AnimNotify_DamageSection
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_DamageSection final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DamageSection">();
	}
	static class UAnimNotify_DamageSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DamageSection>();
	}
};
static_assert(alignof(UAnimNotify_DamageSection) == 0x000008, "Wrong alignment on UAnimNotify_DamageSection");
static_assert(sizeof(UAnimNotify_DamageSection) == 0x000038, "Wrong size on UAnimNotify_DamageSection");

// Class Altar.VAIPackageExecutionOverride_324152
// 0x0000 (0x0028 - 0x0028)
class UVAIPackageExecutionOverride_324152 final : public UVAIPackageExecutionOverride
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIPackageExecutionOverride_324152">();
	}
	static class UVAIPackageExecutionOverride_324152* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIPackageExecutionOverride_324152>();
	}
};
static_assert(alignof(UVAIPackageExecutionOverride_324152) == 0x000008, "Wrong alignment on UVAIPackageExecutionOverride_324152");
static_assert(sizeof(UVAIPackageExecutionOverride_324152) == 0x000028, "Wrong size on UVAIPackageExecutionOverride_324152");

// Class Altar.AnimNotify_MovesetTransition
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_MovesetTransition final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_MovesetTransition">();
	}
	static class UAnimNotify_MovesetTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_MovesetTransition>();
	}
};
static_assert(alignof(UAnimNotify_MovesetTransition) == 0x000008, "Wrong alignment on UAnimNotify_MovesetTransition");
static_assert(sizeof(UAnimNotify_MovesetTransition) == 0x000038, "Wrong size on UAnimNotify_MovesetTransition");

// Class Altar.AsyncAction_CreateWidgetAsync
// 0x0070 (0x00A0 - 0x0030)
class UAsyncAction_CreateWidgetAsync final : public UCancellableAsyncAction
{
public:
	TMulticastInlineDelegate<void(class UUserWidget* UserWidget)> OnComplete;                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x60];                                      // 0x0040(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_CreateWidgetAsync* CreateWidgetAsync(class UObject* WorldContextObject, TSoftClassPtr<class UClass> UserWidgetSoftClass, class APlayerController* OwningPlayer, bool bSuspendInputUntilComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_CreateWidgetAsync">();
	}
	static class UAsyncAction_CreateWidgetAsync* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_CreateWidgetAsync>();
	}
};
static_assert(alignof(UAsyncAction_CreateWidgetAsync) == 0x000008, "Wrong alignment on UAsyncAction_CreateWidgetAsync");
static_assert(sizeof(UAsyncAction_CreateWidgetAsync) == 0x0000A0, "Wrong size on UAsyncAction_CreateWidgetAsync");
static_assert(offsetof(UAsyncAction_CreateWidgetAsync, OnComplete) == 0x000030, "Member 'UAsyncAction_CreateWidgetAsync::OnComplete' has a wrong offset!");

// Class Altar.VPersuasionMenuViewModel
// 0x0090 (0x0160 - 0x00D0)
class UVPersuasionMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnSucessBribeSoundTrigger;                         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FWheelInitializingData                 WheelInitializingData;                             // 0x00E0(0x0030)(NativeAccessSpecifierPrivate)
	struct FNpcDisposition                        Disposition;                                       // 0x0110(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bHasGameStarted;                                   // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBribeData                             BribeData;                                         // 0x011C(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NPCName;                                           // 0x0128(0x0018)(NativeAccessSpecifierPrivate)
	bool                                          bCanPersuade;                                      // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanRotateWheel;                                   // 0x0141(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPersuasionMiniGamePlayState                  GamePlayState;                                     // 0x0142(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBribe;                                         // 0x0143(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PlayerGold;                                        // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToPersuadedCharacters();
	void RegisterClickOnBribeButton();
	void RegisterClickOnDoneButton();
	void RegisterClickOnRotateButton();
	void RegisterClickOnStartButton();
	void RegisterSendClickOnQuandrant(int32 NewQuadrantClickedID);
	void RegisterSendQuadrantHovered(EReaction ReactionValue);
	void RegisterSendWheelUnHovered();
	void SetBribeData(const struct FBribeData& NewBirbeData);
	void SetCanBribe(bool bNewCanBribeValue);
	void SetCanPersuade(bool bCanPersuadeNewValue);
	void SetCanRotateWheel(bool bNewCanRotateWheelValue);
	void SetDisposition(const struct FNpcDisposition& NewDisposition);
	void SetGamePlayState(EPersuasionMiniGamePlayState NewGamePlayState);
	void SetHasGameStarted(bool bNewValue);
	void SetNPCName(const class FText& NewNpcName);
	void SetPlayerGold(int32 InNewPlayerGold);
	void SetWheelInitializingData(const struct FWheelInitializingData& NewWheelInitializingData);

	bool CanBribe() const;
	bool CanPersuade() const;
	bool CanRotateWheel() const;
	bool GameHasStarted() const;
	struct FBribeData GetBribeData() const;
	const struct FNpcDisposition GetDisposition() const;
	EPersuasionMiniGamePlayState GetGamePlayState() const;
	const class FText GetNPCName() const;
	int32 GetPlayerGold() const;
	const struct FWheelInitializingData GetWheelInitializingData() const;
	bool WasSpeakerAlreadyPersuaded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPersuasionMenuViewModel">();
	}
	static class UVPersuasionMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPersuasionMenuViewModel>();
	}
};
static_assert(alignof(UVPersuasionMenuViewModel) == 0x000008, "Wrong alignment on UVPersuasionMenuViewModel");
static_assert(sizeof(UVPersuasionMenuViewModel) == 0x000160, "Wrong size on UVPersuasionMenuViewModel");
static_assert(offsetof(UVPersuasionMenuViewModel, OnSucessBribeSoundTrigger) == 0x0000D0, "Member 'UVPersuasionMenuViewModel::OnSucessBribeSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVPersuasionMenuViewModel, WheelInitializingData) == 0x0000E0, "Member 'UVPersuasionMenuViewModel::WheelInitializingData' has a wrong offset!");
static_assert(offsetof(UVPersuasionMenuViewModel, Disposition) == 0x000110, "Member 'UVPersuasionMenuViewModel::Disposition' has a wrong offset!");
static_assert(offsetof(UVPersuasionMenuViewModel, bHasGameStarted) == 0x000118, "Member 'UVPersuasionMenuViewModel::bHasGameStarted' has a wrong offset!");
static_assert(offsetof(UVPersuasionMenuViewModel, BribeData) == 0x00011C, "Member 'UVPersuasionMenuViewModel::BribeData' has a wrong offset!");
static_assert(offsetof(UVPersuasionMenuViewModel, NPCName) == 0x000128, "Member 'UVPersuasionMenuViewModel::NPCName' has a wrong offset!");
static_assert(offsetof(UVPersuasionMenuViewModel, bCanPersuade) == 0x000140, "Member 'UVPersuasionMenuViewModel::bCanPersuade' has a wrong offset!");
static_assert(offsetof(UVPersuasionMenuViewModel, bCanRotateWheel) == 0x000141, "Member 'UVPersuasionMenuViewModel::bCanRotateWheel' has a wrong offset!");
static_assert(offsetof(UVPersuasionMenuViewModel, GamePlayState) == 0x000142, "Member 'UVPersuasionMenuViewModel::GamePlayState' has a wrong offset!");
static_assert(offsetof(UVPersuasionMenuViewModel, bCanBribe) == 0x000143, "Member 'UVPersuasionMenuViewModel::bCanBribe' has a wrong offset!");
static_assert(offsetof(UVPersuasionMenuViewModel, PlayerGold) == 0x000144, "Member 'UVPersuasionMenuViewModel::PlayerGold' has a wrong offset!");

// Class Altar.VAIProcedureExecution_Pursue
// 0x0008 (0x0048 - 0x0040)
class UVAIProcedureExecution_Pursue final : public UVAIProcedureExecution_Base
{
public:
	class UVAIProcedureExecution_FOLLOW*          InternalFollowProcedure;                           // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UVAIProcedureExecution_FOLLOW* GetFollowProcedure() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_Pursue">();
	}
	static class UVAIProcedureExecution_Pursue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_Pursue>();
	}
};
static_assert(alignof(UVAIProcedureExecution_Pursue) == 0x000008, "Wrong alignment on UVAIProcedureExecution_Pursue");
static_assert(sizeof(UVAIProcedureExecution_Pursue) == 0x000048, "Wrong size on UVAIProcedureExecution_Pursue");
static_assert(offsetof(UVAIProcedureExecution_Pursue, InternalFollowProcedure) == 0x000040, "Member 'UVAIProcedureExecution_Pursue::InternalFollowProcedure' has a wrong offset!");

// Class Altar.VLocomotionHorseRiderAnimInstance
// 0x0030 (0x0490 - 0x0460)
class UVLocomotionHorseRiderAnimInstance : public UVLocomotionCharacterAnimInstance
{
public:
	class UClass*                                 HorseLinkLayer;                                    // 0x0460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHorseSwimming;                                  // 0x0468(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_469[0x3];                                      // 0x0469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalRiderSpeed;                                // 0x046C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlopeAngle;                                        // 0x0470(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInTrot;                                         // 0x0474(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInGallop;                                       // 0x0475(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWalking;                                        // 0x0476(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMoving;                                         // 0x0477(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMovingBackward;                                 // 0x0478(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMovingForward;                                  // 0x0479(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47A[0x6];                                      // 0x047A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UVLocomotionHorseAnimInstance*          HorseLocoAnimInstance;                             // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLocomotionHorseRiderAnimInstance">();
	}
	static class UVLocomotionHorseRiderAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLocomotionHorseRiderAnimInstance>();
	}
};
static_assert(alignof(UVLocomotionHorseRiderAnimInstance) == 0x000010, "Wrong alignment on UVLocomotionHorseRiderAnimInstance");
static_assert(sizeof(UVLocomotionHorseRiderAnimInstance) == 0x000490, "Wrong size on UVLocomotionHorseRiderAnimInstance");
static_assert(offsetof(UVLocomotionHorseRiderAnimInstance, HorseLinkLayer) == 0x000460, "Member 'UVLocomotionHorseRiderAnimInstance::HorseLinkLayer' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseRiderAnimInstance, bIsHorseSwimming) == 0x000468, "Member 'UVLocomotionHorseRiderAnimInstance::bIsHorseSwimming' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseRiderAnimInstance, VerticalRiderSpeed) == 0x00046C, "Member 'UVLocomotionHorseRiderAnimInstance::VerticalRiderSpeed' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseRiderAnimInstance, SlopeAngle) == 0x000470, "Member 'UVLocomotionHorseRiderAnimInstance::SlopeAngle' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseRiderAnimInstance, bIsInTrot) == 0x000474, "Member 'UVLocomotionHorseRiderAnimInstance::bIsInTrot' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseRiderAnimInstance, bIsInGallop) == 0x000475, "Member 'UVLocomotionHorseRiderAnimInstance::bIsInGallop' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseRiderAnimInstance, bIsWalking) == 0x000476, "Member 'UVLocomotionHorseRiderAnimInstance::bIsWalking' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseRiderAnimInstance, bIsMoving) == 0x000477, "Member 'UVLocomotionHorseRiderAnimInstance::bIsMoving' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseRiderAnimInstance, bIsMovingBackward) == 0x000478, "Member 'UVLocomotionHorseRiderAnimInstance::bIsMovingBackward' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseRiderAnimInstance, bIsMovingForward) == 0x000479, "Member 'UVLocomotionHorseRiderAnimInstance::bIsMovingForward' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseRiderAnimInstance, HorseLocoAnimInstance) == 0x000480, "Member 'UVLocomotionHorseRiderAnimInstance::HorseLocoAnimInstance' has a wrong offset!");

// Class Altar.VSwimLocomotionHorseRiderAnimInstance
// 0x0020 (0x04B0 - 0x0490)
class UVSwimLocomotionHorseRiderAnimInstance : public UVLocomotionHorseRiderAnimInstance
{
public:
	struct FVHorseRiderLocomotionSwim             SwimLayerData;                                     // 0x0490(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSwimLayerData(const struct FVHorseRiderLocomotionSwim& InSwimLayerData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSwimLocomotionHorseRiderAnimInstance">();
	}
	static class UVSwimLocomotionHorseRiderAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSwimLocomotionHorseRiderAnimInstance>();
	}
};
static_assert(alignof(UVSwimLocomotionHorseRiderAnimInstance) == 0x000010, "Wrong alignment on UVSwimLocomotionHorseRiderAnimInstance");
static_assert(sizeof(UVSwimLocomotionHorseRiderAnimInstance) == 0x0004B0, "Wrong size on UVSwimLocomotionHorseRiderAnimInstance");
static_assert(offsetof(UVSwimLocomotionHorseRiderAnimInstance, SwimLayerData) == 0x000490, "Member 'UVSwimLocomotionHorseRiderAnimInstance::SwimLayerData' has a wrong offset!");

// Class Altar.AsyncAction_PushWidgetToLayer
// 0x0068 (0x0098 - 0x0030)
class UAsyncAction_PushWidgetToLayer final : public UCancellableAsyncAction
{
public:
	TMulticastInlineDelegate<void(class UCommonActivatableWidget* UserWidget)> BeforePush;           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UCommonActivatableWidget* UserWidget)> AfterPush;            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x48];                                      // 0x0050(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_PushWidgetToLayer* PushDefaultMenuToLayer(TSoftClassPtr<class UClass> ParentMenuClass, const struct FGameplayTag& LayerName, bool bSuspendInputUntilComplete);
	static class UAsyncAction_PushWidgetToLayer* PushWidgetToLayer(TSoftClassPtr<class UClass> WidgetClass, const struct FGameplayTag& LayerName, bool bSuspendInputUntilComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_PushWidgetToLayer">();
	}
	static class UAsyncAction_PushWidgetToLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_PushWidgetToLayer>();
	}
};
static_assert(alignof(UAsyncAction_PushWidgetToLayer) == 0x000008, "Wrong alignment on UAsyncAction_PushWidgetToLayer");
static_assert(sizeof(UAsyncAction_PushWidgetToLayer) == 0x000098, "Wrong size on UAsyncAction_PushWidgetToLayer");
static_assert(offsetof(UAsyncAction_PushWidgetToLayer, BeforePush) == 0x000030, "Member 'UAsyncAction_PushWidgetToLayer::BeforePush' has a wrong offset!");
static_assert(offsetof(UAsyncAction_PushWidgetToLayer, AfterPush) == 0x000040, "Member 'UAsyncAction_PushWidgetToLayer::AfterPush' has a wrong offset!");

// Class Altar.VPrimitiveComponentDebugData
// 0x0018 (0x0040 - 0x0028)
class UVPrimitiveComponentDebugData final : public UObject
{
public:
	class FName                                   LabelName;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComponentMobility                            Mobility;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionProfileName;                              // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesGenerateOverlapEvents;                        // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEverAffectNavigation;                          // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllowedToSimulate;                              // 0x003E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPrimitiveComponentDebugData">();
	}
	static class UVPrimitiveComponentDebugData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPrimitiveComponentDebugData>();
	}
};
static_assert(alignof(UVPrimitiveComponentDebugData) == 0x000008, "Wrong alignment on UVPrimitiveComponentDebugData");
static_assert(sizeof(UVPrimitiveComponentDebugData) == 0x000040, "Wrong size on UVPrimitiveComponentDebugData");
static_assert(offsetof(UVPrimitiveComponentDebugData, LabelName) == 0x000028, "Member 'UVPrimitiveComponentDebugData::LabelName' has a wrong offset!");
static_assert(offsetof(UVPrimitiveComponentDebugData, Mobility) == 0x000030, "Member 'UVPrimitiveComponentDebugData::Mobility' has a wrong offset!");
static_assert(offsetof(UVPrimitiveComponentDebugData, CollisionProfileName) == 0x000034, "Member 'UVPrimitiveComponentDebugData::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(UVPrimitiveComponentDebugData, bDoesGenerateOverlapEvents) == 0x00003C, "Member 'UVPrimitiveComponentDebugData::bDoesGenerateOverlapEvents' has a wrong offset!");
static_assert(offsetof(UVPrimitiveComponentDebugData, bCanEverAffectNavigation) == 0x00003D, "Member 'UVPrimitiveComponentDebugData::bCanEverAffectNavigation' has a wrong offset!");
static_assert(offsetof(UVPrimitiveComponentDebugData, bIsAllowedToSimulate) == 0x00003E, "Member 'UVPrimitiveComponentDebugData::bIsAllowedToSimulate' has a wrong offset!");

// Class Altar.TESScript
// 0x0018 (0x00F0 - 0x00D8)
class UTESScript final : public UTESForm
{
public:
	class FString                                 Source;                                            // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScriptType                                   Type;                                              // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESScript">();
	}
	static class UTESScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESScript>();
	}
};
static_assert(alignof(UTESScript) == 0x000008, "Wrong alignment on UTESScript");
static_assert(sizeof(UTESScript) == 0x0000F0, "Wrong size on UTESScript");
static_assert(offsetof(UTESScript, Source) == 0x0000D8, "Member 'UTESScript::Source' has a wrong offset!");
static_assert(offsetof(UTESScript, Type) == 0x0000E8, "Member 'UTESScript::Type' has a wrong offset!");

// Class Altar.TESMagicItemForm
// 0x0020 (0x00F8 - 0x00D8)
class UTESMagicItemForm : public UTESForm
{
public:
	class FString                                 FullName;                                          // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTESEffectSetting>> EffectSettings;                                  // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESMagicItemForm">();
	}
	static class UTESMagicItemForm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESMagicItemForm>();
	}
};
static_assert(alignof(UTESMagicItemForm) == 0x000008, "Wrong alignment on UTESMagicItemForm");
static_assert(sizeof(UTESMagicItemForm) == 0x0000F8, "Wrong size on UTESMagicItemForm");
static_assert(offsetof(UTESMagicItemForm, FullName) == 0x0000D8, "Member 'UTESMagicItemForm::FullName' has a wrong offset!");
static_assert(offsetof(UTESMagicItemForm, EffectSettings) == 0x0000E8, "Member 'UTESMagicItemForm::EffectSettings' has a wrong offset!");

// Class Altar.TESSpell
// 0x0000 (0x00F8 - 0x00F8)
class UTESSpell final : public UTESMagicItemForm
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESSpell">();
	}
	static class UTESSpell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESSpell>();
	}
};
static_assert(alignof(UTESSpell) == 0x000008, "Wrong alignment on UTESSpell");
static_assert(sizeof(UTESSpell) == 0x0000F8, "Wrong size on UTESSpell");

// Class Altar.bhkBlendController
// 0x0008 (0x0070 - 0x0068)
class UbhkBlendController final : public UNiTimeController
{
public:
	int64                                         Keys;                                              // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkBlendController">();
	}
	static class UbhkBlendController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkBlendController>();
	}
};
static_assert(alignof(UbhkBlendController) == 0x000008, "Wrong alignment on UbhkBlendController");
static_assert(sizeof(UbhkBlendController) == 0x000070, "Wrong size on UbhkBlendController");
static_assert(offsetof(UbhkBlendController, Keys) == 0x000068, "Member 'UbhkBlendController::Keys' has a wrong offset!");

// Class Altar.VLegacyMenuBookLine
// 0x0008 (0x02C8 - 0x02C0)
class UVLegacyMenuBookLine final : public UUserWidget
{
public:
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlignement(ELegacyBookStylizedTextAlignment Alignement);
	void SetFontFamily(const class FString& FontValue);
	struct FVector2D SetLineText(const class FText& Text, const struct FLegacyBookStylizedText& TextStyle, bool bForceLayoutPrepass);
	void SetRichText(const class FText& InText);

	class FString GetRichText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMenuBookLine">();
	}
	static class UVLegacyMenuBookLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMenuBookLine>();
	}
};
static_assert(alignof(UVLegacyMenuBookLine) == 0x000008, "Wrong alignment on UVLegacyMenuBookLine");
static_assert(sizeof(UVLegacyMenuBookLine) == 0x0002C8, "Wrong size on UVLegacyMenuBookLine");

// Class Altar.bhkConvexShapeBase
// 0x0000 (0x0038 - 0x0038)
class UbhkConvexShapeBase : public UbhkShape
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkConvexShapeBase">();
	}
	static class UbhkConvexShapeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkConvexShapeBase>();
	}
};
static_assert(alignof(UbhkConvexShapeBase) == 0x000008, "Wrong alignment on UbhkConvexShapeBase");
static_assert(sizeof(UbhkConvexShapeBase) == 0x000038, "Wrong size on UbhkConvexShapeBase");

// Class Altar.NiInterpolator
// 0x0000 (0x0038 - 0x0038)
class UNiInterpolator : public UNiObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiInterpolator">();
	}
	static class UNiInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiInterpolator>();
	}
};
static_assert(alignof(UNiInterpolator) == 0x000008, "Wrong alignment on UNiInterpolator");
static_assert(sizeof(UNiInterpolator) == 0x000038, "Wrong size on UNiInterpolator");

// Class Altar.bhkSphereRepShape
// 0x0008 (0x0040 - 0x0038)
class UbhkSphereRepShape : public UbhkConvexShapeBase
{
public:
	class UHavokMaterial*                         Material;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkSphereRepShape">();
	}
	static class UbhkSphereRepShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkSphereRepShape>();
	}
};
static_assert(alignof(UbhkSphereRepShape) == 0x000008, "Wrong alignment on UbhkSphereRepShape");
static_assert(sizeof(UbhkSphereRepShape) == 0x000040, "Wrong size on UbhkSphereRepShape");
static_assert(offsetof(UbhkSphereRepShape, Material) == 0x000038, "Member 'UbhkSphereRepShape::Material' has a wrong offset!");

// Class Altar.bhkConvexShape
// 0x0008 (0x0048 - 0x0040)
class UbhkConvexShape : public UbhkSphereRepShape
{
public:
	float                                         Radius;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkConvexShape">();
	}
	static class UbhkConvexShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkConvexShape>();
	}
};
static_assert(alignof(UbhkConvexShape) == 0x000008, "Wrong alignment on UbhkConvexShape");
static_assert(sizeof(UbhkConvexShape) == 0x000048, "Wrong size on UbhkConvexShape");
static_assert(offsetof(UbhkConvexShape, Radius) == 0x000040, "Member 'UbhkConvexShape::Radius' has a wrong offset!");

// Class Altar.VAltarMenu
// 0x0028 (0x04E8 - 0x04C0)
class UVAltarMenu : public UVNavigableActivatableWidgetBase
{
public:
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          FocusDefaultWidgetXbox;                            // 0x04C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C9[0x7];                                      // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IVEnhancedInputNavigable> WidgetToFocusOnControllerDesactivate;           // 0x04D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceSynchronizeProperties();
	void OnInputMethodChanged();
	void OnSynchronizeProperties();
	void SetViewModelReference(class UVViewModelBase* ViewModelRef);
	void SetWidgetToFocusOnControllerDesactivate(const TScriptInterface<class IVEnhancedInputNavigable>& Value);

	void BP_OnInputMethodChanged(const ECommonInputType& InputType) const;
	TScriptInterface<class IVEnhancedInputNavigable> GetWidgetToFocusOnControllerDesactivate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarMenu">();
	}
	static class UVAltarMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarMenu>();
	}
};
static_assert(alignof(UVAltarMenu) == 0x000008, "Wrong alignment on UVAltarMenu");
static_assert(sizeof(UVAltarMenu) == 0x0004E8, "Wrong size on UVAltarMenu");
static_assert(offsetof(UVAltarMenu, FocusDefaultWidgetXbox) == 0x0004C8, "Member 'UVAltarMenu::FocusDefaultWidgetXbox' has a wrong offset!");
static_assert(offsetof(UVAltarMenu, WidgetToFocusOnControllerDesactivate) == 0x0004D0, "Member 'UVAltarMenu::WidgetToFocusOnControllerDesactivate' has a wrong offset!");

// Class Altar.VLegacyPlayerSubMenuBase
// 0x0008 (0x04F0 - 0x04E8)
class UVLegacyPlayerSubMenuBase : public UVAltarMenu
{
public:
	uint8                                         Pad_4E8[0x8];                                      // 0x04E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeInOutMenu(bool bIsVisible, bool bFromLeft, bool bInstant);
	bool RouteBackEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyPlayerSubMenuBase">();
	}
	static class UVLegacyPlayerSubMenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyPlayerSubMenuBase>();
	}
};
static_assert(alignof(UVLegacyPlayerSubMenuBase) == 0x000008, "Wrong alignment on UVLegacyPlayerSubMenuBase");
static_assert(sizeof(UVLegacyPlayerSubMenuBase) == 0x0004F0, "Wrong size on UVLegacyPlayerSubMenuBase");

// Class Altar.VLegacyInventoryMenu
// 0x0038 (0x0528 - 0x04F0)
class UVLegacyInventoryMenu : public UVLegacyPlayerSubMenuBase
{
public:
	struct FLegacyMenuActionBinding               DropItemData;                                      // 0x04F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLegacyMenuActionBinding               SwitchPreviewData;                                 // 0x0508(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_520[0x8];                                      // 0x0520(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDropItemWithController();
	void SwitchPreviewWithController();

	class UVLegacyMagicPopupMenu* GetMagicPopup() const;
	class UVLegacyQuickKeysMenu* GetQuickKeys() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyInventoryMenu">();
	}
	static class UVLegacyInventoryMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyInventoryMenu>();
	}
};
static_assert(alignof(UVLegacyInventoryMenu) == 0x000008, "Wrong alignment on UVLegacyInventoryMenu");
static_assert(sizeof(UVLegacyInventoryMenu) == 0x000528, "Wrong size on UVLegacyInventoryMenu");
static_assert(offsetof(UVLegacyInventoryMenu, DropItemData) == 0x0004F0, "Member 'UVLegacyInventoryMenu::DropItemData' has a wrong offset!");
static_assert(offsetof(UVLegacyInventoryMenu, SwitchPreviewData) == 0x000508, "Member 'UVLegacyInventoryMenu::SwitchPreviewData' has a wrong offset!");

// Class Altar.VLegacyContainerMenu
// 0x0000 (0x0528 - 0x0528)
class UVLegacyContainerMenu : public UVLegacyInventoryMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyContainerMenu">();
	}
	static class UVLegacyContainerMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyContainerMenu>();
	}
};
static_assert(alignof(UVLegacyContainerMenu) == 0x000008, "Wrong alignment on UVLegacyContainerMenu");
static_assert(sizeof(UVLegacyContainerMenu) == 0x000528, "Wrong size on UVLegacyContainerMenu");

// Class Altar.VSubSpaceComponent
// 0x0010 (0x05E0 - 0x05D0)
class UVSubSpaceComponent final : public UDebugDrawComponent
{
public:
	struct FVector                                Dimensions;                                        // 0x05C8(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSubSpaceComponent">();
	}
	static class UVSubSpaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSubSpaceComponent>();
	}
};
static_assert(alignof(UVSubSpaceComponent) == 0x000010, "Wrong alignment on UVSubSpaceComponent");
static_assert(sizeof(UVSubSpaceComponent) == 0x0005E0, "Wrong size on UVSubSpaceComponent");
static_assert(offsetof(UVSubSpaceComponent, Dimensions) == 0x0005C8, "Member 'UVSubSpaceComponent::Dimensions' has a wrong offset!");

// Class Altar.NiPSysBombModifier
// 0x0030 (0x0090 - 0x0060)
class UNiPSysBombModifier final : public UNiPSysModifier
{
public:
	class UNiNode*                                BombObject;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BombAxis;                                          // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Decay;                                             // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaV;                                            // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDecayType                                    DecayType;                                         // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESymmetryType                                 SymmetryType;                                      // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysBombModifier">();
	}
	static class UNiPSysBombModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysBombModifier>();
	}
};
static_assert(alignof(UNiPSysBombModifier) == 0x000008, "Wrong alignment on UNiPSysBombModifier");
static_assert(sizeof(UNiPSysBombModifier) == 0x000090, "Wrong size on UNiPSysBombModifier");
static_assert(offsetof(UNiPSysBombModifier, BombObject) == 0x000060, "Member 'UNiPSysBombModifier::BombObject' has a wrong offset!");
static_assert(offsetof(UNiPSysBombModifier, BombAxis) == 0x000068, "Member 'UNiPSysBombModifier::BombAxis' has a wrong offset!");
static_assert(offsetof(UNiPSysBombModifier, Decay) == 0x000080, "Member 'UNiPSysBombModifier::Decay' has a wrong offset!");
static_assert(offsetof(UNiPSysBombModifier, DeltaV) == 0x000084, "Member 'UNiPSysBombModifier::DeltaV' has a wrong offset!");
static_assert(offsetof(UNiPSysBombModifier, DecayType) == 0x000088, "Member 'UNiPSysBombModifier::DecayType' has a wrong offset!");
static_assert(offsetof(UNiPSysBombModifier, SymmetryType) == 0x00008C, "Member 'UNiPSysBombModifier::SymmetryType' has a wrong offset!");

// Class Altar.bhkBoxShape
// 0x0030 (0x0078 - 0x0048)
class UbhkBoxShape final : public UbhkConvexShape
{
public:
	TArray<uint8>                                 Unused_01;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FVector                                Dimensions;                                        // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Unused_Float;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkBoxShape">();
	}
	static class UbhkBoxShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkBoxShape>();
	}
};
static_assert(alignof(UbhkBoxShape) == 0x000008, "Wrong alignment on UbhkBoxShape");
static_assert(sizeof(UbhkBoxShape) == 0x000078, "Wrong size on UbhkBoxShape");
static_assert(offsetof(UbhkBoxShape, Unused_01) == 0x000048, "Member 'UbhkBoxShape::Unused_01' has a wrong offset!");
static_assert(offsetof(UbhkBoxShape, Dimensions) == 0x000058, "Member 'UbhkBoxShape::Dimensions' has a wrong offset!");
static_assert(offsetof(UbhkBoxShape, Unused_Float) == 0x000070, "Member 'UbhkBoxShape::Unused_Float' has a wrong offset!");

// Class Altar.bhkBvTreeShape
// 0x0008 (0x0040 - 0x0038)
class UbhkBvTreeShape : public UbhkShape
{
public:
	class UbhkShape*                              Shape;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkBvTreeShape">();
	}
	static class UbhkBvTreeShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkBvTreeShape>();
	}
};
static_assert(alignof(UbhkBvTreeShape) == 0x000008, "Wrong alignment on UbhkBvTreeShape");
static_assert(sizeof(UbhkBvTreeShape) == 0x000040, "Wrong size on UbhkBvTreeShape");
static_assert(offsetof(UbhkBvTreeShape, Shape) == 0x000038, "Member 'UbhkBvTreeShape::Shape' has a wrong offset!");

// Class Altar.NiParticleInfo
// 0x0048 (0x0078 - 0x0030)
class UNiParticleInfo final : public UNifType
{
public:
	struct FVector                                Velocity;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationAxis;                                      // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Age;                                               // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastUpdate;                                        // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnGeneration;                                   // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Code;                                              // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiParticleInfo">();
	}
	static class UNiParticleInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiParticleInfo>();
	}
};
static_assert(alignof(UNiParticleInfo) == 0x000008, "Wrong alignment on UNiParticleInfo");
static_assert(sizeof(UNiParticleInfo) == 0x000078, "Wrong size on UNiParticleInfo");
static_assert(offsetof(UNiParticleInfo, Velocity) == 0x000030, "Member 'UNiParticleInfo::Velocity' has a wrong offset!");
static_assert(offsetof(UNiParticleInfo, RotationAxis) == 0x000048, "Member 'UNiParticleInfo::RotationAxis' has a wrong offset!");
static_assert(offsetof(UNiParticleInfo, Age) == 0x000060, "Member 'UNiParticleInfo::Age' has a wrong offset!");
static_assert(offsetof(UNiParticleInfo, LifeSpan) == 0x000064, "Member 'UNiParticleInfo::LifeSpan' has a wrong offset!");
static_assert(offsetof(UNiParticleInfo, LastUpdate) == 0x000068, "Member 'UNiParticleInfo::LastUpdate' has a wrong offset!");
static_assert(offsetof(UNiParticleInfo, SpawnGeneration) == 0x00006C, "Member 'UNiParticleInfo::SpawnGeneration' has a wrong offset!");
static_assert(offsetof(UNiParticleInfo, Code) == 0x000070, "Member 'UNiParticleInfo::Code' has a wrong offset!");

// Class Altar.VLegacySpellPurchaseMenuItem
// 0x0050 (0x0078 - 0x0028)
class UVLegacySpellPurchaseMenuItem final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const struct FLegacySpellPurchaseMenuItemProperties& Value);

	int32 GetListId() const;
	const struct FLegacySpellPurchaseMenuItemProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacySpellPurchaseMenuItem">();
	}
	static class UVLegacySpellPurchaseMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacySpellPurchaseMenuItem>();
	}
};
static_assert(alignof(UVLegacySpellPurchaseMenuItem) == 0x000008, "Wrong alignment on UVLegacySpellPurchaseMenuItem");
static_assert(sizeof(UVLegacySpellPurchaseMenuItem) == 0x000078, "Wrong size on UVLegacySpellPurchaseMenuItem");

// Class Altar.bhkCapsuleShape
// 0x0050 (0x0098 - 0x0048)
class UbhkCapsuleShape final : public UbhkConvexShape
{
public:
	TArray<uint8>                                 Unused1;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FVector                                FirstPoint;                                        // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius1;                                           // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SecondPoint;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius2;                                           // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkCapsuleShape">();
	}
	static class UbhkCapsuleShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkCapsuleShape>();
	}
};
static_assert(alignof(UbhkCapsuleShape) == 0x000008, "Wrong alignment on UbhkCapsuleShape");
static_assert(sizeof(UbhkCapsuleShape) == 0x000098, "Wrong size on UbhkCapsuleShape");
static_assert(offsetof(UbhkCapsuleShape, Unused1) == 0x000048, "Member 'UbhkCapsuleShape::Unused1' has a wrong offset!");
static_assert(offsetof(UbhkCapsuleShape, FirstPoint) == 0x000058, "Member 'UbhkCapsuleShape::FirstPoint' has a wrong offset!");
static_assert(offsetof(UbhkCapsuleShape, Radius1) == 0x000070, "Member 'UbhkCapsuleShape::Radius1' has a wrong offset!");
static_assert(offsetof(UbhkCapsuleShape, SecondPoint) == 0x000078, "Member 'UbhkCapsuleShape::SecondPoint' has a wrong offset!");
static_assert(offsetof(UbhkCapsuleShape, Radius2) == 0x000090, "Member 'UbhkCapsuleShape::Radius2' has a wrong offset!");

// Class Altar.bhkConstraint
// 0x0008 (0x0040 - 0x0038)
class UbhkConstraint : public UbhkSerializable
{
public:
	class UbhkConstraintCInfo*                    ConstraintInfo;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkConstraint">();
	}
	static class UbhkConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkConstraint>();
	}
};
static_assert(alignof(UbhkConstraint) == 0x000008, "Wrong alignment on UbhkConstraint");
static_assert(sizeof(UbhkConstraint) == 0x000040, "Wrong size on UbhkConstraint");
static_assert(offsetof(UbhkConstraint, ConstraintInfo) == 0x000038, "Member 'UbhkConstraint::ConstraintInfo' has a wrong offset!");

// Class Altar.VLegacyDialogMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyDialogMenu : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyDialogMenu">();
	}
	static class UVLegacyDialogMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyDialogMenu>();
	}
};
static_assert(alignof(UVLegacyDialogMenu) == 0x000008, "Wrong alignment on UVLegacyDialogMenu");
static_assert(sizeof(UVLegacyDialogMenu) == 0x0004E8, "Wrong size on UVLegacyDialogMenu");

// Class Altar.NiNode
// 0x0030 (0x00E0 - 0x00B0)
class UNiNode : public UNiAvObject
{
public:
	int64                                         NumChildren;                                       // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiAvObject*>                    Children;                                          // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumEffects;                                        // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiDynamicEffect*>               Effects;                                           // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiNode">();
	}
	static class UNiNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiNode>();
	}
};
static_assert(alignof(UNiNode) == 0x000008, "Wrong alignment on UNiNode");
static_assert(sizeof(UNiNode) == 0x0000E0, "Wrong size on UNiNode");
static_assert(offsetof(UNiNode, NumChildren) == 0x0000B0, "Member 'UNiNode::NumChildren' has a wrong offset!");
static_assert(offsetof(UNiNode, Children) == 0x0000B8, "Member 'UNiNode::Children' has a wrong offset!");
static_assert(offsetof(UNiNode, NumEffects) == 0x0000C8, "Member 'UNiNode::NumEffects' has a wrong offset!");
static_assert(offsetof(UNiNode, Effects) == 0x0000D0, "Member 'UNiNode::Effects' has a wrong offset!");

// Class Altar.NiBillboardNode
// 0x0008 (0x00E8 - 0x00E0)
class UNiBillboardNode final : public UNiNode
{
public:
	EBillboardMode                                BillboardMode;                                     // 0x00E0(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBillboardNode">();
	}
	static class UNiBillboardNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBillboardNode>();
	}
};
static_assert(alignof(UNiBillboardNode) == 0x000008, "Wrong alignment on UNiBillboardNode");
static_assert(sizeof(UNiBillboardNode) == 0x0000E8, "Wrong size on UNiBillboardNode");
static_assert(offsetof(UNiBillboardNode, BillboardMode) == 0x0000E0, "Member 'UNiBillboardNode::BillboardMode' has a wrong offset!");

// Class Altar.bhkConstraintCInfo
// 0x0020 (0x0050 - 0x0030)
class UbhkConstraintCInfo final : public UNifType
{
public:
	int64                                         NumEntities;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkEntity*                             EntityA;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkEntity*                             EntityB;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConstraintPriority                           Priority;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkConstraintCInfo">();
	}
	static class UbhkConstraintCInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkConstraintCInfo>();
	}
};
static_assert(alignof(UbhkConstraintCInfo) == 0x000008, "Wrong alignment on UbhkConstraintCInfo");
static_assert(sizeof(UbhkConstraintCInfo) == 0x000050, "Wrong size on UbhkConstraintCInfo");
static_assert(offsetof(UbhkConstraintCInfo, NumEntities) == 0x000030, "Member 'UbhkConstraintCInfo::NumEntities' has a wrong offset!");
static_assert(offsetof(UbhkConstraintCInfo, EntityA) == 0x000038, "Member 'UbhkConstraintCInfo::EntityA' has a wrong offset!");
static_assert(offsetof(UbhkConstraintCInfo, EntityB) == 0x000040, "Member 'UbhkConstraintCInfo::EntityB' has a wrong offset!");
static_assert(offsetof(UbhkConstraintCInfo, Priority) == 0x000048, "Member 'UbhkConstraintCInfo::Priority' has a wrong offset!");

// Class Altar.bhkConstraintMotorCInfo
// 0x0020 (0x0050 - 0x0030)
class UbhkConstraintMotorCInfo final : public UNifType
{
public:
	EhkMotorType                                  Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UbhkPositionConstraintMotor*            PositionMotor;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkVelocityConstraintMotor*            VelocityMotor;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkSpringDamperConstraintMotor*        SpringDamperMotor;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkConstraintMotorCInfo">();
	}
	static class UbhkConstraintMotorCInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkConstraintMotorCInfo>();
	}
};
static_assert(alignof(UbhkConstraintMotorCInfo) == 0x000008, "Wrong alignment on UbhkConstraintMotorCInfo");
static_assert(sizeof(UbhkConstraintMotorCInfo) == 0x000050, "Wrong size on UbhkConstraintMotorCInfo");
static_assert(offsetof(UbhkConstraintMotorCInfo, Type) == 0x000030, "Member 'UbhkConstraintMotorCInfo::Type' has a wrong offset!");
static_assert(offsetof(UbhkConstraintMotorCInfo, PositionMotor) == 0x000038, "Member 'UbhkConstraintMotorCInfo::PositionMotor' has a wrong offset!");
static_assert(offsetof(UbhkConstraintMotorCInfo, VelocityMotor) == 0x000040, "Member 'UbhkConstraintMotorCInfo::VelocityMotor' has a wrong offset!");
static_assert(offsetof(UbhkConstraintMotorCInfo, SpringDamperMotor) == 0x000048, "Member 'UbhkConstraintMotorCInfo::SpringDamperMotor' has a wrong offset!");

// Class Altar.NiExtraData
// 0x0010 (0x0048 - 0x0038)
class UNiExtraData : public UNiObject
{
public:
	struct FNifString                             Name_0;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiExtraData">();
	}
	static class UNiExtraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiExtraData>();
	}
};
static_assert(alignof(UNiExtraData) == 0x000008, "Wrong alignment on UNiExtraData");
static_assert(sizeof(UNiExtraData) == 0x000048, "Wrong size on UNiExtraData");
static_assert(offsetof(UNiExtraData, Name_0) == 0x000038, "Member 'UNiExtraData::Name_0' has a wrong offset!");

// Class Altar.NiBooleanExtraData
// 0x0008 (0x0050 - 0x0048)
class UNiBooleanExtraData final : public UNiExtraData
{
public:
	uint8                                         BooleanData;                                       // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBooleanExtraData">();
	}
	static class UNiBooleanExtraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBooleanExtraData>();
	}
};
static_assert(alignof(UNiBooleanExtraData) == 0x000008, "Wrong alignment on UNiBooleanExtraData");
static_assert(sizeof(UNiBooleanExtraData) == 0x000050, "Wrong size on UNiBooleanExtraData");
static_assert(offsetof(UNiBooleanExtraData, BooleanData) == 0x000048, "Member 'UNiBooleanExtraData::BooleanData' has a wrong offset!");

// Class Altar.bhkConvexSweepShape
// 0x0020 (0x0058 - 0x0038)
class UbhkConvexSweepShape final : public UbhkConvexShapeBase
{
public:
	class UbhkConvexShape*                        Shape;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHavokMaterial*                         Material;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0xC];                                       // 0x004C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkConvexSweepShape">();
	}
	static class UbhkConvexSweepShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkConvexSweepShape>();
	}
};
static_assert(alignof(UbhkConvexSweepShape) == 0x000008, "Wrong alignment on UbhkConvexSweepShape");
static_assert(sizeof(UbhkConvexSweepShape) == 0x000058, "Wrong size on UbhkConvexSweepShape");
static_assert(offsetof(UbhkConvexSweepShape, Shape) == 0x000038, "Member 'UbhkConvexSweepShape::Shape' has a wrong offset!");
static_assert(offsetof(UbhkConvexSweepShape, Material) == 0x000040, "Member 'UbhkConvexSweepShape::Material' has a wrong offset!");
static_assert(offsetof(UbhkConvexSweepShape, Radius) == 0x000048, "Member 'UbhkConvexSweepShape::Radius' has a wrong offset!");

// Class Altar.bhkConvexTransformShape
// 0x0030 (0x0068 - 0x0038)
class UbhkConvexTransformShape final : public UbhkConvexShapeBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHavokMaterial*                         Material;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 Unused_01;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UMatrix44*                              Transform;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkConvexTransformShape">();
	}
	static class UbhkConvexTransformShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkConvexTransformShape>();
	}
};
static_assert(alignof(UbhkConvexTransformShape) == 0x000008, "Wrong alignment on UbhkConvexTransformShape");
static_assert(sizeof(UbhkConvexTransformShape) == 0x000068, "Wrong size on UbhkConvexTransformShape");
static_assert(offsetof(UbhkConvexTransformShape, Material) == 0x000040, "Member 'UbhkConvexTransformShape::Material' has a wrong offset!");
static_assert(offsetof(UbhkConvexTransformShape, Radius) == 0x000048, "Member 'UbhkConvexTransformShape::Radius' has a wrong offset!");
static_assert(offsetof(UbhkConvexTransformShape, Unused_01) == 0x000050, "Member 'UbhkConvexTransformShape::Unused_01' has a wrong offset!");
static_assert(offsetof(UbhkConvexTransformShape, Transform) == 0x000060, "Member 'UbhkConvexTransformShape::Transform' has a wrong offset!");

// Class Altar.VLegacyGameplayMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyGameplayMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyGameplayMenu">();
	}
	static class UVLegacyGameplayMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyGameplayMenu>();
	}
};
static_assert(alignof(UVLegacyGameplayMenu) == 0x000008, "Wrong alignment on UVLegacyGameplayMenu");
static_assert(sizeof(UVLegacyGameplayMenu) == 0x0004E8, "Wrong size on UVLegacyGameplayMenu");

// Class Altar.NiBlendInterpolator
// 0x0058 (0x0090 - 0x0038)
class UNiBlendInterpolator : public UNiInterpolator
{
public:
	EInterpBlendFlags                             Flags_0;                                           // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ArraySizeUshort;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArrayGrowBy;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ArraySizeByte;                                     // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeightThreshold;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InterpCount;                                       // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SingleIndex;                                       // 0x004D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HighPriority;                                      // 0x004E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NextHighPriority;                                  // 0x004F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SingleTime;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighWeightsSum;                                    // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextHighWeightsSum;                                // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighEaseSpinner;                                   // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInterpBlendItem*>               InterpArrayItems;                                  // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          ManagerControlled;                                 // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyUseHighestWeight;                              // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InterpCountUshort;                                 // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SingleIndexUshort;                                 // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiInterpolator*                        SingleInterpolator;                                // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighPriorityInt;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextHighPriorityInt;                               // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBlendInterpolator">();
	}
	static class UNiBlendInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBlendInterpolator>();
	}
};
static_assert(alignof(UNiBlendInterpolator) == 0x000008, "Wrong alignment on UNiBlendInterpolator");
static_assert(sizeof(UNiBlendInterpolator) == 0x000090, "Wrong size on UNiBlendInterpolator");
static_assert(offsetof(UNiBlendInterpolator, Flags_0) == 0x000038, "Member 'UNiBlendInterpolator::Flags_0' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, ArraySizeUshort) == 0x00003C, "Member 'UNiBlendInterpolator::ArraySizeUshort' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, ArrayGrowBy) == 0x000040, "Member 'UNiBlendInterpolator::ArrayGrowBy' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, ArraySizeByte) == 0x000044, "Member 'UNiBlendInterpolator::ArraySizeByte' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, WeightThreshold) == 0x000048, "Member 'UNiBlendInterpolator::WeightThreshold' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, InterpCount) == 0x00004C, "Member 'UNiBlendInterpolator::InterpCount' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, SingleIndex) == 0x00004D, "Member 'UNiBlendInterpolator::SingleIndex' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, HighPriority) == 0x00004E, "Member 'UNiBlendInterpolator::HighPriority' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, NextHighPriority) == 0x00004F, "Member 'UNiBlendInterpolator::NextHighPriority' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, SingleTime) == 0x000050, "Member 'UNiBlendInterpolator::SingleTime' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, HighWeightsSum) == 0x000054, "Member 'UNiBlendInterpolator::HighWeightsSum' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, NextHighWeightsSum) == 0x000058, "Member 'UNiBlendInterpolator::NextHighWeightsSum' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, HighEaseSpinner) == 0x00005C, "Member 'UNiBlendInterpolator::HighEaseSpinner' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, InterpArrayItems) == 0x000060, "Member 'UNiBlendInterpolator::InterpArrayItems' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, ManagerControlled) == 0x000070, "Member 'UNiBlendInterpolator::ManagerControlled' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, OnlyUseHighestWeight) == 0x000071, "Member 'UNiBlendInterpolator::OnlyUseHighestWeight' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, InterpCountUshort) == 0x000074, "Member 'UNiBlendInterpolator::InterpCountUshort' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, SingleIndexUshort) == 0x000078, "Member 'UNiBlendInterpolator::SingleIndexUshort' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, SingleInterpolator) == 0x000080, "Member 'UNiBlendInterpolator::SingleInterpolator' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, HighPriorityInt) == 0x000088, "Member 'UNiBlendInterpolator::HighPriorityInt' has a wrong offset!");
static_assert(offsetof(UNiBlendInterpolator, NextHighPriorityInt) == 0x00008C, "Member 'UNiBlendInterpolator::NextHighPriorityInt' has a wrong offset!");

// Class Altar.NiBlendBoolInterpolator
// 0x0008 (0x0098 - 0x0090)
class UNiBlendBoolInterpolator final : public UNiBlendInterpolator
{
public:
	uint8                                         Value;                                             // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBlendBoolInterpolator">();
	}
	static class UNiBlendBoolInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBlendBoolInterpolator>();
	}
};
static_assert(alignof(UNiBlendBoolInterpolator) == 0x000008, "Wrong alignment on UNiBlendBoolInterpolator");
static_assert(sizeof(UNiBlendBoolInterpolator) == 0x000098, "Wrong size on UNiBlendBoolInterpolator");
static_assert(offsetof(UNiBlendBoolInterpolator, Value) == 0x000090, "Member 'UNiBlendBoolInterpolator::Value' has a wrong offset!");

// Class Altar.bhkConvexVerticesShape
// 0x0040 (0x0088 - 0x0048)
class UbhkConvexVerticesShape final : public UbhkConvexShape
{
public:
	class UbhkWorldObjCInfoProperty*              VerticesProperty;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkWorldObjCInfoProperty*              NormalsProperty;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumVertices;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVTSVector4f>                   Vertices;                                          // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumNormals;                                        // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVTSVector4f>                   Normals;                                           // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkConvexVerticesShape">();
	}
	static class UbhkConvexVerticesShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkConvexVerticesShape>();
	}
};
static_assert(alignof(UbhkConvexVerticesShape) == 0x000008, "Wrong alignment on UbhkConvexVerticesShape");
static_assert(sizeof(UbhkConvexVerticesShape) == 0x000088, "Wrong size on UbhkConvexVerticesShape");
static_assert(offsetof(UbhkConvexVerticesShape, VerticesProperty) == 0x000048, "Member 'UbhkConvexVerticesShape::VerticesProperty' has a wrong offset!");
static_assert(offsetof(UbhkConvexVerticesShape, NormalsProperty) == 0x000050, "Member 'UbhkConvexVerticesShape::NormalsProperty' has a wrong offset!");
static_assert(offsetof(UbhkConvexVerticesShape, NumVertices) == 0x000058, "Member 'UbhkConvexVerticesShape::NumVertices' has a wrong offset!");
static_assert(offsetof(UbhkConvexVerticesShape, Vertices) == 0x000060, "Member 'UbhkConvexVerticesShape::Vertices' has a wrong offset!");
static_assert(offsetof(UbhkConvexVerticesShape, NumNormals) == 0x000070, "Member 'UbhkConvexVerticesShape::NumNormals' has a wrong offset!");
static_assert(offsetof(UbhkConvexVerticesShape, Normals) == 0x000078, "Member 'UbhkConvexVerticesShape::Normals' has a wrong offset!");

// Class Altar.bhkWorldObject
// 0x0020 (0x0058 - 0x0038)
class UbhkWorldObject : public UbhkSerializable
{
public:
	class UbhkShape*                              Shape;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHavokFilter*                           Filter;                                            // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkWorldObjectCInfo*                   WorldObjectInfo;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkWorldObject">();
	}
	static class UbhkWorldObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkWorldObject>();
	}
};
static_assert(alignof(UbhkWorldObject) == 0x000008, "Wrong alignment on UbhkWorldObject");
static_assert(sizeof(UbhkWorldObject) == 0x000058, "Wrong size on UbhkWorldObject");
static_assert(offsetof(UbhkWorldObject, Shape) == 0x000038, "Member 'UbhkWorldObject::Shape' has a wrong offset!");
static_assert(offsetof(UbhkWorldObject, Filter) == 0x000048, "Member 'UbhkWorldObject::Filter' has a wrong offset!");
static_assert(offsetof(UbhkWorldObject, WorldObjectInfo) == 0x000050, "Member 'UbhkWorldObject::WorldObjectInfo' has a wrong offset!");

// Class Altar.NiAVObjectPalette
// 0x0000 (0x0038 - 0x0038)
class UNiAVObjectPalette : public UNiObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiAVObjectPalette">();
	}
	static class UNiAVObjectPalette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiAVObjectPalette>();
	}
};
static_assert(alignof(UNiAVObjectPalette) == 0x000008, "Wrong alignment on UNiAVObjectPalette");
static_assert(sizeof(UNiAVObjectPalette) == 0x000038, "Wrong size on UNiAVObjectPalette");

// Class Altar.bhkEntity
// 0x0008 (0x0060 - 0x0058)
class UbhkEntity : public UbhkWorldObject
{
public:
	class UbhkEntityCInfo*                        EntityInfo;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkEntity">();
	}
	static class UbhkEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkEntity>();
	}
};
static_assert(alignof(UbhkEntity) == 0x000008, "Wrong alignment on UbhkEntity");
static_assert(sizeof(UbhkEntity) == 0x000060, "Wrong size on UbhkEntity");
static_assert(offsetof(UbhkEntity, EntityInfo) == 0x000058, "Member 'UbhkEntity::EntityInfo' has a wrong offset!");

// Class Altar.bhkEntityCInfo
// 0x0008 (0x0038 - 0x0030)
class UbhkEntityCInfo final : public UNifType
{
public:
	EhkResponseType                               CollisionResponse;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProcessContactCallbackDelay;                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkEntityCInfo">();
	}
	static class UbhkEntityCInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkEntityCInfo>();
	}
};
static_assert(alignof(UbhkEntityCInfo) == 0x000008, "Wrong alignment on UbhkEntityCInfo");
static_assert(sizeof(UbhkEntityCInfo) == 0x000038, "Wrong size on UbhkEntityCInfo");
static_assert(offsetof(UbhkEntityCInfo, CollisionResponse) == 0x000030, "Member 'UbhkEntityCInfo::CollisionResponse' has a wrong offset!");
static_assert(offsetof(UbhkEntityCInfo, ProcessContactCallbackDelay) == 0x000034, "Member 'UbhkEntityCInfo::ProcessContactCallbackDelay' has a wrong offset!");

// Class Altar.VLoadingScreen
// 0x0000 (0x04E8 - 0x04E8)
class UVLoadingScreen : public UVAltarMenu
{
public:
	void BeginRemoveLoadingScreen();

	void OnRemoveLoadingScreenEnded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLoadingScreen">();
	}
	static class UVLoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLoadingScreen>();
	}
};
static_assert(alignof(UVLoadingScreen) == 0x000008, "Wrong alignment on UVLoadingScreen");
static_assert(sizeof(UVLoadingScreen) == 0x0004E8, "Wrong size on UVLoadingScreen");

// Class Altar.NiBoneLODController
// 0x0028 (0x0090 - 0x0068)
class UNiBoneLODController : public UNiTimeController
{
public:
	int64                                         LOD;                                               // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumLODs;                                           // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumNodeGroups;                                     // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNodeSet*>                       NodeGroups;                                        // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBoneLODController">();
	}
	static class UNiBoneLODController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBoneLODController>();
	}
};
static_assert(alignof(UNiBoneLODController) == 0x000008, "Wrong alignment on UNiBoneLODController");
static_assert(sizeof(UNiBoneLODController) == 0x000090, "Wrong size on UNiBoneLODController");
static_assert(offsetof(UNiBoneLODController, LOD) == 0x000068, "Member 'UNiBoneLODController::LOD' has a wrong offset!");
static_assert(offsetof(UNiBoneLODController, NumLODs) == 0x000070, "Member 'UNiBoneLODController::NumLODs' has a wrong offset!");
static_assert(offsetof(UNiBoneLODController, NumNodeGroups) == 0x000078, "Member 'UNiBoneLODController::NumNodeGroups' has a wrong offset!");
static_assert(offsetof(UNiBoneLODController, NodeGroups) == 0x000080, "Member 'UNiBoneLODController::NodeGroups' has a wrong offset!");

// Class Altar.bhkHingeConstraint
// 0x0008 (0x0048 - 0x0040)
class UbhkHingeConstraint final : public UbhkConstraint
{
public:
	class UbhkHingeConstraintCInfo*               Constraint;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkHingeConstraint">();
	}
	static class UbhkHingeConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkHingeConstraint>();
	}
};
static_assert(alignof(UbhkHingeConstraint) == 0x000008, "Wrong alignment on UbhkHingeConstraint");
static_assert(sizeof(UbhkHingeConstraint) == 0x000048, "Wrong size on UbhkHingeConstraint");
static_assert(offsetof(UbhkHingeConstraint, Constraint) == 0x000040, "Member 'UbhkHingeConstraint::Constraint' has a wrong offset!");

// Class Altar.bhkHingeConstraintCInfo
// 0x0080 (0x00B0 - 0x0030)
class UbhkHingeConstraintCInfo final : public UNifType
{
public:
	struct FVTSVector4f                           PivotA;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PerpAxisInA1;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PerpAxisInA2;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PivotB;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           AxisB;                                             // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           AxisA;                                             // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PerpAxisInB1;                                      // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PerpAxisInB2;                                      // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkHingeConstraintCInfo">();
	}
	static class UbhkHingeConstraintCInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkHingeConstraintCInfo>();
	}
};
static_assert(alignof(UbhkHingeConstraintCInfo) == 0x000008, "Wrong alignment on UbhkHingeConstraintCInfo");
static_assert(sizeof(UbhkHingeConstraintCInfo) == 0x0000B0, "Wrong size on UbhkHingeConstraintCInfo");
static_assert(offsetof(UbhkHingeConstraintCInfo, PivotA) == 0x000030, "Member 'UbhkHingeConstraintCInfo::PivotA' has a wrong offset!");
static_assert(offsetof(UbhkHingeConstraintCInfo, PerpAxisInA1) == 0x000040, "Member 'UbhkHingeConstraintCInfo::PerpAxisInA1' has a wrong offset!");
static_assert(offsetof(UbhkHingeConstraintCInfo, PerpAxisInA2) == 0x000050, "Member 'UbhkHingeConstraintCInfo::PerpAxisInA2' has a wrong offset!");
static_assert(offsetof(UbhkHingeConstraintCInfo, PivotB) == 0x000060, "Member 'UbhkHingeConstraintCInfo::PivotB' has a wrong offset!");
static_assert(offsetof(UbhkHingeConstraintCInfo, AxisB) == 0x000070, "Member 'UbhkHingeConstraintCInfo::AxisB' has a wrong offset!");
static_assert(offsetof(UbhkHingeConstraintCInfo, AxisA) == 0x000080, "Member 'UbhkHingeConstraintCInfo::AxisA' has a wrong offset!");
static_assert(offsetof(UbhkHingeConstraintCInfo, PerpAxisInB1) == 0x000090, "Member 'UbhkHingeConstraintCInfo::PerpAxisInB1' has a wrong offset!");
static_assert(offsetof(UbhkHingeConstraintCInfo, PerpAxisInB2) == 0x0000A0, "Member 'UbhkHingeConstraintCInfo::PerpAxisInB2' has a wrong offset!");

// Class Altar.VSimpleInAirCharacterAnimInstance
// 0x0010 (0x03B0 - 0x03A0)
class UVSimpleInAirCharacterAnimInstance final : public UVLayerCharacterAnimInstance
{
public:
	struct FSimpleInAirAnimationData              LayerData;                                         // 0x03A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	bool IsInAir() const;
	bool IsLanding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSimpleInAirCharacterAnimInstance">();
	}
	static class UVSimpleInAirCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSimpleInAirCharacterAnimInstance>();
	}
};
static_assert(alignof(UVSimpleInAirCharacterAnimInstance) == 0x000010, "Wrong alignment on UVSimpleInAirCharacterAnimInstance");
static_assert(sizeof(UVSimpleInAirCharacterAnimInstance) == 0x0003B0, "Wrong size on UVSimpleInAirCharacterAnimInstance");
static_assert(offsetof(UVSimpleInAirCharacterAnimInstance, LayerData) == 0x0003A0, "Member 'UVSimpleInAirCharacterAnimInstance::LayerData' has a wrong offset!");

// Class Altar.NiBSplineInterpolator
// 0x0018 (0x0050 - 0x0038)
class UNiBSplineInterpolator : public UNiInterpolator
{
public:
	float                                         StartTime;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTime;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiBSplineData*                         SplineData;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiBSplineBasisData*                    BasisData;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBSplineInterpolator">();
	}
	static class UNiBSplineInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBSplineInterpolator>();
	}
};
static_assert(alignof(UNiBSplineInterpolator) == 0x000008, "Wrong alignment on UNiBSplineInterpolator");
static_assert(sizeof(UNiBSplineInterpolator) == 0x000050, "Wrong size on UNiBSplineInterpolator");
static_assert(offsetof(UNiBSplineInterpolator, StartTime) == 0x000038, "Member 'UNiBSplineInterpolator::StartTime' has a wrong offset!");
static_assert(offsetof(UNiBSplineInterpolator, StopTime) == 0x00003C, "Member 'UNiBSplineInterpolator::StopTime' has a wrong offset!");
static_assert(offsetof(UNiBSplineInterpolator, SplineData) == 0x000040, "Member 'UNiBSplineInterpolator::SplineData' has a wrong offset!");
static_assert(offsetof(UNiBSplineInterpolator, BasisData) == 0x000048, "Member 'UNiBSplineInterpolator::BasisData' has a wrong offset!");

// Class Altar.NiBSplineFloatInterpolator
// 0x0010 (0x0060 - 0x0050)
class UNiBSplineFloatInterpolator : public UNiBSplineInterpolator
{
public:
	float                                         Value;                                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Handle;                                            // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBSplineFloatInterpolator">();
	}
	static class UNiBSplineFloatInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBSplineFloatInterpolator>();
	}
};
static_assert(alignof(UNiBSplineFloatInterpolator) == 0x000008, "Wrong alignment on UNiBSplineFloatInterpolator");
static_assert(sizeof(UNiBSplineFloatInterpolator) == 0x000060, "Wrong size on UNiBSplineFloatInterpolator");
static_assert(offsetof(UNiBSplineFloatInterpolator, Value) == 0x000050, "Member 'UNiBSplineFloatInterpolator::Value' has a wrong offset!");
static_assert(offsetof(UNiBSplineFloatInterpolator, Handle) == 0x000058, "Member 'UNiBSplineFloatInterpolator::Handle' has a wrong offset!");

// Class Altar.bhkLimitedHingeConstraint
// 0x0008 (0x0048 - 0x0040)
class UbhkLimitedHingeConstraint final : public UbhkConstraint
{
public:
	class UbhkLimitedHingeConstraintCInfo*        Constraint;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkLimitedHingeConstraint">();
	}
	static class UbhkLimitedHingeConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkLimitedHingeConstraint>();
	}
};
static_assert(alignof(UbhkLimitedHingeConstraint) == 0x000008, "Wrong alignment on UbhkLimitedHingeConstraint");
static_assert(sizeof(UbhkLimitedHingeConstraint) == 0x000048, "Wrong size on UbhkLimitedHingeConstraint");
static_assert(offsetof(UbhkLimitedHingeConstraint, Constraint) == 0x000040, "Member 'UbhkLimitedHingeConstraint::Constraint' has a wrong offset!");

// Class Altar.bhkLimitedHingeConstraintCInfo
// 0x0098 (0x00C8 - 0x0030)
class UbhkLimitedHingeConstraintCInfo final : public UNifType
{
public:
	struct FVTSVector4f                           PivotA;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           AxisA;                                             // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PerpAxisInA1;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PerpAxisInA2;                                      // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PivotB;                                            // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           AxisB;                                             // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PerpAxisInB2;                                      // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PerpAxisInB1;                                      // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinAngle;                                          // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFriction;                                       // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UbhkConstraintMotorCInfo*               Motor;                                             // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkLimitedHingeConstraintCInfo">();
	}
	static class UbhkLimitedHingeConstraintCInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkLimitedHingeConstraintCInfo>();
	}
};
static_assert(alignof(UbhkLimitedHingeConstraintCInfo) == 0x000008, "Wrong alignment on UbhkLimitedHingeConstraintCInfo");
static_assert(sizeof(UbhkLimitedHingeConstraintCInfo) == 0x0000C8, "Wrong size on UbhkLimitedHingeConstraintCInfo");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, PivotA) == 0x000030, "Member 'UbhkLimitedHingeConstraintCInfo::PivotA' has a wrong offset!");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, AxisA) == 0x000040, "Member 'UbhkLimitedHingeConstraintCInfo::AxisA' has a wrong offset!");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, PerpAxisInA1) == 0x000050, "Member 'UbhkLimitedHingeConstraintCInfo::PerpAxisInA1' has a wrong offset!");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, PerpAxisInA2) == 0x000060, "Member 'UbhkLimitedHingeConstraintCInfo::PerpAxisInA2' has a wrong offset!");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, PivotB) == 0x000070, "Member 'UbhkLimitedHingeConstraintCInfo::PivotB' has a wrong offset!");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, AxisB) == 0x000080, "Member 'UbhkLimitedHingeConstraintCInfo::AxisB' has a wrong offset!");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, PerpAxisInB2) == 0x000090, "Member 'UbhkLimitedHingeConstraintCInfo::PerpAxisInB2' has a wrong offset!");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, PerpAxisInB1) == 0x0000A0, "Member 'UbhkLimitedHingeConstraintCInfo::PerpAxisInB1' has a wrong offset!");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, MinAngle) == 0x0000B0, "Member 'UbhkLimitedHingeConstraintCInfo::MinAngle' has a wrong offset!");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, MaxAngle) == 0x0000B4, "Member 'UbhkLimitedHingeConstraintCInfo::MaxAngle' has a wrong offset!");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, MaxFriction) == 0x0000B8, "Member 'UbhkLimitedHingeConstraintCInfo::MaxFriction' has a wrong offset!");
static_assert(offsetof(UbhkLimitedHingeConstraintCInfo, Motor) == 0x0000C0, "Member 'UbhkLimitedHingeConstraintCInfo::Motor' has a wrong offset!");

// Class Altar.VLocomotionStandingAnimInstance
// 0x0020 (0x0480 - 0x0460)
class UVLocomotionStandingAnimInstance : public UVLocomotionCharacterAnimInstance
{
public:
	struct FVLocomotion                           AnimSet;                                           // 0x0460(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVSprinting                            SprintSet;                                         // 0x0468(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsInDialogue;                                     // 0x0470(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSprinting;                                      // 0x0471(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasBowEquipped;                                   // 0x0472(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_473[0xD];                                      // 0x0473(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLocomotionStandingAnimInstance">();
	}
	static class UVLocomotionStandingAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLocomotionStandingAnimInstance>();
	}
};
static_assert(alignof(UVLocomotionStandingAnimInstance) == 0x000010, "Wrong alignment on UVLocomotionStandingAnimInstance");
static_assert(sizeof(UVLocomotionStandingAnimInstance) == 0x000480, "Wrong size on UVLocomotionStandingAnimInstance");
static_assert(offsetof(UVLocomotionStandingAnimInstance, AnimSet) == 0x000460, "Member 'UVLocomotionStandingAnimInstance::AnimSet' has a wrong offset!");
static_assert(offsetof(UVLocomotionStandingAnimInstance, SprintSet) == 0x000468, "Member 'UVLocomotionStandingAnimInstance::SprintSet' has a wrong offset!");
static_assert(offsetof(UVLocomotionStandingAnimInstance, bIsInDialogue) == 0x000470, "Member 'UVLocomotionStandingAnimInstance::bIsInDialogue' has a wrong offset!");
static_assert(offsetof(UVLocomotionStandingAnimInstance, bIsSprinting) == 0x000471, "Member 'UVLocomotionStandingAnimInstance::bIsSprinting' has a wrong offset!");
static_assert(offsetof(UVLocomotionStandingAnimInstance, bHasBowEquipped) == 0x000472, "Member 'UVLocomotionStandingAnimInstance::bHasBowEquipped' has a wrong offset!");

// Class Altar.NiKeyBasedInterpolator
// 0x0000 (0x0038 - 0x0038)
class UNiKeyBasedInterpolator : public UNiInterpolator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiKeyBasedInterpolator">();
	}
	static class UNiKeyBasedInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiKeyBasedInterpolator>();
	}
};
static_assert(alignof(UNiKeyBasedInterpolator) == 0x000008, "Wrong alignment on UNiKeyBasedInterpolator");
static_assert(sizeof(UNiKeyBasedInterpolator) == 0x000038, "Wrong size on UNiKeyBasedInterpolator");

// Class Altar.bhkShapeCollection
// 0x0000 (0x0038 - 0x0038)
class UbhkShapeCollection : public UbhkShape
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkShapeCollection">();
	}
	static class UbhkShapeCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkShapeCollection>();
	}
};
static_assert(alignof(UbhkShapeCollection) == 0x000008, "Wrong alignment on UbhkShapeCollection");
static_assert(sizeof(UbhkShapeCollection) == 0x000038, "Wrong size on UbhkShapeCollection");

// Class Altar.bhkListShape
// 0x0048 (0x0080 - 0x0038)
class UbhkListShape final : public UbhkShapeCollection
{
public:
	int64                                         NumSubShapes;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UbhkShape*>                      SubShapes;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UHavokMaterial*                         Material;                                          // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkWorldObjCInfoProperty*              ChildShapeProperty;                                // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkWorldObjCInfoProperty*              ChildFilterProperty;                               // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumFilters;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHavokFilter*>                   Filters;                                           // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkListShape">();
	}
	static class UbhkListShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkListShape>();
	}
};
static_assert(alignof(UbhkListShape) == 0x000008, "Wrong alignment on UbhkListShape");
static_assert(sizeof(UbhkListShape) == 0x000080, "Wrong size on UbhkListShape");
static_assert(offsetof(UbhkListShape, NumSubShapes) == 0x000038, "Member 'UbhkListShape::NumSubShapes' has a wrong offset!");
static_assert(offsetof(UbhkListShape, SubShapes) == 0x000040, "Member 'UbhkListShape::SubShapes' has a wrong offset!");
static_assert(offsetof(UbhkListShape, Material) == 0x000050, "Member 'UbhkListShape::Material' has a wrong offset!");
static_assert(offsetof(UbhkListShape, ChildShapeProperty) == 0x000058, "Member 'UbhkListShape::ChildShapeProperty' has a wrong offset!");
static_assert(offsetof(UbhkListShape, ChildFilterProperty) == 0x000060, "Member 'UbhkListShape::ChildFilterProperty' has a wrong offset!");
static_assert(offsetof(UbhkListShape, NumFilters) == 0x000068, "Member 'UbhkListShape::NumFilters' has a wrong offset!");
static_assert(offsetof(UbhkListShape, Filters) == 0x000070, "Member 'UbhkListShape::Filters' has a wrong offset!");

// Class Altar.NiBlendPoint3Interpolator
// 0x0018 (0x00A8 - 0x0090)
class UNiBlendPoint3Interpolator final : public UNiBlendInterpolator
{
public:
	struct FVector                                Value;                                             // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBlendPoint3Interpolator">();
	}
	static class UNiBlendPoint3Interpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBlendPoint3Interpolator>();
	}
};
static_assert(alignof(UNiBlendPoint3Interpolator) == 0x000008, "Wrong alignment on UNiBlendPoint3Interpolator");
static_assert(sizeof(UNiBlendPoint3Interpolator) == 0x0000A8, "Wrong size on UNiBlendPoint3Interpolator");
static_assert(offsetof(UNiBlendPoint3Interpolator, Value) == 0x000090, "Member 'UNiBlendPoint3Interpolator::Value' has a wrong offset!");

// Class Altar.bhkMalleableConstraint
// 0x0008 (0x0048 - 0x0040)
class UbhkMalleableConstraint final : public UbhkConstraint
{
public:
	class UbhkMalleableConstraintCInfo*           MalleableConstraint;                               // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkMalleableConstraint">();
	}
	static class UbhkMalleableConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkMalleableConstraint>();
	}
};
static_assert(alignof(UbhkMalleableConstraint) == 0x000008, "Wrong alignment on UbhkMalleableConstraint");
static_assert(sizeof(UbhkMalleableConstraint) == 0x000048, "Wrong size on UbhkMalleableConstraint");
static_assert(offsetof(UbhkMalleableConstraint, MalleableConstraint) == 0x000040, "Member 'UbhkMalleableConstraint::MalleableConstraint' has a wrong offset!");

// Class Altar.bhkMalleableConstraintCInfo
// 0x0050 (0x0080 - 0x0030)
class UbhkMalleableConstraintCInfo final : public UNifType
{
public:
	EBHKConstraintType                            Type;                                              // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UbhkConstraintCInfo*                    ConstraintInfo;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkBallAndSocketConstraintCInfo*       BallAndSocket;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkHingeConstraintCInfo*               Hinge;                                             // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkLimitedHingeConstraintCInfo*        LimitedHinge;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkPrismaticConstraintCInfo*           Prismatic;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkRagdollConstraintCInfo*             Ragdoll;                                           // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkStiffSpringConstraintCInfo*         StiffSpring;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tau;                                               // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkMalleableConstraintCInfo">();
	}
	static class UbhkMalleableConstraintCInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkMalleableConstraintCInfo>();
	}
};
static_assert(alignof(UbhkMalleableConstraintCInfo) == 0x000008, "Wrong alignment on UbhkMalleableConstraintCInfo");
static_assert(sizeof(UbhkMalleableConstraintCInfo) == 0x000080, "Wrong size on UbhkMalleableConstraintCInfo");
static_assert(offsetof(UbhkMalleableConstraintCInfo, Type) == 0x000030, "Member 'UbhkMalleableConstraintCInfo::Type' has a wrong offset!");
static_assert(offsetof(UbhkMalleableConstraintCInfo, ConstraintInfo) == 0x000038, "Member 'UbhkMalleableConstraintCInfo::ConstraintInfo' has a wrong offset!");
static_assert(offsetof(UbhkMalleableConstraintCInfo, BallAndSocket) == 0x000040, "Member 'UbhkMalleableConstraintCInfo::BallAndSocket' has a wrong offset!");
static_assert(offsetof(UbhkMalleableConstraintCInfo, Hinge) == 0x000048, "Member 'UbhkMalleableConstraintCInfo::Hinge' has a wrong offset!");
static_assert(offsetof(UbhkMalleableConstraintCInfo, LimitedHinge) == 0x000050, "Member 'UbhkMalleableConstraintCInfo::LimitedHinge' has a wrong offset!");
static_assert(offsetof(UbhkMalleableConstraintCInfo, Prismatic) == 0x000058, "Member 'UbhkMalleableConstraintCInfo::Prismatic' has a wrong offset!");
static_assert(offsetof(UbhkMalleableConstraintCInfo, Ragdoll) == 0x000060, "Member 'UbhkMalleableConstraintCInfo::Ragdoll' has a wrong offset!");
static_assert(offsetof(UbhkMalleableConstraintCInfo, StiffSpring) == 0x000068, "Member 'UbhkMalleableConstraintCInfo::StiffSpring' has a wrong offset!");
static_assert(offsetof(UbhkMalleableConstraintCInfo, Tau) == 0x000070, "Member 'UbhkMalleableConstraintCInfo::Tau' has a wrong offset!");
static_assert(offsetof(UbhkMalleableConstraintCInfo, Damping) == 0x000074, "Member 'UbhkMalleableConstraintCInfo::Damping' has a wrong offset!");
static_assert(offsetof(UbhkMalleableConstraintCInfo, Strength) == 0x000078, "Member 'UbhkMalleableConstraintCInfo::Strength' has a wrong offset!");

// Class Altar.VLegacyMagicMenuHeader
// 0x0020 (0x0048 - 0x0028)
class UVLegacyMagicMenuHeader final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const struct FLegacyMagicMenuHeaderProperties& Value);

	const struct FLegacyMagicMenuHeaderProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMagicMenuHeader">();
	}
	static class UVLegacyMagicMenuHeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMagicMenuHeader>();
	}
};
static_assert(alignof(UVLegacyMagicMenuHeader) == 0x000008, "Wrong alignment on UVLegacyMagicMenuHeader");
static_assert(sizeof(UVLegacyMagicMenuHeader) == 0x000048, "Wrong size on UVLegacyMagicMenuHeader");

// Class Altar.NiBSplineBasisData
// 0x0020 (0x0058 - 0x0038)
class UNiBSplineBasisData final : public UNiObject
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBSplineBasisData">();
	}
	static class UNiBSplineBasisData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBSplineBasisData>();
	}
};
static_assert(alignof(UNiBSplineBasisData) == 0x000008, "Wrong alignment on UNiBSplineBasisData");
static_assert(sizeof(UNiBSplineBasisData) == 0x000058, "Wrong size on UNiBSplineBasisData");

// Class Altar.bhkMeshShape
// 0x0078 (0x00B0 - 0x0038)
class UbhkMeshShape final : public UbhkShape
{
public:
	TArray<int64>                                 Unknown01;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 Unknown02;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NumShapeProperties;                                // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UbhkWorldObjCInfoProperty*>      ShapeProperties;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<int64>                                 Unknown03;                                         // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumStripsData;                                     // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiTriStripsData*>               StripsData;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkMeshShape">();
	}
	static class UbhkMeshShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkMeshShape>();
	}
};
static_assert(alignof(UbhkMeshShape) == 0x000008, "Wrong alignment on UbhkMeshShape");
static_assert(sizeof(UbhkMeshShape) == 0x0000B0, "Wrong size on UbhkMeshShape");
static_assert(offsetof(UbhkMeshShape, Unknown01) == 0x000038, "Member 'UbhkMeshShape::Unknown01' has a wrong offset!");
static_assert(offsetof(UbhkMeshShape, Radius) == 0x000048, "Member 'UbhkMeshShape::Radius' has a wrong offset!");
static_assert(offsetof(UbhkMeshShape, Unknown02) == 0x000050, "Member 'UbhkMeshShape::Unknown02' has a wrong offset!");
static_assert(offsetof(UbhkMeshShape, NumShapeProperties) == 0x000070, "Member 'UbhkMeshShape::NumShapeProperties' has a wrong offset!");
static_assert(offsetof(UbhkMeshShape, ShapeProperties) == 0x000078, "Member 'UbhkMeshShape::ShapeProperties' has a wrong offset!");
static_assert(offsetof(UbhkMeshShape, Unknown03) == 0x000088, "Member 'UbhkMeshShape::Unknown03' has a wrong offset!");
static_assert(offsetof(UbhkMeshShape, NumStripsData) == 0x000098, "Member 'UbhkMeshShape::NumStripsData' has a wrong offset!");
static_assert(offsetof(UbhkMeshShape, StripsData) == 0x0000A0, "Member 'UbhkMeshShape::StripsData' has a wrong offset!");

// Class Altar.bhkMoppBvTreeShape
// 0x0020 (0x0060 - 0x0040)
class UbhkMoppBvTreeShape final : public UbhkBvTreeShape
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UhkpMoppCode*                           MoppCode;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkMoppBvTreeShape">();
	}
	static class UbhkMoppBvTreeShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkMoppBvTreeShape>();
	}
};
static_assert(alignof(UbhkMoppBvTreeShape) == 0x000008, "Wrong alignment on UbhkMoppBvTreeShape");
static_assert(sizeof(UbhkMoppBvTreeShape) == 0x000060, "Wrong size on UbhkMoppBvTreeShape");
static_assert(offsetof(UbhkMoppBvTreeShape, Scale) == 0x000050, "Member 'UbhkMoppBvTreeShape::Scale' has a wrong offset!");
static_assert(offsetof(UbhkMoppBvTreeShape, MoppCode) == 0x000058, "Member 'UbhkMoppBvTreeShape::MoppCode' has a wrong offset!");

// Class Altar.NiControllerManager
// 0x0028 (0x0090 - 0x0068)
class UNiControllerManager final : public UNiTimeController
{
public:
	bool                                          Cumulative;                                        // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NumControllerSequence;                             // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiControllerSequence*>          ControllerSequences;                               // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UNiDefaultAVObjectPalette*              ObjectPalette;                                     // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiControllerManager">();
	}
	static class UNiControllerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiControllerManager>();
	}
};
static_assert(alignof(UNiControllerManager) == 0x000008, "Wrong alignment on UNiControllerManager");
static_assert(sizeof(UNiControllerManager) == 0x000090, "Wrong size on UNiControllerManager");
static_assert(offsetof(UNiControllerManager, Cumulative) == 0x000068, "Member 'UNiControllerManager::Cumulative' has a wrong offset!");
static_assert(offsetof(UNiControllerManager, NumControllerSequence) == 0x000070, "Member 'UNiControllerManager::NumControllerSequence' has a wrong offset!");
static_assert(offsetof(UNiControllerManager, ControllerSequences) == 0x000078, "Member 'UNiControllerManager::ControllerSequences' has a wrong offset!");
static_assert(offsetof(UNiControllerManager, ObjectPalette) == 0x000088, "Member 'UNiControllerManager::ObjectPalette' has a wrong offset!");

// Class Altar.bhkMultiSphereShape
// 0x0020 (0x0060 - 0x0040)
class UbhkMultiSphereShape final : public UbhkSphereRepShape
{
public:
	class UbhkWorldObjCInfoProperty*              ShapeProperty;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumSpheres;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNiBound>                       Spheres;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkMultiSphereShape">();
	}
	static class UbhkMultiSphereShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkMultiSphereShape>();
	}
};
static_assert(alignof(UbhkMultiSphereShape) == 0x000008, "Wrong alignment on UbhkMultiSphereShape");
static_assert(sizeof(UbhkMultiSphereShape) == 0x000060, "Wrong size on UbhkMultiSphereShape");
static_assert(offsetof(UbhkMultiSphereShape, ShapeProperty) == 0x000040, "Member 'UbhkMultiSphereShape::ShapeProperty' has a wrong offset!");
static_assert(offsetof(UbhkMultiSphereShape, NumSpheres) == 0x000048, "Member 'UbhkMultiSphereShape::NumSpheres' has a wrong offset!");
static_assert(offsetof(UbhkMultiSphereShape, Spheres) == 0x000050, "Member 'UbhkMultiSphereShape::Spheres' has a wrong offset!");

// Class Altar.bhkNiTriStripsShape
// 0x0068 (0x00A0 - 0x0038)
class UbhkNiTriStripsShape final : public UbhkShapeCollection
{
public:
	class UHavokMaterial*                         Material;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x14];                                      // 0x0044(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         GrowBy;                                            // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Scale;                                             // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumStripsData;                                     // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiTriStripsData*>               StripsData;                                        // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumFilters;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHavokFilter*>                   Filters;                                           // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkNiTriStripsShape">();
	}
	static class UbhkNiTriStripsShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkNiTriStripsShape>();
	}
};
static_assert(alignof(UbhkNiTriStripsShape) == 0x000008, "Wrong alignment on UbhkNiTriStripsShape");
static_assert(sizeof(UbhkNiTriStripsShape) == 0x0000A0, "Wrong size on UbhkNiTriStripsShape");
static_assert(offsetof(UbhkNiTriStripsShape, Material) == 0x000038, "Member 'UbhkNiTriStripsShape::Material' has a wrong offset!");
static_assert(offsetof(UbhkNiTriStripsShape, Radius) == 0x000040, "Member 'UbhkNiTriStripsShape::Radius' has a wrong offset!");
static_assert(offsetof(UbhkNiTriStripsShape, GrowBy) == 0x000058, "Member 'UbhkNiTriStripsShape::GrowBy' has a wrong offset!");
static_assert(offsetof(UbhkNiTriStripsShape, Scale) == 0x000060, "Member 'UbhkNiTriStripsShape::Scale' has a wrong offset!");
static_assert(offsetof(UbhkNiTriStripsShape, NumStripsData) == 0x000070, "Member 'UbhkNiTriStripsShape::NumStripsData' has a wrong offset!");
static_assert(offsetof(UbhkNiTriStripsShape, StripsData) == 0x000078, "Member 'UbhkNiTriStripsShape::StripsData' has a wrong offset!");
static_assert(offsetof(UbhkNiTriStripsShape, NumFilters) == 0x000088, "Member 'UbhkNiTriStripsShape::NumFilters' has a wrong offset!");
static_assert(offsetof(UbhkNiTriStripsShape, Filters) == 0x000090, "Member 'UbhkNiTriStripsShape::Filters' has a wrong offset!");

// Class Altar.VVFXBlueprint
// 0x0008 (0x02A0 - 0x0298)
class AVVFXBlueprint : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeFirstPerson(bool bIsFirstPerson);
	void OnChangeLevel();
	void OnPause(bool bIsPaused);
	void PauseThisVFX(bool bIsPaused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VVFXBlueprint">();
	}
	static class AVVFXBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVVFXBlueprint>();
	}
};
static_assert(alignof(AVVFXBlueprint) == 0x000008, "Wrong alignment on AVVFXBlueprint");
static_assert(sizeof(AVVFXBlueprint) == 0x0002A0, "Wrong size on AVVFXBlueprint");

// Class Altar.VMagicSpellVFXBlueprint
// 0x0000 (0x02A0 - 0x02A0)
class AVMagicSpellVFXBlueprint final : public AVVFXBlueprint
{
public:
	void OnStartPlay(const struct FBlueprintParameters& Parameters, bool bIsTargetAnActor, class AActor* CasterActor, bool bDoesBeginInFirstPerson, EVCastType CastType, int32 Magnitude, int32 Area, int32 Duration, const struct FVector_NetQuantizeNormal& ImpactNormal, const struct FVector_NetQuantizeNormal& Normal, EVSpellLevel Level, bool bIsTheEndOfTheEffect, bool bIsMainEffect, bool bIsSecondEffect, class AActor* CollidedActor, class UPrimitiveComponent* CollidedComponent);
	void OnStopPlay();
	void OnTargetDead();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMagicSpellVFXBlueprint">();
	}
	static class AVMagicSpellVFXBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVMagicSpellVFXBlueprint>();
	}
};
static_assert(alignof(AVMagicSpellVFXBlueprint) == 0x000008, "Wrong alignment on AVMagicSpellVFXBlueprint");
static_assert(sizeof(AVMagicSpellVFXBlueprint) == 0x0002A0, "Wrong size on AVMagicSpellVFXBlueprint");

// Class Altar.NiBSplineTransformInterpolator
// 0x0020 (0x0070 - 0x0050)
class UNiBSplineTransformInterpolator : public UNiBSplineInterpolator
{
public:
	class UNiQuatTransform*                       Transform;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TranslationHandle;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RotationHandle;                                    // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ScaleHandle;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBSplineTransformInterpolator">();
	}
	static class UNiBSplineTransformInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBSplineTransformInterpolator>();
	}
};
static_assert(alignof(UNiBSplineTransformInterpolator) == 0x000008, "Wrong alignment on UNiBSplineTransformInterpolator");
static_assert(sizeof(UNiBSplineTransformInterpolator) == 0x000070, "Wrong size on UNiBSplineTransformInterpolator");
static_assert(offsetof(UNiBSplineTransformInterpolator, Transform) == 0x000050, "Member 'UNiBSplineTransformInterpolator::Transform' has a wrong offset!");
static_assert(offsetof(UNiBSplineTransformInterpolator, TranslationHandle) == 0x000058, "Member 'UNiBSplineTransformInterpolator::TranslationHandle' has a wrong offset!");
static_assert(offsetof(UNiBSplineTransformInterpolator, RotationHandle) == 0x000060, "Member 'UNiBSplineTransformInterpolator::RotationHandle' has a wrong offset!");
static_assert(offsetof(UNiBSplineTransformInterpolator, ScaleHandle) == 0x000068, "Member 'UNiBSplineTransformInterpolator::ScaleHandle' has a wrong offset!");

// Class Altar.bhkPackedNiTriStripsShape
// 0x0070 (0x00A8 - 0x0038)
class UbhkPackedNiTriStripsShape final : public UbhkShapeCollection
{
public:
	int32                                         NumSubShapes;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UhkSubPartData*>                 SubShapes;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         UserData;                                          // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Unused1;                                           // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Unused2;                                           // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusCopy;                                        // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScaleCopy;                                         // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UhkPackedNiTriStripsData*               Data;                                              // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkPackedNiTriStripsShape">();
	}
	static class UbhkPackedNiTriStripsShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkPackedNiTriStripsShape>();
	}
};
static_assert(alignof(UbhkPackedNiTriStripsShape) == 0x000008, "Wrong alignment on UbhkPackedNiTriStripsShape");
static_assert(sizeof(UbhkPackedNiTriStripsShape) == 0x0000A8, "Wrong size on UbhkPackedNiTriStripsShape");
static_assert(offsetof(UbhkPackedNiTriStripsShape, NumSubShapes) == 0x000038, "Member 'UbhkPackedNiTriStripsShape::NumSubShapes' has a wrong offset!");
static_assert(offsetof(UbhkPackedNiTriStripsShape, SubShapes) == 0x000040, "Member 'UbhkPackedNiTriStripsShape::SubShapes' has a wrong offset!");
static_assert(offsetof(UbhkPackedNiTriStripsShape, UserData) == 0x000050, "Member 'UbhkPackedNiTriStripsShape::UserData' has a wrong offset!");
static_assert(offsetof(UbhkPackedNiTriStripsShape, Unused1) == 0x000058, "Member 'UbhkPackedNiTriStripsShape::Unused1' has a wrong offset!");
static_assert(offsetof(UbhkPackedNiTriStripsShape, Radius) == 0x00005C, "Member 'UbhkPackedNiTriStripsShape::Radius' has a wrong offset!");
static_assert(offsetof(UbhkPackedNiTriStripsShape, Unused2) == 0x000060, "Member 'UbhkPackedNiTriStripsShape::Unused2' has a wrong offset!");
static_assert(offsetof(UbhkPackedNiTriStripsShape, Scale) == 0x000068, "Member 'UbhkPackedNiTriStripsShape::Scale' has a wrong offset!");
static_assert(offsetof(UbhkPackedNiTriStripsShape, RadiusCopy) == 0x000080, "Member 'UbhkPackedNiTriStripsShape::RadiusCopy' has a wrong offset!");
static_assert(offsetof(UbhkPackedNiTriStripsShape, ScaleCopy) == 0x000088, "Member 'UbhkPackedNiTriStripsShape::ScaleCopy' has a wrong offset!");
static_assert(offsetof(UbhkPackedNiTriStripsShape, Data) == 0x0000A0, "Member 'UbhkPackedNiTriStripsShape::Data' has a wrong offset!");

// Class Altar.bhkPCollisionObject
// 0x0000 (0x0050 - 0x0050)
class UbhkPCollisionObject : public UbhkNiCollisionObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkPCollisionObject">();
	}
	static class UbhkPCollisionObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkPCollisionObject>();
	}
};
static_assert(alignof(UbhkPCollisionObject) == 0x000008, "Wrong alignment on UbhkPCollisionObject");
static_assert(sizeof(UbhkPCollisionObject) == 0x000050, "Wrong size on UbhkPCollisionObject");

// Class Altar.NiBoolInterpolator
// 0x0010 (0x0048 - 0x0038)
class UNiBoolInterpolator : public UNiKeyBasedInterpolator
{
public:
	bool                                          Value;                                             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiBoolData*                            Data;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBoolInterpolator">();
	}
	static class UNiBoolInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBoolInterpolator>();
	}
};
static_assert(alignof(UNiBoolInterpolator) == 0x000008, "Wrong alignment on UNiBoolInterpolator");
static_assert(sizeof(UNiBoolInterpolator) == 0x000048, "Wrong size on UNiBoolInterpolator");
static_assert(offsetof(UNiBoolInterpolator, Value) == 0x000038, "Member 'UNiBoolInterpolator::Value' has a wrong offset!");
static_assert(offsetof(UNiBoolInterpolator, Data) == 0x000040, "Member 'UNiBoolInterpolator::Data' has a wrong offset!");

// Class Altar.NiBoolTimelineInterpolator
// 0x0000 (0x0048 - 0x0048)
class UNiBoolTimelineInterpolator final : public UNiBoolInterpolator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBoolTimelineInterpolator">();
	}
	static class UNiBoolTimelineInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBoolTimelineInterpolator>();
	}
};
static_assert(alignof(UNiBoolTimelineInterpolator) == 0x000008, "Wrong alignment on UNiBoolTimelineInterpolator");
static_assert(sizeof(UNiBoolTimelineInterpolator) == 0x000048, "Wrong size on UNiBoolTimelineInterpolator");

// Class Altar.bhkPhantom
// 0x0000 (0x0058 - 0x0058)
class UbhkPhantom : public UbhkWorldObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkPhantom">();
	}
	static class UbhkPhantom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkPhantom>();
	}
};
static_assert(alignof(UbhkPhantom) == 0x000008, "Wrong alignment on UbhkPhantom");
static_assert(sizeof(UbhkPhantom) == 0x000058, "Wrong size on UbhkPhantom");

// Class Altar.bhkPositionConstraintMotor
// 0x0020 (0x0050 - 0x0030)
class UbhkPositionConstraintMotor final : public UNifType
{
public:
	float                                         MinForce;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForce;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tau;                                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProportionalRecoveryVelocity;                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstantRecoveryVelocity;                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MotorEnabled;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkPositionConstraintMotor">();
	}
	static class UbhkPositionConstraintMotor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkPositionConstraintMotor>();
	}
};
static_assert(alignof(UbhkPositionConstraintMotor) == 0x000008, "Wrong alignment on UbhkPositionConstraintMotor");
static_assert(sizeof(UbhkPositionConstraintMotor) == 0x000050, "Wrong size on UbhkPositionConstraintMotor");
static_assert(offsetof(UbhkPositionConstraintMotor, MinForce) == 0x000030, "Member 'UbhkPositionConstraintMotor::MinForce' has a wrong offset!");
static_assert(offsetof(UbhkPositionConstraintMotor, MaxForce) == 0x000034, "Member 'UbhkPositionConstraintMotor::MaxForce' has a wrong offset!");
static_assert(offsetof(UbhkPositionConstraintMotor, Tau) == 0x000038, "Member 'UbhkPositionConstraintMotor::Tau' has a wrong offset!");
static_assert(offsetof(UbhkPositionConstraintMotor, Damping) == 0x00003C, "Member 'UbhkPositionConstraintMotor::Damping' has a wrong offset!");
static_assert(offsetof(UbhkPositionConstraintMotor, ProportionalRecoveryVelocity) == 0x000040, "Member 'UbhkPositionConstraintMotor::ProportionalRecoveryVelocity' has a wrong offset!");
static_assert(offsetof(UbhkPositionConstraintMotor, ConstantRecoveryVelocity) == 0x000044, "Member 'UbhkPositionConstraintMotor::ConstantRecoveryVelocity' has a wrong offset!");
static_assert(offsetof(UbhkPositionConstraintMotor, MotorEnabled) == 0x000048, "Member 'UbhkPositionConstraintMotor::MotorEnabled' has a wrong offset!");

// Class Altar.VLegacyMainMenu
// 0x0008 (0x04F0 - 0x04E8)
class UVLegacyMainMenu : public UVAltarMenu
{
public:
	uint8                                         Pad_4E8[0x8];                                      // 0x04E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWorld* GetCurrentWorld();
	void SetDebugMode(bool bInNewDebug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMainMenu">();
	}
	static class UVLegacyMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMainMenu>();
	}
};
static_assert(alignof(UVLegacyMainMenu) == 0x000008, "Wrong alignment on UVLegacyMainMenu");
static_assert(sizeof(UVLegacyMainMenu) == 0x0004F0, "Wrong size on UVLegacyMainMenu");

// Class Altar.bhkPrismaticConstraint
// 0x0008 (0x0048 - 0x0040)
class UbhkPrismaticConstraint final : public UbhkConstraint
{
public:
	class UbhkPrismaticConstraintCInfo*           Constraint;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkPrismaticConstraint">();
	}
	static class UbhkPrismaticConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkPrismaticConstraint>();
	}
};
static_assert(alignof(UbhkPrismaticConstraint) == 0x000008, "Wrong alignment on UbhkPrismaticConstraint");
static_assert(sizeof(UbhkPrismaticConstraint) == 0x000048, "Wrong size on UbhkPrismaticConstraint");
static_assert(offsetof(UbhkPrismaticConstraint, Constraint) == 0x000040, "Member 'UbhkPrismaticConstraint::Constraint' has a wrong offset!");

// Class Altar.VOriginal_AltarInventoryFilterIconTable
// 0x0050 (0x0100 - 0x00B0)
class UVOriginal_AltarInventoryFilterIconTable final : public UDataTable
{
public:
	TMap<EOriginalInventoryMenuSortType, struct FOriginal_InventoryFilterTableRow> InventoryFilterIconDesign; // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOriginal_AltarInventoryFilterIconTable">();
	}
	static class UVOriginal_AltarInventoryFilterIconTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOriginal_AltarInventoryFilterIconTable>();
	}
};
static_assert(alignof(UVOriginal_AltarInventoryFilterIconTable) == 0x000008, "Wrong alignment on UVOriginal_AltarInventoryFilterIconTable");
static_assert(sizeof(UVOriginal_AltarInventoryFilterIconTable) == 0x000100, "Wrong size on UVOriginal_AltarInventoryFilterIconTable");
static_assert(offsetof(UVOriginal_AltarInventoryFilterIconTable, InventoryFilterIconDesign) == 0x0000B0, "Member 'UVOriginal_AltarInventoryFilterIconTable::InventoryFilterIconDesign' has a wrong offset!");

// Class Altar.bhkPrismaticConstraintCInfo
// 0x0098 (0x00C8 - 0x0030)
class UbhkPrismaticConstraintCInfo final : public UNifType
{
public:
	struct FVTSVector4f                           PivotA;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           RotationA;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PlaneA;                                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           SlidingA;                                          // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           SlidingB;                                          // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PivotB;                                            // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           RotationB;                                         // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PlaneB;                                            // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UbhkConstraintMotorCInfo*               Motor;                                             // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkPrismaticConstraintCInfo">();
	}
	static class UbhkPrismaticConstraintCInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkPrismaticConstraintCInfo>();
	}
};
static_assert(alignof(UbhkPrismaticConstraintCInfo) == 0x000008, "Wrong alignment on UbhkPrismaticConstraintCInfo");
static_assert(sizeof(UbhkPrismaticConstraintCInfo) == 0x0000C8, "Wrong size on UbhkPrismaticConstraintCInfo");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, PivotA) == 0x000030, "Member 'UbhkPrismaticConstraintCInfo::PivotA' has a wrong offset!");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, RotationA) == 0x000040, "Member 'UbhkPrismaticConstraintCInfo::RotationA' has a wrong offset!");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, PlaneA) == 0x000050, "Member 'UbhkPrismaticConstraintCInfo::PlaneA' has a wrong offset!");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, SlidingA) == 0x000060, "Member 'UbhkPrismaticConstraintCInfo::SlidingA' has a wrong offset!");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, SlidingB) == 0x000070, "Member 'UbhkPrismaticConstraintCInfo::SlidingB' has a wrong offset!");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, PivotB) == 0x000080, "Member 'UbhkPrismaticConstraintCInfo::PivotB' has a wrong offset!");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, RotationB) == 0x000090, "Member 'UbhkPrismaticConstraintCInfo::RotationB' has a wrong offset!");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, PlaneB) == 0x0000A0, "Member 'UbhkPrismaticConstraintCInfo::PlaneB' has a wrong offset!");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, MinDistance) == 0x0000B0, "Member 'UbhkPrismaticConstraintCInfo::MinDistance' has a wrong offset!");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, MaxDistance) == 0x0000B4, "Member 'UbhkPrismaticConstraintCInfo::MaxDistance' has a wrong offset!");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, Friction) == 0x0000B8, "Member 'UbhkPrismaticConstraintCInfo::Friction' has a wrong offset!");
static_assert(offsetof(UbhkPrismaticConstraintCInfo, Motor) == 0x0000C0, "Member 'UbhkPrismaticConstraintCInfo::Motor' has a wrong offset!");

// Class Altar.NiFloatInterpolator
// 0x0010 (0x0048 - 0x0038)
class UNiFloatInterpolator final : public UNiKeyBasedInterpolator
{
public:
	float                                         Value;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiFloatData*                           Data;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiFloatInterpolator">();
	}
	static class UNiFloatInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiFloatInterpolator>();
	}
};
static_assert(alignof(UNiFloatInterpolator) == 0x000008, "Wrong alignment on UNiFloatInterpolator");
static_assert(sizeof(UNiFloatInterpolator) == 0x000048, "Wrong size on UNiFloatInterpolator");
static_assert(offsetof(UNiFloatInterpolator, Value) == 0x000038, "Member 'UNiFloatInterpolator::Value' has a wrong offset!");
static_assert(offsetof(UNiFloatInterpolator, Data) == 0x000040, "Member 'UNiFloatInterpolator::Data' has a wrong offset!");

// Class Altar.bhkRagdollConstraint
// 0x0008 (0x0048 - 0x0040)
class UbhkRagdollConstraint final : public UbhkConstraint
{
public:
	class UbhkRagdollConstraintCInfo*             Constraint;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkRagdollConstraint">();
	}
	static class UbhkRagdollConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkRagdollConstraint>();
	}
};
static_assert(alignof(UbhkRagdollConstraint) == 0x000008, "Wrong alignment on UbhkRagdollConstraint");
static_assert(sizeof(UbhkRagdollConstraint) == 0x000048, "Wrong size on UbhkRagdollConstraint");
static_assert(offsetof(UbhkRagdollConstraint, Constraint) == 0x000040, "Member 'UbhkRagdollConstraint::Constraint' has a wrong offset!");

// Class Altar.bhkRagdollConstraintCInfo
// 0x00A0 (0x00D0 - 0x0030)
class UbhkRagdollConstraintCInfo final : public UNifType
{
public:
	struct FVTSVector4f                           PivotA;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PlaneA;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           TwistA;                                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PivotB;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PlaneB;                                            // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           TwistB;                                            // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           MotorA;                                            // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           MotorB;                                            // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConeMaxAngle;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaneMinAngle;                                     // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaneMaxAngle;                                     // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwistMinAngle;                                     // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwistMaxAngle;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFriction;                                       // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkConstraintMotorCInfo*               Motor;                                             // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkRagdollConstraintCInfo">();
	}
	static class UbhkRagdollConstraintCInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkRagdollConstraintCInfo>();
	}
};
static_assert(alignof(UbhkRagdollConstraintCInfo) == 0x000008, "Wrong alignment on UbhkRagdollConstraintCInfo");
static_assert(sizeof(UbhkRagdollConstraintCInfo) == 0x0000D0, "Wrong size on UbhkRagdollConstraintCInfo");
static_assert(offsetof(UbhkRagdollConstraintCInfo, PivotA) == 0x000030, "Member 'UbhkRagdollConstraintCInfo::PivotA' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, PlaneA) == 0x000040, "Member 'UbhkRagdollConstraintCInfo::PlaneA' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, TwistA) == 0x000050, "Member 'UbhkRagdollConstraintCInfo::TwistA' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, PivotB) == 0x000060, "Member 'UbhkRagdollConstraintCInfo::PivotB' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, PlaneB) == 0x000070, "Member 'UbhkRagdollConstraintCInfo::PlaneB' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, TwistB) == 0x000080, "Member 'UbhkRagdollConstraintCInfo::TwistB' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, MotorA) == 0x000090, "Member 'UbhkRagdollConstraintCInfo::MotorA' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, MotorB) == 0x0000A0, "Member 'UbhkRagdollConstraintCInfo::MotorB' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, ConeMaxAngle) == 0x0000B0, "Member 'UbhkRagdollConstraintCInfo::ConeMaxAngle' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, PlaneMinAngle) == 0x0000B4, "Member 'UbhkRagdollConstraintCInfo::PlaneMinAngle' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, PlaneMaxAngle) == 0x0000B8, "Member 'UbhkRagdollConstraintCInfo::PlaneMaxAngle' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, TwistMinAngle) == 0x0000BC, "Member 'UbhkRagdollConstraintCInfo::TwistMinAngle' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, TwistMaxAngle) == 0x0000C0, "Member 'UbhkRagdollConstraintCInfo::TwistMaxAngle' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, MaxFriction) == 0x0000C4, "Member 'UbhkRagdollConstraintCInfo::MaxFriction' has a wrong offset!");
static_assert(offsetof(UbhkRagdollConstraintCInfo, Motor) == 0x0000C8, "Member 'UbhkRagdollConstraintCInfo::Motor' has a wrong offset!");

// Class Altar.VLegacyMessageMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyMessageMenu : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMessageMenu">();
	}
	static class UVLegacyMessageMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMessageMenu>();
	}
};
static_assert(alignof(UVLegacyMessageMenu) == 0x000008, "Wrong alignment on UVLegacyMessageMenu");
static_assert(sizeof(UVLegacyMessageMenu) == 0x0004E8, "Wrong size on UVLegacyMessageMenu");

// Class Altar.bhkRigidBody
// 0x0040 (0x00A0 - 0x0060)
class UbhkRigidBody : public UbhkEntity
{
public:
	class UbhkRigidBodyCInfo550_660*              RigidBodyInfobhkRigidBodyCInfo550_660;             // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkRigidBodyCInfo2010*                 RigidBodyInfobhkRigidBodyCInfo2010;                // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UbhkRigidBodyCInfo2014*                 RigidBodyInfobhkRigidBodyCInfo2014;                // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumConstraints;                                    // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UbhkSerializable*>               Constraints;                                       // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         BodyFlagsUint;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodyFlagsUshort;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkRigidBody">();
	}
	static class UbhkRigidBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkRigidBody>();
	}
};
static_assert(alignof(UbhkRigidBody) == 0x000008, "Wrong alignment on UbhkRigidBody");
static_assert(sizeof(UbhkRigidBody) == 0x0000A0, "Wrong size on UbhkRigidBody");
static_assert(offsetof(UbhkRigidBody, RigidBodyInfobhkRigidBodyCInfo550_660) == 0x000060, "Member 'UbhkRigidBody::RigidBodyInfobhkRigidBodyCInfo550_660' has a wrong offset!");
static_assert(offsetof(UbhkRigidBody, RigidBodyInfobhkRigidBodyCInfo2010) == 0x000068, "Member 'UbhkRigidBody::RigidBodyInfobhkRigidBodyCInfo2010' has a wrong offset!");
static_assert(offsetof(UbhkRigidBody, RigidBodyInfobhkRigidBodyCInfo2014) == 0x000070, "Member 'UbhkRigidBody::RigidBodyInfobhkRigidBodyCInfo2014' has a wrong offset!");
static_assert(offsetof(UbhkRigidBody, NumConstraints) == 0x000078, "Member 'UbhkRigidBody::NumConstraints' has a wrong offset!");
static_assert(offsetof(UbhkRigidBody, Constraints) == 0x000080, "Member 'UbhkRigidBody::Constraints' has a wrong offset!");
static_assert(offsetof(UbhkRigidBody, BodyFlagsUint) == 0x000090, "Member 'UbhkRigidBody::BodyFlagsUint' has a wrong offset!");
static_assert(offsetof(UbhkRigidBody, BodyFlagsUshort) == 0x000098, "Member 'UbhkRigidBody::BodyFlagsUshort' has a wrong offset!");

// Class Altar.VStatusEffectToDelete
// 0x0008 (0x0030 - 0x0028)
class UVStatusEffectToDelete final : public UObject
{
public:
	uint32                                        FormID;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasToKillAllInstance;                             // 0x002C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStatusEffectToDelete">();
	}
	static class UVStatusEffectToDelete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStatusEffectToDelete>();
	}
};
static_assert(alignof(UVStatusEffectToDelete) == 0x000008, "Wrong alignment on UVStatusEffectToDelete");
static_assert(sizeof(UVStatusEffectToDelete) == 0x000030, "Wrong size on UVStatusEffectToDelete");
static_assert(offsetof(UVStatusEffectToDelete, FormID) == 0x000028, "Member 'UVStatusEffectToDelete::FormID' has a wrong offset!");
static_assert(offsetof(UVStatusEffectToDelete, bHasToKillAllInstance) == 0x00002C, "Member 'UVStatusEffectToDelete::bHasToKillAllInstance' has a wrong offset!");

// Class Altar.bhkRigidBodyCInfo2010
// 0x0100 (0x0130 - 0x0030)
class UbhkRigidBodyCInfo2010 final : public UNifType
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHavokFilter*                           Filter;                                            // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x14];                                      // 0x0048(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	EhkResponseType                               CollisionResponse;                                 // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProcessContactCallbackDelay;                       // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Translation;                                       // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0080(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 LinearVelocity;                                    // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 AngularVelocity;                                   // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UMatrix3*                               InertiaTensor;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Center;                                            // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearDamping;                                     // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeFactor;                                        // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityFactor;                                     // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollingFrictionMultiplier;                         // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Restitution;                                       // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearVelocity;                                 // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngularVelocity;                                // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationDepth;                                  // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EhkMotionType                                 MotionSystem;                                      // 0x0104(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableDeactivation;                                // 0x0105(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EhkSolverDeactivation                         SolverDeactivation;                                // 0x0106(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EhkQualityType                                QualityType;                                       // 0x0107(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoRemoveLevel;                                   // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResponseModifierFlags;                             // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumShapeKeysInContactPoint;                        // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceCollidedOntoPPU;                              // 0x0114(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x1B];                                     // 0x0115(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkRigidBodyCInfo2010">();
	}
	static class UbhkRigidBodyCInfo2010* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkRigidBodyCInfo2010>();
	}
};
static_assert(alignof(UbhkRigidBodyCInfo2010) == 0x000010, "Wrong alignment on UbhkRigidBodyCInfo2010");
static_assert(sizeof(UbhkRigidBodyCInfo2010) == 0x000130, "Wrong size on UbhkRigidBodyCInfo2010");
static_assert(offsetof(UbhkRigidBodyCInfo2010, Filter) == 0x000040, "Member 'UbhkRigidBodyCInfo2010::Filter' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, CollisionResponse) == 0x00005C, "Member 'UbhkRigidBodyCInfo2010::CollisionResponse' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, ProcessContactCallbackDelay) == 0x000060, "Member 'UbhkRigidBodyCInfo2010::ProcessContactCallbackDelay' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, Translation) == 0x000068, "Member 'UbhkRigidBodyCInfo2010::Translation' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, Rotation) == 0x000080, "Member 'UbhkRigidBodyCInfo2010::Rotation' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, LinearVelocity) == 0x0000A0, "Member 'UbhkRigidBodyCInfo2010::LinearVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, AngularVelocity) == 0x0000B0, "Member 'UbhkRigidBodyCInfo2010::AngularVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, InertiaTensor) == 0x0000C0, "Member 'UbhkRigidBodyCInfo2010::InertiaTensor' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, Center) == 0x0000C8, "Member 'UbhkRigidBodyCInfo2010::Center' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, Mass) == 0x0000D8, "Member 'UbhkRigidBodyCInfo2010::Mass' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, LinearDamping) == 0x0000DC, "Member 'UbhkRigidBodyCInfo2010::LinearDamping' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, AngularDamping) == 0x0000E0, "Member 'UbhkRigidBodyCInfo2010::AngularDamping' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, TimeFactor) == 0x0000E4, "Member 'UbhkRigidBodyCInfo2010::TimeFactor' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, GravityFactor) == 0x0000E8, "Member 'UbhkRigidBodyCInfo2010::GravityFactor' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, Friction) == 0x0000EC, "Member 'UbhkRigidBodyCInfo2010::Friction' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, RollingFrictionMultiplier) == 0x0000F0, "Member 'UbhkRigidBodyCInfo2010::RollingFrictionMultiplier' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, Restitution) == 0x0000F4, "Member 'UbhkRigidBodyCInfo2010::Restitution' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, MaxLinearVelocity) == 0x0000F8, "Member 'UbhkRigidBodyCInfo2010::MaxLinearVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, MaxAngularVelocity) == 0x0000FC, "Member 'UbhkRigidBodyCInfo2010::MaxAngularVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, PenetrationDepth) == 0x000100, "Member 'UbhkRigidBodyCInfo2010::PenetrationDepth' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, MotionSystem) == 0x000104, "Member 'UbhkRigidBodyCInfo2010::MotionSystem' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, EnableDeactivation) == 0x000105, "Member 'UbhkRigidBodyCInfo2010::EnableDeactivation' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, SolverDeactivation) == 0x000106, "Member 'UbhkRigidBodyCInfo2010::SolverDeactivation' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, QualityType) == 0x000107, "Member 'UbhkRigidBodyCInfo2010::QualityType' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, AutoRemoveLevel) == 0x000108, "Member 'UbhkRigidBodyCInfo2010::AutoRemoveLevel' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, ResponseModifierFlags) == 0x00010C, "Member 'UbhkRigidBodyCInfo2010::ResponseModifierFlags' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, NumShapeKeysInContactPoint) == 0x000110, "Member 'UbhkRigidBodyCInfo2010::NumShapeKeysInContactPoint' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2010, ForceCollidedOntoPPU) == 0x000114, "Member 'UbhkRigidBodyCInfo2010::ForceCollidedOntoPPU' has a wrong offset!");

// Class Altar.bhkRigidBodyCInfo2014
// 0x0110 (0x0140 - 0x0030)
class UbhkRigidBodyCInfo2014 final : public UNifType
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHavokFilter*                           Filter;                                            // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Translation;                                       // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 LinearVelocity;                                    // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 AngularVelocity;                                   // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UMatrix3*                               InertiaTensor;                                     // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Center;                                            // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearDamping;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityFactor;                                     // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollingFrictionMultiplier;                         // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Restitution;                                       // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearVelocity;                                 // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngularVelocity;                                // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EhkMotionType                                 MotionSystem;                                      // 0x00EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableDeactivation;                                // 0x00ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EhkSolverDeactivation                         SolverDeactivation;                                // 0x00EE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF[0x1];                                       // 0x00EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PenetrationDepth;                                  // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeFactor;                                        // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EhkResponseType                               CollisionResponse;                                 // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProcessContactCallbackDelay3;                      // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EhkQualityType                                QualityType;                                       // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AutoRemoveLevel;                                   // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResponseModifierFlags;                             // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumShapeKeysInContactPoint;                        // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceCollidedOntoPPU;                              // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x1F];                                     // 0x0121(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkRigidBodyCInfo2014">();
	}
	static class UbhkRigidBodyCInfo2014* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkRigidBodyCInfo2014>();
	}
};
static_assert(alignof(UbhkRigidBodyCInfo2014) == 0x000010, "Wrong alignment on UbhkRigidBodyCInfo2014");
static_assert(sizeof(UbhkRigidBodyCInfo2014) == 0x000140, "Wrong size on UbhkRigidBodyCInfo2014");
static_assert(offsetof(UbhkRigidBodyCInfo2014, Filter) == 0x000040, "Member 'UbhkRigidBodyCInfo2014::Filter' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, Translation) == 0x000058, "Member 'UbhkRigidBodyCInfo2014::Translation' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, Rotation) == 0x000070, "Member 'UbhkRigidBodyCInfo2014::Rotation' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, LinearVelocity) == 0x000090, "Member 'UbhkRigidBodyCInfo2014::LinearVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, AngularVelocity) == 0x0000A0, "Member 'UbhkRigidBodyCInfo2014::AngularVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, InertiaTensor) == 0x0000B0, "Member 'UbhkRigidBodyCInfo2014::InertiaTensor' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, Center) == 0x0000B8, "Member 'UbhkRigidBodyCInfo2014::Center' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, Mass) == 0x0000C8, "Member 'UbhkRigidBodyCInfo2014::Mass' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, LinearDamping) == 0x0000CC, "Member 'UbhkRigidBodyCInfo2014::LinearDamping' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, AngularDamping) == 0x0000D0, "Member 'UbhkRigidBodyCInfo2014::AngularDamping' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, GravityFactor) == 0x0000D4, "Member 'UbhkRigidBodyCInfo2014::GravityFactor' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, Friction) == 0x0000D8, "Member 'UbhkRigidBodyCInfo2014::Friction' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, RollingFrictionMultiplier) == 0x0000DC, "Member 'UbhkRigidBodyCInfo2014::RollingFrictionMultiplier' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, Restitution) == 0x0000E0, "Member 'UbhkRigidBodyCInfo2014::Restitution' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, MaxLinearVelocity) == 0x0000E4, "Member 'UbhkRigidBodyCInfo2014::MaxLinearVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, MaxAngularVelocity) == 0x0000E8, "Member 'UbhkRigidBodyCInfo2014::MaxAngularVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, MotionSystem) == 0x0000EC, "Member 'UbhkRigidBodyCInfo2014::MotionSystem' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, EnableDeactivation) == 0x0000ED, "Member 'UbhkRigidBodyCInfo2014::EnableDeactivation' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, SolverDeactivation) == 0x0000EE, "Member 'UbhkRigidBodyCInfo2014::SolverDeactivation' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, PenetrationDepth) == 0x0000F0, "Member 'UbhkRigidBodyCInfo2014::PenetrationDepth' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, TimeFactor) == 0x0000F4, "Member 'UbhkRigidBodyCInfo2014::TimeFactor' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, CollisionResponse) == 0x000108, "Member 'UbhkRigidBodyCInfo2014::CollisionResponse' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, ProcessContactCallbackDelay3) == 0x00010C, "Member 'UbhkRigidBodyCInfo2014::ProcessContactCallbackDelay3' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, QualityType) == 0x000110, "Member 'UbhkRigidBodyCInfo2014::QualityType' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, AutoRemoveLevel) == 0x000114, "Member 'UbhkRigidBodyCInfo2014::AutoRemoveLevel' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, ResponseModifierFlags) == 0x000118, "Member 'UbhkRigidBodyCInfo2014::ResponseModifierFlags' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, NumShapeKeysInContactPoint) == 0x00011C, "Member 'UbhkRigidBodyCInfo2014::NumShapeKeysInContactPoint' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo2014, ForceCollidedOntoPPU) == 0x000120, "Member 'UbhkRigidBodyCInfo2014::ForceCollidedOntoPPU' has a wrong offset!");

// Class Altar.bhkRigidBodyCInfo550_660
// 0x00C8 (0x00F8 - 0x0030)
class UbhkRigidBodyCInfo550_660 final : public UNifType
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHavokFilter*                           Filter;                                            // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EhkResponseType                               CollisionResponse;                                 // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProcessContactCallbackDelay;                       // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Translation;                                       // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UhkQuaternion*                          Rotation;                                          // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 LinearVelocity;                                    // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 AngularVelocity;                                   // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UMatrix3*                               InertiaTensor;                                     // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Center;                                            // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearDamping;                                     // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Restitution;                                       // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearVelocity;                                 // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngularVelocity;                                // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Penetration;                                       // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EhkMotionType                                 MotionSystem;                                      // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EhkDeactivatorType                            DeactivatorType;                                   // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EhkSolverDeactivation                         SloverDeactivation;                                // 0x00E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EhkQualityType                                QualityType;                                       // 0x00E3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x14];                                      // 0x00E4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkRigidBodyCInfo550_660">();
	}
	static class UbhkRigidBodyCInfo550_660* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkRigidBodyCInfo550_660>();
	}
};
static_assert(alignof(UbhkRigidBodyCInfo550_660) == 0x000008, "Wrong alignment on UbhkRigidBodyCInfo550_660");
static_assert(sizeof(UbhkRigidBodyCInfo550_660) == 0x0000F8, "Wrong size on UbhkRigidBodyCInfo550_660");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, Filter) == 0x000040, "Member 'UbhkRigidBodyCInfo550_660::Filter' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, CollisionResponse) == 0x000058, "Member 'UbhkRigidBodyCInfo550_660::CollisionResponse' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, ProcessContactCallbackDelay) == 0x00005C, "Member 'UbhkRigidBodyCInfo550_660::ProcessContactCallbackDelay' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, Translation) == 0x000070, "Member 'UbhkRigidBodyCInfo550_660::Translation' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, Rotation) == 0x000080, "Member 'UbhkRigidBodyCInfo550_660::Rotation' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, LinearVelocity) == 0x000088, "Member 'UbhkRigidBodyCInfo550_660::LinearVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, AngularVelocity) == 0x000098, "Member 'UbhkRigidBodyCInfo550_660::AngularVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, InertiaTensor) == 0x0000A8, "Member 'UbhkRigidBodyCInfo550_660::InertiaTensor' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, Center) == 0x0000B0, "Member 'UbhkRigidBodyCInfo550_660::Center' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, Mass) == 0x0000C0, "Member 'UbhkRigidBodyCInfo550_660::Mass' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, LinearDamping) == 0x0000C4, "Member 'UbhkRigidBodyCInfo550_660::LinearDamping' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, AngularDamping) == 0x0000C8, "Member 'UbhkRigidBodyCInfo550_660::AngularDamping' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, Friction) == 0x0000CC, "Member 'UbhkRigidBodyCInfo550_660::Friction' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, Restitution) == 0x0000D0, "Member 'UbhkRigidBodyCInfo550_660::Restitution' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, MaxLinearVelocity) == 0x0000D4, "Member 'UbhkRigidBodyCInfo550_660::MaxLinearVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, MaxAngularVelocity) == 0x0000D8, "Member 'UbhkRigidBodyCInfo550_660::MaxAngularVelocity' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, Penetration) == 0x0000DC, "Member 'UbhkRigidBodyCInfo550_660::Penetration' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, MotionSystem) == 0x0000E0, "Member 'UbhkRigidBodyCInfo550_660::MotionSystem' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, DeactivatorType) == 0x0000E1, "Member 'UbhkRigidBodyCInfo550_660::DeactivatorType' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, SloverDeactivation) == 0x0000E2, "Member 'UbhkRigidBodyCInfo550_660::SloverDeactivation' has a wrong offset!");
static_assert(offsetof(UbhkRigidBodyCInfo550_660, QualityType) == 0x0000E3, "Member 'UbhkRigidBodyCInfo550_660::QualityType' has a wrong offset!");

// Class Altar.VLegacyPersuasionMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyPersuasionMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyPersuasionMenu">();
	}
	static class UVLegacyPersuasionMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyPersuasionMenu>();
	}
};
static_assert(alignof(UVLegacyPersuasionMenu) == 0x000008, "Wrong alignment on UVLegacyPersuasionMenu");
static_assert(sizeof(UVLegacyPersuasionMenu) == 0x0004E8, "Wrong size on UVLegacyPersuasionMenu");

// Class Altar.NiInterpController
// 0x0008 (0x0070 - 0x0068)
class UNiInterpController : public UNiTimeController
{
public:
	bool                                          ManagerControlled;                                 // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiInterpController">();
	}
	static class UNiInterpController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiInterpController>();
	}
};
static_assert(alignof(UNiInterpController) == 0x000008, "Wrong alignment on UNiInterpController");
static_assert(sizeof(UNiInterpController) == 0x000070, "Wrong size on UNiInterpController");
static_assert(offsetof(UNiInterpController, ManagerControlled) == 0x000068, "Member 'UNiInterpController::ManagerControlled' has a wrong offset!");

// Class Altar.NiSingleInterpController
// 0x0008 (0x0078 - 0x0070)
class UNiSingleInterpController : public UNiInterpController
{
public:
	class UNiInterpolator*                        Interpolator;                                      // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiSingleInterpController">();
	}
	static class UNiSingleInterpController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiSingleInterpController>();
	}
};
static_assert(alignof(UNiSingleInterpController) == 0x000008, "Wrong alignment on UNiSingleInterpController");
static_assert(sizeof(UNiSingleInterpController) == 0x000078, "Wrong size on UNiSingleInterpController");
static_assert(offsetof(UNiSingleInterpController, Interpolator) == 0x000070, "Member 'UNiSingleInterpController::Interpolator' has a wrong offset!");

// Class Altar.NiFloatInterpController
// 0x0000 (0x0078 - 0x0078)
class UNiFloatInterpController : public UNiSingleInterpController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiFloatInterpController">();
	}
	static class UNiFloatInterpController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiFloatInterpController>();
	}
};
static_assert(alignof(UNiFloatInterpController) == 0x000008, "Wrong alignment on UNiFloatInterpController");
static_assert(sizeof(UNiFloatInterpController) == 0x000078, "Wrong size on UNiFloatInterpController");

// Class Altar.NiFlipController
// 0x0038 (0x00B0 - 0x0078)
class UNiFlipController final : public UNiFloatInterpController
{
public:
	ETexType                                      TextureSlot;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumTime;                                         // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delta;                                             // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NumSources;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiSourceTexture*>               Sources;                                           // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class UNiImage*>                       Images;                                            // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiFlipController">();
	}
	static class UNiFlipController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiFlipController>();
	}
};
static_assert(alignof(UNiFlipController) == 0x000008, "Wrong alignment on UNiFlipController");
static_assert(sizeof(UNiFlipController) == 0x0000B0, "Wrong size on UNiFlipController");
static_assert(offsetof(UNiFlipController, TextureSlot) == 0x000078, "Member 'UNiFlipController::TextureSlot' has a wrong offset!");
static_assert(offsetof(UNiFlipController, AccumTime) == 0x00007C, "Member 'UNiFlipController::AccumTime' has a wrong offset!");
static_assert(offsetof(UNiFlipController, Delta) == 0x000080, "Member 'UNiFlipController::Delta' has a wrong offset!");
static_assert(offsetof(UNiFlipController, NumSources) == 0x000088, "Member 'UNiFlipController::NumSources' has a wrong offset!");
static_assert(offsetof(UNiFlipController, Sources) == 0x000090, "Member 'UNiFlipController::Sources' has a wrong offset!");
static_assert(offsetof(UNiFlipController, Images) == 0x0000A0, "Member 'UNiFlipController::Images' has a wrong offset!");

// Class Altar.VModernSigilStoneMenuItem
// 0x0040 (0x0068 - 0x0028)
class UVModernSigilStoneMenuItem final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const struct FModernSigilStoneMenuItemProperties& Value);

	const int32 GetItemIndex() const;
	const struct FModernSigilStoneMenuItemProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernSigilStoneMenuItem">();
	}
	static class UVModernSigilStoneMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernSigilStoneMenuItem>();
	}
};
static_assert(alignof(UVModernSigilStoneMenuItem) == 0x000008, "Wrong alignment on UVModernSigilStoneMenuItem");
static_assert(sizeof(UVModernSigilStoneMenuItem) == 0x000068, "Wrong size on UVModernSigilStoneMenuItem");

// Class Altar.bhkRigidBodyT
// 0x0000 (0x00A0 - 0x00A0)
class UbhkRigidBodyT final : public UbhkRigidBody
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkRigidBodyT">();
	}
	static class UbhkRigidBodyT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkRigidBodyT>();
	}
};
static_assert(alignof(UbhkRigidBodyT) == 0x000008, "Wrong alignment on UbhkRigidBodyT");
static_assert(sizeof(UbhkRigidBodyT) == 0x0000A0, "Wrong size on UbhkRigidBodyT");

// Class Altar.VAIProcedureExecution_Unsupported
// 0x0000 (0x0040 - 0x0040)
class UVAIProcedureExecution_Unsupported final : public UVAIProcedureExecution_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_Unsupported">();
	}
	static class UVAIProcedureExecution_Unsupported* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_Unsupported>();
	}
};
static_assert(alignof(UVAIProcedureExecution_Unsupported) == 0x000008, "Wrong alignment on UVAIProcedureExecution_Unsupported");
static_assert(sizeof(UVAIProcedureExecution_Unsupported) == 0x000040, "Wrong size on UVAIProcedureExecution_Unsupported");

// Class Altar.bhkShapePhantom
// 0x0000 (0x0058 - 0x0058)
class UbhkShapePhantom : public UbhkPhantom
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkShapePhantom">();
	}
	static class UbhkShapePhantom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkShapePhantom>();
	}
};
static_assert(alignof(UbhkShapePhantom) == 0x000008, "Wrong alignment on UbhkShapePhantom");
static_assert(sizeof(UbhkShapePhantom) == 0x000058, "Wrong size on UbhkShapePhantom");

// Class Altar.NiMatchGroup
// 0x0018 (0x0048 - 0x0030)
class UNiMatchGroup final : public UNifType
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiMatchGroup">();
	}
	static class UNiMatchGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiMatchGroup>();
	}
};
static_assert(alignof(UNiMatchGroup) == 0x000008, "Wrong alignment on UNiMatchGroup");
static_assert(sizeof(UNiMatchGroup) == 0x000048, "Wrong size on UNiMatchGroup");

// Class Altar.bhkSimpleShapePhantom
// 0x0018 (0x0070 - 0x0058)
class UbhkSimpleShapePhantom final : public UbhkShapePhantom
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatrix44*                              Transform;                                         // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkSimpleShapePhantom">();
	}
	static class UbhkSimpleShapePhantom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkSimpleShapePhantom>();
	}
};
static_assert(alignof(UbhkSimpleShapePhantom) == 0x000008, "Wrong alignment on UbhkSimpleShapePhantom");
static_assert(sizeof(UbhkSimpleShapePhantom) == 0x000070, "Wrong size on UbhkSimpleShapePhantom");
static_assert(offsetof(UbhkSimpleShapePhantom, Transform) == 0x000068, "Member 'UbhkSimpleShapePhantom::Transform' has a wrong offset!");

// Class Altar.bhkSPCollisionObject
// 0x0000 (0x0050 - 0x0050)
class UbhkSPCollisionObject final : public UbhkPCollisionObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkSPCollisionObject">();
	}
	static class UbhkSPCollisionObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkSPCollisionObject>();
	}
};
static_assert(alignof(UbhkSPCollisionObject) == 0x000008, "Wrong alignment on UbhkSPCollisionObject");
static_assert(sizeof(UbhkSPCollisionObject) == 0x000050, "Wrong size on UbhkSPCollisionObject");

// Class Altar.VLegacyQuickKeysMenu
// 0x0010 (0x04F8 - 0x04E8)
class UVLegacyQuickKeysMenu final : public UVAltarMenu
{
public:
	TArray<struct FLegacyQuickKeysActionBinding>  ActionBindings;                                    // 0x04E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void PressedButton(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyQuickKeysMenu">();
	}
	static class UVLegacyQuickKeysMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyQuickKeysMenu>();
	}
};
static_assert(alignof(UVLegacyQuickKeysMenu) == 0x000008, "Wrong alignment on UVLegacyQuickKeysMenu");
static_assert(sizeof(UVLegacyQuickKeysMenu) == 0x0004F8, "Wrong size on UVLegacyQuickKeysMenu");
static_assert(offsetof(UVLegacyQuickKeysMenu, ActionBindings) == 0x0004E8, "Member 'UVLegacyQuickKeysMenu::ActionBindings' has a wrong offset!");

// Class Altar.bhkSphereShape
// 0x0000 (0x0048 - 0x0048)
class UbhkSphereShape final : public UbhkConvexShape
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkSphereShape">();
	}
	static class UbhkSphereShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkSphereShape>();
	}
};
static_assert(alignof(UbhkSphereShape) == 0x000008, "Wrong alignment on UbhkSphereShape");
static_assert(sizeof(UbhkSphereShape) == 0x000048, "Wrong size on UbhkSphereShape");

// Class Altar.StateMachinePlayAnimatedAction
// 0x0040 (0x0070 - 0x0030)
class UStateMachinePlayAnimatedAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCanceled;                                        // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UStateMachinePlayAnimatedAction* PlayAnimatedAction(class AVPairedPawn* PairedPawn, const struct FGameplayTag& ActionTag, class UVPawnAnimatedAction** Action, float DesiredDuration, int32 AnimationIndex);
	static class UStateMachinePlayAnimatedAction* PlayDefaultAnimatedAction(class AVPairedPawn* PairedPawn, class UVPawnAnimatedAction** Action);

	void OnAnimatedActionEnded(bool bIsCanceled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateMachinePlayAnimatedAction">();
	}
	static class UStateMachinePlayAnimatedAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateMachinePlayAnimatedAction>();
	}
};
static_assert(alignof(UStateMachinePlayAnimatedAction) == 0x000008, "Wrong alignment on UStateMachinePlayAnimatedAction");
static_assert(sizeof(UStateMachinePlayAnimatedAction) == 0x000070, "Wrong size on UStateMachinePlayAnimatedAction");
static_assert(offsetof(UStateMachinePlayAnimatedAction, OnCompleted) == 0x000030, "Member 'UStateMachinePlayAnimatedAction::OnCompleted' has a wrong offset!");
static_assert(offsetof(UStateMachinePlayAnimatedAction, OnCanceled) == 0x000040, "Member 'UStateMachinePlayAnimatedAction::OnCanceled' has a wrong offset!");

// Class Altar.bhkSpringDamperConstraintMotor
// 0x0018 (0x0048 - 0x0030)
class UbhkSpringDamperConstraintMotor final : public UNifType
{
public:
	float                                         MinForce;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForce;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringConstant;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringDamping;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MotorEnabled;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkSpringDamperConstraintMotor">();
	}
	static class UbhkSpringDamperConstraintMotor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkSpringDamperConstraintMotor>();
	}
};
static_assert(alignof(UbhkSpringDamperConstraintMotor) == 0x000008, "Wrong alignment on UbhkSpringDamperConstraintMotor");
static_assert(sizeof(UbhkSpringDamperConstraintMotor) == 0x000048, "Wrong size on UbhkSpringDamperConstraintMotor");
static_assert(offsetof(UbhkSpringDamperConstraintMotor, MinForce) == 0x000030, "Member 'UbhkSpringDamperConstraintMotor::MinForce' has a wrong offset!");
static_assert(offsetof(UbhkSpringDamperConstraintMotor, MaxForce) == 0x000034, "Member 'UbhkSpringDamperConstraintMotor::MaxForce' has a wrong offset!");
static_assert(offsetof(UbhkSpringDamperConstraintMotor, SpringConstant) == 0x000038, "Member 'UbhkSpringDamperConstraintMotor::SpringConstant' has a wrong offset!");
static_assert(offsetof(UbhkSpringDamperConstraintMotor, SpringDamping) == 0x00003C, "Member 'UbhkSpringDamperConstraintMotor::SpringDamping' has a wrong offset!");
static_assert(offsetof(UbhkSpringDamperConstraintMotor, MotorEnabled) == 0x000040, "Member 'UbhkSpringDamperConstraintMotor::MotorEnabled' has a wrong offset!");

// Class Altar.NiDynamicEffect
// 0x0030 (0x00E0 - 0x00B0)
class UNiDynamicEffect : public UNiAvObject
{
public:
	bool                                          SwitchState;                                       // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NumAffectedNodes;                                  // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiNode*>                        AffectedNodes;                                     // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<int64>                                 AffectedNodePointers;                              // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiDynamicEffect">();
	}
	static class UNiDynamicEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiDynamicEffect>();
	}
};
static_assert(alignof(UNiDynamicEffect) == 0x000008, "Wrong alignment on UNiDynamicEffect");
static_assert(sizeof(UNiDynamicEffect) == 0x0000E0, "Wrong size on UNiDynamicEffect");
static_assert(offsetof(UNiDynamicEffect, SwitchState) == 0x0000B0, "Member 'UNiDynamicEffect::SwitchState' has a wrong offset!");
static_assert(offsetof(UNiDynamicEffect, NumAffectedNodes) == 0x0000B8, "Member 'UNiDynamicEffect::NumAffectedNodes' has a wrong offset!");
static_assert(offsetof(UNiDynamicEffect, AffectedNodes) == 0x0000C0, "Member 'UNiDynamicEffect::AffectedNodes' has a wrong offset!");
static_assert(offsetof(UNiDynamicEffect, AffectedNodePointers) == 0x0000D0, "Member 'UNiDynamicEffect::AffectedNodePointers' has a wrong offset!");

// Class Altar.NiLight
// 0x0010 (0x00F0 - 0x00E0)
class UNiLight : public UNiDynamicEffect
{
public:
	float                                         Dimmer;                                            // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 AmbientColor;                                      // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DiffuseColor;                                      // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SpecularColor;                                     // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiLight">();
	}
	static class UNiLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiLight>();
	}
};
static_assert(alignof(UNiLight) == 0x000008, "Wrong alignment on UNiLight");
static_assert(sizeof(UNiLight) == 0x0000F0, "Wrong size on UNiLight");
static_assert(offsetof(UNiLight, Dimmer) == 0x0000E0, "Member 'UNiLight::Dimmer' has a wrong offset!");
static_assert(offsetof(UNiLight, AmbientColor) == 0x0000E4, "Member 'UNiLight::AmbientColor' has a wrong offset!");
static_assert(offsetof(UNiLight, DiffuseColor) == 0x0000E8, "Member 'UNiLight::DiffuseColor' has a wrong offset!");
static_assert(offsetof(UNiLight, SpecularColor) == 0x0000EC, "Member 'UNiLight::SpecularColor' has a wrong offset!");

// Class Altar.NiDirectionalLight
// 0x0000 (0x00F0 - 0x00F0)
class UNiDirectionalLight final : public UNiLight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiDirectionalLight">();
	}
	static class UNiDirectionalLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiDirectionalLight>();
	}
};
static_assert(alignof(UNiDirectionalLight) == 0x000008, "Wrong alignment on UNiDirectionalLight");
static_assert(sizeof(UNiDirectionalLight) == 0x0000F0, "Wrong size on UNiDirectionalLight");

// Class Altar.bhkStiffSpringConstraint
// 0x0008 (0x0048 - 0x0040)
class UbhkStiffSpringConstraint final : public UbhkConstraint
{
public:
	class UbhkStiffSpringConstraintCInfo*         Constraint;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkStiffSpringConstraint">();
	}
	static class UbhkStiffSpringConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkStiffSpringConstraint>();
	}
};
static_assert(alignof(UbhkStiffSpringConstraint) == 0x000008, "Wrong alignment on UbhkStiffSpringConstraint");
static_assert(sizeof(UbhkStiffSpringConstraint) == 0x000048, "Wrong size on UbhkStiffSpringConstraint");
static_assert(offsetof(UbhkStiffSpringConstraint, Constraint) == 0x000040, "Member 'UbhkStiffSpringConstraint::Constraint' has a wrong offset!");

// Class Altar.bhkStiffSpringConstraintCInfo
// 0x0028 (0x0058 - 0x0030)
class UbhkStiffSpringConstraintCInfo final : public UNifType
{
public:
	struct FVTSVector4f                           PivotA;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           PivotB;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkStiffSpringConstraintCInfo">();
	}
	static class UbhkStiffSpringConstraintCInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkStiffSpringConstraintCInfo>();
	}
};
static_assert(alignof(UbhkStiffSpringConstraintCInfo) == 0x000008, "Wrong alignment on UbhkStiffSpringConstraintCInfo");
static_assert(sizeof(UbhkStiffSpringConstraintCInfo) == 0x000058, "Wrong size on UbhkStiffSpringConstraintCInfo");
static_assert(offsetof(UbhkStiffSpringConstraintCInfo, PivotA) == 0x000030, "Member 'UbhkStiffSpringConstraintCInfo::PivotA' has a wrong offset!");
static_assert(offsetof(UbhkStiffSpringConstraintCInfo, PivotB) == 0x000040, "Member 'UbhkStiffSpringConstraintCInfo::PivotB' has a wrong offset!");
static_assert(offsetof(UbhkStiffSpringConstraintCInfo, Length) == 0x000050, "Member 'UbhkStiffSpringConstraintCInfo::Length' has a wrong offset!");

// Class Altar.VImpactSystemVFXBlueprint
// 0x0000 (0x02A0 - 0x02A0)
class AVImpactSystemVFXBlueprint final : public AVVFXBlueprint
{
public:
	void OnStartPlay(const struct FVector_NetQuantizeNormal& ImpactNormal, EVHitSourceType HitSourceType, EVHitSourceMaterial HitSourceMaterial, bool bDoesBeginInFirstPerson, EVHitSourceWeaponType HitWeaponType, const class UStaticMeshComponent* WeaponMesh, bool bIsUsingWeapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VImpactSystemVFXBlueprint">();
	}
	static class AVImpactSystemVFXBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVImpactSystemVFXBlueprint>();
	}
};
static_assert(alignof(AVImpactSystemVFXBlueprint) == 0x000008, "Wrong alignment on AVImpactSystemVFXBlueprint");
static_assert(sizeof(AVImpactSystemVFXBlueprint) == 0x0002A0, "Wrong size on AVImpactSystemVFXBlueprint");

// Class Altar.NiImage
// 0x0028 (0x0060 - 0x0038)
class UNiImage final : public UNiObject
{
public:
	int32                                         UseExternal;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNifString                             Filename;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UNiRawImageData*                        ImageData;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiImage">();
	}
	static class UNiImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiImage>();
	}
};
static_assert(alignof(UNiImage) == 0x000008, "Wrong alignment on UNiImage");
static_assert(sizeof(UNiImage) == 0x000060, "Wrong size on UNiImage");
static_assert(offsetof(UNiImage, UseExternal) == 0x000038, "Member 'UNiImage::UseExternal' has a wrong offset!");
static_assert(offsetof(UNiImage, Filename) == 0x000040, "Member 'UNiImage::Filename' has a wrong offset!");
static_assert(offsetof(UNiImage, ImageData) == 0x000050, "Member 'UNiImage::ImageData' has a wrong offset!");

// Class Altar.bhkTransformShape
// 0x0030 (0x0068 - 0x0038)
class UbhkTransformShape final : public UbhkShape
{
public:
	class UbhkShape*                              Shape;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHavokMaterial*                         Material;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x14];                                      // 0x004C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatrix44*                              Transform;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkTransformShape">();
	}
	static class UbhkTransformShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkTransformShape>();
	}
};
static_assert(alignof(UbhkTransformShape) == 0x000008, "Wrong alignment on UbhkTransformShape");
static_assert(sizeof(UbhkTransformShape) == 0x000068, "Wrong size on UbhkTransformShape");
static_assert(offsetof(UbhkTransformShape, Shape) == 0x000038, "Member 'UbhkTransformShape::Shape' has a wrong offset!");
static_assert(offsetof(UbhkTransformShape, Material) == 0x000040, "Member 'UbhkTransformShape::Material' has a wrong offset!");
static_assert(offsetof(UbhkTransformShape, Radius) == 0x000048, "Member 'UbhkTransformShape::Radius' has a wrong offset!");
static_assert(offsetof(UbhkTransformShape, Transform) == 0x000060, "Member 'UbhkTransformShape::Transform' has a wrong offset!");

// Class Altar.bhkVelocityConstraintMotor
// 0x0018 (0x0048 - 0x0030)
class UbhkVelocityConstraintMotor final : public UNifType
{
public:
	float                                         MinForce;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForce;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tau;                                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetVelocity;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseVelocityTarget;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MotorEnabled;                                      // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkVelocityConstraintMotor">();
	}
	static class UbhkVelocityConstraintMotor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkVelocityConstraintMotor>();
	}
};
static_assert(alignof(UbhkVelocityConstraintMotor) == 0x000008, "Wrong alignment on UbhkVelocityConstraintMotor");
static_assert(sizeof(UbhkVelocityConstraintMotor) == 0x000048, "Wrong size on UbhkVelocityConstraintMotor");
static_assert(offsetof(UbhkVelocityConstraintMotor, MinForce) == 0x000030, "Member 'UbhkVelocityConstraintMotor::MinForce' has a wrong offset!");
static_assert(offsetof(UbhkVelocityConstraintMotor, MaxForce) == 0x000034, "Member 'UbhkVelocityConstraintMotor::MaxForce' has a wrong offset!");
static_assert(offsetof(UbhkVelocityConstraintMotor, Tau) == 0x000038, "Member 'UbhkVelocityConstraintMotor::Tau' has a wrong offset!");
static_assert(offsetof(UbhkVelocityConstraintMotor, TargetVelocity) == 0x00003C, "Member 'UbhkVelocityConstraintMotor::TargetVelocity' has a wrong offset!");
static_assert(offsetof(UbhkVelocityConstraintMotor, UseVelocityTarget) == 0x000040, "Member 'UbhkVelocityConstraintMotor::UseVelocityTarget' has a wrong offset!");
static_assert(offsetof(UbhkVelocityConstraintMotor, MotorEnabled) == 0x000041, "Member 'UbhkVelocityConstraintMotor::MotorEnabled' has a wrong offset!");

// Class Altar.SteeringBehavior_ReturnToNavmesh
// 0x0100 (0x0130 - 0x0030)
class USteeringBehavior_ReturnToNavmesh final : public USteeringBehavior
{
public:
	double                                        MinInterest;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxInterest;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MinTimeOutsideNavmeshToEnableBehavior;             // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        AdditionalDurationPerPoly;                         // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxDistanceToReturnToNavmesh;                      // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxSpeedOutsideNavmesh;                            // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxDownStepHeightOutsideNavmesh;                   // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        DisableDurationOnBecomeIrrelevant;                 // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ObstacleDetectionCollisionProfile;                 // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxReachabilityChecksPerFrame;                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        LowPriorityHeightDeltaThreshold;                   // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        NavMeshDistanceTolerance;                          // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARecastNavMesh*                         NavigationData;                                    // 0x0090(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x98];                                      // 0x0098(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehavior_ReturnToNavmesh">();
	}
	static class USteeringBehavior_ReturnToNavmesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehavior_ReturnToNavmesh>();
	}
};
static_assert(alignof(USteeringBehavior_ReturnToNavmesh) == 0x000008, "Wrong alignment on USteeringBehavior_ReturnToNavmesh");
static_assert(sizeof(USteeringBehavior_ReturnToNavmesh) == 0x000130, "Wrong size on USteeringBehavior_ReturnToNavmesh");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, MinInterest) == 0x000030, "Member 'USteeringBehavior_ReturnToNavmesh::MinInterest' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, MaxInterest) == 0x000038, "Member 'USteeringBehavior_ReturnToNavmesh::MaxInterest' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, MinTimeOutsideNavmeshToEnableBehavior) == 0x000040, "Member 'USteeringBehavior_ReturnToNavmesh::MinTimeOutsideNavmeshToEnableBehavior' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, AdditionalDurationPerPoly) == 0x000048, "Member 'USteeringBehavior_ReturnToNavmesh::AdditionalDurationPerPoly' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, MaxDistanceToReturnToNavmesh) == 0x000050, "Member 'USteeringBehavior_ReturnToNavmesh::MaxDistanceToReturnToNavmesh' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, MaxSpeedOutsideNavmesh) == 0x000058, "Member 'USteeringBehavior_ReturnToNavmesh::MaxSpeedOutsideNavmesh' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, MaxDownStepHeightOutsideNavmesh) == 0x000060, "Member 'USteeringBehavior_ReturnToNavmesh::MaxDownStepHeightOutsideNavmesh' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, DisableDurationOnBecomeIrrelevant) == 0x000068, "Member 'USteeringBehavior_ReturnToNavmesh::DisableDurationOnBecomeIrrelevant' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, ObstacleDetectionCollisionProfile) == 0x000070, "Member 'USteeringBehavior_ReturnToNavmesh::ObstacleDetectionCollisionProfile' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, MaxReachabilityChecksPerFrame) == 0x000078, "Member 'USteeringBehavior_ReturnToNavmesh::MaxReachabilityChecksPerFrame' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, LowPriorityHeightDeltaThreshold) == 0x000080, "Member 'USteeringBehavior_ReturnToNavmesh::LowPriorityHeightDeltaThreshold' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, NavMeshDistanceTolerance) == 0x000088, "Member 'USteeringBehavior_ReturnToNavmesh::NavMeshDistanceTolerance' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_ReturnToNavmesh, NavigationData) == 0x000090, "Member 'USteeringBehavior_ReturnToNavmesh::NavigationData' has a wrong offset!");

// Class Altar.NiGeometryData
// 0x0098 (0x00D0 - 0x0038)
class UNiGeometryData : public UNiObject
{
public:
	int64                                         GroupIDGeometryData;                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumVertices;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeepFlags;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompressFlags;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasVertices;                                       // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Vertices;                                          // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         DataFlags;                                         // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasNormals;                                        // 0x0064(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Normals;                                           // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FNiBound                               Bound;                                             // 0x0078(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          HasColor;                                          // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 VertexColors;                                      // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 UVs;                                               // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         DirtyFlags;                                        // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbstractAdditionalGeometryData*        AdditionalData;                                    // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiGeometryData">();
	}
	static class UNiGeometryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiGeometryData>();
	}
};
static_assert(alignof(UNiGeometryData) == 0x000008, "Wrong alignment on UNiGeometryData");
static_assert(sizeof(UNiGeometryData) == 0x0000D0, "Wrong size on UNiGeometryData");
static_assert(offsetof(UNiGeometryData, GroupIDGeometryData) == 0x000038, "Member 'UNiGeometryData::GroupIDGeometryData' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, NumVertices) == 0x000040, "Member 'UNiGeometryData::NumVertices' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, KeepFlags) == 0x000044, "Member 'UNiGeometryData::KeepFlags' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, CompressFlags) == 0x000048, "Member 'UNiGeometryData::CompressFlags' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, HasVertices) == 0x00004C, "Member 'UNiGeometryData::HasVertices' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, Vertices) == 0x000050, "Member 'UNiGeometryData::Vertices' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, DataFlags) == 0x000060, "Member 'UNiGeometryData::DataFlags' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, HasNormals) == 0x000064, "Member 'UNiGeometryData::HasNormals' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, Normals) == 0x000068, "Member 'UNiGeometryData::Normals' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, Bound) == 0x000078, "Member 'UNiGeometryData::Bound' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, HasColor) == 0x000098, "Member 'UNiGeometryData::HasColor' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, VertexColors) == 0x0000A0, "Member 'UNiGeometryData::VertexColors' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, UVs) == 0x0000B0, "Member 'UNiGeometryData::UVs' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, DirtyFlags) == 0x0000C0, "Member 'UNiGeometryData::DirtyFlags' has a wrong offset!");
static_assert(offsetof(UNiGeometryData, AdditionalData) == 0x0000C8, "Member 'UNiGeometryData::AdditionalData' has a wrong offset!");

// Class Altar.NiParticlesData
// 0x00B8 (0x0188 - 0x00D0)
class UNiParticlesData : public UNiGeometryData
{
public:
	float                                         ParticleRadius;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasRadii;                                          // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Radii;                                             // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         NumActive;                                         // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSizes;                                          // 0x00EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Sizes;                                             // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          HasRotations;                                      // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuat>                          Rotations;                                         // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          HasRotationAngles;                                 // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 RotationAngles;                                    // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          HasRotationAxes;                                   // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        RotationAxes;                                      // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          HasTextureIndices;                                 // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NumSubtextureOffsetsUint;                          // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumSubtextureOffsetsByte;                          // 0x0158(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVTSVector4f>                   SubtextureOffsets;                                 // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         AspectRatio;                                       // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAspectFlags                                  AspectFlags;                                       // 0x0174(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_176[0x2];                                      // 0x0176(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedToAspectAspect2;                              // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToAspectSpeed1;                               // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToAspectSpeed2;                               // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiParticlesData">();
	}
	static class UNiParticlesData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiParticlesData>();
	}
};
static_assert(alignof(UNiParticlesData) == 0x000008, "Wrong alignment on UNiParticlesData");
static_assert(sizeof(UNiParticlesData) == 0x000188, "Wrong size on UNiParticlesData");
static_assert(offsetof(UNiParticlesData, ParticleRadius) == 0x0000D0, "Member 'UNiParticlesData::ParticleRadius' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, HasRadii) == 0x0000D4, "Member 'UNiParticlesData::HasRadii' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, Radii) == 0x0000D8, "Member 'UNiParticlesData::Radii' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, NumActive) == 0x0000E8, "Member 'UNiParticlesData::NumActive' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, HasSizes) == 0x0000EC, "Member 'UNiParticlesData::HasSizes' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, Sizes) == 0x0000F0, "Member 'UNiParticlesData::Sizes' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, HasRotations) == 0x000100, "Member 'UNiParticlesData::HasRotations' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, Rotations) == 0x000108, "Member 'UNiParticlesData::Rotations' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, HasRotationAngles) == 0x000118, "Member 'UNiParticlesData::HasRotationAngles' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, RotationAngles) == 0x000120, "Member 'UNiParticlesData::RotationAngles' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, HasRotationAxes) == 0x000130, "Member 'UNiParticlesData::HasRotationAxes' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, RotationAxes) == 0x000138, "Member 'UNiParticlesData::RotationAxes' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, HasTextureIndices) == 0x000148, "Member 'UNiParticlesData::HasTextureIndices' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, NumSubtextureOffsetsUint) == 0x000150, "Member 'UNiParticlesData::NumSubtextureOffsetsUint' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, NumSubtextureOffsetsByte) == 0x000158, "Member 'UNiParticlesData::NumSubtextureOffsetsByte' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, SubtextureOffsets) == 0x000160, "Member 'UNiParticlesData::SubtextureOffsets' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, AspectRatio) == 0x000170, "Member 'UNiParticlesData::AspectRatio' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, AspectFlags) == 0x000174, "Member 'UNiParticlesData::AspectFlags' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, SpeedToAspectAspect2) == 0x000178, "Member 'UNiParticlesData::SpeedToAspectAspect2' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, SpeedToAspectSpeed1) == 0x00017C, "Member 'UNiParticlesData::SpeedToAspectSpeed1' has a wrong offset!");
static_assert(offsetof(UNiParticlesData, SpeedToAspectSpeed2) == 0x000180, "Member 'UNiParticlesData::SpeedToAspectSpeed2' has a wrong offset!");

// Class Altar.NiPSysData
// 0x0048 (0x01D0 - 0x0188)
class UNiPSysData : public UNiParticlesData
{
public:
	TArray<class UNiParticleInfo*>                ParticleInfo;                                      // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FVector                                UnknownVector;                                     // 0x0198(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasRotationSpeeds;                                 // 0x01B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 RotationSpeeds;                                    // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         NumAddedParticles;                                 // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddedParticlesBase;                                // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysData">();
	}
	static class UNiPSysData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysData>();
	}
};
static_assert(alignof(UNiPSysData) == 0x000008, "Wrong alignment on UNiPSysData");
static_assert(sizeof(UNiPSysData) == 0x0001D0, "Wrong size on UNiPSysData");
static_assert(offsetof(UNiPSysData, ParticleInfo) == 0x000188, "Member 'UNiPSysData::ParticleInfo' has a wrong offset!");
static_assert(offsetof(UNiPSysData, UnknownVector) == 0x000198, "Member 'UNiPSysData::UnknownVector' has a wrong offset!");
static_assert(offsetof(UNiPSysData, HasRotationSpeeds) == 0x0001B0, "Member 'UNiPSysData::HasRotationSpeeds' has a wrong offset!");
static_assert(offsetof(UNiPSysData, RotationSpeeds) == 0x0001B8, "Member 'UNiPSysData::RotationSpeeds' has a wrong offset!");
static_assert(offsetof(UNiPSysData, NumAddedParticles) == 0x0001C8, "Member 'UNiPSysData::NumAddedParticles' has a wrong offset!");
static_assert(offsetof(UNiPSysData, AddedParticlesBase) == 0x0001CC, "Member 'UNiPSysData::AddedParticlesBase' has a wrong offset!");

// Class Altar.bhkWorldObjCInfoProperty
// 0x0018 (0x0048 - 0x0030)
class UbhkWorldObjCInfoProperty final : public UNifType
{
public:
	int64                                         Data;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Size;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CapacityAndFlags;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkWorldObjCInfoProperty">();
	}
	static class UbhkWorldObjCInfoProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkWorldObjCInfoProperty>();
	}
};
static_assert(alignof(UbhkWorldObjCInfoProperty) == 0x000008, "Wrong alignment on UbhkWorldObjCInfoProperty");
static_assert(sizeof(UbhkWorldObjCInfoProperty) == 0x000048, "Wrong size on UbhkWorldObjCInfoProperty");
static_assert(offsetof(UbhkWorldObjCInfoProperty, Data) == 0x000030, "Member 'UbhkWorldObjCInfoProperty::Data' has a wrong offset!");
static_assert(offsetof(UbhkWorldObjCInfoProperty, Size) == 0x000038, "Member 'UbhkWorldObjCInfoProperty::Size' has a wrong offset!");
static_assert(offsetof(UbhkWorldObjCInfoProperty, CapacityAndFlags) == 0x000040, "Member 'UbhkWorldObjCInfoProperty::CapacityAndFlags' has a wrong offset!");

// Class Altar.bhkWorldObjectCInfo
// 0x0030 (0x0060 - 0x0030)
class UbhkWorldObjectCInfo final : public UNifType
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EBroadPhaseType                               BroadPhaseTypeValue;                               // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x17];                                      // 0x0041(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UbhkWorldObjCInfoProperty*              Property;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"bhkWorldObjectCInfo">();
	}
	static class UbhkWorldObjectCInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UbhkWorldObjectCInfo>();
	}
};
static_assert(alignof(UbhkWorldObjectCInfo) == 0x000008, "Wrong alignment on UbhkWorldObjectCInfo");
static_assert(sizeof(UbhkWorldObjectCInfo) == 0x000060, "Wrong size on UbhkWorldObjectCInfo");
static_assert(offsetof(UbhkWorldObjectCInfo, BroadPhaseTypeValue) == 0x000040, "Member 'UbhkWorldObjectCInfo::BroadPhaseTypeValue' has a wrong offset!");
static_assert(offsetof(UbhkWorldObjectCInfo, Property) == 0x000058, "Member 'UbhkWorldObjectCInfo::Property' has a wrong offset!");

// Class Altar.VInventoryMenu
// 0x0008 (0x04F8 - 0x04F0)
class UVInventoryMenu : public UVLegacyPlayerSubMenuBase
{
public:
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBlockBackAction(bool bNewBlockBackAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VInventoryMenu">();
	}
	static class UVInventoryMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVInventoryMenu>();
	}
};
static_assert(alignof(UVInventoryMenu) == 0x000008, "Wrong alignment on UVInventoryMenu");
static_assert(sizeof(UVInventoryMenu) == 0x0004F8, "Wrong size on UVInventoryMenu");

// Class Altar.NiPoint3InterpController
// 0x0000 (0x0078 - 0x0078)
class UNiPoint3InterpController : public UNiSingleInterpController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPoint3InterpController">();
	}
	static class UNiPoint3InterpController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPoint3InterpController>();
	}
};
static_assert(alignof(UNiPoint3InterpController) == 0x000008, "Wrong alignment on UNiPoint3InterpController");
static_assert(sizeof(UNiPoint3InterpController) == 0x000078, "Wrong size on UNiPoint3InterpController");

// Class Altar.NiMaterialColorController
// 0x0010 (0x0088 - 0x0078)
class UNiMaterialColorController final : public UNiPoint3InterpController
{
public:
	EMaterialColor                                TargetColor;                                       // 0x0078(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiPosData*                             Data;                                              // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiMaterialColorController">();
	}
	static class UNiMaterialColorController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiMaterialColorController>();
	}
};
static_assert(alignof(UNiMaterialColorController) == 0x000008, "Wrong alignment on UNiMaterialColorController");
static_assert(sizeof(UNiMaterialColorController) == 0x000088, "Wrong size on UNiMaterialColorController");
static_assert(offsetof(UNiMaterialColorController, TargetColor) == 0x000078, "Member 'UNiMaterialColorController::TargetColor' has a wrong offset!");
static_assert(offsetof(UNiMaterialColorController, Data) == 0x000080, "Member 'UNiMaterialColorController::Data' has a wrong offset!");

// Class Altar.BoneData
// 0x0040 (0x0070 - 0x0030)
class UBoneData final : public UNifType
{
public:
	class UNiTransform*                           SkinTransform;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNiBound                               BoundingSphere;                                    // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumVertices;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBoneVertData*>                  VertexWeights;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoneData">();
	}
	static class UBoneData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoneData>();
	}
};
static_assert(alignof(UBoneData) == 0x000008, "Wrong alignment on UBoneData");
static_assert(sizeof(UBoneData) == 0x000070, "Wrong size on UBoneData");
static_assert(offsetof(UBoneData, SkinTransform) == 0x000030, "Member 'UBoneData::SkinTransform' has a wrong offset!");
static_assert(offsetof(UBoneData, BoundingSphere) == 0x000038, "Member 'UBoneData::BoundingSphere' has a wrong offset!");
static_assert(offsetof(UBoneData, NumVertices) == 0x000058, "Member 'UBoneData::NumVertices' has a wrong offset!");
static_assert(offsetof(UBoneData, VertexWeights) == 0x000060, "Member 'UBoneData::VertexWeights' has a wrong offset!");

// Class Altar.BoneVertData
// 0x0008 (0x0038 - 0x0030)
class UBoneVertData final : public UNifType
{
public:
	int32                                         Index_0;                                           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoneVertData">();
	}
	static class UBoneVertData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoneVertData>();
	}
};
static_assert(alignof(UBoneVertData) == 0x000008, "Wrong alignment on UBoneVertData");
static_assert(sizeof(UBoneVertData) == 0x000038, "Wrong size on UBoneVertData");
static_assert(offsetof(UBoneVertData, Index_0) == 0x000030, "Member 'UBoneVertData::Index_0' has a wrong offset!");
static_assert(offsetof(UBoneVertData, Weight) == 0x000034, "Member 'UBoneVertData::Weight' has a wrong offset!");

// Class Altar.NiGeomMorpherController
// 0x0058 (0x00C8 - 0x0070)
class UNiGeomMorpherController final : public UNiInterpController
{
public:
	int64                                         MorpherFlags;                                      // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiMorphData*                           Data;                                              // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AlwaysUpdate;                                      // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NumInterpolators;                                  // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiInterpolator*>                Interpolators;                                     // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class UMorphWeight*>                   InterpolatorWeights;                               // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumUnknownInts;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 UnknownInts;                                       // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiGeomMorpherController">();
	}
	static class UNiGeomMorpherController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiGeomMorpherController>();
	}
};
static_assert(alignof(UNiGeomMorpherController) == 0x000008, "Wrong alignment on UNiGeomMorpherController");
static_assert(sizeof(UNiGeomMorpherController) == 0x0000C8, "Wrong size on UNiGeomMorpherController");
static_assert(offsetof(UNiGeomMorpherController, MorpherFlags) == 0x000070, "Member 'UNiGeomMorpherController::MorpherFlags' has a wrong offset!");
static_assert(offsetof(UNiGeomMorpherController, Data) == 0x000078, "Member 'UNiGeomMorpherController::Data' has a wrong offset!");
static_assert(offsetof(UNiGeomMorpherController, AlwaysUpdate) == 0x000080, "Member 'UNiGeomMorpherController::AlwaysUpdate' has a wrong offset!");
static_assert(offsetof(UNiGeomMorpherController, NumInterpolators) == 0x000088, "Member 'UNiGeomMorpherController::NumInterpolators' has a wrong offset!");
static_assert(offsetof(UNiGeomMorpherController, Interpolators) == 0x000090, "Member 'UNiGeomMorpherController::Interpolators' has a wrong offset!");
static_assert(offsetof(UNiGeomMorpherController, InterpolatorWeights) == 0x0000A0, "Member 'UNiGeomMorpherController::InterpolatorWeights' has a wrong offset!");
static_assert(offsetof(UNiGeomMorpherController, NumUnknownInts) == 0x0000B0, "Member 'UNiGeomMorpherController::NumUnknownInts' has a wrong offset!");
static_assert(offsetof(UNiGeomMorpherController, UnknownInts) == 0x0000B8, "Member 'UNiGeomMorpherController::UnknownInts' has a wrong offset!");

// Class Altar.BSAnimNote
// 0x0020 (0x0058 - 0x0038)
class UBSAnimNote final : public UNiObject
{
public:
	EAnimNoteType                                 Type;                                              // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Arm;                                               // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gain;                                              // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         State;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSAnimNote">();
	}
	static class UBSAnimNote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSAnimNote>();
	}
};
static_assert(alignof(UBSAnimNote) == 0x000008, "Wrong alignment on UBSAnimNote");
static_assert(sizeof(UBSAnimNote) == 0x000058, "Wrong size on UBSAnimNote");
static_assert(offsetof(UBSAnimNote, Type) == 0x000038, "Member 'UBSAnimNote::Type' has a wrong offset!");
static_assert(offsetof(UBSAnimNote, Time) == 0x00003C, "Member 'UBSAnimNote::Time' has a wrong offset!");
static_assert(offsetof(UBSAnimNote, Arm) == 0x000040, "Member 'UBSAnimNote::Arm' has a wrong offset!");
static_assert(offsetof(UBSAnimNote, Gain) == 0x000048, "Member 'UBSAnimNote::Gain' has a wrong offset!");
static_assert(offsetof(UBSAnimNote, State) == 0x000050, "Member 'UBSAnimNote::State' has a wrong offset!");

// Class Altar.BSAnimNotes
// 0x0018 (0x0050 - 0x0038)
class UBSAnimNotes final : public UNiObject
{
public:
	int32                                         NumAnimNotes;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBSAnimNote*>                    AnimNotes;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSAnimNotes">();
	}
	static class UBSAnimNotes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSAnimNotes>();
	}
};
static_assert(alignof(UBSAnimNotes) == 0x000008, "Wrong alignment on UBSAnimNotes");
static_assert(sizeof(UBSAnimNotes) == 0x000050, "Wrong size on UBSAnimNotes");
static_assert(offsetof(UBSAnimNotes, NumAnimNotes) == 0x000038, "Member 'UBSAnimNotes::NumAnimNotes' has a wrong offset!");
static_assert(offsetof(UBSAnimNotes, AnimNotes) == 0x000040, "Member 'UBSAnimNotes::AnimNotes' has a wrong offset!");

// Class Altar.VOriginalInventoryMenuItemEffects
// 0x0020 (0x0048 - 0x0028)
class UVOriginalInventoryMenuItemEffects final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const struct FOriginalInventoryMenuItemEffects& Value);

	const struct FOriginalInventoryMenuItemEffects GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOriginalInventoryMenuItemEffects">();
	}
	static class UVOriginalInventoryMenuItemEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOriginalInventoryMenuItemEffects>();
	}
};
static_assert(alignof(UVOriginalInventoryMenuItemEffects) == 0x000008, "Wrong alignment on UVOriginalInventoryMenuItemEffects");
static_assert(sizeof(UVOriginalInventoryMenuItemEffects) == 0x000048, "Wrong size on UVOriginalInventoryMenuItemEffects");

// Class Altar.NiParticles
// 0x0000 (0x00C0 - 0x00C0)
class UNiParticles : public UNiGeometry
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiParticles">();
	}
	static class UNiParticles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiParticles>();
	}
};
static_assert(alignof(UNiParticles) == 0x000008, "Wrong alignment on UNiParticles");
static_assert(sizeof(UNiParticles) == 0x0000C0, "Wrong size on UNiParticles");

// Class Altar.NiParticleSystem
// 0x0040 (0x0100 - 0x00C0)
class UNiParticleSystem : public UNiParticles
{
public:
	struct FBSVertexDesc                          VertexDesc;                                        // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         FarBegin;                                          // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FarEnd;                                            // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NearBegin;                                         // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NearEnd;                                           // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiPSysData*                            DataNiParticleSystem;                              // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WorldSpace;                                        // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NumModifiers;                                      // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiPSysModifier*>                Modifiers;                                         // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiParticleSystem">();
	}
	static class UNiParticleSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiParticleSystem>();
	}
};
static_assert(alignof(UNiParticleSystem) == 0x000008, "Wrong alignment on UNiParticleSystem");
static_assert(sizeof(UNiParticleSystem) == 0x000100, "Wrong size on UNiParticleSystem");
static_assert(offsetof(UNiParticleSystem, VertexDesc) == 0x0000C0, "Member 'UNiParticleSystem::VertexDesc' has a wrong offset!");
static_assert(offsetof(UNiParticleSystem, FarBegin) == 0x0000C8, "Member 'UNiParticleSystem::FarBegin' has a wrong offset!");
static_assert(offsetof(UNiParticleSystem, FarEnd) == 0x0000CC, "Member 'UNiParticleSystem::FarEnd' has a wrong offset!");
static_assert(offsetof(UNiParticleSystem, NearBegin) == 0x0000D0, "Member 'UNiParticleSystem::NearBegin' has a wrong offset!");
static_assert(offsetof(UNiParticleSystem, NearEnd) == 0x0000D4, "Member 'UNiParticleSystem::NearEnd' has a wrong offset!");
static_assert(offsetof(UNiParticleSystem, DataNiParticleSystem) == 0x0000D8, "Member 'UNiParticleSystem::DataNiParticleSystem' has a wrong offset!");
static_assert(offsetof(UNiParticleSystem, WorldSpace) == 0x0000E0, "Member 'UNiParticleSystem::WorldSpace' has a wrong offset!");
static_assert(offsetof(UNiParticleSystem, NumModifiers) == 0x0000E8, "Member 'UNiParticleSystem::NumModifiers' has a wrong offset!");
static_assert(offsetof(UNiParticleSystem, Modifiers) == 0x0000F0, "Member 'UNiParticleSystem::Modifiers' has a wrong offset!");

// Class Altar.NiMeshParticleSystem
// 0x0000 (0x0100 - 0x0100)
class UNiMeshParticleSystem final : public UNiParticleSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiMeshParticleSystem">();
	}
	static class UNiMeshParticleSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiMeshParticleSystem>();
	}
};
static_assert(alignof(UNiMeshParticleSystem) == 0x000008, "Wrong alignment on UNiMeshParticleSystem");
static_assert(sizeof(UNiMeshParticleSystem) == 0x000100, "Wrong size on UNiMeshParticleSystem");

// Class Altar.BSBound
// 0x0030 (0x0078 - 0x0048)
class UBSBound final : public UNiExtraData
{
public:
	struct FVector                                Center;                                            // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Dimensions;                                        // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSBound">();
	}
	static class UBSBound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSBound>();
	}
};
static_assert(alignof(UBSBound) == 0x000008, "Wrong alignment on UBSBound");
static_assert(sizeof(UBSBound) == 0x000078, "Wrong size on UBSBound");
static_assert(offsetof(UBSBound, Center) == 0x000048, "Member 'UBSBound::Center' has a wrong offset!");
static_assert(offsetof(UBSBound, Dimensions) == 0x000060, "Member 'UBSBound::Dimensions' has a wrong offset!");

// Class Altar.NiPosData
// 0x0018 (0x0050 - 0x0038)
class UNiPosData final : public UNiObject
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPosData">();
	}
	static class UNiPosData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPosData>();
	}
};
static_assert(alignof(UNiPosData) == 0x000008, "Wrong alignment on UNiPosData");
static_assert(sizeof(UNiPosData) == 0x000050, "Wrong size on UNiPosData");

// Class Altar.BSFurnitureMarker
// 0x0018 (0x0060 - 0x0048)
class UBSFurnitureMarker final : public UNiExtraData
{
public:
	int64                                         NumPositions;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSFurnitureMarker">();
	}
	static class UBSFurnitureMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSFurnitureMarker>();
	}
};
static_assert(alignof(UBSFurnitureMarker) == 0x000008, "Wrong alignment on UBSFurnitureMarker");
static_assert(sizeof(UBSFurnitureMarker) == 0x000060, "Wrong size on UBSFurnitureMarker");
static_assert(offsetof(UBSFurnitureMarker, NumPositions) == 0x000048, "Member 'UBSFurnitureMarker::NumPositions' has a wrong offset!");

// Class Altar.VMeleeAttackAnimInstance
// 0x0010 (0x03B0 - 0x03A0)
class UVMeleeAttackAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	class FName                                   CombatStateMachineName;                            // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMeleeAttackAnimInstance">();
	}
	static class UVMeleeAttackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMeleeAttackAnimInstance>();
	}
};
static_assert(alignof(UVMeleeAttackAnimInstance) == 0x000010, "Wrong alignment on UVMeleeAttackAnimInstance");
static_assert(sizeof(UVMeleeAttackAnimInstance) == 0x0003B0, "Wrong size on UVMeleeAttackAnimInstance");
static_assert(offsetof(UVMeleeAttackAnimInstance, CombatStateMachineName) == 0x0003A0, "Member 'UVMeleeAttackAnimInstance::CombatStateMachineName' has a wrong offset!");

// Class Altar.VLeftRightAttackAnimInstance
// 0x0010 (0x03C0 - 0x03B0)
#pragma pack(push, 0x1)
class alignas(0x10) UVLeftRightAttackAnimInstance : public UVMeleeAttackAnimInstance
{
public:
	bool                                          bShouldEnterLightAttackRight;                      // 0x03B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEnterLightAttackLeft;                       // 0x03B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEnterPrepareAttack;                         // 0x03B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B3[0x5];                                      // 0x03B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttackLeftEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnAttackRightEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLeftRightAttackAnimInstance">();
	}
	static class UVLeftRightAttackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLeftRightAttackAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVLeftRightAttackAnimInstance) == 0x000010, "Wrong alignment on UVLeftRightAttackAnimInstance");
static_assert(sizeof(UVLeftRightAttackAnimInstance) == 0x0003C0, "Wrong size on UVLeftRightAttackAnimInstance");
static_assert(offsetof(UVLeftRightAttackAnimInstance, bShouldEnterLightAttackRight) == 0x0003B0, "Member 'UVLeftRightAttackAnimInstance::bShouldEnterLightAttackRight' has a wrong offset!");
static_assert(offsetof(UVLeftRightAttackAnimInstance, bShouldEnterLightAttackLeft) == 0x0003B1, "Member 'UVLeftRightAttackAnimInstance::bShouldEnterLightAttackLeft' has a wrong offset!");
static_assert(offsetof(UVLeftRightAttackAnimInstance, bShouldEnterPrepareAttack) == 0x0003B2, "Member 'UVLeftRightAttackAnimInstance::bShouldEnterPrepareAttack' has a wrong offset!");

// Class Altar.NiMorphData
// 0x0028 (0x0060 - 0x0038)
class UNiMorphData final : public UNiObject
{
public:
	int64                                         NumMorphs;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumVertices;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RelativeTargets;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMorph*>                         Morphs;                                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiMorphData">();
	}
	static class UNiMorphData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiMorphData>();
	}
};
static_assert(alignof(UNiMorphData) == 0x000008, "Wrong alignment on UNiMorphData");
static_assert(sizeof(UNiMorphData) == 0x000060, "Wrong size on UNiMorphData");
static_assert(offsetof(UNiMorphData, NumMorphs) == 0x000038, "Member 'UNiMorphData::NumMorphs' has a wrong offset!");
static_assert(offsetof(UNiMorphData, NumVertices) == 0x000040, "Member 'UNiMorphData::NumVertices' has a wrong offset!");
static_assert(offsetof(UNiMorphData, RelativeTargets) == 0x000048, "Member 'UNiMorphData::RelativeTargets' has a wrong offset!");
static_assert(offsetof(UNiMorphData, Morphs) == 0x000050, "Member 'UNiMorphData::Morphs' has a wrong offset!");

// Class Altar.NiKeyframeController
// 0x0008 (0x0080 - 0x0078)
class UNiKeyframeController : public UNiSingleInterpController
{
public:
	class UNiKeyframeData*                        Data;                                              // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiKeyframeController">();
	}
	static class UNiKeyframeController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiKeyframeController>();
	}
};
static_assert(alignof(UNiKeyframeController) == 0x000008, "Wrong alignment on UNiKeyframeController");
static_assert(sizeof(UNiKeyframeController) == 0x000080, "Wrong size on UNiKeyframeController");
static_assert(offsetof(UNiKeyframeController, Data) == 0x000078, "Member 'UNiKeyframeController::Data' has a wrong offset!");

// Class Altar.BSKeyframeController
// 0x0008 (0x0088 - 0x0080)
class UBSKeyframeController final : public UNiKeyframeController
{
public:
	class UNiKeyframeData*                        Data2;                                             // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSKeyframeController">();
	}
	static class UBSKeyframeController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSKeyframeController>();
	}
};
static_assert(alignof(UBSKeyframeController) == 0x000008, "Wrong alignment on UBSKeyframeController");
static_assert(sizeof(UBSKeyframeController) == 0x000088, "Wrong size on UBSKeyframeController");
static_assert(offsetof(UBSKeyframeController, Data2) == 0x000080, "Member 'UBSKeyframeController::Data2' has a wrong offset!");

// Class Altar.VLegacyTrainingMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyTrainingMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyTrainingMenu">();
	}
	static class UVLegacyTrainingMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyTrainingMenu>();
	}
};
static_assert(alignof(UVLegacyTrainingMenu) == 0x000008, "Wrong alignment on UVLegacyTrainingMenu");
static_assert(sizeof(UVLegacyTrainingMenu) == 0x0004E8, "Wrong size on UVLegacyTrainingMenu");

// Class Altar.NodeSet
// 0x0018 (0x0048 - 0x0030)
class UNodeSet final : public UNifType
{
public:
	int64                                         NumNodes;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiNode*>                        Nodes;                                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NodeSet">();
	}
	static class UNodeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNodeSet>();
	}
};
static_assert(alignof(UNodeSet) == 0x000008, "Wrong alignment on UNodeSet");
static_assert(sizeof(UNodeSet) == 0x000048, "Wrong size on UNodeSet");
static_assert(offsetof(UNodeSet, NumNodes) == 0x000030, "Member 'UNodeSet::NumNodes' has a wrong offset!");
static_assert(offsetof(UNodeSet, Nodes) == 0x000038, "Member 'UNodeSet::Nodes' has a wrong offset!");

// Class Altar.BSParentVelocityModifier
// 0x0008 (0x0068 - 0x0060)
class UBSParentVelocityModifier final : public UNiPSysModifier
{
public:
	float                                         Damping;                                           // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSParentVelocityModifier">();
	}
	static class UBSParentVelocityModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSParentVelocityModifier>();
	}
};
static_assert(alignof(UBSParentVelocityModifier) == 0x000008, "Wrong alignment on UBSParentVelocityModifier");
static_assert(sizeof(UBSParentVelocityModifier) == 0x000068, "Wrong size on UBSParentVelocityModifier");
static_assert(offsetof(UBSParentVelocityModifier, Damping) == 0x000060, "Member 'UBSParentVelocityModifier::Damping' has a wrong offset!");

// Class Altar.NiPSysCylinderEmitter
// 0x0008 (0x00A0 - 0x0098)
class UNiPSysCylinderEmitter final : public UNiPSysVolumeEmitter
{
public:
	float                                         EmitterRadius;                                     // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmitterHeight;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysCylinderEmitter">();
	}
	static class UNiPSysCylinderEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysCylinderEmitter>();
	}
};
static_assert(alignof(UNiPSysCylinderEmitter) == 0x000008, "Wrong alignment on UNiPSysCylinderEmitter");
static_assert(sizeof(UNiPSysCylinderEmitter) == 0x0000A0, "Wrong size on UNiPSysCylinderEmitter");
static_assert(offsetof(UNiPSysCylinderEmitter, EmitterRadius) == 0x000098, "Member 'UNiPSysCylinderEmitter::EmitterRadius' has a wrong offset!");
static_assert(offsetof(UNiPSysCylinderEmitter, EmitterHeight) == 0x00009C, "Member 'UNiPSysCylinderEmitter::EmitterHeight' has a wrong offset!");

// Class Altar.BSPSysArrayEmitter
// 0x0000 (0x0098 - 0x0098)
class UBSPSysArrayEmitter final : public UNiPSysVolumeEmitter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSPSysArrayEmitter">();
	}
	static class UBSPSysArrayEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSPSysArrayEmitter>();
	}
};
static_assert(alignof(UBSPSysArrayEmitter) == 0x000008, "Wrong alignment on UBSPSysArrayEmitter");
static_assert(sizeof(UBSPSysArrayEmitter) == 0x000098, "Wrong size on UBSPSysArrayEmitter");

// Class Altar.VLegacyXboxFloatingHint
// 0x0020 (0x04E8 - 0x04C8)
class UVLegacyXboxFloatingHint final : public UVAltarWidget
{
public:
	ELegacyXboxFloatingHintButton                 ButtonIcon;                                        // 0x04C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C9[0x7];                                      // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x04D0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void SetButtonIcon(const ELegacyXboxFloatingHintButton Value);
	void SetText(const class FText& Value);
	void UpdateVisibility(const ECommonInputType InputType);

	ELegacyXboxFloatingHintButton GetButtonIcon() const;
	float GetCropForIcon() const;
	const class FText GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyXboxFloatingHint">();
	}
	static class UVLegacyXboxFloatingHint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyXboxFloatingHint>();
	}
};
static_assert(alignof(UVLegacyXboxFloatingHint) == 0x000008, "Wrong alignment on UVLegacyXboxFloatingHint");
static_assert(sizeof(UVLegacyXboxFloatingHint) == 0x0004E8, "Wrong size on UVLegacyXboxFloatingHint");
static_assert(offsetof(UVLegacyXboxFloatingHint, ButtonIcon) == 0x0004C8, "Member 'UVLegacyXboxFloatingHint::ButtonIcon' has a wrong offset!");
static_assert(offsetof(UVLegacyXboxFloatingHint, Text) == 0x0004D0, "Member 'UVLegacyXboxFloatingHint::Text' has a wrong offset!");

// Class Altar.ShaderTexDesc
// 0x0018 (0x0048 - 0x0030)
class UShaderTexDesc final : public UNifType
{
public:
	bool                                          HasMap;                                            // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               Map;                                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MapID;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShaderTexDesc">();
	}
	static class UShaderTexDesc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShaderTexDesc>();
	}
};
static_assert(alignof(UShaderTexDesc) == 0x000008, "Wrong alignment on UShaderTexDesc");
static_assert(sizeof(UShaderTexDesc) == 0x000048, "Wrong size on UShaderTexDesc");
static_assert(offsetof(UShaderTexDesc, HasMap) == 0x000030, "Member 'UShaderTexDesc::HasMap' has a wrong offset!");
static_assert(offsetof(UShaderTexDesc, Map) == 0x000038, "Member 'UShaderTexDesc::Map' has a wrong offset!");
static_assert(offsetof(UShaderTexDesc, MapID) == 0x000040, "Member 'UShaderTexDesc::MapID' has a wrong offset!");

// Class Altar.NiProperty
// 0x0000 (0x0068 - 0x0068)
class UNiProperty : public UNiObjectNet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiProperty">();
	}
	static class UNiProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiProperty>();
	}
};
static_assert(alignof(UNiProperty) == 0x000008, "Wrong alignment on UNiProperty");
static_assert(sizeof(UNiProperty) == 0x000068, "Wrong size on UNiProperty");

// Class Altar.NiWireframeProperty
// 0x0008 (0x0070 - 0x0068)
class UNiWireframeProperty final : public UNiProperty
{
public:
	EWireframeFlags                               Flags_0;                                           // 0x0068(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiWireframeProperty">();
	}
	static class UNiWireframeProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiWireframeProperty>();
	}
};
static_assert(alignof(UNiWireframeProperty) == 0x000008, "Wrong alignment on UNiWireframeProperty");
static_assert(sizeof(UNiWireframeProperty) == 0x000070, "Wrong size on UNiWireframeProperty");
static_assert(offsetof(UNiWireframeProperty, Flags_0) == 0x000068, "Member 'UNiWireframeProperty::Flags_0' has a wrong offset!");

// Class Altar.NiShaderProperty
// 0x0008 (0x0070 - 0x0068)
class UNiShaderProperty : public UNiProperty
{
public:
	EShaderFlags                                  Flags_0;                                           // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiShaderProperty">();
	}
	static class UNiShaderProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiShaderProperty>();
	}
};
static_assert(alignof(UNiShaderProperty) == 0x000008, "Wrong alignment on UNiShaderProperty");
static_assert(sizeof(UNiShaderProperty) == 0x000070, "Wrong size on UNiShaderProperty");
static_assert(offsetof(UNiShaderProperty, Flags_0) == 0x000068, "Member 'UNiShaderProperty::Flags_0' has a wrong offset!");

// Class Altar.BSShaderProperty
// 0x0010 (0x0080 - 0x0070)
class UBSShaderProperty final : public UNiShaderProperty
{
public:
	EBSShaderType                                 ShaderType;                                        // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBSShaderFlags1                               ShaderFlags1;                                      // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBSShaderFlags2                               ShaderFlags2;                                      // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnvironmentMapScale;                               // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSShaderProperty">();
	}
	static class UBSShaderProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSShaderProperty>();
	}
};
static_assert(alignof(UBSShaderProperty) == 0x000008, "Wrong alignment on UBSShaderProperty");
static_assert(sizeof(UBSShaderProperty) == 0x000080, "Wrong size on UBSShaderProperty");
static_assert(offsetof(UBSShaderProperty, ShaderType) == 0x000070, "Member 'UBSShaderProperty::ShaderType' has a wrong offset!");
static_assert(offsetof(UBSShaderProperty, ShaderFlags1) == 0x000074, "Member 'UBSShaderProperty::ShaderFlags1' has a wrong offset!");
static_assert(offsetof(UBSShaderProperty, ShaderFlags2) == 0x000078, "Member 'UBSShaderProperty::ShaderFlags2' has a wrong offset!");
static_assert(offsetof(UBSShaderProperty, EnvironmentMapScale) == 0x00007C, "Member 'UBSShaderProperty::EnvironmentMapScale' has a wrong offset!");

// Class Altar.VAssociatedAltarCellToPrePlacedActors
// 0x0068 (0x0090 - 0x0028)
class UVAssociatedAltarCellToPrePlacedActors final : public UObject
{
public:
	TMap<struct FGuid, class UVInitializedPrePlacedActor*> PrePlacedPairableActors;                  // 0x0028(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAssociatedAltarCellToPrePlacedActors">();
	}
	static class UVAssociatedAltarCellToPrePlacedActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAssociatedAltarCellToPrePlacedActors>();
	}
};
static_assert(alignof(UVAssociatedAltarCellToPrePlacedActors) == 0x000008, "Wrong alignment on UVAssociatedAltarCellToPrePlacedActors");
static_assert(sizeof(UVAssociatedAltarCellToPrePlacedActors) == 0x000090, "Wrong size on UVAssociatedAltarCellToPrePlacedActors");
static_assert(offsetof(UVAssociatedAltarCellToPrePlacedActors, PrePlacedPairableActors) == 0x000028, "Member 'UVAssociatedAltarCellToPrePlacedActors::PrePlacedPairableActors' has a wrong offset!");

// Class Altar.NiPSysCollider
// 0x0028 (0x0060 - 0x0038)
class UNiPSysCollider : public UNiObject
{
public:
	float                                         Bounce;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpawnOnCollide;                                    // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DieOnCollide;                                      // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiPSysSpawnModifier*                   SpawnModifier;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiPSysColliderManager*                 Parent;                                            // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiPSysCollider*                        NextCollider;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiAvObject*                            ColliderObject;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysCollider">();
	}
	static class UNiPSysCollider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysCollider>();
	}
};
static_assert(alignof(UNiPSysCollider) == 0x000008, "Wrong alignment on UNiPSysCollider");
static_assert(sizeof(UNiPSysCollider) == 0x000060, "Wrong size on UNiPSysCollider");
static_assert(offsetof(UNiPSysCollider, Bounce) == 0x000038, "Member 'UNiPSysCollider::Bounce' has a wrong offset!");
static_assert(offsetof(UNiPSysCollider, SpawnOnCollide) == 0x00003C, "Member 'UNiPSysCollider::SpawnOnCollide' has a wrong offset!");
static_assert(offsetof(UNiPSysCollider, DieOnCollide) == 0x00003D, "Member 'UNiPSysCollider::DieOnCollide' has a wrong offset!");
static_assert(offsetof(UNiPSysCollider, SpawnModifier) == 0x000040, "Member 'UNiPSysCollider::SpawnModifier' has a wrong offset!");
static_assert(offsetof(UNiPSysCollider, Parent) == 0x000048, "Member 'UNiPSysCollider::Parent' has a wrong offset!");
static_assert(offsetof(UNiPSysCollider, NextCollider) == 0x000050, "Member 'UNiPSysCollider::NextCollider' has a wrong offset!");
static_assert(offsetof(UNiPSysCollider, ColliderObject) == 0x000058, "Member 'UNiPSysCollider::ColliderObject' has a wrong offset!");

// Class Altar.BSStreamHeader
// 0x0050 (0x0088 - 0x0038)
class UBSStreamHeader final : public UNiObject
{
public:
	int64                                         BSVersion;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Author;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ProcessScript;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExportScript;                                      // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MaxFilepath;                                       // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSStreamHeader">();
	}
	static class UBSStreamHeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSStreamHeader>();
	}
};
static_assert(alignof(UBSStreamHeader) == 0x000008, "Wrong alignment on UBSStreamHeader");
static_assert(sizeof(UBSStreamHeader) == 0x000088, "Wrong size on UBSStreamHeader");
static_assert(offsetof(UBSStreamHeader, BSVersion) == 0x000038, "Member 'UBSStreamHeader::BSVersion' has a wrong offset!");
static_assert(offsetof(UBSStreamHeader, Author) == 0x000040, "Member 'UBSStreamHeader::Author' has a wrong offset!");
static_assert(offsetof(UBSStreamHeader, ProcessScript) == 0x000058, "Member 'UBSStreamHeader::ProcessScript' has a wrong offset!");
static_assert(offsetof(UBSStreamHeader, ExportScript) == 0x000068, "Member 'UBSStreamHeader::ExportScript' has a wrong offset!");
static_assert(offsetof(UBSStreamHeader, MaxFilepath) == 0x000078, "Member 'UBSStreamHeader::MaxFilepath' has a wrong offset!");

// Class Altar.BSVertexDataSSE
// 0x00B0 (0x00E0 - 0x0030)
class UBSVertexDataSSE final : public UNifType
{
public:
	struct FVector                                Vertex;                                            // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bitangent_X;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UV;                                                // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Bitangent_Y;                                       // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Tangent;                                           // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Bitangent_Z;                                       // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ColorVertex;                                       // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<float>                                 BoneWeights;                                       // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<uint8>                                 BoneIndices;                                       // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         EyeData;                                           // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSVertexDataSSE">();
	}
	static class UBSVertexDataSSE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSVertexDataSSE>();
	}
};
static_assert(alignof(UBSVertexDataSSE) == 0x000008, "Wrong alignment on UBSVertexDataSSE");
static_assert(sizeof(UBSVertexDataSSE) == 0x0000E0, "Wrong size on UBSVertexDataSSE");
static_assert(offsetof(UBSVertexDataSSE, Vertex) == 0x000030, "Member 'UBSVertexDataSSE::Vertex' has a wrong offset!");
static_assert(offsetof(UBSVertexDataSSE, Bitangent_X) == 0x000048, "Member 'UBSVertexDataSSE::Bitangent_X' has a wrong offset!");
static_assert(offsetof(UBSVertexDataSSE, UV) == 0x000050, "Member 'UBSVertexDataSSE::UV' has a wrong offset!");
static_assert(offsetof(UBSVertexDataSSE, Normal) == 0x000068, "Member 'UBSVertexDataSSE::Normal' has a wrong offset!");
static_assert(offsetof(UBSVertexDataSSE, Bitangent_Y) == 0x000080, "Member 'UBSVertexDataSSE::Bitangent_Y' has a wrong offset!");
static_assert(offsetof(UBSVertexDataSSE, Tangent) == 0x000088, "Member 'UBSVertexDataSSE::Tangent' has a wrong offset!");
static_assert(offsetof(UBSVertexDataSSE, Bitangent_Z) == 0x0000A0, "Member 'UBSVertexDataSSE::Bitangent_Z' has a wrong offset!");
static_assert(offsetof(UBSVertexDataSSE, ColorVertex) == 0x0000A8, "Member 'UBSVertexDataSSE::ColorVertex' has a wrong offset!");
static_assert(offsetof(UBSVertexDataSSE, BoneWeights) == 0x0000B8, "Member 'UBSVertexDataSSE::BoneWeights' has a wrong offset!");
static_assert(offsetof(UBSVertexDataSSE, BoneIndices) == 0x0000C8, "Member 'UBSVertexDataSSE::BoneIndices' has a wrong offset!");
static_assert(offsetof(UBSVertexDataSSE, EyeData) == 0x0000D8, "Member 'UBSVertexDataSSE::EyeData' has a wrong offset!");

// Class Altar.NiPSysModifierCtlr
// 0x0010 (0x0088 - 0x0078)
class UNiPSysModifierCtlr : public UNiSingleInterpController
{
public:
	struct FNifString                             Name_0;                                            // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysModifierCtlr">();
	}
	static class UNiPSysModifierCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysModifierCtlr>();
	}
};
static_assert(alignof(UNiPSysModifierCtlr) == 0x000008, "Wrong alignment on UNiPSysModifierCtlr");
static_assert(sizeof(UNiPSysModifierCtlr) == 0x000088, "Wrong size on UNiPSysModifierCtlr");
static_assert(offsetof(UNiPSysModifierCtlr, Name_0) == 0x000078, "Member 'UNiPSysModifierCtlr::Name_0' has a wrong offset!");

// Class Altar.NiPSysModifierFloatCtlr
// 0x0008 (0x0090 - 0x0088)
class UNiPSysModifierFloatCtlr : public UNiPSysModifierCtlr
{
public:
	class UNiFloatData*                           Data;                                              // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysModifierFloatCtlr">();
	}
	static class UNiPSysModifierFloatCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysModifierFloatCtlr>();
	}
};
static_assert(alignof(UNiPSysModifierFloatCtlr) == 0x000008, "Wrong alignment on UNiPSysModifierFloatCtlr");
static_assert(sizeof(UNiPSysModifierFloatCtlr) == 0x000090, "Wrong size on UNiPSysModifierFloatCtlr");
static_assert(offsetof(UNiPSysModifierFloatCtlr, Data) == 0x000088, "Member 'UNiPSysModifierFloatCtlr::Data' has a wrong offset!");

// Class Altar.NiPSysEmitterInitialRadiusCtlr
// 0x0000 (0x0090 - 0x0090)
class UNiPSysEmitterInitialRadiusCtlr final : public UNiPSysModifierFloatCtlr
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysEmitterInitialRadiusCtlr">();
	}
	static class UNiPSysEmitterInitialRadiusCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysEmitterInitialRadiusCtlr>();
	}
};
static_assert(alignof(UNiPSysEmitterInitialRadiusCtlr) == 0x000008, "Wrong alignment on UNiPSysEmitterInitialRadiusCtlr");
static_assert(sizeof(UNiPSysEmitterInitialRadiusCtlr) == 0x000090, "Wrong size on UNiPSysEmitterInitialRadiusCtlr");

// Class Altar.BSWindModifier
// 0x0008 (0x0068 - 0x0060)
class UBSWindModifier final : public UNiPSysModifier
{
public:
	float                                         Strength;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSWindModifier">();
	}
	static class UBSWindModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSWindModifier>();
	}
};
static_assert(alignof(UBSWindModifier) == 0x000008, "Wrong alignment on UBSWindModifier");
static_assert(sizeof(UBSWindModifier) == 0x000068, "Wrong size on UBSWindModifier");
static_assert(offsetof(UBSWindModifier, Strength) == 0x000060, "Member 'UBSWindModifier::Strength' has a wrong offset!");

// Class Altar.NiIntegerExtraData
// 0x0008 (0x0050 - 0x0048)
class UNiIntegerExtraData : public UNiExtraData
{
public:
	int64                                         IntegerData;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiIntegerExtraData">();
	}
	static class UNiIntegerExtraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiIntegerExtraData>();
	}
};
static_assert(alignof(UNiIntegerExtraData) == 0x000008, "Wrong alignment on UNiIntegerExtraData");
static_assert(sizeof(UNiIntegerExtraData) == 0x000050, "Wrong size on UNiIntegerExtraData");
static_assert(offsetof(UNiIntegerExtraData, IntegerData) == 0x000048, "Member 'UNiIntegerExtraData::IntegerData' has a wrong offset!");

// Class Altar.VLevelSelectDispatcher
// 0x0040 (0x02D8 - 0x0298)
class AVLevelSelectDispatcher final : public AActor
{
public:
	struct FVector                                DoorBaseOffset;                                    // 0x0298(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetBetweenDoors;                                // 0x02B0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UChildActorComponent*>           DoorsChildActors;                                  // 0x02C8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UWorld* StartPairedGame(class AVLevelSelectDoor* Door);
	static class UWorld* StartPairedGameManually(class UObject* WorldContext, const class FString& LevelName, const class FString& StartupCommand, bool bUseDebugGamemode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLevelSelectDispatcher">();
	}
	static class AVLevelSelectDispatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVLevelSelectDispatcher>();
	}
};
static_assert(alignof(AVLevelSelectDispatcher) == 0x000008, "Wrong alignment on AVLevelSelectDispatcher");
static_assert(sizeof(AVLevelSelectDispatcher) == 0x0002D8, "Wrong size on AVLevelSelectDispatcher");
static_assert(offsetof(AVLevelSelectDispatcher, DoorBaseOffset) == 0x000298, "Member 'AVLevelSelectDispatcher::DoorBaseOffset' has a wrong offset!");
static_assert(offsetof(AVLevelSelectDispatcher, OffsetBetweenDoors) == 0x0002B0, "Member 'AVLevelSelectDispatcher::OffsetBetweenDoors' has a wrong offset!");
static_assert(offsetof(AVLevelSelectDispatcher, DoorsChildActors) == 0x0002C8, "Member 'AVLevelSelectDispatcher::DoorsChildActors' has a wrong offset!");

// Class Altar.BSXFlags
// 0x0000 (0x0050 - 0x0050)
class UBSXFlags final : public UNiIntegerExtraData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSXFlags">();
	}
	static class UBSXFlags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBSXFlags>();
	}
};
static_assert(alignof(UBSXFlags) == 0x000008, "Wrong alignment on UBSXFlags");
static_assert(sizeof(UBSXFlags) == 0x000050, "Wrong size on UBSXFlags");

// Class Altar.ControlledBlock
// 0x00B0 (0x00E0 - 0x0030)
class UControlledBlock final : public UNifType
{
public:
	class FString                                 TargetName;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiInterpolator*                        Interpolator;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiTimeController*                      Controller;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiBlendInterpolator*                   BlendInterpolator;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlendIndex;                                        // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNifString                             NodeName;                                          // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FNifString                             PropertyType;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FNifString                             ControllerType;                                    // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FNifString                             ControllerId;                                      // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FNifString                             InterpolatorID;                                    // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UNiStringPalette*                       StringPalette;                                     // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NodeNameOffset;                                    // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         PropertyTypeOffset;                                // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ControllerTypeOffset;                              // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ControllerIDOffset;                                // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         InterpolatorIDOffset;                              // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlledBlock">();
	}
	static class UControlledBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlledBlock>();
	}
};
static_assert(alignof(UControlledBlock) == 0x000008, "Wrong alignment on UControlledBlock");
static_assert(sizeof(UControlledBlock) == 0x0000E0, "Wrong size on UControlledBlock");
static_assert(offsetof(UControlledBlock, TargetName) == 0x000030, "Member 'UControlledBlock::TargetName' has a wrong offset!");
static_assert(offsetof(UControlledBlock, Interpolator) == 0x000040, "Member 'UControlledBlock::Interpolator' has a wrong offset!");
static_assert(offsetof(UControlledBlock, Controller) == 0x000048, "Member 'UControlledBlock::Controller' has a wrong offset!");
static_assert(offsetof(UControlledBlock, BlendInterpolator) == 0x000050, "Member 'UControlledBlock::BlendInterpolator' has a wrong offset!");
static_assert(offsetof(UControlledBlock, BlendIndex) == 0x000058, "Member 'UControlledBlock::BlendIndex' has a wrong offset!");
static_assert(offsetof(UControlledBlock, Priority) == 0x00005C, "Member 'UControlledBlock::Priority' has a wrong offset!");
static_assert(offsetof(UControlledBlock, NodeName) == 0x000060, "Member 'UControlledBlock::NodeName' has a wrong offset!");
static_assert(offsetof(UControlledBlock, PropertyType) == 0x000070, "Member 'UControlledBlock::PropertyType' has a wrong offset!");
static_assert(offsetof(UControlledBlock, ControllerType) == 0x000080, "Member 'UControlledBlock::ControllerType' has a wrong offset!");
static_assert(offsetof(UControlledBlock, ControllerId) == 0x000090, "Member 'UControlledBlock::ControllerId' has a wrong offset!");
static_assert(offsetof(UControlledBlock, InterpolatorID) == 0x0000A0, "Member 'UControlledBlock::InterpolatorID' has a wrong offset!");
static_assert(offsetof(UControlledBlock, StringPalette) == 0x0000B0, "Member 'UControlledBlock::StringPalette' has a wrong offset!");
static_assert(offsetof(UControlledBlock, NodeNameOffset) == 0x0000B8, "Member 'UControlledBlock::NodeNameOffset' has a wrong offset!");
static_assert(offsetof(UControlledBlock, PropertyTypeOffset) == 0x0000C0, "Member 'UControlledBlock::PropertyTypeOffset' has a wrong offset!");
static_assert(offsetof(UControlledBlock, ControllerTypeOffset) == 0x0000C8, "Member 'UControlledBlock::ControllerTypeOffset' has a wrong offset!");
static_assert(offsetof(UControlledBlock, ControllerIDOffset) == 0x0000D0, "Member 'UControlledBlock::ControllerIDOffset' has a wrong offset!");
static_assert(offsetof(UControlledBlock, InterpolatorIDOffset) == 0x0000D8, "Member 'UControlledBlock::InterpolatorIDOffset' has a wrong offset!");

// Class Altar.NiPSysBoxEmitter
// 0x0010 (0x00A8 - 0x0098)
class UNiPSysBoxEmitter final : public UNiPSysVolumeEmitter
{
public:
	float                                         EmitterWidth;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmitterHeight;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmitterDepth;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysBoxEmitter">();
	}
	static class UNiPSysBoxEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysBoxEmitter>();
	}
};
static_assert(alignof(UNiPSysBoxEmitter) == 0x000008, "Wrong alignment on UNiPSysBoxEmitter");
static_assert(sizeof(UNiPSysBoxEmitter) == 0x0000A8, "Wrong size on UNiPSysBoxEmitter");
static_assert(offsetof(UNiPSysBoxEmitter, EmitterWidth) == 0x000098, "Member 'UNiPSysBoxEmitter::EmitterWidth' has a wrong offset!");
static_assert(offsetof(UNiPSysBoxEmitter, EmitterHeight) == 0x00009C, "Member 'UNiPSysBoxEmitter::EmitterHeight' has a wrong offset!");
static_assert(offsetof(UNiPSysBoxEmitter, EmitterDepth) == 0x0000A0, "Member 'UNiPSysBoxEmitter::EmitterDepth' has a wrong offset!");

// Class Altar.LambdaWrapper
// 0x0040 (0x0068 - 0x0028)
class ULambdaWrapper final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Execute();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LambdaWrapper">();
	}
	static class ULambdaWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULambdaWrapper>();
	}
};
static_assert(alignof(ULambdaWrapper) == 0x000008, "Wrong alignment on ULambdaWrapper");
static_assert(sizeof(ULambdaWrapper) == 0x000068, "Wrong size on ULambdaWrapper");

// Class Altar.DebugMenuWidget
// 0x0878 (0x0B38 - 0x02C0)
class UDebugMenuWidget : public UUserWidget
{
public:
	class UScrollBox*                             VerticalBox;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              LocalMapUIMaterial;                                // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULambdaWrapper*>                 CommandLinesLambdas;                               // 0x02E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x340];                                    // 0x02F0(0x0340)(Fixing Size After Last Property [ Dumper-7 ])
	class UCheckBox*                              ToggleInventoryPreviewDebugCheckbox;               // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         InventoryItemLocationOffsetHorizontalBox;          // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         InventoryItemRotationOffsetHorizontalBox;          // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHorizontalBox*                         InventoryItemScaleOffsetHorizontalBox;             // 0x0648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_650[0x490];                                    // 0x0650(0x0490)(Fixing Size After Last Property [ Dumper-7 ])
	class UVShowroomSubsystem*                    ShowroomSubsystem;                                 // 0x0AE0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AE8[0x50];                                     // 0x0AE8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ComboBoxCategoryDelegate();
	void DisplayDebugMenu(class APlayerController* PlayerControllerDebug);
	void DisplayShowroomUI();
	void ExecuteAICommandLineFromComboBoxSelection();
	void ExecuteCommandLineFromComboBoxSelection();
	void ExecutePefCommandLineFromComboBoxSelection();
	void ExecuteQACommandLineFromComboBoxSelection();
	void ExecuteSpawnActorCommandLineFromComboBoxSelection();
	void ExecuteSpawnObjectCommandLineFromComboBoxSelection();
	void ExecuteUICommandLineFromComboBoxSelection();
	void HideDebugMenu();
	void OnItemLocationOffsetXChanged(float InNewValue);
	void OnItemLocationOffsetYChanged(float InNewValue);
	void OnItemLocationOffsetZChanged(float InNewValue);
	void OnItemRotationOffsetXChanged(float InNewValue);
	void OnItemRotationOffsetYChanged(float InNewValue);
	void OnItemRotationOffsetZChanged(float InNewValue);
	void OnItemScaleOffsetXChanged(float InNewValue);
	void OnItemScaleOffsetYChanged(float InNewValue);
	void OnItemScaleOffsetZChanged(float InNewValue);
	void OpenLevel();
	void PrintDamageLogToScreen(const class FString& DamageLogString, const float AttackerDistFromPlayer);
	void ReloadUI();
	bool RunDebugMenuCommand(class FString& Command);
	void SelectCreature();
	void SetAmulet();
	void SetCharacterRace();
	void SetCharacterSex();
	void SetFeet();
	void SetHands();
	void SetHelmet();
	void SetLowerBody();
	void SetShowroomBackdropRotation();
	void SetShowroomSkylightIntensity();
	void SetTimeOfDay();
	void SetUpperBody();
	void SpawnCreature();
	void SwitchShowroomBackground();
	void SwitchShowroomSpawnType();
	void ToggleDebugMenu();
	void ToggleInventoryDebugMode();
	void ToggleLevelList();
	void ToggleLocalMapUIDisplay();
	void ToggleShowroomLightsVisibility();
	void ToggleShowroomPropsVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenuWidget">();
	}
	static class UDebugMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenuWidget>();
	}
};
static_assert(alignof(UDebugMenuWidget) == 0x000008, "Wrong alignment on UDebugMenuWidget");
static_assert(sizeof(UDebugMenuWidget) == 0x000B38, "Wrong size on UDebugMenuWidget");
static_assert(offsetof(UDebugMenuWidget, VerticalBox) == 0x0002C0, "Member 'UDebugMenuWidget::VerticalBox' has a wrong offset!");
static_assert(offsetof(UDebugMenuWidget, LocalMapUIMaterial) == 0x0002D8, "Member 'UDebugMenuWidget::LocalMapUIMaterial' has a wrong offset!");
static_assert(offsetof(UDebugMenuWidget, CommandLinesLambdas) == 0x0002E0, "Member 'UDebugMenuWidget::CommandLinesLambdas' has a wrong offset!");
static_assert(offsetof(UDebugMenuWidget, ToggleInventoryPreviewDebugCheckbox) == 0x000630, "Member 'UDebugMenuWidget::ToggleInventoryPreviewDebugCheckbox' has a wrong offset!");
static_assert(offsetof(UDebugMenuWidget, InventoryItemLocationOffsetHorizontalBox) == 0x000638, "Member 'UDebugMenuWidget::InventoryItemLocationOffsetHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDebugMenuWidget, InventoryItemRotationOffsetHorizontalBox) == 0x000640, "Member 'UDebugMenuWidget::InventoryItemRotationOffsetHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDebugMenuWidget, InventoryItemScaleOffsetHorizontalBox) == 0x000648, "Member 'UDebugMenuWidget::InventoryItemScaleOffsetHorizontalBox' has a wrong offset!");
static_assert(offsetof(UDebugMenuWidget, ShowroomSubsystem) == 0x000AE0, "Member 'UDebugMenuWidget::ShowroomSubsystem' has a wrong offset!");

// Class Altar.VModernSettingPageTable
// 0x0010 (0x00C0 - 0x00B0)
class UVModernSettingPageTable final : public UDataTable
{
public:
	TArray<struct FModernSettingPageTableRow>     Pages;                                             // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernSettingPageTable">();
	}
	static class UVModernSettingPageTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernSettingPageTable>();
	}
};
static_assert(alignof(UVModernSettingPageTable) == 0x000008, "Wrong alignment on UVModernSettingPageTable");
static_assert(sizeof(UVModernSettingPageTable) == 0x0000C0, "Wrong size on UVModernSettingPageTable");
static_assert(offsetof(UVModernSettingPageTable, Pages) == 0x0000B0, "Member 'UVModernSettingPageTable::Pages' has a wrong offset!");

// Class Altar.NiPSysEmitterDeclinationCtlr
// 0x0000 (0x0090 - 0x0090)
class UNiPSysEmitterDeclinationCtlr final : public UNiPSysModifierFloatCtlr
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysEmitterDeclinationCtlr">();
	}
	static class UNiPSysEmitterDeclinationCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysEmitterDeclinationCtlr>();
	}
};
static_assert(alignof(UNiPSysEmitterDeclinationCtlr) == 0x000008, "Wrong alignment on UNiPSysEmitterDeclinationCtlr");
static_assert(sizeof(UNiPSysEmitterDeclinationCtlr) == 0x000090, "Wrong size on UNiPSysEmitterDeclinationCtlr");

// Class Altar.VLightRig
// 0x0030 (0x02C8 - 0x0298)
class AVLightRig : public AActor
{
public:
	float                                         OffsetTimeBeforeDelete;                            // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToReachIntensity;                              // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinIntensityPercentage;                            // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallOffIntensityFactor;                            // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightIntensityBasedOnExposure;                    // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x1F];                                     // 0x02A9(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLightRig">();
	}
	static class AVLightRig* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVLightRig>();
	}
};
static_assert(alignof(AVLightRig) == 0x000008, "Wrong alignment on AVLightRig");
static_assert(sizeof(AVLightRig) == 0x0002C8, "Wrong size on AVLightRig");
static_assert(offsetof(AVLightRig, OffsetTimeBeforeDelete) == 0x000298, "Member 'AVLightRig::OffsetTimeBeforeDelete' has a wrong offset!");
static_assert(offsetof(AVLightRig, TimeToReachIntensity) == 0x00029C, "Member 'AVLightRig::TimeToReachIntensity' has a wrong offset!");
static_assert(offsetof(AVLightRig, MinIntensityPercentage) == 0x0002A0, "Member 'AVLightRig::MinIntensityPercentage' has a wrong offset!");
static_assert(offsetof(AVLightRig, FallOffIntensityFactor) == 0x0002A4, "Member 'AVLightRig::FallOffIntensityFactor' has a wrong offset!");
static_assert(offsetof(AVLightRig, bLightIntensityBasedOnExposure) == 0x0002A8, "Member 'AVLightRig::bLightIntensityBasedOnExposure' has a wrong offset!");

// Class Altar.DialogueSceneSubsystem
// 0x00F0 (0x0130 - 0x0040)
class UDialogueSceneSubsystem final : public UTickableWorldSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnEnterDialogue;                                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnQuitDialogue;                                    // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, class AVLightRig*>               LightRigsInFlight;                                 // 0x0070(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FLightRigParameters                    LightRigBlueprintClass_TriggerVolume;              // 0x00C0(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FLightRigParameters                    LightRigBlueprintClass_Global;                     // 0x00D8(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class AVLightRig>                 LightRigBlueprintClassDefault;                     // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AVLightRig*>                     LightRigActorsAvailable;                           // 0x00F8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         LightRigIntensityFactor;                           // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideOffsetTimeBeforeDelete;                   // 0x010C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffsetTimeBeforeDelete;                            // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideTimeToReachIntensity;                     // 0x0114(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToReachIntensity;                              // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideMinIntensityPercentage;                   // 0x011C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinIntensityPercentage;                            // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideFallOffIntensityFactor;                   // 0x0124(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallOffIntensityFactor;                            // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ApplyBetterShadowResolutionInDialogue;             // 0x012C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RemoveLightRigOnActor(class AVPairedCharacter* TargetActor);
	class AVLightRig* SpawnLightRigOnActor(class AVPairedCharacter* TargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueSceneSubsystem">();
	}
	static class UDialogueSceneSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueSceneSubsystem>();
	}
};
static_assert(alignof(UDialogueSceneSubsystem) == 0x000008, "Wrong alignment on UDialogueSceneSubsystem");
static_assert(sizeof(UDialogueSceneSubsystem) == 0x000130, "Wrong size on UDialogueSceneSubsystem");
static_assert(offsetof(UDialogueSceneSubsystem, OnEnterDialogue) == 0x000040, "Member 'UDialogueSceneSubsystem::OnEnterDialogue' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, OnQuitDialogue) == 0x000050, "Member 'UDialogueSceneSubsystem::OnQuitDialogue' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, LightRigsInFlight) == 0x000070, "Member 'UDialogueSceneSubsystem::LightRigsInFlight' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, LightRigBlueprintClass_TriggerVolume) == 0x0000C0, "Member 'UDialogueSceneSubsystem::LightRigBlueprintClass_TriggerVolume' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, LightRigBlueprintClass_Global) == 0x0000D8, "Member 'UDialogueSceneSubsystem::LightRigBlueprintClass_Global' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, LightRigBlueprintClassDefault) == 0x0000F0, "Member 'UDialogueSceneSubsystem::LightRigBlueprintClassDefault' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, LightRigActorsAvailable) == 0x0000F8, "Member 'UDialogueSceneSubsystem::LightRigActorsAvailable' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, LightRigIntensityFactor) == 0x000108, "Member 'UDialogueSceneSubsystem::LightRigIntensityFactor' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, bOverrideOffsetTimeBeforeDelete) == 0x00010C, "Member 'UDialogueSceneSubsystem::bOverrideOffsetTimeBeforeDelete' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, OffsetTimeBeforeDelete) == 0x000110, "Member 'UDialogueSceneSubsystem::OffsetTimeBeforeDelete' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, bOverrideTimeToReachIntensity) == 0x000114, "Member 'UDialogueSceneSubsystem::bOverrideTimeToReachIntensity' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, TimeToReachIntensity) == 0x000118, "Member 'UDialogueSceneSubsystem::TimeToReachIntensity' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, bOverrideMinIntensityPercentage) == 0x00011C, "Member 'UDialogueSceneSubsystem::bOverrideMinIntensityPercentage' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, MinIntensityPercentage) == 0x000120, "Member 'UDialogueSceneSubsystem::MinIntensityPercentage' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, bOverrideFallOffIntensityFactor) == 0x000124, "Member 'UDialogueSceneSubsystem::bOverrideFallOffIntensityFactor' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, FallOffIntensityFactor) == 0x000128, "Member 'UDialogueSceneSubsystem::FallOffIntensityFactor' has a wrong offset!");
static_assert(offsetof(UDialogueSceneSubsystem, ApplyBetterShadowResolutionInDialogue) == 0x00012C, "Member 'UDialogueSceneSubsystem::ApplyBetterShadowResolutionInDialogue' has a wrong offset!");

// Class Altar.VAltarImageCalibrationSettings
// 0x0028 (0x0050 - 0x0028)
class UVAltarImageCalibrationSettings final : public UObject
{
public:
	float                                         BrightnessCalibration;                             // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCalibrated;                                     // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BrightnessCalibrationMaterial;                     // 0x0030(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarImageCalibrationSettings">();
	}
	static class UVAltarImageCalibrationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarImageCalibrationSettings>();
	}
};
static_assert(alignof(UVAltarImageCalibrationSettings) == 0x000008, "Wrong alignment on UVAltarImageCalibrationSettings");
static_assert(sizeof(UVAltarImageCalibrationSettings) == 0x000050, "Wrong size on UVAltarImageCalibrationSettings");
static_assert(offsetof(UVAltarImageCalibrationSettings, BrightnessCalibration) == 0x000028, "Member 'UVAltarImageCalibrationSettings::BrightnessCalibration' has a wrong offset!");
static_assert(offsetof(UVAltarImageCalibrationSettings, bIsCalibrated) == 0x00002C, "Member 'UVAltarImageCalibrationSettings::bIsCalibrated' has a wrong offset!");
static_assert(offsetof(UVAltarImageCalibrationSettings, BrightnessCalibrationMaterial) == 0x000030, "Member 'UVAltarImageCalibrationSettings::BrightnessCalibrationMaterial' has a wrong offset!");

// Class Altar.NiPSysModifierBoolCtlr
// 0x0000 (0x0088 - 0x0088)
class UNiPSysModifierBoolCtlr : public UNiPSysModifierCtlr
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysModifierBoolCtlr">();
	}
	static class UNiPSysModifierBoolCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysModifierBoolCtlr>();
	}
};
static_assert(alignof(UNiPSysModifierBoolCtlr) == 0x000008, "Wrong alignment on UNiPSysModifierBoolCtlr");
static_assert(sizeof(UNiPSysModifierBoolCtlr) == 0x000088, "Wrong size on UNiPSysModifierBoolCtlr");

// Class Altar.VDressingSwitcher
// 0x0080 (0x0318 - 0x0298)
class AVDressingSwitcher final : public AActor
{
public:
	TMap<class UStaticMesh*, class UInstancedStaticMeshComponent*> CreatedInstancers;                // 0x0298(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootSceneComponent;                                // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVDynamicNavAreaRebuilderComponent*     NavRebuilderComponent;                             // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x4];                                      // 0x02F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  VisibilityPairedTarget;                            // 0x02FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvertedVisibility;                               // 0x0304(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDressingHidden;                                 // 0x0305(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_306[0x12];                                     // 0x0306(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTargetDisabled(bool bShouldBeDisabled);
	void RefreshVisibilityFromTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDressingSwitcher">();
	}
	static class AVDressingSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVDressingSwitcher>();
	}
};
static_assert(alignof(AVDressingSwitcher) == 0x000008, "Wrong alignment on AVDressingSwitcher");
static_assert(sizeof(AVDressingSwitcher) == 0x000318, "Wrong size on AVDressingSwitcher");
static_assert(offsetof(AVDressingSwitcher, CreatedInstancers) == 0x000298, "Member 'AVDressingSwitcher::CreatedInstancers' has a wrong offset!");
static_assert(offsetof(AVDressingSwitcher, RootSceneComponent) == 0x0002E8, "Member 'AVDressingSwitcher::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AVDressingSwitcher, NavRebuilderComponent) == 0x0002F0, "Member 'AVDressingSwitcher::NavRebuilderComponent' has a wrong offset!");
static_assert(offsetof(AVDressingSwitcher, VisibilityPairedTarget) == 0x0002FC, "Member 'AVDressingSwitcher::VisibilityPairedTarget' has a wrong offset!");
static_assert(offsetof(AVDressingSwitcher, bInvertedVisibility) == 0x000304, "Member 'AVDressingSwitcher::bInvertedVisibility' has a wrong offset!");
static_assert(offsetof(AVDressingSwitcher, bIsDressingHidden) == 0x000305, "Member 'AVDressingSwitcher::bIsDressingHidden' has a wrong offset!");

// Class Altar.FacialAnimationBlendUserData
// 0x0010 (0x0038 - 0x0028)
class UFacialAnimationBlendUserData final : public UAssetUserData
{
public:
	int64                                         NumFrames;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartFrame;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FacialAnimationBlendUserData">();
	}
	static class UFacialAnimationBlendUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFacialAnimationBlendUserData>();
	}
};
static_assert(alignof(UFacialAnimationBlendUserData) == 0x000008, "Wrong alignment on UFacialAnimationBlendUserData");
static_assert(sizeof(UFacialAnimationBlendUserData) == 0x000038, "Wrong size on UFacialAnimationBlendUserData");
static_assert(offsetof(UFacialAnimationBlendUserData, NumFrames) == 0x000028, "Member 'UFacialAnimationBlendUserData::NumFrames' has a wrong offset!");
static_assert(offsetof(UFacialAnimationBlendUserData, StartFrame) == 0x000030, "Member 'UFacialAnimationBlendUserData::StartFrame' has a wrong offset!");

// Class Altar.VModernSettingWidget
// 0x0178 (0x0640 - 0x04C8)
class UVModernSettingWidget : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(float NewValue)> OnSettingsWidgetValueChangedDelegate;             // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UVModernSettingWidget* FocussedSettings)> OnSettingFocussedDelegate; // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewState)> OnRequestChangeParentScrollState;                  // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x148];                                    // 0x04F8(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyNewValue(float WidgetValue, bool bDoesTriggerAutoRevert, bool bIsInit);
	const bool GetIsPainted();
	const struct FModernSettingTableRow GetSettingRow();
	void OnConsoleVariableChanged();
	void OnLockStateUpdated();
	void OnReceiveBroadcastFromSettingSubsystem(const class FString& NewCommand);
	void OnRefreshWidgetRequested(float Value);
	void OnSettingAccept();
	void OnSettingChanged(const struct FModernSettingTableRow& NewSettingRow);
	void OnSettingNavigateLeft();
	void OnSettingNavigateRight();
	void OnUserInputDeviceConnectionChange(EInputDeviceConnectionState NewConnectionState, const struct FPlatformUserId& PlatformUserId, const struct FInputDeviceId& InputDeviceId);
	void OnVibrationRequested();
	void RequestChangeParentScrollState(bool bNewState);
	void RevertSettingToDefault();
	void RevertSettingToLastChange();
	void RevertSettingToSavedState();
	void SaveSetting();
	void SetCurrentWidgetValue(float NewValue);
	void SetSettingRow(const struct FModernSettingTableRow& NewSettingRow);
	void UpdateLockState(bool bNewLockState);
	void UpdateStepCommand(const int32 StepIndex, const struct FModernSettingCommand& NewCommand);

	float GetCurrentWidgetValue() const;
	bool IsLocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernSettingWidget">();
	}
	static class UVModernSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernSettingWidget>();
	}
};
static_assert(alignof(UVModernSettingWidget) == 0x000008, "Wrong alignment on UVModernSettingWidget");
static_assert(sizeof(UVModernSettingWidget) == 0x000640, "Wrong size on UVModernSettingWidget");
static_assert(offsetof(UVModernSettingWidget, OnSettingsWidgetValueChangedDelegate) == 0x0004C8, "Member 'UVModernSettingWidget::OnSettingsWidgetValueChangedDelegate' has a wrong offset!");
static_assert(offsetof(UVModernSettingWidget, OnSettingFocussedDelegate) == 0x0004D8, "Member 'UVModernSettingWidget::OnSettingFocussedDelegate' has a wrong offset!");
static_assert(offsetof(UVModernSettingWidget, OnRequestChangeParentScrollState) == 0x0004E8, "Member 'UVModernSettingWidget::OnRequestChangeParentScrollState' has a wrong offset!");

// Class Altar.NiPSysEmitterSpeedCtlr
// 0x0000 (0x0090 - 0x0090)
class UNiPSysEmitterSpeedCtlr final : public UNiPSysModifierFloatCtlr
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysEmitterSpeedCtlr">();
	}
	static class UNiPSysEmitterSpeedCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysEmitterSpeedCtlr>();
	}
};
static_assert(alignof(UNiPSysEmitterSpeedCtlr) == 0x000008, "Wrong alignment on UNiPSysEmitterSpeedCtlr");
static_assert(sizeof(UNiPSysEmitterSpeedCtlr) == 0x000090, "Wrong size on UNiPSysEmitterSpeedCtlr");

// Class Altar.FormatPrefs
// 0x0010 (0x0040 - 0x0030)
class UFormatPrefs final : public UNifType
{
public:
	EPixelLayout                                  PixelLayoutFlag;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMipMapFormat                                 UseMipmaps;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaFormat                                  AlphaFormatFlag;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FormatPrefs">();
	}
	static class UFormatPrefs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFormatPrefs>();
	}
};
static_assert(alignof(UFormatPrefs) == 0x000008, "Wrong alignment on UFormatPrefs");
static_assert(sizeof(UFormatPrefs) == 0x000040, "Wrong size on UFormatPrefs");
static_assert(offsetof(UFormatPrefs, PixelLayoutFlag) == 0x000030, "Member 'UFormatPrefs::PixelLayoutFlag' has a wrong offset!");
static_assert(offsetof(UFormatPrefs, UseMipmaps) == 0x000034, "Member 'UFormatPrefs::UseMipmaps' has a wrong offset!");
static_assert(offsetof(UFormatPrefs, AlphaFormatFlag) == 0x000038, "Member 'UFormatPrefs::AlphaFormatFlag' has a wrong offset!");

// Class Altar.FurniturePosition
// 0x0030 (0x0060 - 0x0030)
class UFurniturePosition final : public UNifType
{
public:
	struct FVector                                Offset;                                            // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Orientation;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PositionRef1;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PositionRef2;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Heading;                                           // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FurniturePosition">();
	}
	static class UFurniturePosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFurniturePosition>();
	}
};
static_assert(alignof(UFurniturePosition) == 0x000008, "Wrong alignment on UFurniturePosition");
static_assert(sizeof(UFurniturePosition) == 0x000060, "Wrong size on UFurniturePosition");
static_assert(offsetof(UFurniturePosition, Offset) == 0x000030, "Member 'UFurniturePosition::Offset' has a wrong offset!");
static_assert(offsetof(UFurniturePosition, Orientation) == 0x000048, "Member 'UFurniturePosition::Orientation' has a wrong offset!");
static_assert(offsetof(UFurniturePosition, PositionRef1) == 0x00004C, "Member 'UFurniturePosition::PositionRef1' has a wrong offset!");
static_assert(offsetof(UFurniturePosition, PositionRef2) == 0x000050, "Member 'UFurniturePosition::PositionRef2' has a wrong offset!");
static_assert(offsetof(UFurniturePosition, Heading) == 0x000054, "Member 'UFurniturePosition::Heading' has a wrong offset!");

// Class Altar.NiPSysEmitterCtlrData
// 0x0030 (0x0068 - 0x0038)
class UNiPSysEmitterCtlrData final : public UNiObject
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NumActiveKeys;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysEmitterCtlrData">();
	}
	static class UNiPSysEmitterCtlrData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysEmitterCtlrData>();
	}
};
static_assert(alignof(UNiPSysEmitterCtlrData) == 0x000008, "Wrong alignment on UNiPSysEmitterCtlrData");
static_assert(sizeof(UNiPSysEmitterCtlrData) == 0x000068, "Wrong size on UNiPSysEmitterCtlrData");
static_assert(offsetof(UNiPSysEmitterCtlrData, NumActiveKeys) == 0x000050, "Member 'UNiPSysEmitterCtlrData::NumActiveKeys' has a wrong offset!");

// Class Altar.VGlobalLighting
// 0x0030 (0x02C8 - 0x0298)
class AVGlobalLighting : public AActor
{
public:
	TSubclassOf<class AVLightRig>                 LightRigBlueprintClassDay;                         // 0x0298(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVLightRig>                 LightRigBlueprintClassNight;                       // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NightBegin;                                        // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NightEnd;                                          // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPostProcessUnbound;                             // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DetectionLightingSkylightIntensityCurve;           // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreDetectionLightingCurve;                     // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VGlobalLighting">();
	}
	static class AVGlobalLighting* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVGlobalLighting>();
	}
};
static_assert(alignof(AVGlobalLighting) == 0x000008, "Wrong alignment on AVGlobalLighting");
static_assert(sizeof(AVGlobalLighting) == 0x0002C8, "Wrong size on AVGlobalLighting");
static_assert(offsetof(AVGlobalLighting, LightRigBlueprintClassDay) == 0x000298, "Member 'AVGlobalLighting::LightRigBlueprintClassDay' has a wrong offset!");
static_assert(offsetof(AVGlobalLighting, LightRigBlueprintClassNight) == 0x0002A0, "Member 'AVGlobalLighting::LightRigBlueprintClassNight' has a wrong offset!");
static_assert(offsetof(AVGlobalLighting, NightBegin) == 0x0002A8, "Member 'AVGlobalLighting::NightBegin' has a wrong offset!");
static_assert(offsetof(AVGlobalLighting, NightEnd) == 0x0002AC, "Member 'AVGlobalLighting::NightEnd' has a wrong offset!");
static_assert(offsetof(AVGlobalLighting, bIsPostProcessUnbound) == 0x0002B0, "Member 'AVGlobalLighting::bIsPostProcessUnbound' has a wrong offset!");
static_assert(offsetof(AVGlobalLighting, DetectionLightingSkylightIntensityCurve) == 0x0002B8, "Member 'AVGlobalLighting::DetectionLightingSkylightIntensityCurve' has a wrong offset!");
static_assert(offsetof(AVGlobalLighting, bIgnoreDetectionLightingCurve) == 0x0002C0, "Member 'AVGlobalLighting::bIgnoreDetectionLightingCurve' has a wrong offset!");

// Class Altar.VAltarGraphicsSettingManager
// 0x00B8 (0x00E0 - 0x0028)
class UVAltarGraphicsSettingManager final : public UObject
{
public:
	uint8                                         Pad_28[0xB8];                                      // 0x0028(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarGraphicsSettingManager">();
	}
	static class UVAltarGraphicsSettingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarGraphicsSettingManager>();
	}
};
static_assert(alignof(UVAltarGraphicsSettingManager) == 0x000008, "Wrong alignment on UVAltarGraphicsSettingManager");
static_assert(sizeof(UVAltarGraphicsSettingManager) == 0x0000E0, "Wrong size on UVAltarGraphicsSettingManager");

// Class Altar.HavokFilter
// 0x0010 (0x0040 - 0x0030)
class UHavokFilter final : public UNifType
{
public:
	EOblivionLayer                                Layer;                                             // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Flags_0;                                           // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Group;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokFilter">();
	}
	static class UHavokFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHavokFilter>();
	}
};
static_assert(alignof(UHavokFilter) == 0x000008, "Wrong alignment on UHavokFilter");
static_assert(sizeof(UHavokFilter) == 0x000040, "Wrong size on UHavokFilter");
static_assert(offsetof(UHavokFilter, Layer) == 0x000030, "Member 'UHavokFilter::Layer' has a wrong offset!");
static_assert(offsetof(UHavokFilter, Flags_0) == 0x000034, "Member 'UHavokFilter::Flags_0' has a wrong offset!");
static_assert(offsetof(UHavokFilter, Group) == 0x000038, "Member 'UHavokFilter::Group' has a wrong offset!");

// Class Altar.VModern_CharacCreationGenericSettingsTitle
// 0x0018 (0x04E0 - 0x04C8)
class UVModern_CharacCreationGenericSettingsTitle final : public UVAltarWidget
{
public:
	class FText                                   Title;                                             // 0x04C8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_CharacCreationGenericSettingsTitle">();
	}
	static class UVModern_CharacCreationGenericSettingsTitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_CharacCreationGenericSettingsTitle>();
	}
};
static_assert(alignof(UVModern_CharacCreationGenericSettingsTitle) == 0x000008, "Wrong alignment on UVModern_CharacCreationGenericSettingsTitle");
static_assert(sizeof(UVModern_CharacCreationGenericSettingsTitle) == 0x0004E0, "Wrong size on UVModern_CharacCreationGenericSettingsTitle");
static_assert(offsetof(UVModern_CharacCreationGenericSettingsTitle, Title) == 0x0004C8, "Member 'UVModern_CharacCreationGenericSettingsTitle::Title' has a wrong offset!");

// Class Altar.NiPSysMeshEmitter
// 0x0038 (0x00C8 - 0x0090)
class UNiPSysMeshEmitter final : public UNiPSysEmitter
{
public:
	int64                                         NumEmitterMeshes;                                  // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiAvObject*>                    EmitterMeshes;                                     // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	EVelocityType                                 InitialVelocityType;                               // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmitFrom                                     EmissionType;                                      // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EmissionAxis;                                      // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysMeshEmitter">();
	}
	static class UNiPSysMeshEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysMeshEmitter>();
	}
};
static_assert(alignof(UNiPSysMeshEmitter) == 0x000008, "Wrong alignment on UNiPSysMeshEmitter");
static_assert(sizeof(UNiPSysMeshEmitter) == 0x0000C8, "Wrong size on UNiPSysMeshEmitter");
static_assert(offsetof(UNiPSysMeshEmitter, NumEmitterMeshes) == 0x000090, "Member 'UNiPSysMeshEmitter::NumEmitterMeshes' has a wrong offset!");
static_assert(offsetof(UNiPSysMeshEmitter, EmitterMeshes) == 0x000098, "Member 'UNiPSysMeshEmitter::EmitterMeshes' has a wrong offset!");
static_assert(offsetof(UNiPSysMeshEmitter, InitialVelocityType) == 0x0000A8, "Member 'UNiPSysMeshEmitter::InitialVelocityType' has a wrong offset!");
static_assert(offsetof(UNiPSysMeshEmitter, EmissionType) == 0x0000AC, "Member 'UNiPSysMeshEmitter::EmissionType' has a wrong offset!");
static_assert(offsetof(UNiPSysMeshEmitter, EmissionAxis) == 0x0000B0, "Member 'UNiPSysMeshEmitter::EmissionAxis' has a wrong offset!");

// Class Altar.HavokMaterial
// 0x0010 (0x0040 - 0x0030)
class UHavokMaterial final : public UNifType
{
public:
	int64                                         Padding;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOblivionHavokMaterial                        Material;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokMaterial">();
	}
	static class UHavokMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHavokMaterial>();
	}
};
static_assert(alignof(UHavokMaterial) == 0x000008, "Wrong alignment on UHavokMaterial");
static_assert(sizeof(UHavokMaterial) == 0x000040, "Wrong size on UHavokMaterial");
static_assert(offsetof(UHavokMaterial, Padding) == 0x000030, "Member 'UHavokMaterial::Padding' has a wrong offset!");
static_assert(offsetof(UHavokMaterial, Material) == 0x000038, "Member 'UHavokMaterial::Material' has a wrong offset!");

// Class Altar.HelpMenuListEntryData
// 0x0058 (0x0080 - 0x0028)
class UHelpMenuListEntryData final : public UObject
{
public:
	class UTexture2D*                             EntryIcon;                                         // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EntryText;                                         // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   EntryCategory;                                     // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UHelpMenuListEntryData*>         Children;                                          // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsExpanded;                                       // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AdjustedIndex;                                     // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EntryId;                                           // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool GetIsCategory();
	void InitializeEntry(const class FName& ID, const struct FModernHelpMenuEntry& DataEntry);
	void InitializeHeader(const class FText& HeaderString, class UTexture2D* CategoryIcon, bool bInIsExpanded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelpMenuListEntryData">();
	}
	static class UHelpMenuListEntryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelpMenuListEntryData>();
	}
};
static_assert(alignof(UHelpMenuListEntryData) == 0x000008, "Wrong alignment on UHelpMenuListEntryData");
static_assert(sizeof(UHelpMenuListEntryData) == 0x000080, "Wrong size on UHelpMenuListEntryData");
static_assert(offsetof(UHelpMenuListEntryData, EntryIcon) == 0x000028, "Member 'UHelpMenuListEntryData::EntryIcon' has a wrong offset!");
static_assert(offsetof(UHelpMenuListEntryData, EntryText) == 0x000030, "Member 'UHelpMenuListEntryData::EntryText' has a wrong offset!");
static_assert(offsetof(UHelpMenuListEntryData, EntryCategory) == 0x000048, "Member 'UHelpMenuListEntryData::EntryCategory' has a wrong offset!");
static_assert(offsetof(UHelpMenuListEntryData, Children) == 0x000060, "Member 'UHelpMenuListEntryData::Children' has a wrong offset!");
static_assert(offsetof(UHelpMenuListEntryData, bIsExpanded) == 0x000070, "Member 'UHelpMenuListEntryData::bIsExpanded' has a wrong offset!");
static_assert(offsetof(UHelpMenuListEntryData, AdjustedIndex) == 0x000074, "Member 'UHelpMenuListEntryData::AdjustedIndex' has a wrong offset!");
static_assert(offsetof(UHelpMenuListEntryData, EntryId) == 0x000078, "Member 'UHelpMenuListEntryData::EntryId' has a wrong offset!");

// Class Altar.VAltarNavigableEditableText
// 0x0020 (0x0510 - 0x04F0)
class UVAltarNavigableEditableText : public UVNavigableEditableText
{
public:
	uint8                                         Pad_4F0[0x20];                                     // 0x04F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartEditText();
	void StopEditText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableEditableText">();
	}
	static class UVAltarNavigableEditableText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableEditableText>();
	}
};
static_assert(alignof(UVAltarNavigableEditableText) == 0x000008, "Wrong alignment on UVAltarNavigableEditableText");
static_assert(sizeof(UVAltarNavigableEditableText) == 0x000510, "Wrong size on UVAltarNavigableEditableText");

// Class Altar.NiPSysUpdateCtlr
// 0x0000 (0x0068 - 0x0068)
class UNiPSysUpdateCtlr final : public UNiTimeController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysUpdateCtlr">();
	}
	static class UNiPSysUpdateCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysUpdateCtlr>();
	}
};
static_assert(alignof(UNiPSysUpdateCtlr) == 0x000008, "Wrong alignment on UNiPSysUpdateCtlr");
static_assert(sizeof(UNiPSysUpdateCtlr) == 0x000068, "Wrong size on UNiPSysUpdateCtlr");

// Class Altar.HelpMenuDetailEntryData
// 0x0088 (0x00B0 - 0x0028)
class UHelpMenuDetailEntryData final : public UObject
{
public:
	class UTexture2D*                             EntryThumbnail;                                    // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VideoPath;                                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EntryName;                                         // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   EntryDescription;                                  // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   EntryFullText;                                     // 0x0070(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   EntryControllerFullText;                           // 0x0088(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsCategory;                                       // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVideo;                                          // 0x00A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHelpMenuListEntryData>  SelectedListEntryPtr;                              // 0x00A4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelpMenuDetailEntryData">();
	}
	static class UHelpMenuDetailEntryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelpMenuDetailEntryData>();
	}
};
static_assert(alignof(UHelpMenuDetailEntryData) == 0x000008, "Wrong alignment on UHelpMenuDetailEntryData");
static_assert(sizeof(UHelpMenuDetailEntryData) == 0x0000B0, "Wrong size on UHelpMenuDetailEntryData");
static_assert(offsetof(UHelpMenuDetailEntryData, EntryThumbnail) == 0x000028, "Member 'UHelpMenuDetailEntryData::EntryThumbnail' has a wrong offset!");
static_assert(offsetof(UHelpMenuDetailEntryData, VideoPath) == 0x000030, "Member 'UHelpMenuDetailEntryData::VideoPath' has a wrong offset!");
static_assert(offsetof(UHelpMenuDetailEntryData, EntryName) == 0x000040, "Member 'UHelpMenuDetailEntryData::EntryName' has a wrong offset!");
static_assert(offsetof(UHelpMenuDetailEntryData, EntryDescription) == 0x000058, "Member 'UHelpMenuDetailEntryData::EntryDescription' has a wrong offset!");
static_assert(offsetof(UHelpMenuDetailEntryData, EntryFullText) == 0x000070, "Member 'UHelpMenuDetailEntryData::EntryFullText' has a wrong offset!");
static_assert(offsetof(UHelpMenuDetailEntryData, EntryControllerFullText) == 0x000088, "Member 'UHelpMenuDetailEntryData::EntryControllerFullText' has a wrong offset!");
static_assert(offsetof(UHelpMenuDetailEntryData, bIsCategory) == 0x0000A0, "Member 'UHelpMenuDetailEntryData::bIsCategory' has a wrong offset!");
static_assert(offsetof(UHelpMenuDetailEntryData, bIsVideo) == 0x0000A1, "Member 'UHelpMenuDetailEntryData::bIsVideo' has a wrong offset!");
static_assert(offsetof(UHelpMenuDetailEntryData, SelectedListEntryPtr) == 0x0000A4, "Member 'UHelpMenuDetailEntryData::SelectedListEntryPtr' has a wrong offset!");

// Class Altar.VAltarImageCalibrationWidget
// 0x0000 (0x02E8 - 0x02E8)
class UVAltarImageCalibrationWidget : public UCommonUserWidget
{
public:
	void SetAndSaveBrightnessSetting(float BrightnessValue);

	float GetBrightnessSetting() const;
	bool GetIsCalibratedSetting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarImageCalibrationWidget">();
	}
	static class UVAltarImageCalibrationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarImageCalibrationWidget>();
	}
};
static_assert(alignof(UVAltarImageCalibrationWidget) == 0x000008, "Wrong alignment on UVAltarImageCalibrationWidget");
static_assert(sizeof(UVAltarImageCalibrationWidget) == 0x0002E8, "Wrong size on UVAltarImageCalibrationWidget");

// Class Altar.Matrix3
// 0x0030 (0x0060 - 0x0030)
class UMatrix3 final : public UNifType
{
public:
	float                                         m11;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m12;                                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m13;                                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m14;                                               // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m21;                                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m22;                                               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m23;                                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m24;                                               // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m31;                                               // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m32;                                               // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m33;                                               // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m34;                                               // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Matrix3">();
	}
	static class UMatrix3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatrix3>();
	}
};
static_assert(alignof(UMatrix3) == 0x000008, "Wrong alignment on UMatrix3");
static_assert(sizeof(UMatrix3) == 0x000060, "Wrong size on UMatrix3");
static_assert(offsetof(UMatrix3, m11) == 0x000030, "Member 'UMatrix3::m11' has a wrong offset!");
static_assert(offsetof(UMatrix3, m12) == 0x000034, "Member 'UMatrix3::m12' has a wrong offset!");
static_assert(offsetof(UMatrix3, m13) == 0x000038, "Member 'UMatrix3::m13' has a wrong offset!");
static_assert(offsetof(UMatrix3, m14) == 0x00003C, "Member 'UMatrix3::m14' has a wrong offset!");
static_assert(offsetof(UMatrix3, m21) == 0x000040, "Member 'UMatrix3::m21' has a wrong offset!");
static_assert(offsetof(UMatrix3, m22) == 0x000044, "Member 'UMatrix3::m22' has a wrong offset!");
static_assert(offsetof(UMatrix3, m23) == 0x000048, "Member 'UMatrix3::m23' has a wrong offset!");
static_assert(offsetof(UMatrix3, m24) == 0x00004C, "Member 'UMatrix3::m24' has a wrong offset!");
static_assert(offsetof(UMatrix3, m31) == 0x000050, "Member 'UMatrix3::m31' has a wrong offset!");
static_assert(offsetof(UMatrix3, m32) == 0x000054, "Member 'UMatrix3::m32' has a wrong offset!");
static_assert(offsetof(UMatrix3, m33) == 0x000058, "Member 'UMatrix3::m33' has a wrong offset!");
static_assert(offsetof(UMatrix3, m34) == 0x00005C, "Member 'UMatrix3::m34' has a wrong offset!");

// Class Altar.VModern_CharacCreationToggleItem
// 0x00B0 (0x00D8 - 0x0028)
class UVModern_CharacCreationToggleItem final : public UObject
{
public:
	uint8                                         Pad_28[0xB0];                                      // 0x0028(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsSelected(const bool Value);
	void SetOption(const struct FVRaceSexMenuCustomisationOptions& Value);
	void SetOptionIndex(const int32 Value);

	const struct FVRaceSexMenuCustomisationOptions GetOption() const;
	const int32 GetOptionIndex() const;
	const bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_CharacCreationToggleItem">();
	}
	static class UVModern_CharacCreationToggleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_CharacCreationToggleItem>();
	}
};
static_assert(alignof(UVModern_CharacCreationToggleItem) == 0x000008, "Wrong alignment on UVModern_CharacCreationToggleItem");
static_assert(sizeof(UVModern_CharacCreationToggleItem) == 0x0000D8, "Wrong size on UVModern_CharacCreationToggleItem");

// Class Altar.NiPSysPlanarCollider
// 0x0038 (0x0098 - 0x0060)
class UNiPSysPlanarCollider final : public UNiPSysCollider
{
public:
	float                                         Width;                                             // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                XAxis;                                             // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                YAxis;                                             // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysPlanarCollider">();
	}
	static class UNiPSysPlanarCollider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysPlanarCollider>();
	}
};
static_assert(alignof(UNiPSysPlanarCollider) == 0x000008, "Wrong alignment on UNiPSysPlanarCollider");
static_assert(sizeof(UNiPSysPlanarCollider) == 0x000098, "Wrong size on UNiPSysPlanarCollider");
static_assert(offsetof(UNiPSysPlanarCollider, Width) == 0x000060, "Member 'UNiPSysPlanarCollider::Width' has a wrong offset!");
static_assert(offsetof(UNiPSysPlanarCollider, Height) == 0x000064, "Member 'UNiPSysPlanarCollider::Height' has a wrong offset!");
static_assert(offsetof(UNiPSysPlanarCollider, XAxis) == 0x000068, "Member 'UNiPSysPlanarCollider::XAxis' has a wrong offset!");
static_assert(offsetof(UNiPSysPlanarCollider, YAxis) == 0x000080, "Member 'UNiPSysPlanarCollider::YAxis' has a wrong offset!");

// Class Altar.Matrix33
// 0x0028 (0x0058 - 0x0030)
class UMatrix33 final : public UNifType
{
public:
	float                                         m11;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m21;                                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m31;                                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m12;                                               // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m22;                                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m32;                                               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m13;                                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m23;                                               // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m33;                                               // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Matrix33">();
	}
	static class UMatrix33* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatrix33>();
	}
};
static_assert(alignof(UMatrix33) == 0x000008, "Wrong alignment on UMatrix33");
static_assert(sizeof(UMatrix33) == 0x000058, "Wrong size on UMatrix33");
static_assert(offsetof(UMatrix33, m11) == 0x000030, "Member 'UMatrix33::m11' has a wrong offset!");
static_assert(offsetof(UMatrix33, m21) == 0x000034, "Member 'UMatrix33::m21' has a wrong offset!");
static_assert(offsetof(UMatrix33, m31) == 0x000038, "Member 'UMatrix33::m31' has a wrong offset!");
static_assert(offsetof(UMatrix33, m12) == 0x00003C, "Member 'UMatrix33::m12' has a wrong offset!");
static_assert(offsetof(UMatrix33, m22) == 0x000040, "Member 'UMatrix33::m22' has a wrong offset!");
static_assert(offsetof(UMatrix33, m32) == 0x000044, "Member 'UMatrix33::m32' has a wrong offset!");
static_assert(offsetof(UMatrix33, m13) == 0x000048, "Member 'UMatrix33::m13' has a wrong offset!");
static_assert(offsetof(UMatrix33, m23) == 0x00004C, "Member 'UMatrix33::m23' has a wrong offset!");
static_assert(offsetof(UMatrix33, m33) == 0x000050, "Member 'UMatrix33::m33' has a wrong offset!");

// Class Altar.hkPackedNiTriStripsData
// 0x0060 (0x0098 - 0x0038)
class UhkPackedNiTriStripsData final : public UbhkShapeCollection
{
public:
	int64                                         NumTriangles;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTriangleData*>                  Triangles;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumVertices;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Compressed;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Vertices;                                          // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        CompressedVertices;                                // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         NumSubShapes;                                      // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UhkSubPartData*>                 SubShapes;                                         // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"hkPackedNiTriStripsData">();
	}
	static class UhkPackedNiTriStripsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UhkPackedNiTriStripsData>();
	}
};
static_assert(alignof(UhkPackedNiTriStripsData) == 0x000008, "Wrong alignment on UhkPackedNiTriStripsData");
static_assert(sizeof(UhkPackedNiTriStripsData) == 0x000098, "Wrong size on UhkPackedNiTriStripsData");
static_assert(offsetof(UhkPackedNiTriStripsData, NumTriangles) == 0x000038, "Member 'UhkPackedNiTriStripsData::NumTriangles' has a wrong offset!");
static_assert(offsetof(UhkPackedNiTriStripsData, Triangles) == 0x000040, "Member 'UhkPackedNiTriStripsData::Triangles' has a wrong offset!");
static_assert(offsetof(UhkPackedNiTriStripsData, NumVertices) == 0x000050, "Member 'UhkPackedNiTriStripsData::NumVertices' has a wrong offset!");
static_assert(offsetof(UhkPackedNiTriStripsData, Compressed) == 0x000058, "Member 'UhkPackedNiTriStripsData::Compressed' has a wrong offset!");
static_assert(offsetof(UhkPackedNiTriStripsData, Vertices) == 0x000060, "Member 'UhkPackedNiTriStripsData::Vertices' has a wrong offset!");
static_assert(offsetof(UhkPackedNiTriStripsData, CompressedVertices) == 0x000070, "Member 'UhkPackedNiTriStripsData::CompressedVertices' has a wrong offset!");
static_assert(offsetof(UhkPackedNiTriStripsData, NumSubShapes) == 0x000080, "Member 'UhkPackedNiTriStripsData::NumSubShapes' has a wrong offset!");
static_assert(offsetof(UhkPackedNiTriStripsData, SubShapes) == 0x000088, "Member 'UhkPackedNiTriStripsData::SubShapes' has a wrong offset!");

// Class Altar.VAltarGameInstance
// 0x00F0 (0x02B8 - 0x01C8)
class UVAltarGameInstance final : public UGameInstance
{
public:
	class UDataTable*                             AltarPrePlacedGuidToCellAsyncFlowHashDataTable;    // 0x01C8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AltarSEWorldPrePlacedGuidToCellAsyncFlowHashDataTable; // 0x01D0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AltarCorpsePhysicsPosesDataTable;                  // 0x01D8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UDataTable*>        WorldPartitionPrePlacedDatatables;                 // 0x01E0(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	class UDataTable*                             AltarTamrielPrePlacedNotSpatiallyLoadedDataTable;  // 0x0230(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AltarSEWorldPrePlacedNotSpatiallyLoadedDataTable;  // 0x0238(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UDataTable*>        WorldPartitionPrePlacedNotSpatiallyLoadedDataTables; // 0x0240(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVPhysicsSaveData*                      PhysicsSaveData;                                   // 0x0298(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAltarSaveIdentificationData*          SaveIdentificationData;                            // 0x02A0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVMovementSaveData*                     MovementSaveData;                                  // 0x02A8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarGameInstance">();
	}
	static class UVAltarGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarGameInstance>();
	}
};
static_assert(alignof(UVAltarGameInstance) == 0x000008, "Wrong alignment on UVAltarGameInstance");
static_assert(sizeof(UVAltarGameInstance) == 0x0002B8, "Wrong size on UVAltarGameInstance");
static_assert(offsetof(UVAltarGameInstance, AltarPrePlacedGuidToCellAsyncFlowHashDataTable) == 0x0001C8, "Member 'UVAltarGameInstance::AltarPrePlacedGuidToCellAsyncFlowHashDataTable' has a wrong offset!");
static_assert(offsetof(UVAltarGameInstance, AltarSEWorldPrePlacedGuidToCellAsyncFlowHashDataTable) == 0x0001D0, "Member 'UVAltarGameInstance::AltarSEWorldPrePlacedGuidToCellAsyncFlowHashDataTable' has a wrong offset!");
static_assert(offsetof(UVAltarGameInstance, AltarCorpsePhysicsPosesDataTable) == 0x0001D8, "Member 'UVAltarGameInstance::AltarCorpsePhysicsPosesDataTable' has a wrong offset!");
static_assert(offsetof(UVAltarGameInstance, WorldPartitionPrePlacedDatatables) == 0x0001E0, "Member 'UVAltarGameInstance::WorldPartitionPrePlacedDatatables' has a wrong offset!");
static_assert(offsetof(UVAltarGameInstance, AltarTamrielPrePlacedNotSpatiallyLoadedDataTable) == 0x000230, "Member 'UVAltarGameInstance::AltarTamrielPrePlacedNotSpatiallyLoadedDataTable' has a wrong offset!");
static_assert(offsetof(UVAltarGameInstance, AltarSEWorldPrePlacedNotSpatiallyLoadedDataTable) == 0x000238, "Member 'UVAltarGameInstance::AltarSEWorldPrePlacedNotSpatiallyLoadedDataTable' has a wrong offset!");
static_assert(offsetof(UVAltarGameInstance, WorldPartitionPrePlacedNotSpatiallyLoadedDataTables) == 0x000240, "Member 'UVAltarGameInstance::WorldPartitionPrePlacedNotSpatiallyLoadedDataTables' has a wrong offset!");
static_assert(offsetof(UVAltarGameInstance, PhysicsSaveData) == 0x000298, "Member 'UVAltarGameInstance::PhysicsSaveData' has a wrong offset!");
static_assert(offsetof(UVAltarGameInstance, SaveIdentificationData) == 0x0002A0, "Member 'UVAltarGameInstance::SaveIdentificationData' has a wrong offset!");
static_assert(offsetof(UVAltarGameInstance, MovementSaveData) == 0x0002A8, "Member 'UVAltarGameInstance::MovementSaveData' has a wrong offset!");

// Class Altar.NiPSysGravityStrengthCtlr
// 0x0000 (0x0090 - 0x0090)
class UNiPSysGravityStrengthCtlr final : public UNiPSysModifierFloatCtlr
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysGravityStrengthCtlr">();
	}
	static class UNiPSysGravityStrengthCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysGravityStrengthCtlr>();
	}
};
static_assert(alignof(UNiPSysGravityStrengthCtlr) == 0x000008, "Wrong alignment on UNiPSysGravityStrengthCtlr");
static_assert(sizeof(UNiPSysGravityStrengthCtlr) == 0x000090, "Wrong size on UNiPSysGravityStrengthCtlr");

// Class Altar.hkpMoppCode
// 0x0030 (0x0060 - 0x0030)
class UhkpMoppCode final : public UNifType
{
public:
	int64                                         DataSize;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Offset;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	EhkMoppCodeBuildType                          BuildType;                                         // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int8>                                  Data;                                              // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"hkpMoppCode">();
	}
	static class UhkpMoppCode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UhkpMoppCode>();
	}
};
static_assert(alignof(UhkpMoppCode) == 0x000008, "Wrong alignment on UhkpMoppCode");
static_assert(sizeof(UhkpMoppCode) == 0x000060, "Wrong size on UhkpMoppCode");
static_assert(offsetof(UhkpMoppCode, DataSize) == 0x000030, "Member 'UhkpMoppCode::DataSize' has a wrong offset!");
static_assert(offsetof(UhkpMoppCode, Offset) == 0x000038, "Member 'UhkpMoppCode::Offset' has a wrong offset!");
static_assert(offsetof(UhkpMoppCode, BuildType) == 0x000048, "Member 'UhkpMoppCode::BuildType' has a wrong offset!");
static_assert(offsetof(UhkpMoppCode, Data) == 0x000050, "Member 'UhkpMoppCode::Data' has a wrong offset!");

// Class Altar.hkQuaternion
// 0x0010 (0x0040 - 0x0030)
class UhkQuaternion final : public UNifType
{
public:
	float                                         X;                                                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         W;                                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"hkQuaternion">();
	}
	static class UhkQuaternion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UhkQuaternion>();
	}
};
static_assert(alignof(UhkQuaternion) == 0x000008, "Wrong alignment on UhkQuaternion");
static_assert(sizeof(UhkQuaternion) == 0x000040, "Wrong size on UhkQuaternion");
static_assert(offsetof(UhkQuaternion, X) == 0x000030, "Member 'UhkQuaternion::X' has a wrong offset!");
static_assert(offsetof(UhkQuaternion, Y) == 0x000034, "Member 'UhkQuaternion::Y' has a wrong offset!");
static_assert(offsetof(UhkQuaternion, Z) == 0x000038, "Member 'UhkQuaternion::Z' has a wrong offset!");
static_assert(offsetof(UhkQuaternion, W) == 0x00003C, "Member 'UhkQuaternion::W' has a wrong offset!");

// Class Altar.VLegacyMapMenuQuestItem
// 0x0098 (0x00C0 - 0x0028)
class UVLegacyMapMenuQuestItem final : public UObject
{
public:
	uint8                                         Pad_28[0x98];                                      // 0x0028(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const struct FLegacyMapMenuQuestProperties& Value);

	const struct FLegacyMapMenuQuestProperties GetProperties() const;
	const int32 GetQuestId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMapMenuQuestItem">();
	}
	static class UVLegacyMapMenuQuestItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMapMenuQuestItem>();
	}
};
static_assert(alignof(UVLegacyMapMenuQuestItem) == 0x000008, "Wrong alignment on UVLegacyMapMenuQuestItem");
static_assert(sizeof(UVLegacyMapMenuQuestItem) == 0x0000C0, "Wrong size on UVLegacyMapMenuQuestItem");

// Class Altar.NiColorData
// 0x0018 (0x0050 - 0x0038)
class UNiColorData final : public UNiObject
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiColorData">();
	}
	static class UNiColorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiColorData>();
	}
};
static_assert(alignof(UNiColorData) == 0x000008, "Wrong alignment on UNiColorData");
static_assert(sizeof(UNiColorData) == 0x000050, "Wrong size on UNiColorData");

// Class Altar.hkSubPartData
// 0x0018 (0x0048 - 0x0030)
class UhkSubPartData final : public UNifType
{
public:
	class UHavokFilter*                           HavokFilter;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumVertices;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHavokMaterial*                         Material;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"hkSubPartData">();
	}
	static class UhkSubPartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UhkSubPartData>();
	}
};
static_assert(alignof(UhkSubPartData) == 0x000008, "Wrong alignment on UhkSubPartData");
static_assert(sizeof(UhkSubPartData) == 0x000048, "Wrong size on UhkSubPartData");
static_assert(offsetof(UhkSubPartData, HavokFilter) == 0x000030, "Member 'UhkSubPartData::HavokFilter' has a wrong offset!");
static_assert(offsetof(UhkSubPartData, NumVertices) == 0x000038, "Member 'UhkSubPartData::NumVertices' has a wrong offset!");
static_assert(offsetof(UhkSubPartData, Material) == 0x000040, "Member 'UhkSubPartData::Material' has a wrong offset!");

// Class Altar.InterpBlendItem
// 0x0020 (0x0050 - 0x0030)
class UInterpBlendItem final : public UNifType
{
public:
	class UNiInterpolator*                        Interpolator;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalizedWeight;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PriorityInt;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PriorityByte;                                      // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EaseSpinner;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpBlendItem">();
	}
	static class UInterpBlendItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpBlendItem>();
	}
};
static_assert(alignof(UInterpBlendItem) == 0x000008, "Wrong alignment on UInterpBlendItem");
static_assert(sizeof(UInterpBlendItem) == 0x000050, "Wrong size on UInterpBlendItem");
static_assert(offsetof(UInterpBlendItem, Interpolator) == 0x000030, "Member 'UInterpBlendItem::Interpolator' has a wrong offset!");
static_assert(offsetof(UInterpBlendItem, Weight) == 0x000038, "Member 'UInterpBlendItem::Weight' has a wrong offset!");
static_assert(offsetof(UInterpBlendItem, NormalizedWeight) == 0x00003C, "Member 'UInterpBlendItem::NormalizedWeight' has a wrong offset!");
static_assert(offsetof(UInterpBlendItem, PriorityInt) == 0x000040, "Member 'UInterpBlendItem::PriorityInt' has a wrong offset!");
static_assert(offsetof(UInterpBlendItem, PriorityByte) == 0x000044, "Member 'UInterpBlendItem::PriorityByte' has a wrong offset!");
static_assert(offsetof(UInterpBlendItem, EaseSpinner) == 0x000048, "Member 'UInterpBlendItem::EaseSpinner' has a wrong offset!");

// Class Altar.NiSpecularProperty
// 0x0008 (0x0070 - 0x0068)
class UNiSpecularProperty final : public UNiProperty
{
public:
	ESpecularFlags                                Flags_0;                                           // 0x0068(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiSpecularProperty">();
	}
	static class UNiSpecularProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiSpecularProperty>();
	}
};
static_assert(alignof(UNiSpecularProperty) == 0x000008, "Wrong alignment on UNiSpecularProperty");
static_assert(sizeof(UNiSpecularProperty) == 0x000070, "Wrong size on UNiSpecularProperty");
static_assert(offsetof(UNiSpecularProperty, Flags_0) == 0x000068, "Member 'UNiSpecularProperty::Flags_0' has a wrong offset!");

// Class Altar.IvyGenerator
// 0x0108 (0x03A0 - 0x0298)
class AIvyGenerator final : public AActor
{
public:
	bool                                          bBaked;                                            // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   BakedInfoText;                                     // 0x02A0(0x0018)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	class FText                                   EditInfoText;                                      // 0x02B8(0x0018)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoUpdate;                                       // 0x02D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowClimbingOnCeiling;                           // 0x02D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFallingMode;                                      // 0x02D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRandomizeAfterFalling;                            // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfPoints;                                    // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnChildBranches;                               // 0x02DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfBranches;                                  // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BranchSeparationDegree;                            // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BranchDistance;                                    // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Curliness;                                         // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WillingnessToClimb;                                // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WillingnessToTwirl;                                // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        AttractorArray;                                    // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         AttractorInfluence;                                // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttractorAffectsChildBranches;                    // 0x030C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRandomize;                                        // 0x030D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30E[0x2];                                      // 0x030E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Randomness;                                        // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RandomnessSeed;                                    // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bGenerateStem;                                     // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMesh*>                    StemMesh;                                          // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxNumberOfStemMeshes;                             // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StemMeshScale;                                     // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StemStartDelay;                                    // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGenerateLeaves;                                   // 0x034C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34D[0x3];                                      // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMesh*>                    LeafMesh;                                          // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         NumberOfLeaves;                                    // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUniformLeafDistribution;                          // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_365[0x3];                                      // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeafRandomness;                                    // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeafScale;                                         // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeafScaleRandomness;                               // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinLeafScale;                                      // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxLeafScale;                                      // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExportToSM;                                       // 0x037C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplineResolution;                                  // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TangentFrequency;                                  // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StemMeshSpacing;                                   // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DownTraceMultiplier;                               // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDrawDebugTrace                               LineTraceVis;                                      // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTraceComplex;                                     // 0x0391(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttractorDebug;                                   // 0x0392(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugUpVectors;                                   // 0x0393(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseInstancedSplineMesh;                           // 0x0394(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InstanceXScale;                                    // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IvyGenerator">();
	}
	static class AIvyGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIvyGenerator>();
	}
};
static_assert(alignof(AIvyGenerator) == 0x000008, "Wrong alignment on AIvyGenerator");
static_assert(sizeof(AIvyGenerator) == 0x0003A0, "Wrong size on AIvyGenerator");
static_assert(offsetof(AIvyGenerator, bBaked) == 0x000298, "Member 'AIvyGenerator::bBaked' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, BakedInfoText) == 0x0002A0, "Member 'AIvyGenerator::BakedInfoText' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, EditInfoText) == 0x0002B8, "Member 'AIvyGenerator::EditInfoText' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bUpdateSpline) == 0x0002D0, "Member 'AIvyGenerator::bUpdateSpline' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bAutoUpdate) == 0x0002D1, "Member 'AIvyGenerator::bAutoUpdate' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bAllowClimbingOnCeiling) == 0x0002D2, "Member 'AIvyGenerator::bAllowClimbingOnCeiling' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bFallingMode) == 0x0002D3, "Member 'AIvyGenerator::bFallingMode' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bRandomizeAfterFalling) == 0x0002D4, "Member 'AIvyGenerator::bRandomizeAfterFalling' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, NumberOfPoints) == 0x0002D8, "Member 'AIvyGenerator::NumberOfPoints' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bSpawnChildBranches) == 0x0002DC, "Member 'AIvyGenerator::bSpawnChildBranches' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, NumberOfBranches) == 0x0002E0, "Member 'AIvyGenerator::NumberOfBranches' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, BranchSeparationDegree) == 0x0002E4, "Member 'AIvyGenerator::BranchSeparationDegree' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, BranchDistance) == 0x0002E8, "Member 'AIvyGenerator::BranchDistance' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, Curliness) == 0x0002EC, "Member 'AIvyGenerator::Curliness' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, WillingnessToClimb) == 0x0002F0, "Member 'AIvyGenerator::WillingnessToClimb' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, WillingnessToTwirl) == 0x0002F4, "Member 'AIvyGenerator::WillingnessToTwirl' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, AttractorArray) == 0x0002F8, "Member 'AIvyGenerator::AttractorArray' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, AttractorInfluence) == 0x000308, "Member 'AIvyGenerator::AttractorInfluence' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bAttractorAffectsChildBranches) == 0x00030C, "Member 'AIvyGenerator::bAttractorAffectsChildBranches' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bRandomize) == 0x00030D, "Member 'AIvyGenerator::bRandomize' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, Randomness) == 0x000310, "Member 'AIvyGenerator::Randomness' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, RandomnessSeed) == 0x000314, "Member 'AIvyGenerator::RandomnessSeed' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, ActorsToIgnore) == 0x000318, "Member 'AIvyGenerator::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bGenerateStem) == 0x000328, "Member 'AIvyGenerator::bGenerateStem' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, StemMesh) == 0x000330, "Member 'AIvyGenerator::StemMesh' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, MaxNumberOfStemMeshes) == 0x000340, "Member 'AIvyGenerator::MaxNumberOfStemMeshes' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, StemMeshScale) == 0x000344, "Member 'AIvyGenerator::StemMeshScale' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, StemStartDelay) == 0x000348, "Member 'AIvyGenerator::StemStartDelay' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bGenerateLeaves) == 0x00034C, "Member 'AIvyGenerator::bGenerateLeaves' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, LeafMesh) == 0x000350, "Member 'AIvyGenerator::LeafMesh' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, NumberOfLeaves) == 0x000360, "Member 'AIvyGenerator::NumberOfLeaves' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bUniformLeafDistribution) == 0x000364, "Member 'AIvyGenerator::bUniformLeafDistribution' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, LeafRandomness) == 0x000368, "Member 'AIvyGenerator::LeafRandomness' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, LeafScale) == 0x00036C, "Member 'AIvyGenerator::LeafScale' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, LeafScaleRandomness) == 0x000370, "Member 'AIvyGenerator::LeafScaleRandomness' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, MinLeafScale) == 0x000374, "Member 'AIvyGenerator::MinLeafScale' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, MaxLeafScale) == 0x000378, "Member 'AIvyGenerator::MaxLeafScale' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bExportToSM) == 0x00037C, "Member 'AIvyGenerator::bExportToSM' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, SplineResolution) == 0x000380, "Member 'AIvyGenerator::SplineResolution' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, TangentFrequency) == 0x000384, "Member 'AIvyGenerator::TangentFrequency' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, StemMeshSpacing) == 0x000388, "Member 'AIvyGenerator::StemMeshSpacing' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, DownTraceMultiplier) == 0x00038C, "Member 'AIvyGenerator::DownTraceMultiplier' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, LineTraceVis) == 0x000390, "Member 'AIvyGenerator::LineTraceVis' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bTraceComplex) == 0x000391, "Member 'AIvyGenerator::bTraceComplex' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bAttractorDebug) == 0x000392, "Member 'AIvyGenerator::bAttractorDebug' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bDebugUpVectors) == 0x000393, "Member 'AIvyGenerator::bDebugUpVectors' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, bUseInstancedSplineMesh) == 0x000394, "Member 'AIvyGenerator::bUseInstancedSplineMesh' has a wrong offset!");
static_assert(offsetof(AIvyGenerator, InstanceXScale) == 0x000398, "Member 'AIvyGenerator::InstanceXScale' has a wrong offset!");

// Class Altar.LandscapeConfig
// 0x0150 (0x0178 - 0x0028)
class ULandscapeConfig final : public UObject
{
public:
	class UMaterialInstance*                      LandscapeMaterial;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ELandscapeLayerName, class ULandscapeLayerInfoObject*> LandscapeLayerInfo;                  // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ELandscapeLayerName                           DefaultLayer;                                      // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, ELandscapeLayerName>      TextureToLayerNoFoliage;                           // 0x0088(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, ELandscapeLayerName>      TextureToLayerWithFoliage;                         // 0x00D8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, class UFoliageType*>      TreesFoliage;                                      // 0x0128(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeConfig">();
	}
	static class ULandscapeConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandscapeConfig>();
	}
};
static_assert(alignof(ULandscapeConfig) == 0x000008, "Wrong alignment on ULandscapeConfig");
static_assert(sizeof(ULandscapeConfig) == 0x000178, "Wrong size on ULandscapeConfig");
static_assert(offsetof(ULandscapeConfig, LandscapeMaterial) == 0x000028, "Member 'ULandscapeConfig::LandscapeMaterial' has a wrong offset!");
static_assert(offsetof(ULandscapeConfig, LandscapeLayerInfo) == 0x000030, "Member 'ULandscapeConfig::LandscapeLayerInfo' has a wrong offset!");
static_assert(offsetof(ULandscapeConfig, DefaultLayer) == 0x000080, "Member 'ULandscapeConfig::DefaultLayer' has a wrong offset!");
static_assert(offsetof(ULandscapeConfig, TextureToLayerNoFoliage) == 0x000088, "Member 'ULandscapeConfig::TextureToLayerNoFoliage' has a wrong offset!");
static_assert(offsetof(ULandscapeConfig, TextureToLayerWithFoliage) == 0x0000D8, "Member 'ULandscapeConfig::TextureToLayerWithFoliage' has a wrong offset!");
static_assert(offsetof(ULandscapeConfig, TreesFoliage) == 0x000128, "Member 'ULandscapeConfig::TreesFoliage' has a wrong offset!");

// Class Altar.VPrepareAttackAnimInstance
// 0x0010 (0x03C0 - 0x03B0)
#pragma pack(push, 0x1)
class alignas(0x10) UVPrepareAttackAnimInstance : public UVMeleeAttackAnimInstance
{
public:
	class UAnimSequenceBase*                      PrepareAttackAnim;                                 // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPrepareAttackEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPrepareAttackAnimInstance">();
	}
	static class UVPrepareAttackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPrepareAttackAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVPrepareAttackAnimInstance) == 0x000010, "Wrong alignment on UVPrepareAttackAnimInstance");
static_assert(sizeof(UVPrepareAttackAnimInstance) == 0x0003C0, "Wrong size on UVPrepareAttackAnimInstance");
static_assert(offsetof(UVPrepareAttackAnimInstance, PrepareAttackAnim) == 0x0003B0, "Member 'UVPrepareAttackAnimInstance::PrepareAttackAnim' has a wrong offset!");

// Class Altar.VMeleeAttackComboAnimInstance
// 0x0050 (0x0410 - 0x03C0)
class UVMeleeAttackComboAnimInstance : public UVPrepareAttackAnimInstance
{
public:
	struct FMeleeAttackComboAnimationData         LayerData;                                         // 0x03B8(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CurrentAttackAnimSequence;                         // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanEnterAttack1;                                  // 0x0400(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanEnterAttack2;                                  // 0x0401(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanEnterAttack3;                                  // 0x0402(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanEnterAttack4;                                  // 0x0403(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayingPowerAttackMontage;                      // 0x0404(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_405[0xB];                                      // 0x0405(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMeleeAttackComboAnimInstance">();
	}
	static class UVMeleeAttackComboAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMeleeAttackComboAnimInstance>();
	}
};
static_assert(alignof(UVMeleeAttackComboAnimInstance) == 0x000010, "Wrong alignment on UVMeleeAttackComboAnimInstance");
static_assert(sizeof(UVMeleeAttackComboAnimInstance) == 0x000410, "Wrong size on UVMeleeAttackComboAnimInstance");
static_assert(offsetof(UVMeleeAttackComboAnimInstance, LayerData) == 0x0003B8, "Member 'UVMeleeAttackComboAnimInstance::LayerData' has a wrong offset!");
static_assert(offsetof(UVMeleeAttackComboAnimInstance, CurrentAttackAnimSequence) == 0x0003F8, "Member 'UVMeleeAttackComboAnimInstance::CurrentAttackAnimSequence' has a wrong offset!");
static_assert(offsetof(UVMeleeAttackComboAnimInstance, bCanEnterAttack1) == 0x000400, "Member 'UVMeleeAttackComboAnimInstance::bCanEnterAttack1' has a wrong offset!");
static_assert(offsetof(UVMeleeAttackComboAnimInstance, bCanEnterAttack2) == 0x000401, "Member 'UVMeleeAttackComboAnimInstance::bCanEnterAttack2' has a wrong offset!");
static_assert(offsetof(UVMeleeAttackComboAnimInstance, bCanEnterAttack3) == 0x000402, "Member 'UVMeleeAttackComboAnimInstance::bCanEnterAttack3' has a wrong offset!");
static_assert(offsetof(UVMeleeAttackComboAnimInstance, bCanEnterAttack4) == 0x000403, "Member 'UVMeleeAttackComboAnimInstance::bCanEnterAttack4' has a wrong offset!");
static_assert(offsetof(UVMeleeAttackComboAnimInstance, bIsPlayingPowerAttackMontage) == 0x000404, "Member 'UVMeleeAttackComboAnimInstance::bIsPlayingPowerAttackMontage' has a wrong offset!");

// Class Altar.VSkillItemObject
// 0x0080 (0x00A8 - 0x0028)
class UVSkillItemObject final : public UObject
{
public:
	struct FSkillsMenuItemProperties              Properties;                                        // 0x0028(0x0078)(NativeAccessSpecifierPrivate)
	bool                                          bIsSelected;                                       // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsSelected(bool bNewSelectionState);
	void SetProperties(const struct FSkillsMenuItemProperties& NewProperties);

	const struct FSkillsMenuItemProperties GetProperties() const;
	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSkillItemObject">();
	}
	static class UVSkillItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSkillItemObject>();
	}
};
static_assert(alignof(UVSkillItemObject) == 0x000008, "Wrong alignment on UVSkillItemObject");
static_assert(sizeof(UVSkillItemObject) == 0x0000A8, "Wrong size on UVSkillItemObject");
static_assert(offsetof(UVSkillItemObject, Properties) == 0x000028, "Member 'UVSkillItemObject::Properties' has a wrong offset!");
static_assert(offsetof(UVSkillItemObject, bIsSelected) == 0x0000A0, "Member 'UVSkillItemObject::bIsSelected' has a wrong offset!");

// Class Altar.NiSequence
// 0x0068 (0x00A0 - 0x0038)
class UNiSequence : public UNiObject
{
public:
	struct FNifString                             Name_0;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FNifString                             AccumRootName;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UNiTextKeyExtraData*                    TextKeys;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumDIV2Ints;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 DIV2Ints;                                          // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UNiObject*                              DIV2Ref;                                           // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumControlledBlocks;                               // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ArrayGrowBy;                                       // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UControlledBlock*>               ControlledBlocks;                                  // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiSequence">();
	}
	static class UNiSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiSequence>();
	}
};
static_assert(alignof(UNiSequence) == 0x000008, "Wrong alignment on UNiSequence");
static_assert(sizeof(UNiSequence) == 0x0000A0, "Wrong size on UNiSequence");
static_assert(offsetof(UNiSequence, Name_0) == 0x000038, "Member 'UNiSequence::Name_0' has a wrong offset!");
static_assert(offsetof(UNiSequence, AccumRootName) == 0x000048, "Member 'UNiSequence::AccumRootName' has a wrong offset!");
static_assert(offsetof(UNiSequence, TextKeys) == 0x000058, "Member 'UNiSequence::TextKeys' has a wrong offset!");
static_assert(offsetof(UNiSequence, NumDIV2Ints) == 0x000060, "Member 'UNiSequence::NumDIV2Ints' has a wrong offset!");
static_assert(offsetof(UNiSequence, DIV2Ints) == 0x000068, "Member 'UNiSequence::DIV2Ints' has a wrong offset!");
static_assert(offsetof(UNiSequence, DIV2Ref) == 0x000078, "Member 'UNiSequence::DIV2Ref' has a wrong offset!");
static_assert(offsetof(UNiSequence, NumControlledBlocks) == 0x000080, "Member 'UNiSequence::NumControlledBlocks' has a wrong offset!");
static_assert(offsetof(UNiSequence, ArrayGrowBy) == 0x000088, "Member 'UNiSequence::ArrayGrowBy' has a wrong offset!");
static_assert(offsetof(UNiSequence, ControlledBlocks) == 0x000090, "Member 'UNiSequence::ControlledBlocks' has a wrong offset!");

// Class Altar.NiControllerSequence
// 0x0070 (0x0110 - 0x00A0)
class UNiControllerSequence final : public UNiSequence
{
public:
	float                                         Weight;                                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiTextKeyExtraData*                    TextKeysNiControllerSequence;                      // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECycleType                                    Cycle;                                             // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase;                                             // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTime;                                          // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayBackwards;                                     // 0x00C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiControllerManager*                   Manager;                                           // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNifString                             AccumRootNameNiControllerSequence;                 // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	EAccumFlags                                   Accum;                                             // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiStringPalette*                       StringPalette;                                     // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBSAnimNotes*                           AnimNotes;                                         // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAnimNoteArrays;                                 // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBSAnimNotes*>                   AnimNoteArrays;                                    // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiControllerSequence">();
	}
	static class UNiControllerSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiControllerSequence>();
	}
};
static_assert(alignof(UNiControllerSequence) == 0x000008, "Wrong alignment on UNiControllerSequence");
static_assert(sizeof(UNiControllerSequence) == 0x000110, "Wrong size on UNiControllerSequence");
static_assert(offsetof(UNiControllerSequence, Weight) == 0x0000A0, "Member 'UNiControllerSequence::Weight' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, TextKeysNiControllerSequence) == 0x0000A8, "Member 'UNiControllerSequence::TextKeysNiControllerSequence' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, Cycle) == 0x0000B0, "Member 'UNiControllerSequence::Cycle' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, Frequency) == 0x0000B4, "Member 'UNiControllerSequence::Frequency' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, Phase) == 0x0000B8, "Member 'UNiControllerSequence::Phase' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, StartTime) == 0x0000BC, "Member 'UNiControllerSequence::StartTime' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, StopTime) == 0x0000C0, "Member 'UNiControllerSequence::StopTime' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, PlayBackwards) == 0x0000C4, "Member 'UNiControllerSequence::PlayBackwards' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, Manager) == 0x0000C8, "Member 'UNiControllerSequence::Manager' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, AccumRootNameNiControllerSequence) == 0x0000D0, "Member 'UNiControllerSequence::AccumRootNameNiControllerSequence' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, Accum) == 0x0000E0, "Member 'UNiControllerSequence::Accum' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, StringPalette) == 0x0000E8, "Member 'UNiControllerSequence::StringPalette' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, AnimNotes) == 0x0000F0, "Member 'UNiControllerSequence::AnimNotes' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, NumAnimNoteArrays) == 0x0000F8, "Member 'UNiControllerSequence::NumAnimNoteArrays' has a wrong offset!");
static_assert(offsetof(UNiControllerSequence, AnimNoteArrays) == 0x000100, "Member 'UNiControllerSequence::AnimNoteArrays' has a wrong offset!");

// Class Altar.LightRigTriggerVolume
// 0x00A0 (0x0340 - 0x02A0)
class ALightRigTriggerVolume final : public ATriggerBox
{
public:
	TSubclassOf<class AVLightRig>                 LightRigDay;                                       // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVLightRig>                 LightRigNight;                                     // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NightBegin;                                        // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NightEnd;                                          // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UTESNPC*, TSubclassOf<class AVLightRig>> LightRigMap;                                 // 0x02B8(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x10];                                     // 0x0308(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightRigIntensityFactor;                           // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideOffsetTimeBeforeDelete;                   // 0x031C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffsetTimeBeforeDelete;                            // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTimeToReachIntensity;                     // 0x0324(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_325[0x3];                                      // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToReachIntensity;                              // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMinIntensityPercentage;                   // 0x032C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32D[0x3];                                      // 0x032D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinIntensityPercentage;                            // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideFallOffIntensityFactor;                   // 0x0334(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_335[0x3];                                      // 0x0335(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallOffIntensityFactor;                            // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class AActor* Actor, class AActor* OtherActor);
	void OnEndOverlap(class AActor* Actor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightRigTriggerVolume">();
	}
	static class ALightRigTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightRigTriggerVolume>();
	}
};
static_assert(alignof(ALightRigTriggerVolume) == 0x000008, "Wrong alignment on ALightRigTriggerVolume");
static_assert(sizeof(ALightRigTriggerVolume) == 0x000340, "Wrong size on ALightRigTriggerVolume");
static_assert(offsetof(ALightRigTriggerVolume, LightRigDay) == 0x0002A0, "Member 'ALightRigTriggerVolume::LightRigDay' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, LightRigNight) == 0x0002A8, "Member 'ALightRigTriggerVolume::LightRigNight' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, NightBegin) == 0x0002B0, "Member 'ALightRigTriggerVolume::NightBegin' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, NightEnd) == 0x0002B4, "Member 'ALightRigTriggerVolume::NightEnd' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, LightRigMap) == 0x0002B8, "Member 'ALightRigTriggerVolume::LightRigMap' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, LightRigIntensityFactor) == 0x000318, "Member 'ALightRigTriggerVolume::LightRigIntensityFactor' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, bOverrideOffsetTimeBeforeDelete) == 0x00031C, "Member 'ALightRigTriggerVolume::bOverrideOffsetTimeBeforeDelete' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, OffsetTimeBeforeDelete) == 0x000320, "Member 'ALightRigTriggerVolume::OffsetTimeBeforeDelete' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, bOverrideTimeToReachIntensity) == 0x000324, "Member 'ALightRigTriggerVolume::bOverrideTimeToReachIntensity' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, TimeToReachIntensity) == 0x000328, "Member 'ALightRigTriggerVolume::TimeToReachIntensity' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, bOverrideMinIntensityPercentage) == 0x00032C, "Member 'ALightRigTriggerVolume::bOverrideMinIntensityPercentage' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, MinIntensityPercentage) == 0x000330, "Member 'ALightRigTriggerVolume::MinIntensityPercentage' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, bOverrideFallOffIntensityFactor) == 0x000334, "Member 'ALightRigTriggerVolume::bOverrideFallOffIntensityFactor' has a wrong offset!");
static_assert(offsetof(ALightRigTriggerVolume, FallOffIntensityFactor) == 0x000338, "Member 'ALightRigTriggerVolume::FallOffIntensityFactor' has a wrong offset!");

// Class Altar.LocalMapComponent
// 0x0048 (0x00E8 - 0x00A0)
class ULocalMapComponent final : public UActorComponent
{
public:
	bool                                          bReplaceAllSlotsWithDefaultCutParams;              // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCutParameter>                  CutParameters;                                     // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOriginalMaterial>              OriginalMaterials;                                 // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshComponent*>           OwnerStaticMeshes;                                 // 0x00D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalMapComponent">();
	}
	static class ULocalMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalMapComponent>();
	}
};
static_assert(alignof(ULocalMapComponent) == 0x000008, "Wrong alignment on ULocalMapComponent");
static_assert(sizeof(ULocalMapComponent) == 0x0000E8, "Wrong size on ULocalMapComponent");
static_assert(offsetof(ULocalMapComponent, bReplaceAllSlotsWithDefaultCutParams) == 0x0000A0, "Member 'ULocalMapComponent::bReplaceAllSlotsWithDefaultCutParams' has a wrong offset!");
static_assert(offsetof(ULocalMapComponent, CutParameters) == 0x0000A8, "Member 'ULocalMapComponent::CutParameters' has a wrong offset!");
static_assert(offsetof(ULocalMapComponent, OriginalMaterials) == 0x0000C8, "Member 'ULocalMapComponent::OriginalMaterials' has a wrong offset!");
static_assert(offsetof(ULocalMapComponent, OwnerStaticMeshes) == 0x0000D8, "Member 'ULocalMapComponent::OwnerStaticMeshes' has a wrong offset!");

// Class Altar.NiBSplineData
// 0x0030 (0x0068 - 0x0038)
class UNiBSplineData final : public UNiObject
{
public:
	int64                                         NumFloatControlPoints;                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatControlPoints;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumCompactControlPoints;                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CompactControlPoints;                              // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBSplineData">();
	}
	static class UNiBSplineData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBSplineData>();
	}
};
static_assert(alignof(UNiBSplineData) == 0x000008, "Wrong alignment on UNiBSplineData");
static_assert(sizeof(UNiBSplineData) == 0x000068, "Wrong size on UNiBSplineData");
static_assert(offsetof(UNiBSplineData, NumFloatControlPoints) == 0x000038, "Member 'UNiBSplineData::NumFloatControlPoints' has a wrong offset!");
static_assert(offsetof(UNiBSplineData, FloatControlPoints) == 0x000040, "Member 'UNiBSplineData::FloatControlPoints' has a wrong offset!");
static_assert(offsetof(UNiBSplineData, NumCompactControlPoints) == 0x000050, "Member 'UNiBSplineData::NumCompactControlPoints' has a wrong offset!");
static_assert(offsetof(UNiBSplineData, CompactControlPoints) == 0x000058, "Member 'UNiBSplineData::CompactControlPoints' has a wrong offset!");

// Class Altar.LocalMapManager
// 0x00A8 (0x0148 - 0x00A0)
class ULocalMapManager final : public UActorComponent
{
public:
	struct FVector                                CameraRotationAngles;                              // 0x00A0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneCaptureComponent2D*               LocalMapDepthCaptureComponent;                     // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               LocalMapBaseColorCaptureComponent;                 // 0x00C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              CutMaterial;                                       // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LocalMapDepthCaptureOrthoWidth;                    // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x24];                                      // 0x00D4(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UMaterialInterface*> CutMaterialInstances;                             // 0x00F8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	struct FVector2D GetLocalMapCoordinates(const struct FVector& WorldPosition) const;
	struct FVector LocalMapToUnrealWorld(const struct FVector2D& LocalMapPosition, const struct FVector2D& MapSize) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalMapManager">();
	}
	static class ULocalMapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalMapManager>();
	}
};
static_assert(alignof(ULocalMapManager) == 0x000008, "Wrong alignment on ULocalMapManager");
static_assert(sizeof(ULocalMapManager) == 0x000148, "Wrong size on ULocalMapManager");
static_assert(offsetof(ULocalMapManager, CameraRotationAngles) == 0x0000A0, "Member 'ULocalMapManager::CameraRotationAngles' has a wrong offset!");
static_assert(offsetof(ULocalMapManager, LocalMapDepthCaptureComponent) == 0x0000B8, "Member 'ULocalMapManager::LocalMapDepthCaptureComponent' has a wrong offset!");
static_assert(offsetof(ULocalMapManager, LocalMapBaseColorCaptureComponent) == 0x0000C0, "Member 'ULocalMapManager::LocalMapBaseColorCaptureComponent' has a wrong offset!");
static_assert(offsetof(ULocalMapManager, CutMaterial) == 0x0000C8, "Member 'ULocalMapManager::CutMaterial' has a wrong offset!");
static_assert(offsetof(ULocalMapManager, LocalMapDepthCaptureOrthoWidth) == 0x0000D0, "Member 'ULocalMapManager::LocalMapDepthCaptureOrthoWidth' has a wrong offset!");
static_assert(offsetof(ULocalMapManager, CutMaterialInstances) == 0x0000F8, "Member 'ULocalMapManager::CutMaterialInstances' has a wrong offset!");

// Class Altar.MaterialData
// 0x0058 (0x0088 - 0x0030)
class UMaterialData final : public UNifType
{
public:
	bool                                          HasShader;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNifString                             ShaderName;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	int32                                         ShaderExtraData;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NumMaterials;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 MaterialName;                                      // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<int32>                                 MaterialExtraData;                                 // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         ActiveMaterial;                                    // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x8];                                       // 0x007C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          MaterialNeedsUpdate;                               // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialData">();
	}
	static class UMaterialData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialData>();
	}
};
static_assert(alignof(UMaterialData) == 0x000008, "Wrong alignment on UMaterialData");
static_assert(sizeof(UMaterialData) == 0x000088, "Wrong size on UMaterialData");
static_assert(offsetof(UMaterialData, HasShader) == 0x000030, "Member 'UMaterialData::HasShader' has a wrong offset!");
static_assert(offsetof(UMaterialData, ShaderName) == 0x000038, "Member 'UMaterialData::ShaderName' has a wrong offset!");
static_assert(offsetof(UMaterialData, ShaderExtraData) == 0x000048, "Member 'UMaterialData::ShaderExtraData' has a wrong offset!");
static_assert(offsetof(UMaterialData, NumMaterials) == 0x000050, "Member 'UMaterialData::NumMaterials' has a wrong offset!");
static_assert(offsetof(UMaterialData, MaterialName) == 0x000058, "Member 'UMaterialData::MaterialName' has a wrong offset!");
static_assert(offsetof(UMaterialData, MaterialExtraData) == 0x000068, "Member 'UMaterialData::MaterialExtraData' has a wrong offset!");
static_assert(offsetof(UMaterialData, ActiveMaterial) == 0x000078, "Member 'UMaterialData::ActiveMaterial' has a wrong offset!");
static_assert(offsetof(UMaterialData, MaterialNeedsUpdate) == 0x000084, "Member 'UMaterialData::MaterialNeedsUpdate' has a wrong offset!");

// Class Altar.VMergedSkeletalMeshComponent
// 0x0030 (0x00D0 - 0x00A0)
class UVMergedSkeletalMeshComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MergedMeshComponent;                               // 0x00C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UVMergedSkeletalMeshSubsystem> MergedMeshSubsystem;                         // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class USkeletalMeshComponent* GetSkeletalMeshComponent();
	void SetMergedMesh(class USkeletalMeshComponent* MasterPoseComponent, const TArray<class USkeletalMesh*>& SkeletalMeshes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMergedSkeletalMeshComponent">();
	}
	static class UVMergedSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMergedSkeletalMeshComponent>();
	}
};
static_assert(alignof(UVMergedSkeletalMeshComponent) == 0x000008, "Wrong alignment on UVMergedSkeletalMeshComponent");
static_assert(sizeof(UVMergedSkeletalMeshComponent) == 0x0000D0, "Wrong size on UVMergedSkeletalMeshComponent");
static_assert(offsetof(UVMergedSkeletalMeshComponent, MergedMeshComponent) == 0x0000C0, "Member 'UVMergedSkeletalMeshComponent::MergedMeshComponent' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshComponent, MergedMeshSubsystem) == 0x0000C8, "Member 'UVMergedSkeletalMeshComponent::MergedMeshSubsystem' has a wrong offset!");

// Class Altar.VWeapon_Staff
// 0x0008 (0x0398 - 0x0390)
class AVWeapon_Staff : public AVWeapon
{
public:
	class UStaticMeshComponent*                   MainStaticMeshComponent;                           // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnChargeUp();
	void OnFire();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWeapon_Staff">();
	}
	static class AVWeapon_Staff* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWeapon_Staff>();
	}
};
static_assert(alignof(AVWeapon_Staff) == 0x000008, "Wrong alignment on AVWeapon_Staff");
static_assert(sizeof(AVWeapon_Staff) == 0x000398, "Wrong size on AVWeapon_Staff");
static_assert(offsetof(AVWeapon_Staff, MainStaticMeshComponent) == 0x000390, "Member 'AVWeapon_Staff::MainStaticMeshComponent' has a wrong offset!");

// Class Altar.NiTexture
// 0x0000 (0x0068 - 0x0068)
class UNiTexture : public UNiObjectNet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTexture">();
	}
	static class UNiTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTexture>();
	}
};
static_assert(alignof(UNiTexture) == 0x000008, "Wrong alignment on UNiTexture");
static_assert(sizeof(UNiTexture) == 0x000068, "Wrong size on UNiTexture");

// Class Altar.Matrix22
// 0x0010 (0x0040 - 0x0030)
class UMatrix22 final : public UNifType
{
public:
	float                                         m11;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m21;                                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m12;                                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m22;                                               // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Matrix22">();
	}
	static class UMatrix22* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatrix22>();
	}
};
static_assert(alignof(UMatrix22) == 0x000008, "Wrong alignment on UMatrix22");
static_assert(sizeof(UMatrix22) == 0x000040, "Wrong size on UMatrix22");
static_assert(offsetof(UMatrix22, m11) == 0x000030, "Member 'UMatrix22::m11' has a wrong offset!");
static_assert(offsetof(UMatrix22, m21) == 0x000034, "Member 'UMatrix22::m21' has a wrong offset!");
static_assert(offsetof(UMatrix22, m12) == 0x000038, "Member 'UMatrix22::m12' has a wrong offset!");
static_assert(offsetof(UMatrix22, m22) == 0x00003C, "Member 'UMatrix22::m22' has a wrong offset!");

// Class Altar.Matrix44
// 0x0040 (0x0070 - 0x0030)
class UMatrix44 final : public UNifType
{
public:
	float                                         m11;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m21;                                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m31;                                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m41;                                               // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m12;                                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m22;                                               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m32;                                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m42;                                               // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m13;                                               // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m23;                                               // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m33;                                               // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m43;                                               // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m14;                                               // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m24;                                               // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m34;                                               // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m44;                                               // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Matrix44">();
	}
	static class UMatrix44* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatrix44>();
	}
};
static_assert(alignof(UMatrix44) == 0x000008, "Wrong alignment on UMatrix44");
static_assert(sizeof(UMatrix44) == 0x000070, "Wrong size on UMatrix44");
static_assert(offsetof(UMatrix44, m11) == 0x000030, "Member 'UMatrix44::m11' has a wrong offset!");
static_assert(offsetof(UMatrix44, m21) == 0x000034, "Member 'UMatrix44::m21' has a wrong offset!");
static_assert(offsetof(UMatrix44, m31) == 0x000038, "Member 'UMatrix44::m31' has a wrong offset!");
static_assert(offsetof(UMatrix44, m41) == 0x00003C, "Member 'UMatrix44::m41' has a wrong offset!");
static_assert(offsetof(UMatrix44, m12) == 0x000040, "Member 'UMatrix44::m12' has a wrong offset!");
static_assert(offsetof(UMatrix44, m22) == 0x000044, "Member 'UMatrix44::m22' has a wrong offset!");
static_assert(offsetof(UMatrix44, m32) == 0x000048, "Member 'UMatrix44::m32' has a wrong offset!");
static_assert(offsetof(UMatrix44, m42) == 0x00004C, "Member 'UMatrix44::m42' has a wrong offset!");
static_assert(offsetof(UMatrix44, m13) == 0x000050, "Member 'UMatrix44::m13' has a wrong offset!");
static_assert(offsetof(UMatrix44, m23) == 0x000054, "Member 'UMatrix44::m23' has a wrong offset!");
static_assert(offsetof(UMatrix44, m33) == 0x000058, "Member 'UMatrix44::m33' has a wrong offset!");
static_assert(offsetof(UMatrix44, m43) == 0x00005C, "Member 'UMatrix44::m43' has a wrong offset!");
static_assert(offsetof(UMatrix44, m14) == 0x000060, "Member 'UMatrix44::m14' has a wrong offset!");
static_assert(offsetof(UMatrix44, m24) == 0x000064, "Member 'UMatrix44::m24' has a wrong offset!");
static_assert(offsetof(UMatrix44, m34) == 0x000068, "Member 'UMatrix44::m34' has a wrong offset!");
static_assert(offsetof(UMatrix44, m44) == 0x00006C, "Member 'UMatrix44::m44' has a wrong offset!");

// Class Altar.NiTransformController
// 0x0000 (0x0080 - 0x0080)
class UNiTransformController final : public UNiKeyframeController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTransformController">();
	}
	static class UNiTransformController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTransformController>();
	}
};
static_assert(alignof(UNiTransformController) == 0x000008, "Wrong alignment on UNiTransformController");
static_assert(sizeof(UNiTransformController) == 0x000080, "Wrong size on UNiTransformController");

// Class Altar.MeshMergeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMeshMergeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class USkeletalMesh* MergeMeshes(const struct FSkeletalMeshMergeParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshMergeFunctionLibrary">();
	}
	static class UMeshMergeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshMergeFunctionLibrary>();
	}
};
static_assert(alignof(UMeshMergeFunctionLibrary) == 0x000008, "Wrong alignment on UMeshMergeFunctionLibrary");
static_assert(sizeof(UMeshMergeFunctionLibrary) == 0x000028, "Wrong size on UMeshMergeFunctionLibrary");

// Class Altar.Morph
// 0x0048 (0x0078 - 0x0030)
class UMorph final : public UNifType
{
public:
	struct FNifString                             FrameName;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumKeys;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKeyType                                      Interpolation;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x14];                                      // 0x004C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LegacyWeight;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Vectors;                                           // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Morph">();
	}
	static class UMorph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMorph>();
	}
};
static_assert(alignof(UMorph) == 0x000008, "Wrong alignment on UMorph");
static_assert(sizeof(UMorph) == 0x000078, "Wrong size on UMorph");
static_assert(offsetof(UMorph, FrameName) == 0x000030, "Member 'UMorph::FrameName' has a wrong offset!");
static_assert(offsetof(UMorph, NumKeys) == 0x000040, "Member 'UMorph::NumKeys' has a wrong offset!");
static_assert(offsetof(UMorph, Interpolation) == 0x000048, "Member 'UMorph::Interpolation' has a wrong offset!");
static_assert(offsetof(UMorph, LegacyWeight) == 0x000060, "Member 'UMorph::LegacyWeight' has a wrong offset!");
static_assert(offsetof(UMorph, Vectors) == 0x000068, "Member 'UMorph::Vectors' has a wrong offset!");

// Class Altar.VMergedSkeletalMeshBuffer
// 0x0038 (0x0060 - 0x0028)
class UVMergedSkeletalMeshBuffer final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UVMergedSkeletalMeshCache*>      KeepAliveHistory;                                  // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UVMergedSkeletalMeshCache*              UsingCache;                                        // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UVMergedSkeletalMeshQuery*>      PendingQueries;                                    // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMergedSkeletalMeshBuffer">();
	}
	static class UVMergedSkeletalMeshBuffer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMergedSkeletalMeshBuffer>();
	}
};
static_assert(alignof(UVMergedSkeletalMeshBuffer) == 0x000008, "Wrong alignment on UVMergedSkeletalMeshBuffer");
static_assert(sizeof(UVMergedSkeletalMeshBuffer) == 0x000060, "Wrong size on UVMergedSkeletalMeshBuffer");
static_assert(offsetof(UVMergedSkeletalMeshBuffer, KeepAliveHistory) == 0x000038, "Member 'UVMergedSkeletalMeshBuffer::KeepAliveHistory' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshBuffer, UsingCache) == 0x000048, "Member 'UVMergedSkeletalMeshBuffer::UsingCache' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshBuffer, PendingQueries) == 0x000050, "Member 'UVMergedSkeletalMeshBuffer::PendingQueries' has a wrong offset!");

// Class Altar.NiStringExtraData
// 0x0010 (0x0058 - 0x0048)
class UNiStringExtraData final : public UNiExtraData
{
public:
	struct FNifString                             StringData;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiStringExtraData">();
	}
	static class UNiStringExtraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiStringExtraData>();
	}
};
static_assert(alignof(UNiStringExtraData) == 0x000008, "Wrong alignment on UNiStringExtraData");
static_assert(sizeof(UNiStringExtraData) == 0x000058, "Wrong size on UNiStringExtraData");
static_assert(offsetof(UNiStringExtraData, StringData) == 0x000048, "Member 'UNiStringExtraData::StringData' has a wrong offset!");

// Class Altar.MorphWeight
// 0x0010 (0x0048 - 0x0038)
class UMorphWeight final : public UNiObject
{
public:
	class UNiInterpolator*                        Interpolator;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MorphWeight">();
	}
	static class UMorphWeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMorphWeight>();
	}
};
static_assert(alignof(UMorphWeight) == 0x000008, "Wrong alignment on UMorphWeight");
static_assert(sizeof(UMorphWeight) == 0x000048, "Wrong size on UMorphWeight");
static_assert(offsetof(UMorphWeight, Interpolator) == 0x000038, "Member 'UMorphWeight::Interpolator' has a wrong offset!");
static_assert(offsetof(UMorphWeight, Weight) == 0x000040, "Member 'UMorphWeight::Weight' has a wrong offset!");

// Class Altar.NavigationButton
// 0x0070 (0x15F0 - 0x1580)
#pragma pack(push, 0x1)
class alignas(0x10) UNavigationButton : public UCommonButtonBase
{
public:
	uint8                                         Pad_1580[0x8];                                     // 0x1580(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBasicUINavigation                     BasicUINavigation;                                 // 0x1588(0x0060)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationButton">();
	}
	static class UNavigationButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationButton>();
	}
};
#pragma pack(pop)
static_assert(alignof(UNavigationButton) == 0x000010, "Wrong alignment on UNavigationButton");
static_assert(sizeof(UNavigationButton) == 0x0015F0, "Wrong size on UNavigationButton");
static_assert(offsetof(UNavigationButton, BasicUINavigation) == 0x001588, "Member 'UNavigationButton::BasicUINavigation' has a wrong offset!");

// Class Altar.NiSkinInstance
// 0x0030 (0x0068 - 0x0038)
class UNiSkinInstance final : public UNiObject
{
public:
	class UNiSkinData*                            Data;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiSkinPartition*                       SkinPartition;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiNode*                                SkeletonRoot;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumBones;                                          // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiNode*>                        Bones;                                             // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiSkinInstance">();
	}
	static class UNiSkinInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiSkinInstance>();
	}
};
static_assert(alignof(UNiSkinInstance) == 0x000008, "Wrong alignment on UNiSkinInstance");
static_assert(sizeof(UNiSkinInstance) == 0x000068, "Wrong size on UNiSkinInstance");
static_assert(offsetof(UNiSkinInstance, Data) == 0x000038, "Member 'UNiSkinInstance::Data' has a wrong offset!");
static_assert(offsetof(UNiSkinInstance, SkinPartition) == 0x000040, "Member 'UNiSkinInstance::SkinPartition' has a wrong offset!");
static_assert(offsetof(UNiSkinInstance, SkeletonRoot) == 0x000048, "Member 'UNiSkinInstance::SkeletonRoot' has a wrong offset!");
static_assert(offsetof(UNiSkinInstance, NumBones) == 0x000050, "Member 'UNiSkinInstance::NumBones' has a wrong offset!");
static_assert(offsetof(UNiSkinInstance, Bones) == 0x000058, "Member 'UNiSkinInstance::Bones' has a wrong offset!");

// Class Altar.NavigationExpandableArea
// 0x0070 (0x0500 - 0x0490)
class UNavigationExpandableArea final : public UExpandableArea
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBasicUINavigation                     BasicUINavigation;                                 // 0x0498(0x0060)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationExpandableArea">();
	}
	static class UNavigationExpandableArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationExpandableArea>();
	}
};
static_assert(alignof(UNavigationExpandableArea) == 0x000010, "Wrong alignment on UNavigationExpandableArea");
static_assert(sizeof(UNavigationExpandableArea) == 0x000500, "Wrong size on UNavigationExpandableArea");
static_assert(offsetof(UNavigationExpandableArea, BasicUINavigation) == 0x000498, "Member 'UNavigationExpandableArea::BasicUINavigation' has a wrong offset!");

// Class Altar.VLegacyListViewBase
// 0x0020 (0x1010 - 0x0FF0)
class UVLegacyListViewBase : public UListView
{
public:
	uint8                                         Pad_FE8[0x10];                                     // 0x0FE8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float ScrollOffsetOfEnd)> BP_OnScrollOffsetOfEndChanged;           // 0x0FF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1008[0x8];                                     // 0x1008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnScrollOffsetOfEndChangedInternal(float ScrollOffsetOfEnd);
	void RequestScrollOffsetOfEndSync();

	class UUserWidget* GetEntryFromItem(const class UObject* Item) const;
	const class UObject* GetItemFromEntryWidget(const class UUserWidget* EntryWidget) const;
	int32 GetItemIndexOfTopEntry() const;
	float GetScrollOffsetOfEnd() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyListViewBase">();
	}
	static class UVLegacyListViewBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyListViewBase>();
	}
};
static_assert(alignof(UVLegacyListViewBase) == 0x000010, "Wrong alignment on UVLegacyListViewBase");
static_assert(sizeof(UVLegacyListViewBase) == 0x001010, "Wrong size on UVLegacyListViewBase");
static_assert(offsetof(UVLegacyListViewBase, BP_OnScrollOffsetOfEndChanged) == 0x000FF8, "Member 'UVLegacyListViewBase::BP_OnScrollOffsetOfEndChanged' has a wrong offset!");

// Class Altar.VLegacySaveLoadMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacySaveLoadMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacySaveLoadMenu">();
	}
	static class UVLegacySaveLoadMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacySaveLoadMenu>();
	}
};
static_assert(alignof(UVLegacySaveLoadMenu) == 0x000008, "Wrong alignment on UVLegacySaveLoadMenu");
static_assert(sizeof(UVLegacySaveLoadMenu) == 0x0004E8, "Wrong size on UVLegacySaveLoadMenu");

// Class Altar.NiTexturingProperty
// 0x0100 (0x0168 - 0x0068)
class UNiTexturingProperty final : public UNiProperty
{
public:
	int32                                         Flagsushort;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTexturingFlags                        FlagsTexturingFlags;                               // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	EApplyMode                                    ApplyModeFlag;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         TextureCount;                                      // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBaseTexture;                                    // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               BaseTexture;                                       // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDarkTexture;                                    // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               DarkTexture;                                       // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDetailTexture;                                  // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               DetailTexture;                                     // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasGlossTexture;                                   // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               GlossTexture;                                      // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasGlowTexture;                                    // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               GlowTexture;                                       // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBumpMapTexture;                                 // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               BumpMapTexture;                                    // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BumpMapLumaScale;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BumpMapLumaOffset;                                 // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatrix22*                              BumpMapMatrix;                                     // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasNormalTexture;                                  // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               NormalTexture;                                     // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasParallaxTexture;                                // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               ParallaxTexture;                                   // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParallaxOffset;                                    // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDecal0Texture;                                  // 0x0114(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               Decal0Texture;                                     // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDecal1Texture;                                  // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               Decal1Texture;                                     // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDecal2Texture;                                  // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               Decal2Texture;                                     // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDecal3Texture;                                  // 0x0140(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexDesc*                               Decal3Texture;                                     // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumShaderTextures;                                 // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UShaderTexDesc*>                 ShaderTextures;                                    // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTexturingProperty">();
	}
	static class UNiTexturingProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTexturingProperty>();
	}
};
static_assert(alignof(UNiTexturingProperty) == 0x000008, "Wrong alignment on UNiTexturingProperty");
static_assert(sizeof(UNiTexturingProperty) == 0x000168, "Wrong size on UNiTexturingProperty");
static_assert(offsetof(UNiTexturingProperty, Flagsushort) == 0x000068, "Member 'UNiTexturingProperty::Flagsushort' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, FlagsTexturingFlags) == 0x00006C, "Member 'UNiTexturingProperty::FlagsTexturingFlags' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, ApplyModeFlag) == 0x000070, "Member 'UNiTexturingProperty::ApplyModeFlag' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, TextureCount) == 0x000078, "Member 'UNiTexturingProperty::TextureCount' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasBaseTexture) == 0x000080, "Member 'UNiTexturingProperty::HasBaseTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, BaseTexture) == 0x000088, "Member 'UNiTexturingProperty::BaseTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasDarkTexture) == 0x000090, "Member 'UNiTexturingProperty::HasDarkTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, DarkTexture) == 0x000098, "Member 'UNiTexturingProperty::DarkTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasDetailTexture) == 0x0000A0, "Member 'UNiTexturingProperty::HasDetailTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, DetailTexture) == 0x0000A8, "Member 'UNiTexturingProperty::DetailTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasGlossTexture) == 0x0000B0, "Member 'UNiTexturingProperty::HasGlossTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, GlossTexture) == 0x0000B8, "Member 'UNiTexturingProperty::GlossTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasGlowTexture) == 0x0000C0, "Member 'UNiTexturingProperty::HasGlowTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, GlowTexture) == 0x0000C8, "Member 'UNiTexturingProperty::GlowTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasBumpMapTexture) == 0x0000D0, "Member 'UNiTexturingProperty::HasBumpMapTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, BumpMapTexture) == 0x0000D8, "Member 'UNiTexturingProperty::BumpMapTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, BumpMapLumaScale) == 0x0000E0, "Member 'UNiTexturingProperty::BumpMapLumaScale' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, BumpMapLumaOffset) == 0x0000E4, "Member 'UNiTexturingProperty::BumpMapLumaOffset' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, BumpMapMatrix) == 0x0000E8, "Member 'UNiTexturingProperty::BumpMapMatrix' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasNormalTexture) == 0x0000F0, "Member 'UNiTexturingProperty::HasNormalTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, NormalTexture) == 0x0000F8, "Member 'UNiTexturingProperty::NormalTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasParallaxTexture) == 0x000100, "Member 'UNiTexturingProperty::HasParallaxTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, ParallaxTexture) == 0x000108, "Member 'UNiTexturingProperty::ParallaxTexture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, ParallaxOffset) == 0x000110, "Member 'UNiTexturingProperty::ParallaxOffset' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasDecal0Texture) == 0x000114, "Member 'UNiTexturingProperty::HasDecal0Texture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, Decal0Texture) == 0x000118, "Member 'UNiTexturingProperty::Decal0Texture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasDecal1Texture) == 0x000120, "Member 'UNiTexturingProperty::HasDecal1Texture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, Decal1Texture) == 0x000128, "Member 'UNiTexturingProperty::Decal1Texture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasDecal2Texture) == 0x000130, "Member 'UNiTexturingProperty::HasDecal2Texture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, Decal2Texture) == 0x000138, "Member 'UNiTexturingProperty::Decal2Texture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, HasDecal3Texture) == 0x000140, "Member 'UNiTexturingProperty::HasDecal3Texture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, Decal3Texture) == 0x000148, "Member 'UNiTexturingProperty::Decal3Texture' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, NumShaderTextures) == 0x000150, "Member 'UNiTexturingProperty::NumShaderTextures' has a wrong offset!");
static_assert(offsetof(UNiTexturingProperty, ShaderTextures) == 0x000158, "Member 'UNiTexturingProperty::ShaderTextures' has a wrong offset!");

// Class Altar.NavigationListview
// 0x0070 (0x1080 - 0x1010)
class UNavigationListview final : public UVLegacyListViewBase
{
public:
	struct FBasicUINavigation                     BasicUINavigation;                                 // 0x1010(0x0060)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1070[0x10];                                    // 0x1070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TScriptInterface<class INavigationUIElement> NavigateToItemIndex(int32 SelectedChildIndex);
	void OnEntryClicked(class UObject* Item);

	int32 GetChildIndexFromWidget(class UWidget* NavigatableWidget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationListview">();
	}
	static class UNavigationListview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationListview>();
	}
};
static_assert(alignof(UNavigationListview) == 0x000010, "Wrong alignment on UNavigationListview");
static_assert(sizeof(UNavigationListview) == 0x001080, "Wrong size on UNavigationListview");
static_assert(offsetof(UNavigationListview, BasicUINavigation) == 0x001010, "Member 'UNavigationListview::BasicUINavigation' has a wrong offset!");

// Class Altar.NavigationListviewEntry
// 0x0010 (0x02D0 - 0x02C0)
class UNavigationListviewEntry : public UUserWidget
{
public:
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSelectable;                                     // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSynchronizeProperties();
	void SetItemObject(class UObject* Item);

	bool IsListItemSelectable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationListviewEntry">();
	}
	static class UNavigationListviewEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationListviewEntry>();
	}
};
static_assert(alignof(UNavigationListviewEntry) == 0x000008, "Wrong alignment on UNavigationListviewEntry");
static_assert(sizeof(UNavigationListviewEntry) == 0x0002D0, "Wrong size on UNavigationListviewEntry");
static_assert(offsetof(UNavigationListviewEntry, bIsSelectable) == 0x0002C8, "Member 'UNavigationListviewEntry::bIsSelectable' has a wrong offset!");

// Class Altar.NiTriBasedGeomData
// 0x0008 (0x00D8 - 0x00D0)
class UNiTriBasedGeomData : public UNiGeometryData
{
public:
	int32                                         NumTriangles;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTriBasedGeomData">();
	}
	static class UNiTriBasedGeomData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTriBasedGeomData>();
	}
};
static_assert(alignof(UNiTriBasedGeomData) == 0x000008, "Wrong alignment on UNiTriBasedGeomData");
static_assert(sizeof(UNiTriBasedGeomData) == 0x0000D8, "Wrong size on UNiTriBasedGeomData");
static_assert(offsetof(UNiTriBasedGeomData, NumTriangles) == 0x0000D0, "Member 'UNiTriBasedGeomData::NumTriangles' has a wrong offset!");

// Class Altar.NiTriStripsData
// 0x0028 (0x0100 - 0x00D8)
class UNiTriStripsData final : public UNiTriBasedGeomData
{
public:
	int32                                         NumStrips;                                         // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 StripLengths;                                      // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<int32>                                 StripLists;                                        // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTriStripsData">();
	}
	static class UNiTriStripsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTriStripsData>();
	}
};
static_assert(alignof(UNiTriStripsData) == 0x000008, "Wrong alignment on UNiTriStripsData");
static_assert(sizeof(UNiTriStripsData) == 0x000100, "Wrong size on UNiTriStripsData");
static_assert(offsetof(UNiTriStripsData, NumStrips) == 0x0000D8, "Member 'UNiTriStripsData::NumStrips' has a wrong offset!");
static_assert(offsetof(UNiTriStripsData, StripLengths) == 0x0000E0, "Member 'UNiTriStripsData::StripLengths' has a wrong offset!");
static_assert(offsetof(UNiTriStripsData, StripLists) == 0x0000F0, "Member 'UNiTriStripsData::StripLists' has a wrong offset!");

// Class Altar.NavigationScrollbox
// 0x0070 (0x0D60 - 0x0CF0)
class UNavigationScrollbox final : public UScrollBox
{
public:
	uint8                                         Pad_CF0[0x8];                                      // 0x0CF0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldRememberNavigationIndex;                    // 0x0CF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CF9[0x3];                                      // 0x0CF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NavigationIndex;                                   // 0x0CFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBasicUINavigation                     BasicUINavigation;                                 // 0x0D00(0x0060)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationScrollbox">();
	}
	static class UNavigationScrollbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationScrollbox>();
	}
};
static_assert(alignof(UNavigationScrollbox) == 0x000010, "Wrong alignment on UNavigationScrollbox");
static_assert(sizeof(UNavigationScrollbox) == 0x000D60, "Wrong size on UNavigationScrollbox");
static_assert(offsetof(UNavigationScrollbox, bShouldRememberNavigationIndex) == 0x000CF8, "Member 'UNavigationScrollbox::bShouldRememberNavigationIndex' has a wrong offset!");
static_assert(offsetof(UNavigationScrollbox, NavigationIndex) == 0x000CFC, "Member 'UNavigationScrollbox::NavigationIndex' has a wrong offset!");
static_assert(offsetof(UNavigationScrollbox, BasicUINavigation) == 0x000D00, "Member 'UNavigationScrollbox::BasicUINavigation' has a wrong offset!");

// Class Altar.NavigationUIElement
// 0x0000 (0x0000 - 0x0000)
class INavigationUIElement final
{
public:
	TScriptInterface<class INavigationUIElement> GetNavigationWidgetForAction(ENavigationInputAction Action);
	void OnCancelPressed();
	void OnFocus();
	void OnSubmitPressed();
	void OnUnfocus();

	bool IsNavigatable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationUIElement">();
	}
	static class INavigationUIElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<INavigationUIElement>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(INavigationUIElement) == 0x000001, "Wrong alignment on INavigationUIElement");
static_assert(sizeof(INavigationUIElement) == 0x000001, "Wrong size on INavigationUIElement");

// Class Altar.VLegacySkillsMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacySkillsMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacySkillsMenu">();
	}
	static class UVLegacySkillsMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacySkillsMenu>();
	}
};
static_assert(alignof(UVLegacySkillsMenu) == 0x000008, "Wrong alignment on UVLegacySkillsMenu");
static_assert(sizeof(UVLegacySkillsMenu) == 0x0004E8, "Wrong size on UVLegacySkillsMenu");

// Class Altar.NiTransformInterpolator
// 0x0010 (0x0048 - 0x0038)
class UNiTransformInterpolator final : public UNiKeyBasedInterpolator
{
public:
	class UNiQuatTransform*                       Transform;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiTransformData*                       Data;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTransformInterpolator">();
	}
	static class UNiTransformInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTransformInterpolator>();
	}
};
static_assert(alignof(UNiTransformInterpolator) == 0x000008, "Wrong alignment on UNiTransformInterpolator");
static_assert(sizeof(UNiTransformInterpolator) == 0x000048, "Wrong size on UNiTransformInterpolator");
static_assert(offsetof(UNiTransformInterpolator, Transform) == 0x000038, "Member 'UNiTransformInterpolator::Transform' has a wrong offset!");
static_assert(offsetof(UNiTransformInterpolator, Data) == 0x000040, "Member 'UNiTransformInterpolator::Data' has a wrong offset!");

// Class Altar.NavigationUISubsystem
// 0x00F8 (0x0128 - 0x0030)
class UNavigationUISubsystem final : public ULocalPlayerSubsystem
{
public:
	TMulticastInlineDelegate<void(const ECommonInputType InputType)> OnInputTypeUpdated;             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector2D& ThumbstickValue)> OnLeftThumbstickMoved;   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector2D& ThumbstickValue)> OnRightThumbstickMoved;  // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool ShoulderValue)> OnLeftShoulderPressed;                        // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool ShoulderValue)> OnRightShoulderPressed;                       // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UDataTable*                             MappingTable;                                      // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x40];                                      // 0x0088(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMenuNavigationElements                NavigationElements;                                // 0x00C8(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x4];                                       // 0x00F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RightThumbStickAxisValue_X;                        // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RightThumbStickAxisValue_Y;                        // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeftThumbStickAxisValue_X;                         // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeftThumbStickAxisValue_Y;                         // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x24];                                     // 0x0104(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NavigateTo(TScriptInterface<class INavigationUIElement> DestinationElement);
	void StartNavigation(TScriptInterface<class INavigationUIElement> DefaultNavigationElement, bool ImmediatelyFocus, class UVAltarMenu* Menu);
	void StopNavigation();

	ECommonInputType GetCurrentInputType() const;
	class UWidget* GetCurrentNavigationWidget() const;
	ENavigationInputAction GetLastNavigationAction() const;
	float GetLefthumbstickAxisValue_Y() const;
	float GetLeftThumbstickAxisValue_X() const;
	float GetRightThumbstickAxisValue_X() const;
	float GetRightThumbstickAxisValue_Y() const;
	bool IsGamepadActive() const;
	bool IsShiftKeyDown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationUISubsystem">();
	}
	static class UNavigationUISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationUISubsystem>();
	}
};
static_assert(alignof(UNavigationUISubsystem) == 0x000008, "Wrong alignment on UNavigationUISubsystem");
static_assert(sizeof(UNavigationUISubsystem) == 0x000128, "Wrong size on UNavigationUISubsystem");
static_assert(offsetof(UNavigationUISubsystem, OnInputTypeUpdated) == 0x000030, "Member 'UNavigationUISubsystem::OnInputTypeUpdated' has a wrong offset!");
static_assert(offsetof(UNavigationUISubsystem, OnLeftThumbstickMoved) == 0x000040, "Member 'UNavigationUISubsystem::OnLeftThumbstickMoved' has a wrong offset!");
static_assert(offsetof(UNavigationUISubsystem, OnRightThumbstickMoved) == 0x000050, "Member 'UNavigationUISubsystem::OnRightThumbstickMoved' has a wrong offset!");
static_assert(offsetof(UNavigationUISubsystem, OnLeftShoulderPressed) == 0x000060, "Member 'UNavigationUISubsystem::OnLeftShoulderPressed' has a wrong offset!");
static_assert(offsetof(UNavigationUISubsystem, OnRightShoulderPressed) == 0x000070, "Member 'UNavigationUISubsystem::OnRightShoulderPressed' has a wrong offset!");
static_assert(offsetof(UNavigationUISubsystem, MappingTable) == 0x000080, "Member 'UNavigationUISubsystem::MappingTable' has a wrong offset!");
static_assert(offsetof(UNavigationUISubsystem, NavigationElements) == 0x0000C8, "Member 'UNavigationUISubsystem::NavigationElements' has a wrong offset!");
static_assert(offsetof(UNavigationUISubsystem, RightThumbStickAxisValue_X) == 0x0000F4, "Member 'UNavigationUISubsystem::RightThumbStickAxisValue_X' has a wrong offset!");
static_assert(offsetof(UNavigationUISubsystem, RightThumbStickAxisValue_Y) == 0x0000F8, "Member 'UNavigationUISubsystem::RightThumbStickAxisValue_Y' has a wrong offset!");
static_assert(offsetof(UNavigationUISubsystem, LeftThumbStickAxisValue_X) == 0x0000FC, "Member 'UNavigationUISubsystem::LeftThumbStickAxisValue_X' has a wrong offset!");
static_assert(offsetof(UNavigationUISubsystem, LeftThumbStickAxisValue_Y) == 0x000100, "Member 'UNavigationUISubsystem::LeftThumbStickAxisValue_Y' has a wrong offset!");

// Class Altar.NavMeshLandmarkMetaClustersSubsystem
// 0x0020 (0x0050 - 0x0030)
class UNavMeshLandmarkMetaClustersSubsystem final : public UWorldSubsystem
{
public:
	TArray<struct FNavMeshLandmarkType>           NavMeshLandmarkTypes;                              // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FNavigationDataLandmarkMetaClusters> NavigationDataLandmarkMetaClustersCollection; // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnLandmarkActorEndPlay(const class AActor* Actor, const EEndPlayReason EndPlayReason);
	void OnNavDataRegistered(const class ANavigationData* NavData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavMeshLandmarkMetaClustersSubsystem">();
	}
	static class UNavMeshLandmarkMetaClustersSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavMeshLandmarkMetaClustersSubsystem>();
	}
};
static_assert(alignof(UNavMeshLandmarkMetaClustersSubsystem) == 0x000008, "Wrong alignment on UNavMeshLandmarkMetaClustersSubsystem");
static_assert(sizeof(UNavMeshLandmarkMetaClustersSubsystem) == 0x000050, "Wrong size on UNavMeshLandmarkMetaClustersSubsystem");
static_assert(offsetof(UNavMeshLandmarkMetaClustersSubsystem, NavMeshLandmarkTypes) == 0x000030, "Member 'UNavMeshLandmarkMetaClustersSubsystem::NavMeshLandmarkTypes' has a wrong offset!");
static_assert(offsetof(UNavMeshLandmarkMetaClustersSubsystem, NavigationDataLandmarkMetaClustersCollection) == 0x000040, "Member 'UNavMeshLandmarkMetaClustersSubsystem::NavigationDataLandmarkMetaClustersCollection' has a wrong offset!");

// Class Altar.NiTextKeyExtraData
// 0x0018 (0x0060 - 0x0048)
class UNiTextKeyExtraData final : public UNiExtraData
{
public:
	int64                                         NumTextKeys;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTextKey*>                       TextKeys;                                          // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTextKeyExtraData">();
	}
	static class UNiTextKeyExtraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTextKeyExtraData>();
	}
};
static_assert(alignof(UNiTextKeyExtraData) == 0x000008, "Wrong alignment on UNiTextKeyExtraData");
static_assert(sizeof(UNiTextKeyExtraData) == 0x000060, "Wrong size on UNiTextKeyExtraData");
static_assert(offsetof(UNiTextKeyExtraData, NumTextKeys) == 0x000048, "Member 'UNiTextKeyExtraData::NumTextKeys' has a wrong offset!");
static_assert(offsetof(UNiTextKeyExtraData, TextKeys) == 0x000050, "Member 'UNiTextKeyExtraData::TextKeys' has a wrong offset!");

// Class Altar.NiAdditionalGeometryData
// 0x0038 (0x0070 - 0x0038)
class UNiAdditionalGeometryData final : public UAbstractAdditionalGeometryData
{
public:
	int32                                         NumVertices;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NumBlockInfos;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiAGDDataStream*>               BlockInfos;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumBlocks;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiAGDDataStream*>               Blocks;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiAdditionalGeometryData">();
	}
	static class UNiAdditionalGeometryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiAdditionalGeometryData>();
	}
};
static_assert(alignof(UNiAdditionalGeometryData) == 0x000008, "Wrong alignment on UNiAdditionalGeometryData");
static_assert(sizeof(UNiAdditionalGeometryData) == 0x000070, "Wrong size on UNiAdditionalGeometryData");
static_assert(offsetof(UNiAdditionalGeometryData, NumVertices) == 0x000038, "Member 'UNiAdditionalGeometryData::NumVertices' has a wrong offset!");
static_assert(offsetof(UNiAdditionalGeometryData, NumBlockInfos) == 0x000040, "Member 'UNiAdditionalGeometryData::NumBlockInfos' has a wrong offset!");
static_assert(offsetof(UNiAdditionalGeometryData, BlockInfos) == 0x000048, "Member 'UNiAdditionalGeometryData::BlockInfos' has a wrong offset!");
static_assert(offsetof(UNiAdditionalGeometryData, NumBlocks) == 0x000058, "Member 'UNiAdditionalGeometryData::NumBlocks' has a wrong offset!");
static_assert(offsetof(UNiAdditionalGeometryData, Blocks) == 0x000060, "Member 'UNiAdditionalGeometryData::Blocks' has a wrong offset!");

// Class Altar.NiAGDDataStream
// 0x0038 (0x0068 - 0x0030)
class UNiAGDDataStream final : public UNifType
{
public:
	int64                                         Type;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         UnitSize;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TotalSize;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Stride;                                            // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BlockIndex;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BlockOffset;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNiAGDDataStreamFlags                  Flags_0;                                           // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiAGDDataStream">();
	}
	static class UNiAGDDataStream* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiAGDDataStream>();
	}
};
static_assert(alignof(UNiAGDDataStream) == 0x000008, "Wrong alignment on UNiAGDDataStream");
static_assert(sizeof(UNiAGDDataStream) == 0x000068, "Wrong size on UNiAGDDataStream");
static_assert(offsetof(UNiAGDDataStream, Type) == 0x000030, "Member 'UNiAGDDataStream::Type' has a wrong offset!");
static_assert(offsetof(UNiAGDDataStream, UnitSize) == 0x000038, "Member 'UNiAGDDataStream::UnitSize' has a wrong offset!");
static_assert(offsetof(UNiAGDDataStream, TotalSize) == 0x000040, "Member 'UNiAGDDataStream::TotalSize' has a wrong offset!");
static_assert(offsetof(UNiAGDDataStream, Stride) == 0x000048, "Member 'UNiAGDDataStream::Stride' has a wrong offset!");
static_assert(offsetof(UNiAGDDataStream, BlockIndex) == 0x000050, "Member 'UNiAGDDataStream::BlockIndex' has a wrong offset!");
static_assert(offsetof(UNiAGDDataStream, BlockOffset) == 0x000058, "Member 'UNiAGDDataStream::BlockOffset' has a wrong offset!");
static_assert(offsetof(UNiAGDDataStream, Flags_0) == 0x000060, "Member 'UNiAGDDataStream::Flags_0' has a wrong offset!");

// Class Altar.VLegacyStatsMenu
// 0x0000 (0x04F0 - 0x04F0)
class UVLegacyStatsMenu : public UVLegacyPlayerSubMenuBase
{
public:
	void MoveToNextPage(const bool Right);

	class UVLegacyStatsMenuPage1* GetPage1() const;
	class UVLegacyStatsMenuPage2* GetPage2() const;
	class UVLegacyStatsMenuPage3* GetPage3() const;
	class UVLegacyStatsMenuPage4* GetPage4() const;
	class UVLegacyStatsMenuPage5* GetPage5() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyStatsMenu">();
	}
	static class UVLegacyStatsMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyStatsMenu>();
	}
};
static_assert(alignof(UVLegacyStatsMenu) == 0x000008, "Wrong alignment on UVLegacyStatsMenu");
static_assert(sizeof(UVLegacyStatsMenu) == 0x0004F0, "Wrong size on UVLegacyStatsMenu");

// Class Altar.NiTriShapeData
// 0x0038 (0x0110 - 0x00D8)
class UNiTriShapeData final : public UNiTriBasedGeomData
{
public:
	int64                                         NumTrianglePoints;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasTriangles;                                      // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Triangles;                                         // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         NumMatchGroups;                                    // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiMatchGroup*>                  MatchGroups;                                       // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTriShapeData">();
	}
	static class UNiTriShapeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTriShapeData>();
	}
};
static_assert(alignof(UNiTriShapeData) == 0x000008, "Wrong alignment on UNiTriShapeData");
static_assert(sizeof(UNiTriShapeData) == 0x000110, "Wrong size on UNiTriShapeData");
static_assert(offsetof(UNiTriShapeData, NumTrianglePoints) == 0x0000D8, "Member 'UNiTriShapeData::NumTrianglePoints' has a wrong offset!");
static_assert(offsetof(UNiTriShapeData, HasTriangles) == 0x0000E0, "Member 'UNiTriShapeData::HasTriangles' has a wrong offset!");
static_assert(offsetof(UNiTriShapeData, Triangles) == 0x0000E8, "Member 'UNiTriShapeData::Triangles' has a wrong offset!");
static_assert(offsetof(UNiTriShapeData, NumMatchGroups) == 0x0000F8, "Member 'UNiTriShapeData::NumMatchGroups' has a wrong offset!");
static_assert(offsetof(UNiTriShapeData, MatchGroups) == 0x000100, "Member 'UNiTriShapeData::MatchGroups' has a wrong offset!");

// Class Altar.NiAlphaController
// 0x0008 (0x0080 - 0x0078)
class UNiAlphaController final : public UNiFloatInterpController
{
public:
	class UNiFloatData*                           Data;                                              // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiAlphaController">();
	}
	static class UNiAlphaController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiAlphaController>();
	}
};
static_assert(alignof(UNiAlphaController) == 0x000008, "Wrong alignment on UNiAlphaController");
static_assert(sizeof(UNiAlphaController) == 0x000080, "Wrong size on UNiAlphaController");
static_assert(offsetof(UNiAlphaController, Data) == 0x000078, "Member 'UNiAlphaController::Data' has a wrong offset!");

// Class Altar.PixelFormatComponent
// 0x0010 (0x0040 - 0x0030)
class UPixelFormatComponent final : public UNifType
{
public:
	EPixelComponent                               Type;                                              // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPixelRepresentation                          Convention;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BitsPerChannel;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSigned;                                          // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PixelFormatComponent">();
	}
	static class UPixelFormatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPixelFormatComponent>();
	}
};
static_assert(alignof(UPixelFormatComponent) == 0x000008, "Wrong alignment on UPixelFormatComponent");
static_assert(sizeof(UPixelFormatComponent) == 0x000040, "Wrong size on UPixelFormatComponent");
static_assert(offsetof(UPixelFormatComponent, Type) == 0x000030, "Member 'UPixelFormatComponent::Type' has a wrong offset!");
static_assert(offsetof(UPixelFormatComponent, Convention) == 0x000034, "Member 'UPixelFormatComponent::Convention' has a wrong offset!");
static_assert(offsetof(UPixelFormatComponent, BitsPerChannel) == 0x000038, "Member 'UPixelFormatComponent::BitsPerChannel' has a wrong offset!");
static_assert(offsetof(UPixelFormatComponent, IsSigned) == 0x000039, "Member 'UPixelFormatComponent::IsSigned' has a wrong offset!");

// Class Altar.NiAlphaProperty
// 0x0010 (0x0078 - 0x0068)
class UNiAlphaProperty final : public UNiProperty
{
public:
	struct FAlphaFlags                            Flags_0;                                           // 0x0068(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Threshold;                                         // 0x006A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0xD];                                       // 0x006B(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiAlphaProperty">();
	}
	static class UNiAlphaProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiAlphaProperty>();
	}
};
static_assert(alignof(UNiAlphaProperty) == 0x000008, "Wrong alignment on UNiAlphaProperty");
static_assert(sizeof(UNiAlphaProperty) == 0x000078, "Wrong size on UNiAlphaProperty");
static_assert(offsetof(UNiAlphaProperty, Flags_0) == 0x000068, "Member 'UNiAlphaProperty::Flags_0' has a wrong offset!");
static_assert(offsetof(UNiAlphaProperty, Threshold) == 0x00006A, "Member 'UNiAlphaProperty::Threshold' has a wrong offset!");

// Class Altar.VLegacyStatsMenuPage3
// 0x0020 (0x04E8 - 0x04C8)
class UVLegacyStatsMenuPage3 : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(const int32 SkillIndex)> OnItemHovered;                            // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnNoItemsHovered;                                  // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyStatsMenuPage3">();
	}
	static class UVLegacyStatsMenuPage3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyStatsMenuPage3>();
	}
};
static_assert(alignof(UVLegacyStatsMenuPage3) == 0x000008, "Wrong alignment on UVLegacyStatsMenuPage3");
static_assert(sizeof(UVLegacyStatsMenuPage3) == 0x0004E8, "Wrong size on UVLegacyStatsMenuPage3");
static_assert(offsetof(UVLegacyStatsMenuPage3, OnItemHovered) == 0x0004C8, "Member 'UVLegacyStatsMenuPage3::OnItemHovered' has a wrong offset!");
static_assert(offsetof(UVLegacyStatsMenuPage3, OnNoItemsHovered) == 0x0004D8, "Member 'UVLegacyStatsMenuPage3::OnNoItemsHovered' has a wrong offset!");

// Class Altar.NiBoolInterpController
// 0x0000 (0x0078 - 0x0078)
class UNiBoolInterpController : public UNiSingleInterpController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBoolInterpController">();
	}
	static class UNiBoolInterpController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBoolInterpController>();
	}
};
static_assert(alignof(UNiBoolInterpController) == 0x000008, "Wrong alignment on UNiBoolInterpController");
static_assert(sizeof(UNiBoolInterpController) == 0x000078, "Wrong size on UNiBoolInterpController");

// Class Altar.NiVisController
// 0x0008 (0x0080 - 0x0078)
class UNiVisController final : public UNiBoolInterpController
{
public:
	class UNiVisData*                             Data;                                              // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiVisController">();
	}
	static class UNiVisController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiVisController>();
	}
};
static_assert(alignof(UNiVisController) == 0x000008, "Wrong alignment on UNiVisController");
static_assert(sizeof(UNiVisController) == 0x000080, "Wrong size on UNiVisController");
static_assert(offsetof(UNiVisController, Data) == 0x000078, "Member 'UNiVisController::Data' has a wrong offset!");

// Class Altar.NiAmbientLight
// 0x0000 (0x00F0 - 0x00F0)
class UNiAmbientLight final : public UNiLight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiAmbientLight">();
	}
	static class UNiAmbientLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiAmbientLight>();
	}
};
static_assert(alignof(UNiAmbientLight) == 0x000008, "Wrong alignment on UNiAmbientLight");
static_assert(sizeof(UNiAmbientLight) == 0x0000F0, "Wrong size on UNiAmbientLight");

// Class Altar.VInventoryMenuViewModel
// 0x0068 (0x0138 - 0x00D0)
class UVInventoryMenuViewModel : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnInteractWithItem;                                // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FLegacyInventoryMenuExtraData          ExtraData;                                         // 0x00E0(0x0028)(Protected, NativeAccessSpecifierProtected)
	EOriginalInventoryMenuSortType                SortTypeInventory;                                 // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSortReversedInventory;                          // 0x0109(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A[0x6];                                      // 0x010A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOriginalInventoryMenuItemProperties> CurrentPageItemsInventory;                   // 0x0110(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOriginalInventoryMenuItemProperties> Items;                                       // 0x0120(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	ELegacyInventoryMenuPage                      CurrentPageInventory;                              // 0x0130(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsListViewHovered;                                // 0x0131(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockBackAction;                                  // 0x0132(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_133[0x5];                                      // 0x0133(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendClickOnItemHandler(int32 ItemIndex);
	void RegisterSendDropAllItemHandler(int32 ItemIndex, int32 Count);
	void RegisterSendDropAndHoldItemHandler(int32 ItemIndex);
	void RegisterSendDropItemHandler(int32 ItemIndex);
	void RegisterSendItemHoverHandler(int32 ItemIndex);
	void ReplaceCurrentPageItemsInventory(const TArray<struct FOriginalInventoryMenuItemProperties>& NewPageInventory);
	void SetBlockBackAction(bool bNewBlockBackAction);
	void SetCurrentPageInventory(ELegacyInventoryMenuPage NewPage);
	void SetExtraData(const struct FLegacyInventoryMenuExtraData& NewExtraData);
	void SetInventory(const TArray<struct FOriginalInventoryMenuItemProperties>& InventoryItems);
	void SetIsListViewHovered(bool bNewIsListViewHovered);
	void SetIsSortReversedInventory(bool bNewIsSortReversedInventory);
	void SetSortTypeInventory(const EOriginalInventoryMenuSortType& NewSortTypeInventory);

	bool GetBlockBackAction() const;
	ELegacyInventoryMenuPage GetCurrentPageInventory() const;
	const TArray<struct FOriginalInventoryMenuItemProperties> GetCurrentPageItemsInventory() const;
	const struct FLegacyInventoryMenuExtraData GetExtraData() const;
	const TArray<struct FOriginalInventoryMenuItemProperties> GetInventory() const;
	bool GetIsListViewHovered() const;
	bool GetIsSortReversedInventory() const;
	EOriginalInventoryMenuSortType GetSortTypeInventory() const;
	bool ThisIsForPluginCompliance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VInventoryMenuViewModel">();
	}
	static class UVInventoryMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVInventoryMenuViewModel>();
	}
};
static_assert(alignof(UVInventoryMenuViewModel) == 0x000008, "Wrong alignment on UVInventoryMenuViewModel");
static_assert(sizeof(UVInventoryMenuViewModel) == 0x000138, "Wrong size on UVInventoryMenuViewModel");
static_assert(offsetof(UVInventoryMenuViewModel, OnInteractWithItem) == 0x0000D0, "Member 'UVInventoryMenuViewModel::OnInteractWithItem' has a wrong offset!");
static_assert(offsetof(UVInventoryMenuViewModel, ExtraData) == 0x0000E0, "Member 'UVInventoryMenuViewModel::ExtraData' has a wrong offset!");
static_assert(offsetof(UVInventoryMenuViewModel, SortTypeInventory) == 0x000108, "Member 'UVInventoryMenuViewModel::SortTypeInventory' has a wrong offset!");
static_assert(offsetof(UVInventoryMenuViewModel, bIsSortReversedInventory) == 0x000109, "Member 'UVInventoryMenuViewModel::bIsSortReversedInventory' has a wrong offset!");
static_assert(offsetof(UVInventoryMenuViewModel, CurrentPageItemsInventory) == 0x000110, "Member 'UVInventoryMenuViewModel::CurrentPageItemsInventory' has a wrong offset!");
static_assert(offsetof(UVInventoryMenuViewModel, Items) == 0x000120, "Member 'UVInventoryMenuViewModel::Items' has a wrong offset!");
static_assert(offsetof(UVInventoryMenuViewModel, CurrentPageInventory) == 0x000130, "Member 'UVInventoryMenuViewModel::CurrentPageInventory' has a wrong offset!");
static_assert(offsetof(UVInventoryMenuViewModel, bIsListViewHovered) == 0x000131, "Member 'UVInventoryMenuViewModel::bIsListViewHovered' has a wrong offset!");
static_assert(offsetof(UVInventoryMenuViewModel, bBlockBackAction) == 0x000132, "Member 'UVInventoryMenuViewModel::bBlockBackAction' has a wrong offset!");

// Class Altar.NiBinaryExtraData
// 0x0018 (0x0060 - 0x0048)
class UNiBinaryExtraData final : public UNiExtraData
{
public:
	struct FByteArray                             BinaryData;                                        // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBinaryExtraData">();
	}
	static class UNiBinaryExtraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBinaryExtraData>();
	}
};
static_assert(alignof(UNiBinaryExtraData) == 0x000008, "Wrong alignment on UNiBinaryExtraData");
static_assert(sizeof(UNiBinaryExtraData) == 0x000060, "Wrong size on UNiBinaryExtraData");
static_assert(offsetof(UNiBinaryExtraData, BinaryData) == 0x000048, "Member 'UNiBinaryExtraData::BinaryData' has a wrong offset!");

// Class Altar.VDeathCharacterAnimInstance
// 0x0010 (0x03B0 - 0x03A0)
class UVDeathCharacterAnimInstance final : public UVLayerCharacterAnimInstance
{
public:
	struct FDeathAnimationData                    AnimSet;                                           // 0x03A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDeathCharacterAnimInstance">();
	}
	static class UVDeathCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDeathCharacterAnimInstance>();
	}
};
static_assert(alignof(UVDeathCharacterAnimInstance) == 0x000010, "Wrong alignment on UVDeathCharacterAnimInstance");
static_assert(sizeof(UVDeathCharacterAnimInstance) == 0x0003B0, "Wrong size on UVDeathCharacterAnimInstance");
static_assert(offsetof(UVDeathCharacterAnimInstance, AnimSet) == 0x0003A0, "Member 'UVDeathCharacterAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.NiBlendFloatInterpolator
// 0x0008 (0x0098 - 0x0090)
class UNiBlendFloatInterpolator final : public UNiBlendInterpolator
{
public:
	float                                         Value;                                             // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBlendFloatInterpolator">();
	}
	static class UNiBlendFloatInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBlendFloatInterpolator>();
	}
};
static_assert(alignof(UNiBlendFloatInterpolator) == 0x000008, "Wrong alignment on UNiBlendFloatInterpolator");
static_assert(sizeof(UNiBlendFloatInterpolator) == 0x000098, "Wrong size on UNiBlendFloatInterpolator");
static_assert(offsetof(UNiBlendFloatInterpolator, Value) == 0x000090, "Member 'UNiBlendFloatInterpolator::Value' has a wrong offset!");

// Class Altar.NiBlendTransformInterpolator
// 0x0008 (0x0098 - 0x0090)
class UNiBlendTransformInterpolator final : public UNiBlendInterpolator
{
public:
	class UNiQuatTransform*                       Value;                                             // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBlendTransformInterpolator">();
	}
	static class UNiBlendTransformInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBlendTransformInterpolator>();
	}
};
static_assert(alignof(UNiBlendTransformInterpolator) == 0x000008, "Wrong alignment on UNiBlendTransformInterpolator");
static_assert(sizeof(UNiBlendTransformInterpolator) == 0x000098, "Wrong size on UNiBlendTransformInterpolator");
static_assert(offsetof(UNiBlendTransformInterpolator, Value) == 0x000090, "Member 'UNiBlendTransformInterpolator::Value' has a wrong offset!");

// Class Altar.VDetectionLightingFakePointLightComponent
// 0x0000 (0x0430 - 0x0430)
class UVDetectionLightingFakePointLightComponent final : public UPointLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDetectionLightingFakePointLightComponent">();
	}
	static class UVDetectionLightingFakePointLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDetectionLightingFakePointLightComponent>();
	}
};
static_assert(alignof(UVDetectionLightingFakePointLightComponent) == 0x000010, "Wrong alignment on UVDetectionLightingFakePointLightComponent");
static_assert(sizeof(UVDetectionLightingFakePointLightComponent) == 0x000430, "Wrong size on UVDetectionLightingFakePointLightComponent");

// Class Altar.NiBoolData
// 0x0018 (0x0050 - 0x0038)
class UNiBoolData final : public UNiObject
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBoolData">();
	}
	static class UNiBoolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBoolData>();
	}
};
static_assert(alignof(UNiBoolData) == 0x000008, "Wrong alignment on UNiBoolData");
static_assert(sizeof(UNiBoolData) == 0x000050, "Wrong size on UNiBoolData");

// Class Altar.VDetectionLightingSettings
// 0x0070 (0x0098 - 0x0028)
class UVDetectionLightingSettings final : public UObject
{
public:
	bool                                          bIgnoreDetectionLightingUpdatesInMainMenu;         // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVDetectionLightingProfile> DefaultLightProfile;                            // 0x0030(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InverseSquaredFalloffLerpAlphaExponent;            // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPawnDetectionLightingUpdateFrequency;       // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPlayerDetectionLightingUpdateFrequency;     // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyLuminanceMultiplier;                            // 0x0064(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumEnvironmentLuminance;                       // 0x0068(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightsLuminanceSumBiasFactor;                      // 0x006C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightsLuminanceSumBiasExponent;                    // 0x0070(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotlightsConeAngleFalloffExponent;                // 0x0074(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSynchronousFallbackObstructionLineTraces;    // 0x0078(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObstructionUpdatesPerSecond;                       // 0x007C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightObstructionHistorySize;                       // 0x0080(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RunningAsyncLineTracesTarget;                      // 0x0084(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AsyncLineTraceDebugDrawDuration;                   // 0x0088(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVDetectionLightingObstructionTracesType      ObstructionTracesType;                             // 0x008C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ObstructionTracesPerLight;                         // 0x0090(0x0004)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetNumberOfLineTracesForTraceType(const EVDetectionLightingObstructionTracesType TraceType);

	int32 GetNumberOfLineTracesForCurrentTraceType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDetectionLightingSettings">();
	}
	static class UVDetectionLightingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDetectionLightingSettings>();
	}
};
static_assert(alignof(UVDetectionLightingSettings) == 0x000008, "Wrong alignment on UVDetectionLightingSettings");
static_assert(sizeof(UVDetectionLightingSettings) == 0x000098, "Wrong size on UVDetectionLightingSettings");
static_assert(offsetof(UVDetectionLightingSettings, bIgnoreDetectionLightingUpdatesInMainMenu) == 0x000028, "Member 'UVDetectionLightingSettings::bIgnoreDetectionLightingUpdatesInMainMenu' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, DefaultLightProfile) == 0x000030, "Member 'UVDetectionLightingSettings::DefaultLightProfile' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, InverseSquaredFalloffLerpAlphaExponent) == 0x000058, "Member 'UVDetectionLightingSettings::InverseSquaredFalloffLerpAlphaExponent' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, DefaultPawnDetectionLightingUpdateFrequency) == 0x00005C, "Member 'UVDetectionLightingSettings::DefaultPawnDetectionLightingUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, DefaultPlayerDetectionLightingUpdateFrequency) == 0x000060, "Member 'UVDetectionLightingSettings::DefaultPlayerDetectionLightingUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, SkyLuminanceMultiplier) == 0x000064, "Member 'UVDetectionLightingSettings::SkyLuminanceMultiplier' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, MaximumEnvironmentLuminance) == 0x000068, "Member 'UVDetectionLightingSettings::MaximumEnvironmentLuminance' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, LightsLuminanceSumBiasFactor) == 0x00006C, "Member 'UVDetectionLightingSettings::LightsLuminanceSumBiasFactor' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, LightsLuminanceSumBiasExponent) == 0x000070, "Member 'UVDetectionLightingSettings::LightsLuminanceSumBiasExponent' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, SpotlightsConeAngleFalloffExponent) == 0x000074, "Member 'UVDetectionLightingSettings::SpotlightsConeAngleFalloffExponent' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, bAllowSynchronousFallbackObstructionLineTraces) == 0x000078, "Member 'UVDetectionLightingSettings::bAllowSynchronousFallbackObstructionLineTraces' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, ObstructionUpdatesPerSecond) == 0x00007C, "Member 'UVDetectionLightingSettings::ObstructionUpdatesPerSecond' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, LightObstructionHistorySize) == 0x000080, "Member 'UVDetectionLightingSettings::LightObstructionHistorySize' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, RunningAsyncLineTracesTarget) == 0x000084, "Member 'UVDetectionLightingSettings::RunningAsyncLineTracesTarget' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, AsyncLineTraceDebugDrawDuration) == 0x000088, "Member 'UVDetectionLightingSettings::AsyncLineTraceDebugDrawDuration' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, ObstructionTracesType) == 0x00008C, "Member 'UVDetectionLightingSettings::ObstructionTracesType' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSettings, ObstructionTracesPerLight) == 0x000090, "Member 'UVDetectionLightingSettings::ObstructionTracesPerLight' has a wrong offset!");

// Class Altar.VBaseStaffAttackAnimInstance
// 0x0010 (0x03B0 - 0x03A0)
class UVBaseStaffAttackAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	struct FGameplayTag                           AttackTag;                                         // 0x03A0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AttackAnim;                                        // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAttackEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBaseStaffAttackAnimInstance">();
	}
	static class UVBaseStaffAttackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBaseStaffAttackAnimInstance>();
	}
};
static_assert(alignof(UVBaseStaffAttackAnimInstance) == 0x000010, "Wrong alignment on UVBaseStaffAttackAnimInstance");
static_assert(sizeof(UVBaseStaffAttackAnimInstance) == 0x0003B0, "Wrong size on UVBaseStaffAttackAnimInstance");
static_assert(offsetof(UVBaseStaffAttackAnimInstance, AttackTag) == 0x0003A0, "Member 'UVBaseStaffAttackAnimInstance::AttackTag' has a wrong offset!");
static_assert(offsetof(UVBaseStaffAttackAnimInstance, AttackAnim) == 0x0003A8, "Member 'UVBaseStaffAttackAnimInstance::AttackAnim' has a wrong offset!");

// Class Altar.VStandSneakStaffAttackAnimInstance
// 0x0010 (0x03C0 - 0x03B0)
class UVStandSneakStaffAttackAnimInstance : public UVBaseStaffAttackAnimInstance
{
public:
	struct FStandSneakStaffAttackData             AnimSet;                                           // 0x03B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStandSneakStaffAttackAnimInstance">();
	}
	static class UVStandSneakStaffAttackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStandSneakStaffAttackAnimInstance>();
	}
};
static_assert(alignof(UVStandSneakStaffAttackAnimInstance) == 0x000010, "Wrong alignment on UVStandSneakStaffAttackAnimInstance");
static_assert(sizeof(UVStandSneakStaffAttackAnimInstance) == 0x0003C0, "Wrong size on UVStandSneakStaffAttackAnimInstance");
static_assert(offsetof(UVStandSneakStaffAttackAnimInstance, AnimSet) == 0x0003B0, "Member 'UVStandSneakStaffAttackAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VSpecialIdleAndDockCharacterAnimInstance
// 0x00A0 (0x0440 - 0x03A0)
class UVSpecialIdleAndDockCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	struct FVSpecialIdleAndDockData               LayerData;                                         // 0x03A0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   SpecialIdleSlotName;                               // 0x03E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDocked;                                         // 0x03E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasSpecialIdleWhileDocked;                        // 0x03E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLayerActive;                                    // 0x03EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHoldingTorch;                                   // 0x03EB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      DockedAnim;                                        // 0x03F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CurrentSpecialIdleMontage;                         // 0x03F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x40];                                     // 0x0400(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSpecialIdleAndDockCharacterAnimInstance">();
	}
	static class UVSpecialIdleAndDockCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSpecialIdleAndDockCharacterAnimInstance>();
	}
};
static_assert(alignof(UVSpecialIdleAndDockCharacterAnimInstance) == 0x000010, "Wrong alignment on UVSpecialIdleAndDockCharacterAnimInstance");
static_assert(sizeof(UVSpecialIdleAndDockCharacterAnimInstance) == 0x000440, "Wrong size on UVSpecialIdleAndDockCharacterAnimInstance");
static_assert(offsetof(UVSpecialIdleAndDockCharacterAnimInstance, LayerData) == 0x0003A0, "Member 'UVSpecialIdleAndDockCharacterAnimInstance::LayerData' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleAndDockCharacterAnimInstance, SpecialIdleSlotName) == 0x0003E0, "Member 'UVSpecialIdleAndDockCharacterAnimInstance::SpecialIdleSlotName' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleAndDockCharacterAnimInstance, bIsDocked) == 0x0003E8, "Member 'UVSpecialIdleAndDockCharacterAnimInstance::bIsDocked' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleAndDockCharacterAnimInstance, bHasSpecialIdleWhileDocked) == 0x0003E9, "Member 'UVSpecialIdleAndDockCharacterAnimInstance::bHasSpecialIdleWhileDocked' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleAndDockCharacterAnimInstance, bIsLayerActive) == 0x0003EA, "Member 'UVSpecialIdleAndDockCharacterAnimInstance::bIsLayerActive' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleAndDockCharacterAnimInstance, bIsHoldingTorch) == 0x0003EB, "Member 'UVSpecialIdleAndDockCharacterAnimInstance::bIsHoldingTorch' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleAndDockCharacterAnimInstance, DockedAnim) == 0x0003F0, "Member 'UVSpecialIdleAndDockCharacterAnimInstance::DockedAnim' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleAndDockCharacterAnimInstance, CurrentSpecialIdleMontage) == 0x0003F8, "Member 'UVSpecialIdleAndDockCharacterAnimInstance::CurrentSpecialIdleMontage' has a wrong offset!");

// Class Altar.VStaggerCharacterAnimInstance
// 0x0010 (0x03B0 - 0x03A0)
class UVStaggerCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	bool                                          bPlayStaggerMontage;                               // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           StaggerMontage;                                    // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStaggerCharacterAnimInstance">();
	}
	static class UVStaggerCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStaggerCharacterAnimInstance>();
	}
};
static_assert(alignof(UVStaggerCharacterAnimInstance) == 0x000010, "Wrong alignment on UVStaggerCharacterAnimInstance");
static_assert(sizeof(UVStaggerCharacterAnimInstance) == 0x0003B0, "Wrong size on UVStaggerCharacterAnimInstance");
static_assert(offsetof(UVStaggerCharacterAnimInstance, bPlayStaggerMontage) == 0x0003A0, "Member 'UVStaggerCharacterAnimInstance::bPlayStaggerMontage' has a wrong offset!");
static_assert(offsetof(UVStaggerCharacterAnimInstance, StaggerMontage) == 0x0003A8, "Member 'UVStaggerCharacterAnimInstance::StaggerMontage' has a wrong offset!");

// Class Altar.NiBSBoneLODController
// 0x0000 (0x0090 - 0x0090)
class UNiBSBoneLODController final : public UNiBoneLODController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBSBoneLODController">();
	}
	static class UNiBSBoneLODController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBSBoneLODController>();
	}
};
static_assert(alignof(UNiBSBoneLODController) == 0x000008, "Wrong alignment on UNiBSBoneLODController");
static_assert(sizeof(UNiBSBoneLODController) == 0x000090, "Wrong size on UNiBSBoneLODController");

// Class Altar.NiBSplineCompFloatInterpolator
// 0x0008 (0x0068 - 0x0060)
class UNiBSplineCompFloatInterpolator final : public UNiBSplineFloatInterpolator
{
public:
	float                                         Offset;                                            // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfRange;                                         // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBSplineCompFloatInterpolator">();
	}
	static class UNiBSplineCompFloatInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBSplineCompFloatInterpolator>();
	}
};
static_assert(alignof(UNiBSplineCompFloatInterpolator) == 0x000008, "Wrong alignment on UNiBSplineCompFloatInterpolator");
static_assert(sizeof(UNiBSplineCompFloatInterpolator) == 0x000068, "Wrong size on UNiBSplineCompFloatInterpolator");
static_assert(offsetof(UNiBSplineCompFloatInterpolator, Offset) == 0x000060, "Member 'UNiBSplineCompFloatInterpolator::Offset' has a wrong offset!");
static_assert(offsetof(UNiBSplineCompFloatInterpolator, HalfRange) == 0x000064, "Member 'UNiBSplineCompFloatInterpolator::HalfRange' has a wrong offset!");

// Class Altar.VDoorNavLinkCustomComponent
// 0x0000 (0x01E0 - 0x01E0)
class UVDoorNavLinkCustomComponent : public UNavLinkCustomComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDoorNavLinkCustomComponent">();
	}
	static class UVDoorNavLinkCustomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDoorNavLinkCustomComponent>();
	}
};
static_assert(alignof(UVDoorNavLinkCustomComponent) == 0x000008, "Wrong alignment on UVDoorNavLinkCustomComponent");
static_assert(sizeof(UVDoorNavLinkCustomComponent) == 0x0001E0, "Wrong size on UVDoorNavLinkCustomComponent");

// Class Altar.NiBSplineCompTransformInterpolator
// 0x0018 (0x0088 - 0x0070)
class UNiBSplineCompTransformInterpolator final : public UNiBSplineTransformInterpolator
{
public:
	float                                         TranslationOffset;                                 // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslationHalfRange;                              // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationOffset;                                    // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationHalfRange;                                 // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleOffset;                                       // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleHalfRange;                                    // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiBSplineCompTransformInterpolator">();
	}
	static class UNiBSplineCompTransformInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiBSplineCompTransformInterpolator>();
	}
};
static_assert(alignof(UNiBSplineCompTransformInterpolator) == 0x000008, "Wrong alignment on UNiBSplineCompTransformInterpolator");
static_assert(sizeof(UNiBSplineCompTransformInterpolator) == 0x000088, "Wrong size on UNiBSplineCompTransformInterpolator");
static_assert(offsetof(UNiBSplineCompTransformInterpolator, TranslationOffset) == 0x000070, "Member 'UNiBSplineCompTransformInterpolator::TranslationOffset' has a wrong offset!");
static_assert(offsetof(UNiBSplineCompTransformInterpolator, TranslationHalfRange) == 0x000074, "Member 'UNiBSplineCompTransformInterpolator::TranslationHalfRange' has a wrong offset!");
static_assert(offsetof(UNiBSplineCompTransformInterpolator, RotationOffset) == 0x000078, "Member 'UNiBSplineCompTransformInterpolator::RotationOffset' has a wrong offset!");
static_assert(offsetof(UNiBSplineCompTransformInterpolator, RotationHalfRange) == 0x00007C, "Member 'UNiBSplineCompTransformInterpolator::RotationHalfRange' has a wrong offset!");
static_assert(offsetof(UNiBSplineCompTransformInterpolator, ScaleOffset) == 0x000080, "Member 'UNiBSplineCompTransformInterpolator::ScaleOffset' has a wrong offset!");
static_assert(offsetof(UNiBSplineCompTransformInterpolator, ScaleHalfRange) == 0x000084, "Member 'UNiBSplineCompTransformInterpolator::ScaleHalfRange' has a wrong offset!");

// Class Altar.NiCamera
// 0x0058 (0x0108 - 0x00B0)
class UNiCamera final : public UNiAvObject
{
public:
	int32                                         CameraFlags;                                       // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrustumLeft;                                       // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrustumRight;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrustumTop;                                        // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrustumBottom;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrustumNear;                                       // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrustumFar;                                        // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseOrthographicProjection;                         // 0x00CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewportLeft;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewportRight;                                     // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewportTop;                                       // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewportBottom;                                    // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODAdjust;                                         // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiAvObject*                            Scene;                                             // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumScreenPolygons;                                 // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumScreenTextures;                                 // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         UnknownInt3;                                       // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiCamera">();
	}
	static class UNiCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiCamera>();
	}
};
static_assert(alignof(UNiCamera) == 0x000008, "Wrong alignment on UNiCamera");
static_assert(sizeof(UNiCamera) == 0x000108, "Wrong size on UNiCamera");
static_assert(offsetof(UNiCamera, CameraFlags) == 0x0000B0, "Member 'UNiCamera::CameraFlags' has a wrong offset!");
static_assert(offsetof(UNiCamera, FrustumLeft) == 0x0000B4, "Member 'UNiCamera::FrustumLeft' has a wrong offset!");
static_assert(offsetof(UNiCamera, FrustumRight) == 0x0000B8, "Member 'UNiCamera::FrustumRight' has a wrong offset!");
static_assert(offsetof(UNiCamera, FrustumTop) == 0x0000BC, "Member 'UNiCamera::FrustumTop' has a wrong offset!");
static_assert(offsetof(UNiCamera, FrustumBottom) == 0x0000C0, "Member 'UNiCamera::FrustumBottom' has a wrong offset!");
static_assert(offsetof(UNiCamera, FrustumNear) == 0x0000C4, "Member 'UNiCamera::FrustumNear' has a wrong offset!");
static_assert(offsetof(UNiCamera, FrustumFar) == 0x0000C8, "Member 'UNiCamera::FrustumFar' has a wrong offset!");
static_assert(offsetof(UNiCamera, UseOrthographicProjection) == 0x0000CC, "Member 'UNiCamera::UseOrthographicProjection' has a wrong offset!");
static_assert(offsetof(UNiCamera, ViewportLeft) == 0x0000D0, "Member 'UNiCamera::ViewportLeft' has a wrong offset!");
static_assert(offsetof(UNiCamera, ViewportRight) == 0x0000D4, "Member 'UNiCamera::ViewportRight' has a wrong offset!");
static_assert(offsetof(UNiCamera, ViewportTop) == 0x0000D8, "Member 'UNiCamera::ViewportTop' has a wrong offset!");
static_assert(offsetof(UNiCamera, ViewportBottom) == 0x0000DC, "Member 'UNiCamera::ViewportBottom' has a wrong offset!");
static_assert(offsetof(UNiCamera, LODAdjust) == 0x0000E0, "Member 'UNiCamera::LODAdjust' has a wrong offset!");
static_assert(offsetof(UNiCamera, Scene) == 0x0000E8, "Member 'UNiCamera::Scene' has a wrong offset!");
static_assert(offsetof(UNiCamera, NumScreenPolygons) == 0x0000F0, "Member 'UNiCamera::NumScreenPolygons' has a wrong offset!");
static_assert(offsetof(UNiCamera, NumScreenTextures) == 0x0000F8, "Member 'UNiCamera::NumScreenTextures' has a wrong offset!");
static_assert(offsetof(UNiCamera, UnknownInt3) == 0x000100, "Member 'UNiCamera::UnknownInt3' has a wrong offset!");

// Class Altar.VBlinkCharacterAnimInstance
// 0x0000 (0x0360 - 0x0360)
#pragma pack(push, 0x1)
class alignas(0x10) UVBlinkCharacterAnimInstance : public UVBaseCharacterAnimInstance
{
public:
	float GetBlinkProgress() const;
	bool IsBlinking() const;
	bool IsDead() const;
	bool IsSleeping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBlinkCharacterAnimInstance">();
	}
	static class UVBlinkCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBlinkCharacterAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVBlinkCharacterAnimInstance) == 0x000010, "Wrong alignment on UVBlinkCharacterAnimInstance");
static_assert(sizeof(UVBlinkCharacterAnimInstance) == 0x000360, "Wrong size on UVBlinkCharacterAnimInstance");

// Class Altar.VBlinkCreatureCharacterAnimInstance
// 0x00A0 (0x0400 - 0x0360)
class UVBlinkCreatureCharacterAnimInstance final : public UVBlinkCharacterAnimInstance
{
public:
	struct FActorBlinkData                        LayerData;                                         // 0x0358(0x00A0)(Edit, BlueprintVisible, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetBlinkWeight() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBlinkCreatureCharacterAnimInstance">();
	}
	static class UVBlinkCreatureCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBlinkCreatureCharacterAnimInstance>();
	}
};
static_assert(alignof(UVBlinkCreatureCharacterAnimInstance) == 0x000010, "Wrong alignment on UVBlinkCreatureCharacterAnimInstance");
static_assert(sizeof(UVBlinkCreatureCharacterAnimInstance) == 0x000400, "Wrong size on UVBlinkCreatureCharacterAnimInstance");
static_assert(offsetof(UVBlinkCreatureCharacterAnimInstance, LayerData) == 0x000358, "Member 'UVBlinkCreatureCharacterAnimInstance::LayerData' has a wrong offset!");

// Class Altar.NiColorInterpolator
// 0x0010 (0x0048 - 0x0038)
class UNiColorInterpolator final : public UNiKeyBasedInterpolator
{
public:
	struct FColor                                 Value;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiColorData*                           Data;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiColorInterpolator">();
	}
	static class UNiColorInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiColorInterpolator>();
	}
};
static_assert(alignof(UNiColorInterpolator) == 0x000008, "Wrong alignment on UNiColorInterpolator");
static_assert(sizeof(UNiColorInterpolator) == 0x000048, "Wrong size on UNiColorInterpolator");
static_assert(offsetof(UNiColorInterpolator, Value) == 0x000038, "Member 'UNiColorInterpolator::Value' has a wrong offset!");
static_assert(offsetof(UNiColorInterpolator, Data) == 0x000040, "Member 'UNiColorInterpolator::Data' has a wrong offset!");

// Class Altar.VTrailVFXBlueprint
// 0x0000 (0x02A0 - 0x02A0)
class AVTrailVFXBlueprint : public AVVFXBlueprint
{
public:
	void OnStartPlay(bool bIsPowerAttack, bool bIsUsingWeapon, const class FName BoneNameUsedToAttack, const class USceneComponent* WeaponRootComp);
	void OnStopPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTrailVFXBlueprint">();
	}
	static class AVTrailVFXBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVTrailVFXBlueprint>();
	}
};
static_assert(alignof(AVTrailVFXBlueprint) == 0x000008, "Wrong alignment on AVTrailVFXBlueprint");
static_assert(sizeof(AVTrailVFXBlueprint) == 0x0002A0, "Wrong size on AVTrailVFXBlueprint");

// Class Altar.NiDefaultAVObjectPalette
// 0x0020 (0x0058 - 0x0038)
class UNiDefaultAVObjectPalette final : public UNiAVObjectPalette
{
public:
	class UNiAvObject*                            Scene;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumObjs;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAVObject*>                      Objs;                                              // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiDefaultAVObjectPalette">();
	}
	static class UNiDefaultAVObjectPalette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiDefaultAVObjectPalette>();
	}
};
static_assert(alignof(UNiDefaultAVObjectPalette) == 0x000008, "Wrong alignment on UNiDefaultAVObjectPalette");
static_assert(sizeof(UNiDefaultAVObjectPalette) == 0x000058, "Wrong size on UNiDefaultAVObjectPalette");
static_assert(offsetof(UNiDefaultAVObjectPalette, Scene) == 0x000038, "Member 'UNiDefaultAVObjectPalette::Scene' has a wrong offset!");
static_assert(offsetof(UNiDefaultAVObjectPalette, NumObjs) == 0x000040, "Member 'UNiDefaultAVObjectPalette::NumObjs' has a wrong offset!");
static_assert(offsetof(UNiDefaultAVObjectPalette, Objs) == 0x000048, "Member 'UNiDefaultAVObjectPalette::Objs' has a wrong offset!");

// Class Altar.NiDitherProperty
// 0x0008 (0x0070 - 0x0068)
class UNiDitherProperty final : public UNiProperty
{
public:
	EDitherFlags                                  DitherFlags;                                       // 0x0068(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiDitherProperty">();
	}
	static class UNiDitherProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiDitherProperty>();
	}
};
static_assert(alignof(UNiDitherProperty) == 0x000008, "Wrong alignment on UNiDitherProperty");
static_assert(sizeof(UNiDitherProperty) == 0x000070, "Wrong size on UNiDitherProperty");
static_assert(offsetof(UNiDitherProperty, DitherFlags) == 0x000068, "Member 'UNiDitherProperty::DitherFlags' has a wrong offset!");

// Class Altar.VAltarUIDebugSubsystem
// 0x0050 (0x0080 - 0x0030)
class UVAltarUIDebugSubsystem final : public UGameInstanceSubsystem
{
public:
	struct FVector                                DebugInventoryItemLocationOffset;                  // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DebugInventoryItemScaleOffset;                     // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               DebugInventoryItemRotationOffset;                  // 0x0060(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsInventoryDebugModeEnabled;                      // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetDebugInventoryItemLocationOffset();
	struct FRotator GetDebugInventoryItemRotationOffset();
	struct FVector GetDebugInventoryItemScaleOffset();
	bool GetInventoryDebugModeState();
	void SetDebugInventoryItemLocationOffset(const struct FVector& InNewLocationOffset);
	void SetDebugInventoryItemRotationOffset(const struct FRotator& InNewRotationOffset);
	void SetDebugInventoryItemScaleOffset(const struct FVector& InNewScaleOffset);
	void SetInventoryDebugModeEnabled(bool bIsEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarUIDebugSubsystem">();
	}
	static class UVAltarUIDebugSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarUIDebugSubsystem>();
	}
};
static_assert(alignof(UVAltarUIDebugSubsystem) == 0x000008, "Wrong alignment on UVAltarUIDebugSubsystem");
static_assert(sizeof(UVAltarUIDebugSubsystem) == 0x000080, "Wrong size on UVAltarUIDebugSubsystem");
static_assert(offsetof(UVAltarUIDebugSubsystem, DebugInventoryItemLocationOffset) == 0x000030, "Member 'UVAltarUIDebugSubsystem::DebugInventoryItemLocationOffset' has a wrong offset!");
static_assert(offsetof(UVAltarUIDebugSubsystem, DebugInventoryItemScaleOffset) == 0x000048, "Member 'UVAltarUIDebugSubsystem::DebugInventoryItemScaleOffset' has a wrong offset!");
static_assert(offsetof(UVAltarUIDebugSubsystem, DebugInventoryItemRotationOffset) == 0x000060, "Member 'UVAltarUIDebugSubsystem::DebugInventoryItemRotationOffset' has a wrong offset!");
static_assert(offsetof(UVAltarUIDebugSubsystem, bIsInventoryDebugModeEnabled) == 0x000078, "Member 'UVAltarUIDebugSubsystem::bIsInventoryDebugModeEnabled' has a wrong offset!");

// Class Altar.NiFloatData
// 0x0018 (0x0050 - 0x0038)
class UNiFloatData final : public UNiObject
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiFloatData">();
	}
	static class UNiFloatData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiFloatData>();
	}
};
static_assert(alignof(UNiFloatData) == 0x000008, "Wrong alignment on UNiFloatData");
static_assert(sizeof(UNiFloatData) == 0x000050, "Wrong size on UNiFloatData");

// Class Altar.NiFogProperty
// 0x0010 (0x0078 - 0x0068)
class UNiFogProperty final : public UNiProperty
{
public:
	struct FFogFlags                              Flags_0;                                           // 0x0068(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Fog_Depth;                                         // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Fog_Color;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiFogProperty">();
	}
	static class UNiFogProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiFogProperty>();
	}
};
static_assert(alignof(UNiFogProperty) == 0x000008, "Wrong alignment on UNiFogProperty");
static_assert(sizeof(UNiFogProperty) == 0x000078, "Wrong size on UNiFogProperty");
static_assert(offsetof(UNiFogProperty, Flags_0) == 0x000068, "Member 'UNiFogProperty::Flags_0' has a wrong offset!");
static_assert(offsetof(UNiFogProperty, Fog_Depth) == 0x00006C, "Member 'UNiFogProperty::Fog_Depth' has a wrong offset!");
static_assert(offsetof(UNiFogProperty, Fog_Color) == 0x000070, "Member 'UNiFogProperty::Fog_Color' has a wrong offset!");

// Class Altar.VAmbientDelimiter
// 0x0038 (0x0328 - 0x02F0)
class AVAmbientDelimiter final : public AVActor
{
public:
	struct FTimerHandle                           AmbientUpdateTimerHandle;                          // 0x02F0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          LeftAmbientEvent;                                  // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          RightAmbientEvent;                                 // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopDelimiterAmbientEvent;                         // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineWidth;                                       // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAmbientDelimiter">();
	}
	static class AVAmbientDelimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAmbientDelimiter>();
	}
};
static_assert(alignof(AVAmbientDelimiter) == 0x000008, "Wrong alignment on AVAmbientDelimiter");
static_assert(sizeof(AVAmbientDelimiter) == 0x000328, "Wrong size on AVAmbientDelimiter");
static_assert(offsetof(AVAmbientDelimiter, AmbientUpdateTimerHandle) == 0x0002F0, "Member 'AVAmbientDelimiter::AmbientUpdateTimerHandle' has a wrong offset!");
static_assert(offsetof(AVAmbientDelimiter, LeftAmbientEvent) == 0x0002F8, "Member 'AVAmbientDelimiter::LeftAmbientEvent' has a wrong offset!");
static_assert(offsetof(AVAmbientDelimiter, RightAmbientEvent) == 0x000300, "Member 'AVAmbientDelimiter::RightAmbientEvent' has a wrong offset!");
static_assert(offsetof(AVAmbientDelimiter, StopDelimiterAmbientEvent) == 0x000308, "Member 'AVAmbientDelimiter::StopDelimiterAmbientEvent' has a wrong offset!");
static_assert(offsetof(AVAmbientDelimiter, SplineWidth) == 0x000310, "Member 'AVAmbientDelimiter::SplineWidth' has a wrong offset!");
static_assert(offsetof(AVAmbientDelimiter, SplineComponent) == 0x000318, "Member 'AVAmbientDelimiter::SplineComponent' has a wrong offset!");

// Class Altar.NiHeader
// 0x0078 (0x00B0 - 0x0038)
class UNiHeader final : public UNiObject
{
public:
	class FString                                 HeaderString;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Version;                                           // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EndianType                                    EndianTypeValue;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         UserVersion;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NumBlocks;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBSStreamHeader*                        BSHeader;                                          // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBlockTypes;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         BlockTypes;                                        // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<int32>                                 BlockTypeIndex;                                    // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         NumGroups;                                         // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 Groups;                                            // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiHeader">();
	}
	static class UNiHeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiHeader>();
	}
};
static_assert(alignof(UNiHeader) == 0x000008, "Wrong alignment on UNiHeader");
static_assert(sizeof(UNiHeader) == 0x0000B0, "Wrong size on UNiHeader");
static_assert(offsetof(UNiHeader, HeaderString) == 0x000038, "Member 'UNiHeader::HeaderString' has a wrong offset!");
static_assert(offsetof(UNiHeader, Version) == 0x000048, "Member 'UNiHeader::Version' has a wrong offset!");
static_assert(offsetof(UNiHeader, EndianTypeValue) == 0x000050, "Member 'UNiHeader::EndianTypeValue' has a wrong offset!");
static_assert(offsetof(UNiHeader, UserVersion) == 0x000058, "Member 'UNiHeader::UserVersion' has a wrong offset!");
static_assert(offsetof(UNiHeader, NumBlocks) == 0x000060, "Member 'UNiHeader::NumBlocks' has a wrong offset!");
static_assert(offsetof(UNiHeader, BSHeader) == 0x000068, "Member 'UNiHeader::BSHeader' has a wrong offset!");
static_assert(offsetof(UNiHeader, NumBlockTypes) == 0x000070, "Member 'UNiHeader::NumBlockTypes' has a wrong offset!");
static_assert(offsetof(UNiHeader, BlockTypes) == 0x000078, "Member 'UNiHeader::BlockTypes' has a wrong offset!");
static_assert(offsetof(UNiHeader, BlockTypeIndex) == 0x000088, "Member 'UNiHeader::BlockTypeIndex' has a wrong offset!");
static_assert(offsetof(UNiHeader, NumGroups) == 0x000098, "Member 'UNiHeader::NumGroups' has a wrong offset!");
static_assert(offsetof(UNiHeader, Groups) == 0x0000A0, "Member 'UNiHeader::Groups' has a wrong offset!");

// Class Altar.VAnimNotifyState_ChangePlayRate
// 0x0008 (0x0038 - 0x0030)
class UVAnimNotifyState_ChangePlayRate final : public UAnimNotifyState
{
public:
	float                                         PlayRate;                                          // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotifyState_ChangePlayRate">();
	}
	static class UVAnimNotifyState_ChangePlayRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotifyState_ChangePlayRate>();
	}
};
static_assert(alignof(UVAnimNotifyState_ChangePlayRate) == 0x000008, "Wrong alignment on UVAnimNotifyState_ChangePlayRate");
static_assert(sizeof(UVAnimNotifyState_ChangePlayRate) == 0x000038, "Wrong size on UVAnimNotifyState_ChangePlayRate");
static_assert(offsetof(UVAnimNotifyState_ChangePlayRate, PlayRate) == 0x000030, "Member 'UVAnimNotifyState_ChangePlayRate::PlayRate' has a wrong offset!");

// Class Altar.NiKeyframeData
// 0x0068 (0x00A0 - 0x0038)
class UNiKeyframeData : public UNiObject
{
public:
	int64                                         NumRotationKeys;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKeyType                                      RotationType;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x14];                                      // 0x0044(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Order;                                             // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x44];                                      // 0x005C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiKeyframeData">();
	}
	static class UNiKeyframeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiKeyframeData>();
	}
};
static_assert(alignof(UNiKeyframeData) == 0x000008, "Wrong alignment on UNiKeyframeData");
static_assert(sizeof(UNiKeyframeData) == 0x0000A0, "Wrong size on UNiKeyframeData");
static_assert(offsetof(UNiKeyframeData, NumRotationKeys) == 0x000038, "Member 'UNiKeyframeData::NumRotationKeys' has a wrong offset!");
static_assert(offsetof(UNiKeyframeData, RotationType) == 0x000040, "Member 'UNiKeyframeData::RotationType' has a wrong offset!");
static_assert(offsetof(UNiKeyframeData, Order) == 0x000058, "Member 'UNiKeyframeData::Order' has a wrong offset!");

// Class Altar.VAnimNotifyState_SyncAnim
// 0x0008 (0x0038 - 0x0030)
class UVAnimNotifyState_SyncAnim final : public UAnimNotifyState
{
public:
	TSubclassOf<class UObject>                    PropToAnimateClass;                                // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SyncAnimation(class AActor* OwnerActor, float StartAnimTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotifyState_SyncAnim">();
	}
	static class UVAnimNotifyState_SyncAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotifyState_SyncAnim>();
	}
};
static_assert(alignof(UVAnimNotifyState_SyncAnim) == 0x000008, "Wrong alignment on UVAnimNotifyState_SyncAnim");
static_assert(sizeof(UVAnimNotifyState_SyncAnim) == 0x000038, "Wrong size on UVAnimNotifyState_SyncAnim");
static_assert(offsetof(UVAnimNotifyState_SyncAnim, PropToAnimateClass) == 0x000030, "Member 'UVAnimNotifyState_SyncAnim::PropToAnimateClass' has a wrong offset!");

// Class Altar.VTextEditMenuViewModel
// 0x0030 (0x0100 - 0x00D0)
class UVTextEditMenuViewModel final : public UVViewModelBase
{
public:
	struct FLegacyTextEditMenuProperties          Properties;                                        // 0x00D0(0x0030)(NativeAccessSpecifierPrivate)

public:
	void RegisterSendClickedCancelButton();
	void RegisterSendClickedOkButton(const class FText& UpdatedText);
	void SetProperties(const struct FLegacyTextEditMenuProperties& Properties_0);

	struct FLegacyTextEditMenuProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTextEditMenuViewModel">();
	}
	static class UVTextEditMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVTextEditMenuViewModel>();
	}
};
static_assert(alignof(UVTextEditMenuViewModel) == 0x000008, "Wrong alignment on UVTextEditMenuViewModel");
static_assert(sizeof(UVTextEditMenuViewModel) == 0x000100, "Wrong size on UVTextEditMenuViewModel");
static_assert(offsetof(UVTextEditMenuViewModel, Properties) == 0x0000D0, "Member 'UVTextEditMenuViewModel::Properties' has a wrong offset!");

// Class Altar.NiMaterialProperty
// 0x0020 (0x0088 - 0x0068)
class UNiMaterialProperty final : public UNiProperty
{
public:
	int32                                         Flags_0;                                           // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 AmbientColor;                                      // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DiffuseColor;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SpecularColor;                                     // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 EmissiveColor;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Glossiness;                                        // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ALPHA;                                             // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiMaterialProperty">();
	}
	static class UNiMaterialProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiMaterialProperty>();
	}
};
static_assert(alignof(UNiMaterialProperty) == 0x000008, "Wrong alignment on UNiMaterialProperty");
static_assert(sizeof(UNiMaterialProperty) == 0x000088, "Wrong size on UNiMaterialProperty");
static_assert(offsetof(UNiMaterialProperty, Flags_0) == 0x000068, "Member 'UNiMaterialProperty::Flags_0' has a wrong offset!");
static_assert(offsetof(UNiMaterialProperty, AmbientColor) == 0x00006C, "Member 'UNiMaterialProperty::AmbientColor' has a wrong offset!");
static_assert(offsetof(UNiMaterialProperty, DiffuseColor) == 0x000070, "Member 'UNiMaterialProperty::DiffuseColor' has a wrong offset!");
static_assert(offsetof(UNiMaterialProperty, SpecularColor) == 0x000074, "Member 'UNiMaterialProperty::SpecularColor' has a wrong offset!");
static_assert(offsetof(UNiMaterialProperty, EmissiveColor) == 0x000078, "Member 'UNiMaterialProperty::EmissiveColor' has a wrong offset!");
static_assert(offsetof(UNiMaterialProperty, Glossiness) == 0x00007C, "Member 'UNiMaterialProperty::Glossiness' has a wrong offset!");
static_assert(offsetof(UNiMaterialProperty, ALPHA) == 0x000080, "Member 'UNiMaterialProperty::ALPHA' has a wrong offset!");

// Class Altar.VTurnInPlaceFPAnimInstance
// 0x00C0 (0x0520 - 0x0460)
class UVTurnInPlaceFPAnimInstance : public UVLocomotionCharacterAnimInstance
{
public:
	float                                         TurnTimerResetTime;                                // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTurn;                                           // 0x0464(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTurn;                                           // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnAlphaInterpSpeed;                              // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTurnInPlaceFP                         LayerData;                                         // 0x0470(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTurnInPlaceAnimSet                    TorchAnimSet;                                      // 0x04A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTurnInPlaceAnimSet                    SwimmingShieldAnimSet;                             // 0x04B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TwoHandedWeaponTags;                               // 0x04C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TurnAlpha;                                         // 0x04E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSneaking;                                       // 0x04E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSwimming;                                       // 0x04E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTurning;                                        // 0x04E6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTurningLeft;                                    // 0x04E7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUsingTorch;                                     // 0x04E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSwimmingWithShield;                             // 0x04E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EA[0x36];                                     // 0x04EA(0x0036)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTurnInPlaceFPAnimInstance">();
	}
	static class UVTurnInPlaceFPAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVTurnInPlaceFPAnimInstance>();
	}
};
static_assert(alignof(UVTurnInPlaceFPAnimInstance) == 0x000010, "Wrong alignment on UVTurnInPlaceFPAnimInstance");
static_assert(sizeof(UVTurnInPlaceFPAnimInstance) == 0x000520, "Wrong size on UVTurnInPlaceFPAnimInstance");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, TurnTimerResetTime) == 0x000460, "Member 'UVTurnInPlaceFPAnimInstance::TurnTimerResetTime' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, MinTurn) == 0x000464, "Member 'UVTurnInPlaceFPAnimInstance::MinTurn' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, MaxTurn) == 0x000468, "Member 'UVTurnInPlaceFPAnimInstance::MaxTurn' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, TurnAlphaInterpSpeed) == 0x00046C, "Member 'UVTurnInPlaceFPAnimInstance::TurnAlphaInterpSpeed' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, LayerData) == 0x000470, "Member 'UVTurnInPlaceFPAnimInstance::LayerData' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, TorchAnimSet) == 0x0004A0, "Member 'UVTurnInPlaceFPAnimInstance::TorchAnimSet' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, SwimmingShieldAnimSet) == 0x0004B0, "Member 'UVTurnInPlaceFPAnimInstance::SwimmingShieldAnimSet' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, TwoHandedWeaponTags) == 0x0004C0, "Member 'UVTurnInPlaceFPAnimInstance::TwoHandedWeaponTags' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, TurnAlpha) == 0x0004E0, "Member 'UVTurnInPlaceFPAnimInstance::TurnAlpha' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, bIsSneaking) == 0x0004E4, "Member 'UVTurnInPlaceFPAnimInstance::bIsSneaking' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, bIsSwimming) == 0x0004E5, "Member 'UVTurnInPlaceFPAnimInstance::bIsSwimming' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, bIsTurning) == 0x0004E6, "Member 'UVTurnInPlaceFPAnimInstance::bIsTurning' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, bIsTurningLeft) == 0x0004E7, "Member 'UVTurnInPlaceFPAnimInstance::bIsTurningLeft' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, bIsUsingTorch) == 0x0004E8, "Member 'UVTurnInPlaceFPAnimInstance::bIsUsingTorch' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceFPAnimInstance, bIsSwimmingWithShield) == 0x0004E9, "Member 'UVTurnInPlaceFPAnimInstance::bIsSwimmingWithShield' has a wrong offset!");

// Class Altar.VCharacterPhenotypePreset
// 0x0008 (0x0038 - 0x0030)
class UVCharacterPhenotypePreset final : public UDataAsset
{
public:
	class UVCharacterPhenotypeData*               PhenotypeData;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterPhenotypePreset">();
	}
	static class UVCharacterPhenotypePreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterPhenotypePreset>();
	}
};
static_assert(alignof(UVCharacterPhenotypePreset) == 0x000008, "Wrong alignment on UVCharacterPhenotypePreset");
static_assert(sizeof(UVCharacterPhenotypePreset) == 0x000038, "Wrong size on UVCharacterPhenotypePreset");
static_assert(offsetof(UVCharacterPhenotypePreset, PhenotypeData) == 0x000030, "Member 'UVCharacterPhenotypePreset::PhenotypeData' has a wrong offset!");

// Class Altar.NiMeshPSysData
// 0x0030 (0x0200 - 0x01D0)
class UNiMeshPSysData final : public UNiPSysData
{
public:
	int64                                         DefaultPoolSize;                                   // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FillPoolsOnLoad;                                   // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         NumGenerations;                                    // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 Generations;                                       // 0x01E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UNiNode*                                ParticleMeshes;                                    // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiMeshPSysData">();
	}
	static class UNiMeshPSysData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiMeshPSysData>();
	}
};
static_assert(alignof(UNiMeshPSysData) == 0x000008, "Wrong alignment on UNiMeshPSysData");
static_assert(sizeof(UNiMeshPSysData) == 0x000200, "Wrong size on UNiMeshPSysData");
static_assert(offsetof(UNiMeshPSysData, DefaultPoolSize) == 0x0001D0, "Member 'UNiMeshPSysData::DefaultPoolSize' has a wrong offset!");
static_assert(offsetof(UNiMeshPSysData, FillPoolsOnLoad) == 0x0001D8, "Member 'UNiMeshPSysData::FillPoolsOnLoad' has a wrong offset!");
static_assert(offsetof(UNiMeshPSysData, NumGenerations) == 0x0001E0, "Member 'UNiMeshPSysData::NumGenerations' has a wrong offset!");
static_assert(offsetof(UNiMeshPSysData, Generations) == 0x0001E8, "Member 'UNiMeshPSysData::Generations' has a wrong offset!");
static_assert(offsetof(UNiMeshPSysData, ParticleMeshes) == 0x0001F8, "Member 'UNiMeshPSysData::ParticleMeshes' has a wrong offset!");

// Class Altar.VCinematicSaveData
// 0x0080 (0x00B0 - 0x0030)
class UVCinematicSaveData final : public UVBaseAltarSaveData
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EVCinematicType, struct FVAltarCinematicState> CinematicsStates;                            // 0x0060(0x0050)(SaveGame, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCinematicSaveData">();
	}
	static class UVCinematicSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCinematicSaveData>();
	}
};
static_assert(alignof(UVCinematicSaveData) == 0x000008, "Wrong alignment on UVCinematicSaveData");
static_assert(sizeof(UVCinematicSaveData) == 0x0000B0, "Wrong size on UVCinematicSaveData");
static_assert(offsetof(UVCinematicSaveData, CinematicsStates) == 0x000060, "Member 'UVCinematicSaveData::CinematicsStates' has a wrong offset!");

// Class Altar.NiMultiTargetTransformController
// 0x0018 (0x0088 - 0x0070)
class UNiMultiTargetTransformController final : public UNiInterpController
{
public:
	int32                                         NumExtraTargets;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiAvObject*>                    ExtraTargets;                                      // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiMultiTargetTransformController">();
	}
	static class UNiMultiTargetTransformController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiMultiTargetTransformController>();
	}
};
static_assert(alignof(UNiMultiTargetTransformController) == 0x000008, "Wrong alignment on UNiMultiTargetTransformController");
static_assert(sizeof(UNiMultiTargetTransformController) == 0x000088, "Wrong size on UNiMultiTargetTransformController");
static_assert(offsetof(UNiMultiTargetTransformController, NumExtraTargets) == 0x000070, "Member 'UNiMultiTargetTransformController::NumExtraTargets' has a wrong offset!");
static_assert(offsetof(UNiMultiTargetTransformController, ExtraTargets) == 0x000078, "Member 'UNiMultiTargetTransformController::ExtraTargets' has a wrong offset!");

// Class Altar.NiPathInterpolator
// 0x0028 (0x0060 - 0x0038)
class UNiPathInterpolator final : public UNiKeyBasedInterpolator
{
public:
	EPathFlags                                    Flags_0;                                           // 0x0038(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BankDir;                                           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBankAngle;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Smoothing;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FollowAxis;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiPosData*                             PathData;                                          // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiFloatData*                           PercentData;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPathInterpolator">();
	}
	static class UNiPathInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPathInterpolator>();
	}
};
static_assert(alignof(UNiPathInterpolator) == 0x000008, "Wrong alignment on UNiPathInterpolator");
static_assert(sizeof(UNiPathInterpolator) == 0x000060, "Wrong size on UNiPathInterpolator");
static_assert(offsetof(UNiPathInterpolator, Flags_0) == 0x000038, "Member 'UNiPathInterpolator::Flags_0' has a wrong offset!");
static_assert(offsetof(UNiPathInterpolator, BankDir) == 0x00003C, "Member 'UNiPathInterpolator::BankDir' has a wrong offset!");
static_assert(offsetof(UNiPathInterpolator, MaxBankAngle) == 0x000040, "Member 'UNiPathInterpolator::MaxBankAngle' has a wrong offset!");
static_assert(offsetof(UNiPathInterpolator, Smoothing) == 0x000044, "Member 'UNiPathInterpolator::Smoothing' has a wrong offset!");
static_assert(offsetof(UNiPathInterpolator, FollowAxis) == 0x000048, "Member 'UNiPathInterpolator::FollowAxis' has a wrong offset!");
static_assert(offsetof(UNiPathInterpolator, PathData) == 0x000050, "Member 'UNiPathInterpolator::PathData' has a wrong offset!");
static_assert(offsetof(UNiPathInterpolator, PercentData) == 0x000058, "Member 'UNiPathInterpolator::PercentData' has a wrong offset!");

// Class Altar.VClairvoyanceVFXBlueprint
// 0x0018 (0x02B8 - 0x02A0)
class AVClairvoyanceVFXBlueprint : public AVVFXBlueprint
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     ClairvoyanceVFXNavigationQueryFilterClass;         // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavArea>                   WaterNavAreaClass;                                 // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnStartPlay(class USplineComponent* SplineComp);
	void OnStopPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VClairvoyanceVFXBlueprint">();
	}
	static class AVClairvoyanceVFXBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVClairvoyanceVFXBlueprint>();
	}
};
static_assert(alignof(AVClairvoyanceVFXBlueprint) == 0x000008, "Wrong alignment on AVClairvoyanceVFXBlueprint");
static_assert(sizeof(AVClairvoyanceVFXBlueprint) == 0x0002B8, "Wrong size on AVClairvoyanceVFXBlueprint");
static_assert(offsetof(AVClairvoyanceVFXBlueprint, SplineComponent) == 0x0002A0, "Member 'AVClairvoyanceVFXBlueprint::SplineComponent' has a wrong offset!");
static_assert(offsetof(AVClairvoyanceVFXBlueprint, ClairvoyanceVFXNavigationQueryFilterClass) == 0x0002A8, "Member 'AVClairvoyanceVFXBlueprint::ClairvoyanceVFXNavigationQueryFilterClass' has a wrong offset!");
static_assert(offsetof(AVClairvoyanceVFXBlueprint, WaterNavAreaClass) == 0x0002B0, "Member 'AVClairvoyanceVFXBlueprint::WaterNavAreaClass' has a wrong offset!");

// Class Altar.NiPoint3Interpolator
// 0x0020 (0x0058 - 0x0038)
class UNiPoint3Interpolator final : public UNiKeyBasedInterpolator
{
public:
	struct FVector                                Value;                                             // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiPosData*                             Data;                                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPoint3Interpolator">();
	}
	static class UNiPoint3Interpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPoint3Interpolator>();
	}
};
static_assert(alignof(UNiPoint3Interpolator) == 0x000008, "Wrong alignment on UNiPoint3Interpolator");
static_assert(sizeof(UNiPoint3Interpolator) == 0x000058, "Wrong size on UNiPoint3Interpolator");
static_assert(offsetof(UNiPoint3Interpolator, Value) == 0x000038, "Member 'UNiPoint3Interpolator::Value' has a wrong offset!");
static_assert(offsetof(UNiPoint3Interpolator, Data) == 0x000050, "Member 'UNiPoint3Interpolator::Data' has a wrong offset!");

// Class Altar.NiPSysAgeDeathModifier
// 0x0010 (0x0070 - 0x0060)
class UNiPSysAgeDeathModifier final : public UNiPSysModifier
{
public:
	bool                                          SpawnOnDeath;                                      // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiPSysSpawnModifier*                   SpawnModifier;                                     // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysAgeDeathModifier">();
	}
	static class UNiPSysAgeDeathModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysAgeDeathModifier>();
	}
};
static_assert(alignof(UNiPSysAgeDeathModifier) == 0x000008, "Wrong alignment on UNiPSysAgeDeathModifier");
static_assert(sizeof(UNiPSysAgeDeathModifier) == 0x000070, "Wrong size on UNiPSysAgeDeathModifier");
static_assert(offsetof(UNiPSysAgeDeathModifier, SpawnOnDeath) == 0x000060, "Member 'UNiPSysAgeDeathModifier::SpawnOnDeath' has a wrong offset!");
static_assert(offsetof(UNiPSysAgeDeathModifier, SpawnModifier) == 0x000068, "Member 'UNiPSysAgeDeathModifier::SpawnModifier' has a wrong offset!");

// Class Altar.VClassOverviewViewModel
// 0x00A0 (0x0170 - 0x00D0)
class UVClassOverviewViewModel final : public UVViewModelBase
{
public:
	struct FPlayerClassItemProperties             ClassProperties;                                   // 0x00D0(0x00A0)(NativeAccessSpecifierPrivate)

public:
	void AddClassSkill(const struct FSkillInformation& SkillToAdd);
	void ClearClassAttributes();
	void ClearClassSkills();
	void RemoveClassSkill(const struct FSkillInformation& SkillToRemove);
	void SetClassName(const class FText& NewName);
	void SetClassPicture(class UTexture2D* NewPicture);
	void SetClassProperties(const struct FPlayerClassItemProperties& NewClassProperties);
	void SetClassSpecialisation(const class FText& NewSpecialisation);
	void SetPrimaryAttribute(const class FText& NewAttribute);
	void SetSecondaryAttribute(const class FText& NewAttribute);
	void SetSpecializationEnum(ESkillAndClassSpecialization NewSpecializationEnum);

	const struct FPlayerClassItemProperties GetClassProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VClassOverviewViewModel">();
	}
	static class UVClassOverviewViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVClassOverviewViewModel>();
	}
};
static_assert(alignof(UVClassOverviewViewModel) == 0x000008, "Wrong alignment on UVClassOverviewViewModel");
static_assert(sizeof(UVClassOverviewViewModel) == 0x000170, "Wrong size on UVClassOverviewViewModel");
static_assert(offsetof(UVClassOverviewViewModel, ClassProperties) == 0x0000D0, "Member 'UVClassOverviewViewModel::ClassProperties' has a wrong offset!");

// Class Altar.NiPSysBoundUpdateModifier
// 0x0008 (0x0068 - 0x0060)
class UNiPSysBoundUpdateModifier final : public UNiPSysModifier
{
public:
	int32                                         UpdateSkip;                                        // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysBoundUpdateModifier">();
	}
	static class UNiPSysBoundUpdateModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysBoundUpdateModifier>();
	}
};
static_assert(alignof(UNiPSysBoundUpdateModifier) == 0x000008, "Wrong alignment on UNiPSysBoundUpdateModifier");
static_assert(sizeof(UNiPSysBoundUpdateModifier) == 0x000068, "Wrong size on UNiPSysBoundUpdateModifier");
static_assert(offsetof(UNiPSysBoundUpdateModifier, UpdateSkip) == 0x000060, "Member 'UNiPSysBoundUpdateModifier::UpdateSkip' has a wrong offset!");

// Class Altar.NiPSysColliderManager
// 0x0008 (0x0068 - 0x0060)
class UNiPSysColliderManager final : public UNiPSysModifier
{
public:
	class UNiPSysCollider*                        Collider;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysColliderManager">();
	}
	static class UNiPSysColliderManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysColliderManager>();
	}
};
static_assert(alignof(UNiPSysColliderManager) == 0x000008, "Wrong alignment on UNiPSysColliderManager");
static_assert(sizeof(UNiPSysColliderManager) == 0x000068, "Wrong size on UNiPSysColliderManager");
static_assert(offsetof(UNiPSysColliderManager, Collider) == 0x000060, "Member 'UNiPSysColliderManager::Collider' has a wrong offset!");

// Class Altar.VHitBoxComponent
// 0x00D0 (0x0690 - 0x05C0)
class UVHitBoxComponent final : public UBoxComponent
{
public:
	int32                                         TriggerFlags;                                      // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVHitSourceMaterial                           HitSourceMaterial;                                 // 0x05BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVHitSourceWeaponType                         HitSourceWeaponType;                               // 0x05BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BE[0x2];                                      // 0x05BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDurationBetweenImpacts;                         // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVGameplayHitboxBehaviour                     GameplayBehaviour;                                 // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnvironmentImpactHitForceMultiplier;               // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCloudTrap;                                      // 0x05CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPhantom;                                        // 0x05CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsContinuous;                                     // 0x05CE(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CF[0x1];                                      // 0x05CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityScale;                                     // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyTriggerAgainstPawns;                          // 0x05D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D5[0x53];                                     // 0x05D5(0x0053)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ImpactBlueprintClass;                              // 0x0628(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 AttackerActor;                                     // 0x0650(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          TrappedActors;                                     // 0x0658(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          TriggeringActors;                                  // 0x0668(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           CooldownTimerHandle;                               // 0x0678(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           MaxDurationTimerHandle;                            // 0x0680(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateTriggers();
	void AddTriggerTarget(class UPrimitiveComponent* SourceComp, class AActor* TargetActor, class UPrimitiveComponent* TargetComp, int32 UnusedOtherBox, bool UnusedSweep, const struct FHitResult& EmptyHitResult);
	void OnOverlapTriggered(class UPrimitiveComponent* SourceComp, class AActor* TargetActor, class UPrimitiveComponent* TargetComp, int32 UnusedOtherBox, bool UnusedSweep, const struct FHitResult& OverlapHitResult);
	void PauseHit();
	void RemoveTriggerTarget(class UPrimitiveComponent* SourceComp, class AActor* TargetActor, class UPrimitiveComponent* TargetComp, int32 UnusedOtherBox);
	void StartHit(EVHitSourceType HitSourceTypeParam, class AActor* Attacker, TSoftClassPtr<class UClass> BlueprintClass, float Duration, bool bUseOverlaps);
	void StopHit();
	bool TriggerImpactSystem(const class UPhysicalMaterial* PhysicalMaterial, const struct FVector& ImpactPoint, const struct FVector& ImpactNormal);
	bool TriggerImpactSystemFromHitResult(const struct FHitResult& MaterialHitResult, const struct FHitResult& LocationHitResult, struct FVProjectilePenetrationSettings* OutProjectilePenetrationSettings);
	bool TriggerImpactSystemFromRow(const struct FImpactSystemRowBase& ChosenRow, const struct FVector& ImpactPoint, const struct FVector& ImpactNormal);
	void TriggerTrapBegin(class UPrimitiveComponent* SourceComp, class AActor* TargetActor, class UPrimitiveComponent* TargetComp, int32 UnusedOtherBox, bool UnusedSweep, const struct FHitResult& EmptyHitResult);
	void TriggerTrapEnd(class UPrimitiveComponent* SourceComp, class AActor* TargetActor, class UPrimitiveComponent* TargetComp, int32 UnusedOtherBox);
	void UnpauseHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHitBoxComponent">();
	}
	static class UVHitBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHitBoxComponent>();
	}
};
static_assert(alignof(UVHitBoxComponent) == 0x000010, "Wrong alignment on UVHitBoxComponent");
static_assert(sizeof(UVHitBoxComponent) == 0x000690, "Wrong size on UVHitBoxComponent");
static_assert(offsetof(UVHitBoxComponent, TriggerFlags) == 0x0005B8, "Member 'UVHitBoxComponent::TriggerFlags' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, HitSourceMaterial) == 0x0005BC, "Member 'UVHitBoxComponent::HitSourceMaterial' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, HitSourceWeaponType) == 0x0005BD, "Member 'UVHitBoxComponent::HitSourceWeaponType' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, MinDurationBetweenImpacts) == 0x0005C0, "Member 'UVHitBoxComponent::MinDurationBetweenImpacts' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, GameplayBehaviour) == 0x0005C4, "Member 'UVHitBoxComponent::GameplayBehaviour' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, EnvironmentImpactHitForceMultiplier) == 0x0005C8, "Member 'UVHitBoxComponent::EnvironmentImpactHitForceMultiplier' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, bIsCloudTrap) == 0x0005CC, "Member 'UVHitBoxComponent::bIsCloudTrap' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, bIsPhantom) == 0x0005CD, "Member 'UVHitBoxComponent::bIsPhantom' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, bIsContinuous) == 0x0005CE, "Member 'UVHitBoxComponent::bIsContinuous' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, VelocityScale) == 0x0005D0, "Member 'UVHitBoxComponent::VelocityScale' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, bOnlyTriggerAgainstPawns) == 0x0005D4, "Member 'UVHitBoxComponent::bOnlyTriggerAgainstPawns' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, ImpactBlueprintClass) == 0x000628, "Member 'UVHitBoxComponent::ImpactBlueprintClass' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, AttackerActor) == 0x000650, "Member 'UVHitBoxComponent::AttackerActor' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, TrappedActors) == 0x000658, "Member 'UVHitBoxComponent::TrappedActors' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, TriggeringActors) == 0x000668, "Member 'UVHitBoxComponent::TriggeringActors' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, CooldownTimerHandle) == 0x000678, "Member 'UVHitBoxComponent::CooldownTimerHandle' has a wrong offset!");
static_assert(offsetof(UVHitBoxComponent, MaxDurationTimerHandle) == 0x000680, "Member 'UVHitBoxComponent::MaxDurationTimerHandle' has a wrong offset!");

// Class Altar.NiPSysColorModifier
// 0x0008 (0x0068 - 0x0060)
class UNiPSysColorModifier final : public UNiPSysModifier
{
public:
	class UNiColorData*                           ColorData;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysColorModifier">();
	}
	static class UNiPSysColorModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysColorModifier>();
	}
};
static_assert(alignof(UNiPSysColorModifier) == 0x000008, "Wrong alignment on UNiPSysColorModifier");
static_assert(sizeof(UNiPSysColorModifier) == 0x000068, "Wrong size on UNiPSysColorModifier");
static_assert(offsetof(UNiPSysColorModifier, ColorData) == 0x000060, "Member 'UNiPSysColorModifier::ColorData' has a wrong offset!");

// Class Altar.NiPSysDragModifier
// 0x0030 (0x0090 - 0x0060)
class UNiPSysDragModifier final : public UNiPSysModifier
{
public:
	class UNiAvObject*                            DragObject;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DragAxis;                                          // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percentage;                                        // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeFalloff;                                      // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysDragModifier">();
	}
	static class UNiPSysDragModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysDragModifier>();
	}
};
static_assert(alignof(UNiPSysDragModifier) == 0x000008, "Wrong alignment on UNiPSysDragModifier");
static_assert(sizeof(UNiPSysDragModifier) == 0x000090, "Wrong size on UNiPSysDragModifier");
static_assert(offsetof(UNiPSysDragModifier, DragObject) == 0x000060, "Member 'UNiPSysDragModifier::DragObject' has a wrong offset!");
static_assert(offsetof(UNiPSysDragModifier, DragAxis) == 0x000068, "Member 'UNiPSysDragModifier::DragAxis' has a wrong offset!");
static_assert(offsetof(UNiPSysDragModifier, Percentage) == 0x000080, "Member 'UNiPSysDragModifier::Percentage' has a wrong offset!");
static_assert(offsetof(UNiPSysDragModifier, Range) == 0x000084, "Member 'UNiPSysDragModifier::Range' has a wrong offset!");
static_assert(offsetof(UNiPSysDragModifier, RangeFalloff) == 0x000088, "Member 'UNiPSysDragModifier::RangeFalloff' has a wrong offset!");

// Class Altar.VHorseAccessoryAnimInstance
// 0x0000 (0x0360 - 0x0360)
class UVHorseAccessoryAnimInstance final : public UVBaseCharacterAnimInstance
{
public:
	class USkeletalMeshComponent*                 MainSkeletalMeshComponent;                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHorseAccessoryAnimInstance">();
	}
	static class UVHorseAccessoryAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHorseAccessoryAnimInstance>();
	}
};
static_assert(alignof(UVHorseAccessoryAnimInstance) == 0x000010, "Wrong alignment on UVHorseAccessoryAnimInstance");
static_assert(sizeof(UVHorseAccessoryAnimInstance) == 0x000360, "Wrong size on UVHorseAccessoryAnimInstance");
static_assert(offsetof(UVHorseAccessoryAnimInstance, MainSkeletalMeshComponent) == 0x000358, "Member 'UVHorseAccessoryAnimInstance::MainSkeletalMeshComponent' has a wrong offset!");

// Class Altar.NiPSysEmitterCtlr
// 0x0010 (0x0098 - 0x0088)
class UNiPSysEmitterCtlr final : public UNiPSysModifierCtlr
{
public:
	class UNiPSysEmitterCtlrData*                 Data;                                              // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiInterpolator*                        VisibilityInterpolator;                            // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysEmitterCtlr">();
	}
	static class UNiPSysEmitterCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysEmitterCtlr>();
	}
};
static_assert(alignof(UNiPSysEmitterCtlr) == 0x000008, "Wrong alignment on UNiPSysEmitterCtlr");
static_assert(sizeof(UNiPSysEmitterCtlr) == 0x000098, "Wrong size on UNiPSysEmitterCtlr");
static_assert(offsetof(UNiPSysEmitterCtlr, Data) == 0x000088, "Member 'UNiPSysEmitterCtlr::Data' has a wrong offset!");
static_assert(offsetof(UNiPSysEmitterCtlr, VisibilityInterpolator) == 0x000090, "Member 'UNiPSysEmitterCtlr::VisibilityInterpolator' has a wrong offset!");

// Class Altar.VHUDInfoViewModel
// 0x00D0 (0x01A0 - 0x00D0)
class UVHUDInfoViewModel final : public UVViewModelBase
{
public:
	class FText                                   TargetedItemName;                                  // 0x00D0(0x0018)(NativeAccessSpecifierPrivate)
	class FText                                   TargetedDoorDestinationName;                       // 0x00E8(0x0018)(NativeAccessSpecifierPrivate)
	struct FLegacyIconProperties                  LastIconModifiedProperties;                        // 0x0100(0x0028)(NativeAccessSpecifierPrivate)
	TMap<ELegacyHudInfoIcon, struct FLegacyIconProperties> IconsProperties;                          // 0x0128(0x0050)(NativeAccessSpecifierPrivate)
	struct FLegacyActionProperties                ActionProperties;                                  // 0x0178(0x0020)(NativeAccessSpecifierPrivate)
	bool                                          bIsTelekinesisActive;                              // 0x0198(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEmptyContainer;                                 // 0x0199(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19A[0x6];                                      // 0x019A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActionProperties(const struct FLegacyActionProperties& NewProperties);
	void SetIconsProperties(const TMap<ELegacyHudInfoIcon, struct FLegacyIconProperties>& NewProperties);
	void SetIsEmptyContainer(const bool bIsEmpty);
	void SetIsTelekinesisActive(bool bNewValue);
	void SetLastIconModifiedProperties(const struct FLegacyIconProperties& NewProperties);
	void SetTargetedDoorDestinationName(const class FText& NewName);
	void SetTargetedItemName(const class FText& NewName);

	const struct FLegacyActionProperties GetActionProperties() const;
	const TMap<ELegacyHudInfoIcon, struct FLegacyIconProperties> GetIconsProperties() const;
	const bool GetIsEmptyContainer() const;
	bool GetIsTelekinesisActive() const;
	const struct FLegacyIconProperties GetLastIconModifiedProperties() const;
	const class FText GetTargetedDoorDestinationName() const;
	const class FText GetTargetedItemName() const;
	bool HasContent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHUDInfoViewModel">();
	}
	static class UVHUDInfoViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHUDInfoViewModel>();
	}
};
static_assert(alignof(UVHUDInfoViewModel) == 0x000008, "Wrong alignment on UVHUDInfoViewModel");
static_assert(sizeof(UVHUDInfoViewModel) == 0x0001A0, "Wrong size on UVHUDInfoViewModel");
static_assert(offsetof(UVHUDInfoViewModel, TargetedItemName) == 0x0000D0, "Member 'UVHUDInfoViewModel::TargetedItemName' has a wrong offset!");
static_assert(offsetof(UVHUDInfoViewModel, TargetedDoorDestinationName) == 0x0000E8, "Member 'UVHUDInfoViewModel::TargetedDoorDestinationName' has a wrong offset!");
static_assert(offsetof(UVHUDInfoViewModel, LastIconModifiedProperties) == 0x000100, "Member 'UVHUDInfoViewModel::LastIconModifiedProperties' has a wrong offset!");
static_assert(offsetof(UVHUDInfoViewModel, IconsProperties) == 0x000128, "Member 'UVHUDInfoViewModel::IconsProperties' has a wrong offset!");
static_assert(offsetof(UVHUDInfoViewModel, ActionProperties) == 0x000178, "Member 'UVHUDInfoViewModel::ActionProperties' has a wrong offset!");
static_assert(offsetof(UVHUDInfoViewModel, bIsTelekinesisActive) == 0x000198, "Member 'UVHUDInfoViewModel::bIsTelekinesisActive' has a wrong offset!");
static_assert(offsetof(UVHUDInfoViewModel, bIsEmptyContainer) == 0x000199, "Member 'UVHUDInfoViewModel::bIsEmptyContainer' has a wrong offset!");

// Class Altar.NiPSysEmitterDeclinationVarCtlr
// 0x0000 (0x0090 - 0x0090)
class UNiPSysEmitterDeclinationVarCtlr final : public UNiPSysModifierFloatCtlr
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysEmitterDeclinationVarCtlr">();
	}
	static class UNiPSysEmitterDeclinationVarCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysEmitterDeclinationVarCtlr>();
	}
};
static_assert(alignof(UNiPSysEmitterDeclinationVarCtlr) == 0x000008, "Wrong alignment on UNiPSysEmitterDeclinationVarCtlr");
static_assert(sizeof(UNiPSysEmitterDeclinationVarCtlr) == 0x000090, "Wrong size on UNiPSysEmitterDeclinationVarCtlr");

// Class Altar.NiPSysEmitterLifeSpanCtlr
// 0x0000 (0x0090 - 0x0090)
class UNiPSysEmitterLifeSpanCtlr final : public UNiPSysModifierFloatCtlr
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysEmitterLifeSpanCtlr">();
	}
	static class UNiPSysEmitterLifeSpanCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysEmitterLifeSpanCtlr>();
	}
};
static_assert(alignof(UNiPSysEmitterLifeSpanCtlr) == 0x000008, "Wrong alignment on UNiPSysEmitterLifeSpanCtlr");
static_assert(sizeof(UNiPSysEmitterLifeSpanCtlr) == 0x000090, "Wrong size on UNiPSysEmitterLifeSpanCtlr");

// Class Altar.VHUDSubtitleViewModel
// 0x0088 (0x0158 - 0x00D0)
class UVHUDSubtitleViewModel : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void(class UVAltarNotificationBaseWidget* NotificationWidget)> OnNotificationSetActiveUpdated; // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnNotificationFinishedToBeConsumed;                // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x00F0(0x0018)(NativeAccessSpecifierPrivate)
	bool                                          bSubtitleVisibility;                               // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyNotificationProperties          Notification;                                      // 0x0110(0x0030)(NativeAccessSpecifierPrivate)
	TArray<struct FLegacyNotificationProperties>  NotificationQueue;                                 // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bNotificationVisibility;                           // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNotification(const struct FLegacyNotificationProperties& Properties);
	void ConsumeNotification();
	void ResumeNotificationQueue();
	void SetNotification(const struct FLegacyNotificationProperties& NewProperties);
	void SetNotificationVisibility(bool bNewVisibility);
	void SetSubtitle(const class FText& NewText);
	void SetSubtitleVisibility(bool bNewVisibility);
	void UpdateNotificationQueue();

	const struct FLegacyNotificationProperties GetNotification() const;
	bool GetNotificationVisibility() const;
	const class FText GetSubtitle() const;
	bool GetSubtitleVisibility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHUDSubtitleViewModel">();
	}
	static class UVHUDSubtitleViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHUDSubtitleViewModel>();
	}
};
static_assert(alignof(UVHUDSubtitleViewModel) == 0x000008, "Wrong alignment on UVHUDSubtitleViewModel");
static_assert(sizeof(UVHUDSubtitleViewModel) == 0x000158, "Wrong size on UVHUDSubtitleViewModel");
static_assert(offsetof(UVHUDSubtitleViewModel, OnNotificationSetActiveUpdated) == 0x0000D0, "Member 'UVHUDSubtitleViewModel::OnNotificationSetActiveUpdated' has a wrong offset!");
static_assert(offsetof(UVHUDSubtitleViewModel, OnNotificationFinishedToBeConsumed) == 0x0000E0, "Member 'UVHUDSubtitleViewModel::OnNotificationFinishedToBeConsumed' has a wrong offset!");
static_assert(offsetof(UVHUDSubtitleViewModel, Subtitle) == 0x0000F0, "Member 'UVHUDSubtitleViewModel::Subtitle' has a wrong offset!");
static_assert(offsetof(UVHUDSubtitleViewModel, bSubtitleVisibility) == 0x000108, "Member 'UVHUDSubtitleViewModel::bSubtitleVisibility' has a wrong offset!");
static_assert(offsetof(UVHUDSubtitleViewModel, Notification) == 0x000110, "Member 'UVHUDSubtitleViewModel::Notification' has a wrong offset!");
static_assert(offsetof(UVHUDSubtitleViewModel, NotificationQueue) == 0x000140, "Member 'UVHUDSubtitleViewModel::NotificationQueue' has a wrong offset!");
static_assert(offsetof(UVHUDSubtitleViewModel, bNotificationVisibility) == 0x000150, "Member 'UVHUDSubtitleViewModel::bNotificationVisibility' has a wrong offset!");

// Class Altar.VHUDSaveNotificationViewModel
// 0x0000 (0x0158 - 0x0158)
class UVHUDSaveNotificationViewModel final : public UVHUDSubtitleViewModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHUDSaveNotificationViewModel">();
	}
	static class UVHUDSaveNotificationViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHUDSaveNotificationViewModel>();
	}
};
static_assert(alignof(UVHUDSaveNotificationViewModel) == 0x000008, "Wrong alignment on UVHUDSaveNotificationViewModel");
static_assert(sizeof(UVHUDSaveNotificationViewModel) == 0x000158, "Wrong size on UVHUDSaveNotificationViewModel");

// Class Altar.NiPSysGravityModifier
// 0x0038 (0x0098 - 0x0060)
class UNiPSysGravityModifier final : public UNiPSysModifier
{
public:
	class UNiAvObject*                            GravityObject;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GravityAxis;                                       // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Decay;                                             // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EForceType                                    ForceType;                                         // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Turbulence;                                        // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurbulenceScale;                                   // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WorldAligned;                                      // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysGravityModifier">();
	}
	static class UNiPSysGravityModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysGravityModifier>();
	}
};
static_assert(alignof(UNiPSysGravityModifier) == 0x000008, "Wrong alignment on UNiPSysGravityModifier");
static_assert(sizeof(UNiPSysGravityModifier) == 0x000098, "Wrong size on UNiPSysGravityModifier");
static_assert(offsetof(UNiPSysGravityModifier, GravityObject) == 0x000060, "Member 'UNiPSysGravityModifier::GravityObject' has a wrong offset!");
static_assert(offsetof(UNiPSysGravityModifier, GravityAxis) == 0x000068, "Member 'UNiPSysGravityModifier::GravityAxis' has a wrong offset!");
static_assert(offsetof(UNiPSysGravityModifier, Decay) == 0x000080, "Member 'UNiPSysGravityModifier::Decay' has a wrong offset!");
static_assert(offsetof(UNiPSysGravityModifier, Strength) == 0x000084, "Member 'UNiPSysGravityModifier::Strength' has a wrong offset!");
static_assert(offsetof(UNiPSysGravityModifier, ForceType) == 0x000088, "Member 'UNiPSysGravityModifier::ForceType' has a wrong offset!");
static_assert(offsetof(UNiPSysGravityModifier, Turbulence) == 0x00008C, "Member 'UNiPSysGravityModifier::Turbulence' has a wrong offset!");
static_assert(offsetof(UNiPSysGravityModifier, TurbulenceScale) == 0x000090, "Member 'UNiPSysGravityModifier::TurbulenceScale' has a wrong offset!");
static_assert(offsetof(UNiPSysGravityModifier, WorldAligned) == 0x000094, "Member 'UNiPSysGravityModifier::WorldAligned' has a wrong offset!");

// Class Altar.NiPSysMeshUpdateModifier
// 0x0018 (0x0078 - 0x0060)
class UNiPSysMeshUpdateModifier final : public UNiPSysModifier
{
public:
	int64                                         NumMeshes;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiAvObject*>                    Meshes;                                            // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysMeshUpdateModifier">();
	}
	static class UNiPSysMeshUpdateModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysMeshUpdateModifier>();
	}
};
static_assert(alignof(UNiPSysMeshUpdateModifier) == 0x000008, "Wrong alignment on UNiPSysMeshUpdateModifier");
static_assert(sizeof(UNiPSysMeshUpdateModifier) == 0x000078, "Wrong size on UNiPSysMeshUpdateModifier");
static_assert(offsetof(UNiPSysMeshUpdateModifier, NumMeshes) == 0x000060, "Member 'UNiPSysMeshUpdateModifier::NumMeshes' has a wrong offset!");
static_assert(offsetof(UNiPSysMeshUpdateModifier, Meshes) == 0x000068, "Member 'UNiPSysMeshUpdateModifier::Meshes' has a wrong offset!");

// Class Altar.NiPSysModifierActiveCtlr
// 0x0008 (0x0090 - 0x0088)
class UNiPSysModifierActiveCtlr final : public UNiPSysModifierBoolCtlr
{
public:
	class UNiVisData*                             Data;                                              // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysModifierActiveCtlr">();
	}
	static class UNiPSysModifierActiveCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysModifierActiveCtlr>();
	}
};
static_assert(alignof(UNiPSysModifierActiveCtlr) == 0x000008, "Wrong alignment on UNiPSysModifierActiveCtlr");
static_assert(sizeof(UNiPSysModifierActiveCtlr) == 0x000090, "Wrong size on UNiPSysModifierActiveCtlr");
static_assert(offsetof(UNiPSysModifierActiveCtlr, Data) == 0x000088, "Member 'UNiPSysModifierActiveCtlr::Data' has a wrong offset!");

// Class Altar.VAltarNavigableSlider
// 0x0078 (0x0588 - 0x0510)
class UVAltarNavigableSlider : public UVNavigableSlider
{
public:
	class UWidget*                                Handle;                                            // 0x0510(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ValueLabel;                                        // 0x0518(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                DecreaseButton;                                    // 0x0520(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                IncreaseButton;                                    // 0x0528(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SliderClampValues;                                 // 0x0530(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderStepSize;                                    // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderStartupValue;                                // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLabelEnabled;                                     // 0x0548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_549[0x3];                                      // 0x0549(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LabelColor;                                        // 0x054C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumFractionalDigits;                           // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsButtonInputContinuous;                          // 0x0560(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCapturingMouseWheelInput;                       // 0x0561(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_562[0x26];                                     // 0x0562(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecreaseValue();
	void EndControllerValueDecrease();
	void EndControllerValueIncrease();
	void HandleOnValueChanged(float NewValue);
	void IncreaseValue();
	void InitializeSlider(float MinValue, float MaxValue, float StepSize, float StartupValue);
	void OnDecreaseButtonPressed();
	void OnDecreaseButtonReleased();
	void OnIncreaseButtonPressed();
	void OnIncreaseButtonReleased();
	void SetValue(float Value);
	void StartControllerValueDecrease();
	void StartControllerValueIncrease();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableSlider">();
	}
	static class UVAltarNavigableSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableSlider>();
	}
};
static_assert(alignof(UVAltarNavigableSlider) == 0x000008, "Wrong alignment on UVAltarNavigableSlider");
static_assert(sizeof(UVAltarNavigableSlider) == 0x000588, "Wrong size on UVAltarNavigableSlider");
static_assert(offsetof(UVAltarNavigableSlider, Handle) == 0x000510, "Member 'UVAltarNavigableSlider::Handle' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableSlider, ValueLabel) == 0x000518, "Member 'UVAltarNavigableSlider::ValueLabel' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableSlider, DecreaseButton) == 0x000520, "Member 'UVAltarNavigableSlider::DecreaseButton' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableSlider, IncreaseButton) == 0x000528, "Member 'UVAltarNavigableSlider::IncreaseButton' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableSlider, SliderClampValues) == 0x000530, "Member 'UVAltarNavigableSlider::SliderClampValues' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableSlider, SliderStepSize) == 0x000540, "Member 'UVAltarNavigableSlider::SliderStepSize' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableSlider, SliderStartupValue) == 0x000544, "Member 'UVAltarNavigableSlider::SliderStartupValue' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableSlider, bLabelEnabled) == 0x000548, "Member 'UVAltarNavigableSlider::bLabelEnabled' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableSlider, LabelColor) == 0x00054C, "Member 'UVAltarNavigableSlider::LabelColor' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableSlider, MaximumFractionalDigits) == 0x00055C, "Member 'UVAltarNavigableSlider::MaximumFractionalDigits' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableSlider, bIsButtonInputContinuous) == 0x000560, "Member 'UVAltarNavigableSlider::bIsButtonInputContinuous' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableSlider, bIsCapturingMouseWheelInput) == 0x000561, "Member 'UVAltarNavigableSlider::bIsCapturingMouseWheelInput' has a wrong offset!");

// Class Altar.VDotedAltarNavigableSlider
// 0x0118 (0x06A0 - 0x0588)
class UVDotedAltarNavigableSlider : public UVAltarNavigableSlider
{
public:
	class UCanvasPanel*                           DotsParent;                                        // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                DotsClass;                                         // 0x0590(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfDots;                                      // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59C[0x4];                                      // 0x059C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            DotsBrush;                                         // 0x05A0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector2D                              DotsSize;                                          // 0x0670(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DotsOffset;                                        // 0x0680(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_690[0x10];                                     // 0x0690(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllDots();
	void GenerateDot();
	void OnDotCreated(class UUserWidget* NewDot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDotedAltarNavigableSlider">();
	}
	static class UVDotedAltarNavigableSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDotedAltarNavigableSlider>();
	}
};
static_assert(alignof(UVDotedAltarNavigableSlider) == 0x000010, "Wrong alignment on UVDotedAltarNavigableSlider");
static_assert(sizeof(UVDotedAltarNavigableSlider) == 0x0006A0, "Wrong size on UVDotedAltarNavigableSlider");
static_assert(offsetof(UVDotedAltarNavigableSlider, DotsParent) == 0x000588, "Member 'UVDotedAltarNavigableSlider::DotsParent' has a wrong offset!");
static_assert(offsetof(UVDotedAltarNavigableSlider, DotsClass) == 0x000590, "Member 'UVDotedAltarNavigableSlider::DotsClass' has a wrong offset!");
static_assert(offsetof(UVDotedAltarNavigableSlider, NumberOfDots) == 0x000598, "Member 'UVDotedAltarNavigableSlider::NumberOfDots' has a wrong offset!");
static_assert(offsetof(UVDotedAltarNavigableSlider, DotsBrush) == 0x0005A0, "Member 'UVDotedAltarNavigableSlider::DotsBrush' has a wrong offset!");
static_assert(offsetof(UVDotedAltarNavigableSlider, DotsSize) == 0x000670, "Member 'UVDotedAltarNavigableSlider::DotsSize' has a wrong offset!");
static_assert(offsetof(UVDotedAltarNavigableSlider, DotsOffset) == 0x000680, "Member 'UVDotedAltarNavigableSlider::DotsOffset' has a wrong offset!");

// Class Altar.VShowroomSubsystem
// 0x0060 (0x0090 - 0x0030)
class UVShowroomSubsystem final : public UGameInstanceSubsystem
{
public:
	struct FShowroomHDRIBackdropParams            HDRIBackdropParams;                                // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnShowroomBackdropParamsUpdated;                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 SpawnedActorAssetPath;                             // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpawnDistanceFactor;                               // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               SkySphereMID;                                      // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector CalculateSpawnLocation();
	void CreateShowroomCharacter();
	void HideDefaultBackgroundScene(bool bHidden);
	void RemoveCharacterBodyPart(EBipedModularBodySlot Slot);
	void SetActorAnimation(class AActor* SpawnedActor, const class FString& AnimationPath);
	void SetBackgroundHDRI(const class FString& HDRITexturePath);
	void SetCharacterBodyPart(EBipedModularBodySlot Slot, const class FString& FormPath);
	void SetCharacterRace(const class FString& RaceFormPath);
	void SetCharacterSex(bool bIsMale);
	void SetHDRIRotation(float Rotation);
	void SetLightsHidden(bool bHidden);
	void SetPropsHidden(bool bHidden);
	void SetSkylightIntensity(float Intensity);
	TArray<class AActor*> SpawnActorsByAssetsPath(const TArray<class FString>& InPaths, const struct FVector& CenterPoint, const struct FVector& BoxExtent, int32 Offset, bool* bRemainNotSpawned, TArray<class FString>* OutPaths);
	void SpawnAnimatedActor(const class FString& BlueprintPath, const class FString& AnimationPath);
	class AActor* SpawnBlueprintActor(const class FString& BlueprintPath);

	class AVPairedCharacter* GetShowroomCharacter() const;
	class AActor* GetTargetPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VShowroomSubsystem">();
	}
	static class UVShowroomSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVShowroomSubsystem>();
	}
};
static_assert(alignof(UVShowroomSubsystem) == 0x000008, "Wrong alignment on UVShowroomSubsystem");
static_assert(sizeof(UVShowroomSubsystem) == 0x000090, "Wrong size on UVShowroomSubsystem");
static_assert(offsetof(UVShowroomSubsystem, HDRIBackdropParams) == 0x000030, "Member 'UVShowroomSubsystem::HDRIBackdropParams' has a wrong offset!");
static_assert(offsetof(UVShowroomSubsystem, OnShowroomBackdropParamsUpdated) == 0x000040, "Member 'UVShowroomSubsystem::OnShowroomBackdropParamsUpdated' has a wrong offset!");
static_assert(offsetof(UVShowroomSubsystem, SpawnedActorAssetPath) == 0x000050, "Member 'UVShowroomSubsystem::SpawnedActorAssetPath' has a wrong offset!");
static_assert(offsetof(UVShowroomSubsystem, SpawnDistanceFactor) == 0x000060, "Member 'UVShowroomSubsystem::SpawnDistanceFactor' has a wrong offset!");
static_assert(offsetof(UVShowroomSubsystem, SkySphereMID) == 0x000068, "Member 'UVShowroomSubsystem::SkySphereMID' has a wrong offset!");

// Class Altar.NiPSysPositionModifier
// 0x0000 (0x0060 - 0x0060)
class UNiPSysPositionModifier final : public UNiPSysModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysPositionModifier">();
	}
	static class UNiPSysPositionModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysPositionModifier>();
	}
};
static_assert(alignof(UNiPSysPositionModifier) == 0x000008, "Wrong alignment on UNiPSysPositionModifier");
static_assert(sizeof(UNiPSysPositionModifier) == 0x000060, "Wrong size on UNiPSysPositionModifier");

// Class Altar.VAltarMenuDefaultsTable
// 0x0050 (0x0100 - 0x00B0)
class UVAltarMenuDefaultsTable final : public UDataTable
{
public:
	TMap<TSoftClassPtr<class UClass>, struct FVAltarMenuDefaults> MenuDefaultsMap;                   // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarMenuDefaultsTable">();
	}
	static class UVAltarMenuDefaultsTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarMenuDefaultsTable>();
	}
};
static_assert(alignof(UVAltarMenuDefaultsTable) == 0x000008, "Wrong alignment on UVAltarMenuDefaultsTable");
static_assert(sizeof(UVAltarMenuDefaultsTable) == 0x000100, "Wrong size on UVAltarMenuDefaultsTable");
static_assert(offsetof(UVAltarMenuDefaultsTable, MenuDefaultsMap) == 0x0000B0, "Member 'UVAltarMenuDefaultsTable::MenuDefaultsMap' has a wrong offset!");

// Class Altar.NiPSysResetOnLoopCtlr
// 0x0000 (0x0068 - 0x0068)
class UNiPSysResetOnLoopCtlr final : public UNiTimeController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysResetOnLoopCtlr">();
	}
	static class UNiPSysResetOnLoopCtlr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysResetOnLoopCtlr>();
	}
};
static_assert(alignof(UNiPSysResetOnLoopCtlr) == 0x000008, "Wrong alignment on UNiPSysResetOnLoopCtlr");
static_assert(sizeof(UNiPSysResetOnLoopCtlr) == 0x000068, "Wrong size on UNiPSysResetOnLoopCtlr");

// Class Altar.VSpellCastMultiAnimInstance
// 0x00A0 (0x0440 - 0x03A0)
class UVSpellCastMultiAnimInstance final : public UVLayerCharacterAnimInstance
{
public:
	struct FSpellCastMultiAnimSet                 AnimSet;                                           // 0x03A0(0x0068)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      CastTargetLeftAnim;                                // 0x0408(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      CastTargetRightAnim;                               // 0x0410(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      CastSelfLeftAnim;                                  // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      CastSelfRightAnim;                                 // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      CastTouchLeftAnim;                                 // 0x0428(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      CastTouchRightAnim;                                // 0x0430(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCastSelfLeftEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCastSelfRightEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCastTargeRightEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCastTargetLeftEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCastTouchLeftEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCastTouchRightEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSpellCastMultiAnimInstance">();
	}
	static class UVSpellCastMultiAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSpellCastMultiAnimInstance>();
	}
};
static_assert(alignof(UVSpellCastMultiAnimInstance) == 0x000010, "Wrong alignment on UVSpellCastMultiAnimInstance");
static_assert(sizeof(UVSpellCastMultiAnimInstance) == 0x000440, "Wrong size on UVSpellCastMultiAnimInstance");
static_assert(offsetof(UVSpellCastMultiAnimInstance, AnimSet) == 0x0003A0, "Member 'UVSpellCastMultiAnimInstance::AnimSet' has a wrong offset!");
static_assert(offsetof(UVSpellCastMultiAnimInstance, CastTargetLeftAnim) == 0x000408, "Member 'UVSpellCastMultiAnimInstance::CastTargetLeftAnim' has a wrong offset!");
static_assert(offsetof(UVSpellCastMultiAnimInstance, CastTargetRightAnim) == 0x000410, "Member 'UVSpellCastMultiAnimInstance::CastTargetRightAnim' has a wrong offset!");
static_assert(offsetof(UVSpellCastMultiAnimInstance, CastSelfLeftAnim) == 0x000418, "Member 'UVSpellCastMultiAnimInstance::CastSelfLeftAnim' has a wrong offset!");
static_assert(offsetof(UVSpellCastMultiAnimInstance, CastSelfRightAnim) == 0x000420, "Member 'UVSpellCastMultiAnimInstance::CastSelfRightAnim' has a wrong offset!");
static_assert(offsetof(UVSpellCastMultiAnimInstance, CastTouchLeftAnim) == 0x000428, "Member 'UVSpellCastMultiAnimInstance::CastTouchLeftAnim' has a wrong offset!");
static_assert(offsetof(UVSpellCastMultiAnimInstance, CastTouchRightAnim) == 0x000430, "Member 'UVSpellCastMultiAnimInstance::CastTouchRightAnim' has a wrong offset!");

// Class Altar.NiPSysRotationModifier
// 0x0040 (0x00A0 - 0x0060)
class UNiPSysRotationModifier final : public UNiPSysModifier
{
public:
	float                                         InitialRotSpeed;                                   // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialRotSpeedVariation;                          // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVTSVector4f                           UnknownVector;                                     // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         UnknownByte;                                       // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialRotAngle;                                   // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialRotAngleVariation;                          // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomRotSpeedSign;                                // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomInitialAxis;                                 // 0x0085(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86[0x2];                                       // 0x0086(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialAxis;                                       // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysRotationModifier">();
	}
	static class UNiPSysRotationModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysRotationModifier>();
	}
};
static_assert(alignof(UNiPSysRotationModifier) == 0x000008, "Wrong alignment on UNiPSysRotationModifier");
static_assert(sizeof(UNiPSysRotationModifier) == 0x0000A0, "Wrong size on UNiPSysRotationModifier");
static_assert(offsetof(UNiPSysRotationModifier, InitialRotSpeed) == 0x000060, "Member 'UNiPSysRotationModifier::InitialRotSpeed' has a wrong offset!");
static_assert(offsetof(UNiPSysRotationModifier, InitialRotSpeedVariation) == 0x000064, "Member 'UNiPSysRotationModifier::InitialRotSpeedVariation' has a wrong offset!");
static_assert(offsetof(UNiPSysRotationModifier, UnknownVector) == 0x000068, "Member 'UNiPSysRotationModifier::UnknownVector' has a wrong offset!");
static_assert(offsetof(UNiPSysRotationModifier, UnknownByte) == 0x000078, "Member 'UNiPSysRotationModifier::UnknownByte' has a wrong offset!");
static_assert(offsetof(UNiPSysRotationModifier, InitialRotAngle) == 0x00007C, "Member 'UNiPSysRotationModifier::InitialRotAngle' has a wrong offset!");
static_assert(offsetof(UNiPSysRotationModifier, InitialRotAngleVariation) == 0x000080, "Member 'UNiPSysRotationModifier::InitialRotAngleVariation' has a wrong offset!");
static_assert(offsetof(UNiPSysRotationModifier, RandomRotSpeedSign) == 0x000084, "Member 'UNiPSysRotationModifier::RandomRotSpeedSign' has a wrong offset!");
static_assert(offsetof(UNiPSysRotationModifier, RandomInitialAxis) == 0x000085, "Member 'UNiPSysRotationModifier::RandomInitialAxis' has a wrong offset!");
static_assert(offsetof(UNiPSysRotationModifier, InitialAxis) == 0x000088, "Member 'UNiPSysRotationModifier::InitialAxis' has a wrong offset!");

// Class Altar.VModernEnchantmentItem
// 0x0050 (0x0078 - 0x0028)
class UVModernEnchantmentItem final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const struct FVModernEnchantmentItemProperties& Value);

	const int32 GetIndex() const;
	const struct FVModernEnchantmentItemProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernEnchantmentItem">();
	}
	static class UVModernEnchantmentItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernEnchantmentItem>();
	}
};
static_assert(alignof(UVModernEnchantmentItem) == 0x000008, "Wrong alignment on UVModernEnchantmentItem");
static_assert(sizeof(UVModernEnchantmentItem) == 0x000078, "Wrong size on UVModernEnchantmentItem");

// Class Altar.NiPSysSpawnModifier
// 0x0028 (0x0088 - 0x0060)
class UNiPSysSpawnModifier final : public UNiPSysModifier
{
public:
	int32                                         NumSpawnGenerations;                               // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentageSpawned;                                 // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinNumToSpawn;                                     // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumToSpawn;                                     // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnSpeedVariation;                               // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnDirectionVariation;                           // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpanVariation;                                 // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldShiftSpawnSpeedAddition;                      // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiPSysSpawnModifier">();
	}
	static class UNiPSysSpawnModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiPSysSpawnModifier>();
	}
};
static_assert(alignof(UNiPSysSpawnModifier) == 0x000008, "Wrong alignment on UNiPSysSpawnModifier");
static_assert(sizeof(UNiPSysSpawnModifier) == 0x000088, "Wrong size on UNiPSysSpawnModifier");
static_assert(offsetof(UNiPSysSpawnModifier, NumSpawnGenerations) == 0x000060, "Member 'UNiPSysSpawnModifier::NumSpawnGenerations' has a wrong offset!");
static_assert(offsetof(UNiPSysSpawnModifier, PercentageSpawned) == 0x000064, "Member 'UNiPSysSpawnModifier::PercentageSpawned' has a wrong offset!");
static_assert(offsetof(UNiPSysSpawnModifier, MinNumToSpawn) == 0x000068, "Member 'UNiPSysSpawnModifier::MinNumToSpawn' has a wrong offset!");
static_assert(offsetof(UNiPSysSpawnModifier, MaxNumToSpawn) == 0x00006C, "Member 'UNiPSysSpawnModifier::MaxNumToSpawn' has a wrong offset!");
static_assert(offsetof(UNiPSysSpawnModifier, SpawnSpeedVariation) == 0x000070, "Member 'UNiPSysSpawnModifier::SpawnSpeedVariation' has a wrong offset!");
static_assert(offsetof(UNiPSysSpawnModifier, SpawnDirectionVariation) == 0x000074, "Member 'UNiPSysSpawnModifier::SpawnDirectionVariation' has a wrong offset!");
static_assert(offsetof(UNiPSysSpawnModifier, LifeSpan) == 0x000078, "Member 'UNiPSysSpawnModifier::LifeSpan' has a wrong offset!");
static_assert(offsetof(UNiPSysSpawnModifier, LifeSpanVariation) == 0x00007C, "Member 'UNiPSysSpawnModifier::LifeSpanVariation' has a wrong offset!");
static_assert(offsetof(UNiPSysSpawnModifier, WorldShiftSpawnSpeedAddition) == 0x000080, "Member 'UNiPSysSpawnModifier::WorldShiftSpawnSpeedAddition' has a wrong offset!");

// Class Altar.NiRawImageData
// 0x0038 (0x0070 - 0x0038)
class UNiRawImageData final : public UNiObject
{
public:
	int64                                         Width;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Height;                                            // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EImageType                                    ImageTypeFlag;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FColor>                         RGBImageData;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         RGBAImageData;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiRawImageData">();
	}
	static class UNiRawImageData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiRawImageData>();
	}
};
static_assert(alignof(UNiRawImageData) == 0x000008, "Wrong alignment on UNiRawImageData");
static_assert(sizeof(UNiRawImageData) == 0x000070, "Wrong size on UNiRawImageData");
static_assert(offsetof(UNiRawImageData, Width) == 0x000038, "Member 'UNiRawImageData::Width' has a wrong offset!");
static_assert(offsetof(UNiRawImageData, Height) == 0x000040, "Member 'UNiRawImageData::Height' has a wrong offset!");
static_assert(offsetof(UNiRawImageData, ImageTypeFlag) == 0x000048, "Member 'UNiRawImageData::ImageTypeFlag' has a wrong offset!");
static_assert(offsetof(UNiRawImageData, RGBImageData) == 0x000050, "Member 'UNiRawImageData::RGBImageData' has a wrong offset!");
static_assert(offsetof(UNiRawImageData, RGBAImageData) == 0x000060, "Member 'UNiRawImageData::RGBAImageData' has a wrong offset!");

// Class Altar.NiSkinPartition
// 0x0040 (0x0078 - 0x0038)
class UNiSkinPartition final : public UNiObject
{
public:
	int64                                         NumPartitions;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DataSize;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         VertexSize;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBSVertexDesc                          VertexDesc;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UBSVertexDataSSE*>               VertexData;                                        // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class USkinPartition*>                 Partitions;                                        // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiSkinPartition">();
	}
	static class UNiSkinPartition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiSkinPartition>();
	}
};
static_assert(alignof(UNiSkinPartition) == 0x000008, "Wrong alignment on UNiSkinPartition");
static_assert(sizeof(UNiSkinPartition) == 0x000078, "Wrong size on UNiSkinPartition");
static_assert(offsetof(UNiSkinPartition, NumPartitions) == 0x000038, "Member 'UNiSkinPartition::NumPartitions' has a wrong offset!");
static_assert(offsetof(UNiSkinPartition, DataSize) == 0x000040, "Member 'UNiSkinPartition::DataSize' has a wrong offset!");
static_assert(offsetof(UNiSkinPartition, VertexSize) == 0x000048, "Member 'UNiSkinPartition::VertexSize' has a wrong offset!");
static_assert(offsetof(UNiSkinPartition, VertexDesc) == 0x000050, "Member 'UNiSkinPartition::VertexDesc' has a wrong offset!");
static_assert(offsetof(UNiSkinPartition, VertexData) == 0x000058, "Member 'UNiSkinPartition::VertexData' has a wrong offset!");
static_assert(offsetof(UNiSkinPartition, Partitions) == 0x000068, "Member 'UNiSkinPartition::Partitions' has a wrong offset!");

// Class Altar.VBowAttackAnimInstance
// 0x0020 (0x03C0 - 0x03A0)
class UVBowAttackAnimInstance final : public UVLayerCharacterAnimInstance
{
public:
	struct FVBowAttack                            AnimSet;                                           // 0x03A0(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBowAttackAnimInstance">();
	}
	static class UVBowAttackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBowAttackAnimInstance>();
	}
};
static_assert(alignof(UVBowAttackAnimInstance) == 0x000010, "Wrong alignment on UVBowAttackAnimInstance");
static_assert(sizeof(UVBowAttackAnimInstance) == 0x0003C0, "Wrong size on UVBowAttackAnimInstance");
static_assert(offsetof(UVBowAttackAnimInstance, AnimSet) == 0x0003A0, "Member 'UVBowAttackAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.NiSourceTexture
// 0x0030 (0x0098 - 0x0068)
class UNiSourceTexture final : public UNiTexture
{
public:
	uint8                                         UseExternal;                                       // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseInternal;                                       // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNifString                             Filename;                                          // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UNiPixelFormat*                         PixelData;                                         // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFormatPrefs*                           FormatPrefs;                                       // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsStatic;                                          // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DirectRender;                                      // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PersistRenderData;                                 // 0x0092(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiSourceTexture">();
	}
	static class UNiSourceTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiSourceTexture>();
	}
};
static_assert(alignof(UNiSourceTexture) == 0x000008, "Wrong alignment on UNiSourceTexture");
static_assert(sizeof(UNiSourceTexture) == 0x000098, "Wrong size on UNiSourceTexture");
static_assert(offsetof(UNiSourceTexture, UseExternal) == 0x000068, "Member 'UNiSourceTexture::UseExternal' has a wrong offset!");
static_assert(offsetof(UNiSourceTexture, UseInternal) == 0x000069, "Member 'UNiSourceTexture::UseInternal' has a wrong offset!");
static_assert(offsetof(UNiSourceTexture, Filename) == 0x000070, "Member 'UNiSourceTexture::Filename' has a wrong offset!");
static_assert(offsetof(UNiSourceTexture, PixelData) == 0x000080, "Member 'UNiSourceTexture::PixelData' has a wrong offset!");
static_assert(offsetof(UNiSourceTexture, FormatPrefs) == 0x000088, "Member 'UNiSourceTexture::FormatPrefs' has a wrong offset!");
static_assert(offsetof(UNiSourceTexture, IsStatic) == 0x000090, "Member 'UNiSourceTexture::IsStatic' has a wrong offset!");
static_assert(offsetof(UNiSourceTexture, DirectRender) == 0x000091, "Member 'UNiSourceTexture::DirectRender' has a wrong offset!");
static_assert(offsetof(UNiSourceTexture, PersistRenderData) == 0x000092, "Member 'UNiSourceTexture::PersistRenderData' has a wrong offset!");

// Class Altar.NiStencilProperty
// 0x0038 (0x00A0 - 0x0068)
class UNiStencilProperty final : public UNiProperty
{
public:
	int32                                         Flags_0;                                           // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StencilEnabled;                                    // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EStencilTestFunc                              StencilFunction;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         StencilRef;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         StencilMask;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStencilAction                                FailAction;                                        // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStencilAction                                ZFailAction;                                       // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStencilAction                                PassAction;                                        // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStencilDrawMode                              DrawMode;                                          // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStencilFlags                          StencilFlags;                                      // 0x0098(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiStencilProperty">();
	}
	static class UNiStencilProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiStencilProperty>();
	}
};
static_assert(alignof(UNiStencilProperty) == 0x000008, "Wrong alignment on UNiStencilProperty");
static_assert(sizeof(UNiStencilProperty) == 0x0000A0, "Wrong size on UNiStencilProperty");
static_assert(offsetof(UNiStencilProperty, Flags_0) == 0x000068, "Member 'UNiStencilProperty::Flags_0' has a wrong offset!");
static_assert(offsetof(UNiStencilProperty, StencilEnabled) == 0x00006C, "Member 'UNiStencilProperty::StencilEnabled' has a wrong offset!");
static_assert(offsetof(UNiStencilProperty, StencilFunction) == 0x000070, "Member 'UNiStencilProperty::StencilFunction' has a wrong offset!");
static_assert(offsetof(UNiStencilProperty, StencilRef) == 0x000078, "Member 'UNiStencilProperty::StencilRef' has a wrong offset!");
static_assert(offsetof(UNiStencilProperty, StencilMask) == 0x000080, "Member 'UNiStencilProperty::StencilMask' has a wrong offset!");
static_assert(offsetof(UNiStencilProperty, FailAction) == 0x000088, "Member 'UNiStencilProperty::FailAction' has a wrong offset!");
static_assert(offsetof(UNiStencilProperty, ZFailAction) == 0x00008C, "Member 'UNiStencilProperty::ZFailAction' has a wrong offset!");
static_assert(offsetof(UNiStencilProperty, PassAction) == 0x000090, "Member 'UNiStencilProperty::PassAction' has a wrong offset!");
static_assert(offsetof(UNiStencilProperty, DrawMode) == 0x000094, "Member 'UNiStencilProperty::DrawMode' has a wrong offset!");
static_assert(offsetof(UNiStencilProperty, StencilFlags) == 0x000098, "Member 'UNiStencilProperty::StencilFlags' has a wrong offset!");

// Class Altar.VCharacterAppearancePairingComponent
// 0x0088 (0x0140 - 0x00B8)
class UVCharacterAppearancePairingComponent final : public UVActorPairingComponent
{
public:
	TMulticastInlineDelegate<void(const class UVCharacterPhenotypeData* Phenotype)> OnAppearanceRefresh; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bUseProceduralHead;                                // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UVHumanoidHeadComponent> LinkedHeadMeshComponent;                           // 0x00CC(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class USkeletalMeshComponent>> LinkedBodyMeshComponents;                   // 0x00D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<TSoftObjectPtr<class UTESMagicItemForm>> CurrentDiseases;                                   // 0x00E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         VampireLevel;                                      // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ApplySenescenceLevel(const class USkeletalMeshComponent* SkeletalMesh, const class UVSenescenceLevel* Level, EVSenescenceModifiers Modifiers, int32 MaterialIndex);

	void AddNewDisease(const class UTESMagicItemForm* NewDiseaseForm);
	void CureAllDiseases();
	void ReapplyPhenotypeData(EVCharacterPhenotypeDataFilter Filter);
	void RefreshCharacterAppearance();
	void RemoveDisease(const class UTESMagicItemForm* NewDiseaseForm);
	void SetVampireLevel(int32 NewVampireLevel);

	EVSenescenceModifiers GetSenescenceModifier() const;
	int32 GetVampireLevel() const;
	bool IsAVampire() const;
	bool IsDiseaseActive(const class UTESMagicItemForm* NewDiseaseForm) const;
	bool IsSick() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterAppearancePairingComponent">();
	}
	static class UVCharacterAppearancePairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterAppearancePairingComponent>();
	}
};
static_assert(alignof(UVCharacterAppearancePairingComponent) == 0x000008, "Wrong alignment on UVCharacterAppearancePairingComponent");
static_assert(sizeof(UVCharacterAppearancePairingComponent) == 0x000140, "Wrong size on UVCharacterAppearancePairingComponent");
static_assert(offsetof(UVCharacterAppearancePairingComponent, OnAppearanceRefresh) == 0x0000B8, "Member 'UVCharacterAppearancePairingComponent::OnAppearanceRefresh' has a wrong offset!");
static_assert(offsetof(UVCharacterAppearancePairingComponent, bUseProceduralHead) == 0x0000C8, "Member 'UVCharacterAppearancePairingComponent::bUseProceduralHead' has a wrong offset!");
static_assert(offsetof(UVCharacterAppearancePairingComponent, LinkedHeadMeshComponent) == 0x0000CC, "Member 'UVCharacterAppearancePairingComponent::LinkedHeadMeshComponent' has a wrong offset!");
static_assert(offsetof(UVCharacterAppearancePairingComponent, LinkedBodyMeshComponents) == 0x0000D8, "Member 'UVCharacterAppearancePairingComponent::LinkedBodyMeshComponents' has a wrong offset!");
static_assert(offsetof(UVCharacterAppearancePairingComponent, CurrentDiseases) == 0x0000E8, "Member 'UVCharacterAppearancePairingComponent::CurrentDiseases' has a wrong offset!");
static_assert(offsetof(UVCharacterAppearancePairingComponent, VampireLevel) == 0x000138, "Member 'UVCharacterAppearancePairingComponent::VampireLevel' has a wrong offset!");

// Class Altar.NiStringPalette
// 0x0008 (0x0040 - 0x0038)
class UNiStringPalette final : public UNiObject
{
public:
	class UStringPalette*                         Palette;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiStringPalette">();
	}
	static class UNiStringPalette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiStringPalette>();
	}
};
static_assert(alignof(UNiStringPalette) == 0x000008, "Wrong alignment on UNiStringPalette");
static_assert(sizeof(UNiStringPalette) == 0x000040, "Wrong size on UNiStringPalette");
static_assert(offsetof(UNiStringPalette, Palette) == 0x000038, "Member 'UNiStringPalette::Palette' has a wrong offset!");

// Class Altar.NiTextureTransformController
// 0x0018 (0x0090 - 0x0078)
class UNiTextureTransformController final : public UNiFloatInterpController
{
public:
	bool                                          ShaderMap;                                         // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETexType                                      TextureSlot;                                       // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformMember                              Operation;                                         // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiFloatData*                           Data;                                              // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTextureTransformController">();
	}
	static class UNiTextureTransformController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTextureTransformController>();
	}
};
static_assert(alignof(UNiTextureTransformController) == 0x000008, "Wrong alignment on UNiTextureTransformController");
static_assert(sizeof(UNiTextureTransformController) == 0x000090, "Wrong size on UNiTextureTransformController");
static_assert(offsetof(UNiTextureTransformController, ShaderMap) == 0x000078, "Member 'UNiTextureTransformController::ShaderMap' has a wrong offset!");
static_assert(offsetof(UNiTextureTransformController, TextureSlot) == 0x00007C, "Member 'UNiTextureTransformController::TextureSlot' has a wrong offset!");
static_assert(offsetof(UNiTextureTransformController, Operation) == 0x000080, "Member 'UNiTextureTransformController::Operation' has a wrong offset!");
static_assert(offsetof(UNiTextureTransformController, Data) == 0x000088, "Member 'UNiTextureTransformController::Data' has a wrong offset!");

// Class Altar.VCharacterHairPieceBase
// 0x00F8 (0x0128 - 0x0030)
class UVCharacterHairPieceBase : public UDataAsset
{
public:
	bool                                          bUseHairPhysics;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FVSexAndRaceMapKey, struct FVCharacterHairPieceMeshPair> RaceAndSexSpecificHairMeshes; // 0x0038(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVCharacterHairPieceMeshPair           HairSkeletalMeshes;                                // 0x0088(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FCharacterFaceMorphAxis> SpecificMorphTarget;                           // 0x00D8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	struct FCharacterHairPieceBaseConstructResult ConstructComponent(class USkeletalMeshComponent* FaceMeshComponent, class UVCharacterPhenotypeData* Phenotype) const;
	EVFacialHairType GetFacialHairType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterHairPieceBase">();
	}
	static class UVCharacterHairPieceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterHairPieceBase>();
	}
};
static_assert(alignof(UVCharacterHairPieceBase) == 0x000008, "Wrong alignment on UVCharacterHairPieceBase");
static_assert(sizeof(UVCharacterHairPieceBase) == 0x000128, "Wrong size on UVCharacterHairPieceBase");
static_assert(offsetof(UVCharacterHairPieceBase, bUseHairPhysics) == 0x000030, "Member 'UVCharacterHairPieceBase::bUseHairPhysics' has a wrong offset!");
static_assert(offsetof(UVCharacterHairPieceBase, RaceAndSexSpecificHairMeshes) == 0x000038, "Member 'UVCharacterHairPieceBase::RaceAndSexSpecificHairMeshes' has a wrong offset!");
static_assert(offsetof(UVCharacterHairPieceBase, HairSkeletalMeshes) == 0x000088, "Member 'UVCharacterHairPieceBase::HairSkeletalMeshes' has a wrong offset!");
static_assert(offsetof(UVCharacterHairPieceBase, SpecificMorphTarget) == 0x0000D8, "Member 'UVCharacterHairPieceBase::SpecificMorphTarget' has a wrong offset!");

// Class Altar.VCharacterHairPiece_Hair
// 0x0000 (0x0128 - 0x0128)
class UVCharacterHairPiece_Hair final : public UVCharacterHairPieceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterHairPiece_Hair">();
	}
	static class UVCharacterHairPiece_Hair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterHairPiece_Hair>();
	}
};
static_assert(alignof(UVCharacterHairPiece_Hair) == 0x000008, "Wrong alignment on UVCharacterHairPiece_Hair");
static_assert(sizeof(UVCharacterHairPiece_Hair) == 0x000128, "Wrong size on UVCharacterHairPiece_Hair");

// Class Altar.NiTransform
// 0x0028 (0x0058 - 0x0030)
class UNiTransform final : public UNifType
{
public:
	class UMatrix33*                              Rotation;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTransform">();
	}
	static class UNiTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTransform>();
	}
};
static_assert(alignof(UNiTransform) == 0x000008, "Wrong alignment on UNiTransform");
static_assert(sizeof(UNiTransform) == 0x000058, "Wrong size on UNiTransform");
static_assert(offsetof(UNiTransform, Rotation) == 0x000030, "Member 'UNiTransform::Rotation' has a wrong offset!");
static_assert(offsetof(UNiTransform, Translation) == 0x000038, "Member 'UNiTransform::Translation' has a wrong offset!");
static_assert(offsetof(UNiTransform, Scale) == 0x000050, "Member 'UNiTransform::Scale' has a wrong offset!");

// Class Altar.NiTransformData
// 0x0000 (0x00A0 - 0x00A0)
class UNiTransformData final : public UNiKeyframeData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTransformData">();
	}
	static class UNiTransformData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTransformData>();
	}
};
static_assert(alignof(UNiTransformData) == 0x000008, "Wrong alignment on UNiTransformData");
static_assert(sizeof(UNiTransformData) == 0x0000A0, "Wrong size on UNiTransformData");

// Class Altar.VOblivionToAltarFaceMorphsConversionMap
// 0x0050 (0x0080 - 0x0030)
class UVOblivionToAltarFaceMorphsConversionMap final : public UDataAsset
{
public:
	TMap<int32, struct FOblivionToAltarFaceConversionValue> IndexMap;                                // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOblivionToAltarFaceMorphsConversionMap">();
	}
	static class UVOblivionToAltarFaceMorphsConversionMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOblivionToAltarFaceMorphsConversionMap>();
	}
};
static_assert(alignof(UVOblivionToAltarFaceMorphsConversionMap) == 0x000008, "Wrong alignment on UVOblivionToAltarFaceMorphsConversionMap");
static_assert(sizeof(UVOblivionToAltarFaceMorphsConversionMap) == 0x000080, "Wrong size on UVOblivionToAltarFaceMorphsConversionMap");
static_assert(offsetof(UVOblivionToAltarFaceMorphsConversionMap, IndexMap) == 0x000030, "Member 'UVOblivionToAltarFaceMorphsConversionMap::IndexMap' has a wrong offset!");

// Class Altar.VRepairMenuViewModel
// 0x00D8 (0x01A8 - 0x00D0)
class UVRepairMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnHammerBreakSoundTrigger;                         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnIngredientSelectedSoundTrigger;                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSucessRepairSoundTrigger;                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSucessRepairMerchantSoundTrigger;                // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSucessRepairAllSoundTrigger;                     // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<struct FLegacyRepairItemProperties>    RepairList;                                        // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	ELegacyRepairMenuType                         TypeMenu;                                          // 0x0130(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyRepairAmount                    AmountHammer;                                      // 0x0134(0x0004)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FLegacyRepairAmount                    RepairAllAmount;                                   // 0x0138(0x0004)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FilterButtonName;                                  // 0x0140(0x0018)(NativeAccessSpecifierPrivate)
	EOriginalInventoryMenuSortType                SortType;                                          // 0x0158(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRepairAllButtonVisible;                         // 0x0159(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRepairAllButtonEnable;                          // 0x015A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRemoveButtonVisible;                            // 0x015B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFilterButtonVisible;                            // 0x015C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSortReversed;                                   // 0x015D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAtLeastExpert;                                  // 0x015E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOpenedFromQuickWheel;                           // 0x015F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x4];                                      // 0x0160(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HammerBreakChance;                                 // 0x0164(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FModernRepairMenuCharacterData         PlayerData;                                        // 0x0168(0x0020)(NativeAccessSpecifierPrivate)
	struct FModernRepairMenuCharacterData         MerchantData;                                      // 0x0188(0x0020)(NativeAccessSpecifierPrivate)

public:
	void RegisterSendClickedExit();
	void RegisterSendClickedFilter();
	void RegisterSendClickedOnRepair(int32 Item);
	void RegisterSendClickedRemove();
	void RegisterSendClickedRepairAll();
	void RegisterSendHoverItem(int32 ItemIndex);
	void SetAmountHammer(const struct FLegacyRepairAmount& NewValue);
	void SetAmountMerchantGold(int32 NewValue);
	void SetAmountPlayerGold(int32 NewValue);
	void SetFilterButtonName(const class FText& NewText);
	void SetFilterButtonVisible(bool bIsVisible);
	void SetHammerBreakChance(float BreakChanceValue);
	void SetIsAtLeastExpert(bool bNewIsAtLeastExpert);
	void SetIsOpenedFromQuickWheel(bool bNewIsOpenedFromQuickWheel);
	void SetIsSortReversed(bool bNewIsSortReversed);
	void SetMerchantData(const struct FModernRepairMenuCharacterData& NewMerchantData);
	void SetPlayerData(const struct FModernRepairMenuCharacterData& NewPlayerData);
	void SetRemoveButtonVisible(bool bIsVisible);
	void SetRepairAllAmount(const struct FLegacyRepairAmount& NewValue);
	void SetRepairAllButtonEnable(bool bIsEnable);
	void SetRepairAllButtonVisible(bool bIsVisible);
	void SetRepairList(const TArray<struct FLegacyRepairItemProperties>& NewProperties);
	void SetSortType(const EOriginalInventoryMenuSortType& NewSortType);
	void SetTypeMenu(ELegacyRepairMenuType NewType);

	struct FLegacyRepairAmount GetAmountHammer() const;
	const class FText GetFilterButtonName() const;
	bool GetFilterButtonVisible() const;
	float GetHammerBreakChance() const;
	const struct FModernRepairMenuCharacterData GetMerchantData() const;
	const struct FModernRepairMenuCharacterData GetPlayerData() const;
	bool GetRemoveButtonVisible() const;
	const struct FLegacyRepairAmount GetRepairAllAmount() const;
	bool GetRepairAllButtonEnable() const;
	bool GetRepairAllButtonVisible() const;
	const TArray<struct FLegacyRepairItemProperties> GetRepairList() const;
	EOriginalInventoryMenuSortType GetSortType() const;
	ELegacyRepairMenuType GetTypeMenu() const;
	bool IsAtLeastExpert() const;
	bool IsOpenedFromQuickWheel() const;
	bool IsSortReversed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VRepairMenuViewModel">();
	}
	static class UVRepairMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVRepairMenuViewModel>();
	}
};
static_assert(alignof(UVRepairMenuViewModel) == 0x000008, "Wrong alignment on UVRepairMenuViewModel");
static_assert(sizeof(UVRepairMenuViewModel) == 0x0001A8, "Wrong size on UVRepairMenuViewModel");
static_assert(offsetof(UVRepairMenuViewModel, OnHammerBreakSoundTrigger) == 0x0000D0, "Member 'UVRepairMenuViewModel::OnHammerBreakSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, OnIngredientSelectedSoundTrigger) == 0x0000E0, "Member 'UVRepairMenuViewModel::OnIngredientSelectedSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, OnSucessRepairSoundTrigger) == 0x0000F0, "Member 'UVRepairMenuViewModel::OnSucessRepairSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, OnSucessRepairMerchantSoundTrigger) == 0x000100, "Member 'UVRepairMenuViewModel::OnSucessRepairMerchantSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, OnSucessRepairAllSoundTrigger) == 0x000110, "Member 'UVRepairMenuViewModel::OnSucessRepairAllSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, RepairList) == 0x000120, "Member 'UVRepairMenuViewModel::RepairList' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, TypeMenu) == 0x000130, "Member 'UVRepairMenuViewModel::TypeMenu' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, AmountHammer) == 0x000134, "Member 'UVRepairMenuViewModel::AmountHammer' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, RepairAllAmount) == 0x000138, "Member 'UVRepairMenuViewModel::RepairAllAmount' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, FilterButtonName) == 0x000140, "Member 'UVRepairMenuViewModel::FilterButtonName' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, SortType) == 0x000158, "Member 'UVRepairMenuViewModel::SortType' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, bIsRepairAllButtonVisible) == 0x000159, "Member 'UVRepairMenuViewModel::bIsRepairAllButtonVisible' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, bIsRepairAllButtonEnable) == 0x00015A, "Member 'UVRepairMenuViewModel::bIsRepairAllButtonEnable' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, bIsRemoveButtonVisible) == 0x00015B, "Member 'UVRepairMenuViewModel::bIsRemoveButtonVisible' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, bIsFilterButtonVisible) == 0x00015C, "Member 'UVRepairMenuViewModel::bIsFilterButtonVisible' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, bIsSortReversed) == 0x00015D, "Member 'UVRepairMenuViewModel::bIsSortReversed' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, bIsAtLeastExpert) == 0x00015E, "Member 'UVRepairMenuViewModel::bIsAtLeastExpert' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, bIsOpenedFromQuickWheel) == 0x00015F, "Member 'UVRepairMenuViewModel::bIsOpenedFromQuickWheel' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, HammerBreakChance) == 0x000164, "Member 'UVRepairMenuViewModel::HammerBreakChance' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, PlayerData) == 0x000168, "Member 'UVRepairMenuViewModel::PlayerData' has a wrong offset!");
static_assert(offsetof(UVRepairMenuViewModel, MerchantData) == 0x000188, "Member 'UVRepairMenuViewModel::MerchantData' has a wrong offset!");

// Class Altar.NiTriShape
// 0x0000 (0x00C0 - 0x00C0)
class UNiTriShape final : public UNiTriBasedGeom
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTriShape">();
	}
	static class UNiTriShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTriShape>();
	}
};
static_assert(alignof(UNiTriShape) == 0x000008, "Wrong alignment on UNiTriShape");
static_assert(sizeof(UNiTriShape) == 0x0000C0, "Wrong size on UNiTriShape");

// Class Altar.VForceMoveRequestTrigger
// 0x00A8 (0x0348 - 0x02A0)
class AVForceMoveRequestTrigger final : public ATriggerBox
{
public:
	TArray<int32>                                 AllowedPawnFormIds;                                // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class AActor>                  DestinationActor;                                  // 0x02B0(0x0028)(Edit, BlueprintVisible, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                DestinationLocation;                               // 0x02D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AcceptanceRadius;                                  // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AVPairedPawn*>                     ProcessedPawns;                                    // 0x02F8(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VForceMoveRequestTrigger">();
	}
	static class AVForceMoveRequestTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVForceMoveRequestTrigger>();
	}
};
static_assert(alignof(AVForceMoveRequestTrigger) == 0x000008, "Wrong alignment on AVForceMoveRequestTrigger");
static_assert(sizeof(AVForceMoveRequestTrigger) == 0x000348, "Wrong size on AVForceMoveRequestTrigger");
static_assert(offsetof(AVForceMoveRequestTrigger, AllowedPawnFormIds) == 0x0002A0, "Member 'AVForceMoveRequestTrigger::AllowedPawnFormIds' has a wrong offset!");
static_assert(offsetof(AVForceMoveRequestTrigger, DestinationActor) == 0x0002B0, "Member 'AVForceMoveRequestTrigger::DestinationActor' has a wrong offset!");
static_assert(offsetof(AVForceMoveRequestTrigger, DestinationLocation) == 0x0002D8, "Member 'AVForceMoveRequestTrigger::DestinationLocation' has a wrong offset!");
static_assert(offsetof(AVForceMoveRequestTrigger, AcceptanceRadius) == 0x0002F0, "Member 'AVForceMoveRequestTrigger::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(AVForceMoveRequestTrigger, ProcessedPawns) == 0x0002F8, "Member 'AVForceMoveRequestTrigger::ProcessedPawns' has a wrong offset!");

// Class Altar.NiTriStrips
// 0x0000 (0x00C0 - 0x00C0)
class UNiTriStrips final : public UNiTriBasedGeom
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiTriStrips">();
	}
	static class UNiTriStrips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiTriStrips>();
	}
};
static_assert(alignof(UNiTriStrips) == 0x000008, "Wrong alignment on UNiTriStrips");
static_assert(sizeof(UNiTriStrips) == 0x0000C0, "Wrong size on UNiTriStrips");

// Class Altar.NiVertexColorProperty
// 0x0010 (0x0078 - 0x0068)
class UNiVertexColorProperty final : public UNiProperty
{
public:
	struct FVertexColorFlags                      Flags_0;                                           // 0x0068(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESourceVertexMode                             VertexMode;                                        // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightingMode                                 LightMode;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiVertexColorProperty">();
	}
	static class UNiVertexColorProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiVertexColorProperty>();
	}
};
static_assert(alignof(UNiVertexColorProperty) == 0x000008, "Wrong alignment on UNiVertexColorProperty");
static_assert(sizeof(UNiVertexColorProperty) == 0x000078, "Wrong size on UNiVertexColorProperty");
static_assert(offsetof(UNiVertexColorProperty, Flags_0) == 0x000068, "Member 'UNiVertexColorProperty::Flags_0' has a wrong offset!");
static_assert(offsetof(UNiVertexColorProperty, VertexMode) == 0x00006C, "Member 'UNiVertexColorProperty::VertexMode' has a wrong offset!");
static_assert(offsetof(UNiVertexColorProperty, LightMode) == 0x000070, "Member 'UNiVertexColorProperty::LightMode' has a wrong offset!");

// Class Altar.VGameplayMenuViewModel
// 0x0010 (0x00E0 - 0x00D0)
class UVGameplayMenuViewModel final : public UVViewModelBase
{
public:
	float                                         Difficulty;                                        // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          GeneralSubtitles;                                  // 0x00D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DialogSubtitles;                                   // 0x00D5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Crosshair;                                         // 0x00D6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SaveOnRest;                                        // 0x00D7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SaveOnWait;                                        // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SaveOnTravel;                                      // 0x00D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendClickedButton(ELegacyGameplayMenuIDs InButtonIndex);
	void SetCrosshair(const bool Value);
	void SetDialogSubtitles(const bool Value);
	void SetDifficulty(const float Value);
	void SetGeneralSubtitles(const bool Value);
	void SetSaveOnRest(const bool Value);
	void SetSaveOnTravel(const bool Value);
	void SetSaveOnWait(const bool Value);

	bool GetCrosshair() const;
	bool GetDialogSubtitles() const;
	float GetDifficulty() const;
	bool GetGeneralSubtitles() const;
	bool GetSaveOnRest() const;
	bool GetSaveOnTravel() const;
	bool GetSaveOnWait() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VGameplayMenuViewModel">();
	}
	static class UVGameplayMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVGameplayMenuViewModel>();
	}
};
static_assert(alignof(UVGameplayMenuViewModel) == 0x000008, "Wrong alignment on UVGameplayMenuViewModel");
static_assert(sizeof(UVGameplayMenuViewModel) == 0x0000E0, "Wrong size on UVGameplayMenuViewModel");
static_assert(offsetof(UVGameplayMenuViewModel, Difficulty) == 0x0000D0, "Member 'UVGameplayMenuViewModel::Difficulty' has a wrong offset!");
static_assert(offsetof(UVGameplayMenuViewModel, GeneralSubtitles) == 0x0000D4, "Member 'UVGameplayMenuViewModel::GeneralSubtitles' has a wrong offset!");
static_assert(offsetof(UVGameplayMenuViewModel, DialogSubtitles) == 0x0000D5, "Member 'UVGameplayMenuViewModel::DialogSubtitles' has a wrong offset!");
static_assert(offsetof(UVGameplayMenuViewModel, Crosshair) == 0x0000D6, "Member 'UVGameplayMenuViewModel::Crosshair' has a wrong offset!");
static_assert(offsetof(UVGameplayMenuViewModel, SaveOnRest) == 0x0000D7, "Member 'UVGameplayMenuViewModel::SaveOnRest' has a wrong offset!");
static_assert(offsetof(UVGameplayMenuViewModel, SaveOnWait) == 0x0000D8, "Member 'UVGameplayMenuViewModel::SaveOnWait' has a wrong offset!");
static_assert(offsetof(UVGameplayMenuViewModel, SaveOnTravel) == 0x0000D9, "Member 'UVGameplayMenuViewModel::SaveOnTravel' has a wrong offset!");

// Class Altar.VStatusEffectVFXBlueprint
// 0x0010 (0x02B0 - 0x02A0)
class AVStatusEffectVFXBlueprint : public AVVFXBlueprint
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangePerfomances(bool bIsTheOnlyVFX, bool bIsMainEffect);
	void OnEnchantTrailStart();
	void OnEnchantTrailStop();
	void OnStartPlayBody(bool bDoesBeginInFirstPerson, float Value, const TArray<struct FLinearColor>& VFXColors);
	void OnStartPlaySkeletal(class USkeletalMeshComponent* SkeletalMeshComponent, bool bDoesBeginInFirstPerson, float Value, const TArray<struct FLinearColor>& VFXColors, bool bDoesBeginAsTheOnlyVFX, bool bIsEnchant, bool bIsMainEffect, bool bIsInInventory);
	void OnStartPlayStatic(class UStaticMeshComponent* StaticMeshComponent, bool bDoesBeginInFirstPerson, float Value, const TArray<struct FLinearColor>& VFXColors, bool bDoesBeginAsTheOnlyVFX, bool bIsEnchant, bool bIsMainEffect, bool bIsInInventory);
	void OnStopPlay();
	void OnStopPlayBody();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStatusEffectVFXBlueprint">();
	}
	static class AVStatusEffectVFXBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVStatusEffectVFXBlueprint>();
	}
};
static_assert(alignof(AVStatusEffectVFXBlueprint) == 0x000008, "Wrong alignment on AVStatusEffectVFXBlueprint");
static_assert(sizeof(AVStatusEffectVFXBlueprint) == 0x0002B0, "Wrong size on AVStatusEffectVFXBlueprint");

// Class Altar.NiVisData
// 0x0018 (0x0050 - 0x0038)
class UNiVisData final : public UNiObject
{
public:
	int64                                         NumKeys;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiVisData">();
	}
	static class UNiVisData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiVisData>();
	}
};
static_assert(alignof(UNiVisData) == 0x000008, "Wrong alignment on UNiVisData");
static_assert(sizeof(UNiVisData) == 0x000050, "Wrong size on UNiVisData");
static_assert(offsetof(UNiVisData, NumKeys) == 0x000038, "Member 'UNiVisData::NumKeys' has a wrong offset!");

// Class Altar.VTickSynchronizer
// 0x0018 (0x02B0 - 0x0298)
class AVTickSynchronizer final : public AInfo
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UVLevelChangeData*                      LevelData;                                         // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTickSynchronizer">();
	}
	static class AVTickSynchronizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVTickSynchronizer>();
	}
};
static_assert(alignof(AVTickSynchronizer) == 0x000008, "Wrong alignment on AVTickSynchronizer");
static_assert(sizeof(AVTickSynchronizer) == 0x0002B0, "Wrong size on AVTickSynchronizer");
static_assert(offsetof(AVTickSynchronizer, LevelData) == 0x0002A8, "Member 'AVTickSynchronizer::LevelData' has a wrong offset!");

// Class Altar.NiZBufferProperty
// 0x0008 (0x0070 - 0x0068)
class UNiZBufferProperty final : public UNiProperty
{
public:
	int32                                         FlagZBuffer;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZBufferTestFunction                          TestFunction;                                      // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiZBufferProperty">();
	}
	static class UNiZBufferProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiZBufferProperty>();
	}
};
static_assert(alignof(UNiZBufferProperty) == 0x000008, "Wrong alignment on UNiZBufferProperty");
static_assert(sizeof(UNiZBufferProperty) == 0x000070, "Wrong size on UNiZBufferProperty");
static_assert(offsetof(UNiZBufferProperty, FlagZBuffer) == 0x000068, "Member 'UNiZBufferProperty::FlagZBuffer' has a wrong offset!");
static_assert(offsetof(UNiZBufferProperty, TestFunction) == 0x00006C, "Member 'UNiZBufferProperty::TestFunction' has a wrong offset!");

// Class Altar.VGetUpAnimInstance
// 0x0030 (0x03D0 - 0x03A0)
class UVGetUpAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	bool                                          bIsGettingUp;                                      // 0x03A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HeadSocketName;                                    // 0x03A4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           GetUpAnimation;                                    // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGetUpAnimationData                    LayerData;                                         // 0x03B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VGetUpAnimInstance">();
	}
	static class UVGetUpAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVGetUpAnimInstance>();
	}
};
static_assert(alignof(UVGetUpAnimInstance) == 0x000010, "Wrong alignment on UVGetUpAnimInstance");
static_assert(sizeof(UVGetUpAnimInstance) == 0x0003D0, "Wrong size on UVGetUpAnimInstance");
static_assert(offsetof(UVGetUpAnimInstance, bIsGettingUp) == 0x0003A0, "Member 'UVGetUpAnimInstance::bIsGettingUp' has a wrong offset!");
static_assert(offsetof(UVGetUpAnimInstance, HeadSocketName) == 0x0003A4, "Member 'UVGetUpAnimInstance::HeadSocketName' has a wrong offset!");
static_assert(offsetof(UVGetUpAnimInstance, GetUpAnimation) == 0x0003B0, "Member 'UVGetUpAnimInstance::GetUpAnimation' has a wrong offset!");
static_assert(offsetof(UVGetUpAnimInstance, LayerData) == 0x0003B8, "Member 'UVGetUpAnimInstance::LayerData' has a wrong offset!");

// Class Altar.OblivionActorFactory
// 0x0000 (0x0028 - 0x0028)
class UOblivionActorFactory final : public UBlueprintFunctionLibrary
{
public:
	static bool InitializeActor(class AActor* Actor, class UTESForm* InObject, const bool bIsDefaultObject, int32 NumberToSpawn);
	static class AActor* SpawnActorFromFormAtLocationInBlueprint(class UObject* WorldContextObject, class UTESForm* InObject, const struct FVector& Translation, float RefScale, const struct FRotator& Rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OblivionActorFactory">();
	}
	static class UOblivionActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOblivionActorFactory>();
	}
};
static_assert(alignof(UOblivionActorFactory) == 0x000008, "Wrong alignment on UOblivionActorFactory");
static_assert(sizeof(UOblivionActorFactory) == 0x000028, "Wrong size on UOblivionActorFactory");

// Class Altar.VSpellMakingEnchantingViewModel
// 0x0028 (0x00F8 - 0x00D0)
class UVSpellMakingEnchantingViewModel final : public UVViewModelBase
{
public:
	int32                                         MagickaCost;                                       // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxMagickaCost;                                    // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MagickaCostVisibility;                             // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsConstantEffect;                                 // 0x00D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsExceedingMaxMagickaCost;                        // 0x00DA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DB[0x1];                                       // 0x00DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxUsage;                                          // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MaxUsageVisibility;                                // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GoldCost;                                          // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          GoldCostVisibility;                                // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerGold;                                        // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          PlayerGoldVisibility;                              // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGoldCostIsExceedingPlayerGold;                    // 0x00F1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGoldCost(int32 NewGoldCost);
	void SetGoldCostIsExceedingPlayerGold(bool NewValue);
	void SetGoldCostVisibility(bool NewVisibility);
	void SetIsConstantEffect(bool NewValue);
	void SetIsExceedingMaxMagickaCost(bool NewValue);
	void SetMagickaCost(int32 NewMagickaCost);
	void SetMagickaCostVisibility(bool NewVisibility);
	void SetMaxMagickaCost(int32 NewMaxMagickaCost);
	void SetMaxUsage(int32 NewMaxUsage);
	void SetMaxUsageVisibility(bool NewVisibility);
	void SetPlayerGold(int32 NewPlayerGold);
	void SetPlayerGoldVisibility(bool NewVisibility);

	int32 GetGoldCost() const;
	int32 GetMagickaCost() const;
	int32 GetMaxMagickaCost() const;
	int32 GetMaxUsage() const;
	int32 GetPlayerGold() const;
	bool GoldCostIsExceedingPlayerGold() const;
	bool GoldCostIsVisibile() const;
	bool IsConstantEffect() const;
	bool IsExceedingMaxMagickaCost() const;
	bool MagickaCostIsVisibile() const;
	bool MaxUsageIsVisibile() const;
	bool PlayerGoldIsVisibile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSpellMakingEnchantingViewModel">();
	}
	static class UVSpellMakingEnchantingViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSpellMakingEnchantingViewModel>();
	}
};
static_assert(alignof(UVSpellMakingEnchantingViewModel) == 0x000008, "Wrong alignment on UVSpellMakingEnchantingViewModel");
static_assert(sizeof(UVSpellMakingEnchantingViewModel) == 0x0000F8, "Wrong size on UVSpellMakingEnchantingViewModel");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, MagickaCost) == 0x0000D0, "Member 'UVSpellMakingEnchantingViewModel::MagickaCost' has a wrong offset!");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, MaxMagickaCost) == 0x0000D4, "Member 'UVSpellMakingEnchantingViewModel::MaxMagickaCost' has a wrong offset!");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, MagickaCostVisibility) == 0x0000D8, "Member 'UVSpellMakingEnchantingViewModel::MagickaCostVisibility' has a wrong offset!");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, bIsConstantEffect) == 0x0000D9, "Member 'UVSpellMakingEnchantingViewModel::bIsConstantEffect' has a wrong offset!");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, bIsExceedingMaxMagickaCost) == 0x0000DA, "Member 'UVSpellMakingEnchantingViewModel::bIsExceedingMaxMagickaCost' has a wrong offset!");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, MaxUsage) == 0x0000DC, "Member 'UVSpellMakingEnchantingViewModel::MaxUsage' has a wrong offset!");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, MaxUsageVisibility) == 0x0000E0, "Member 'UVSpellMakingEnchantingViewModel::MaxUsageVisibility' has a wrong offset!");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, GoldCost) == 0x0000E4, "Member 'UVSpellMakingEnchantingViewModel::GoldCost' has a wrong offset!");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, GoldCostVisibility) == 0x0000E8, "Member 'UVSpellMakingEnchantingViewModel::GoldCostVisibility' has a wrong offset!");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, PlayerGold) == 0x0000EC, "Member 'UVSpellMakingEnchantingViewModel::PlayerGold' has a wrong offset!");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, PlayerGoldVisibility) == 0x0000F0, "Member 'UVSpellMakingEnchantingViewModel::PlayerGoldVisibility' has a wrong offset!");
static_assert(offsetof(UVSpellMakingEnchantingViewModel, bGoldCostIsExceedingPlayerGold) == 0x0000F1, "Member 'UVSpellMakingEnchantingViewModel::bGoldCostIsExceedingPlayerGold' has a wrong offset!");

// Class Altar.PostTickExecutorSubsytem
// 0x0058 (0x0088 - 0x0030)
class UPostTickExecutorSubsytem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostTickExecutorSubsytem">();
	}
	static class UPostTickExecutorSubsytem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostTickExecutorSubsytem>();
	}
};
static_assert(alignof(UPostTickExecutorSubsytem) == 0x000008, "Wrong alignment on UPostTickExecutorSubsytem");
static_assert(sizeof(UPostTickExecutorSubsytem) == 0x000088, "Wrong size on UPostTickExecutorSubsytem");

// Class Altar.SkinPartition
// 0x00C8 (0x00F8 - 0x0030)
class USkinPartition final : public UNifType
{
public:
	int32                                         NumVertices;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTriangles;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBones;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumStrips;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumWeightsPerVertex;                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Bones;                                             // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          HasVertexMap;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 VertexMap;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          HasVertexWeights;                                  // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 VertexWeights;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<int32>                                 StripLengths;                                      // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          HasFaces;                                          // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Strips;                                            // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Triangles;                                         // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          HasBoneIndices;                                    // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 BoneIndices;                                       // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         LODLevel;                                          // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GlobalVB;                                          // 0x00D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBSVertexDesc                          VertexDesc;                                        // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TrianglesCopy;                                     // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkinPartition">();
	}
	static class USkinPartition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkinPartition>();
	}
};
static_assert(alignof(USkinPartition) == 0x000008, "Wrong alignment on USkinPartition");
static_assert(sizeof(USkinPartition) == 0x0000F8, "Wrong size on USkinPartition");
static_assert(offsetof(USkinPartition, NumVertices) == 0x000030, "Member 'USkinPartition::NumVertices' has a wrong offset!");
static_assert(offsetof(USkinPartition, NumTriangles) == 0x000034, "Member 'USkinPartition::NumTriangles' has a wrong offset!");
static_assert(offsetof(USkinPartition, NumBones) == 0x000038, "Member 'USkinPartition::NumBones' has a wrong offset!");
static_assert(offsetof(USkinPartition, NumStrips) == 0x00003C, "Member 'USkinPartition::NumStrips' has a wrong offset!");
static_assert(offsetof(USkinPartition, NumWeightsPerVertex) == 0x000040, "Member 'USkinPartition::NumWeightsPerVertex' has a wrong offset!");
static_assert(offsetof(USkinPartition, Bones) == 0x000048, "Member 'USkinPartition::Bones' has a wrong offset!");
static_assert(offsetof(USkinPartition, HasVertexMap) == 0x000058, "Member 'USkinPartition::HasVertexMap' has a wrong offset!");
static_assert(offsetof(USkinPartition, VertexMap) == 0x000060, "Member 'USkinPartition::VertexMap' has a wrong offset!");
static_assert(offsetof(USkinPartition, HasVertexWeights) == 0x000070, "Member 'USkinPartition::HasVertexWeights' has a wrong offset!");
static_assert(offsetof(USkinPartition, VertexWeights) == 0x000078, "Member 'USkinPartition::VertexWeights' has a wrong offset!");
static_assert(offsetof(USkinPartition, StripLengths) == 0x000088, "Member 'USkinPartition::StripLengths' has a wrong offset!");
static_assert(offsetof(USkinPartition, HasFaces) == 0x000098, "Member 'USkinPartition::HasFaces' has a wrong offset!");
static_assert(offsetof(USkinPartition, Strips) == 0x0000A0, "Member 'USkinPartition::Strips' has a wrong offset!");
static_assert(offsetof(USkinPartition, Triangles) == 0x0000B0, "Member 'USkinPartition::Triangles' has a wrong offset!");
static_assert(offsetof(USkinPartition, HasBoneIndices) == 0x0000C0, "Member 'USkinPartition::HasBoneIndices' has a wrong offset!");
static_assert(offsetof(USkinPartition, BoneIndices) == 0x0000C8, "Member 'USkinPartition::BoneIndices' has a wrong offset!");
static_assert(offsetof(USkinPartition, LODLevel) == 0x0000D8, "Member 'USkinPartition::LODLevel' has a wrong offset!");
static_assert(offsetof(USkinPartition, GlobalVB) == 0x0000D9, "Member 'USkinPartition::GlobalVB' has a wrong offset!");
static_assert(offsetof(USkinPartition, VertexDesc) == 0x0000E0, "Member 'USkinPartition::VertexDesc' has a wrong offset!");
static_assert(offsetof(USkinPartition, TrianglesCopy) == 0x0000E8, "Member 'USkinPartition::TrianglesCopy' has a wrong offset!");

// Class Altar.VAltarBoundActionBar
// 0x0018 (0x02A0 - 0x0288)
class UVAltarBoundActionBar final : public UCommonBoundActionBar
{
public:
	TMulticastInlineDelegate<void()>              OnAcceptedWidgetChange;                            // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UVAltarBoundActionButton* GetAcceptedActionWidget() const;
	const class UVAltarBoundActionButton* GetActionWidget(class UInputAction* InputAction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarBoundActionBar">();
	}
	static class UVAltarBoundActionBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarBoundActionBar>();
	}
};
static_assert(alignof(UVAltarBoundActionBar) == 0x000008, "Wrong alignment on UVAltarBoundActionBar");
static_assert(sizeof(UVAltarBoundActionBar) == 0x0002A0, "Wrong size on UVAltarBoundActionBar");
static_assert(offsetof(UVAltarBoundActionBar, OnAcceptedWidgetChange) == 0x000288, "Member 'UVAltarBoundActionBar::OnAcceptedWidgetChange' has a wrong offset!");

// Class Altar.StainedGlassCapturer
// 0x00A8 (0x0340 - 0x0298)
class AStainedGlassCapturer final : public AActor
{
public:
	class USceneCaptureComponent2D*               SceneCapture;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDirectionalLightComponent> LightSource;                                    // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LightSourceForwardVector;                          // 0x02A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LightSourceUpVector;                               // 0x02C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LightSourceRightVector;                            // 0x02D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LightRotation;                                     // 0x02F0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStainedGlassElement>           GlassObjects;                                      // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTexture2DArray*                        BakedGlassTexture;                                 // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           MaterialParameterCollection;                       // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TextureExportFolder;                               // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CaptureResolution;                                 // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentageBorderOffset;                            // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static float FindOrthoWidthForBox(const struct FVector& Extents, const struct FRotator& Rotator, float Offset);

	void BakeGlassTexture();
	void CollectSceneActors();
	void PrepareMaterialParameterCollection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StainedGlassCapturer">();
	}
	static class AStainedGlassCapturer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStainedGlassCapturer>();
	}
};
static_assert(alignof(AStainedGlassCapturer) == 0x000008, "Wrong alignment on AStainedGlassCapturer");
static_assert(sizeof(AStainedGlassCapturer) == 0x000340, "Wrong size on AStainedGlassCapturer");
static_assert(offsetof(AStainedGlassCapturer, SceneCapture) == 0x000298, "Member 'AStainedGlassCapturer::SceneCapture' has a wrong offset!");
static_assert(offsetof(AStainedGlassCapturer, LightSource) == 0x0002A0, "Member 'AStainedGlassCapturer::LightSource' has a wrong offset!");
static_assert(offsetof(AStainedGlassCapturer, LightSourceForwardVector) == 0x0002A8, "Member 'AStainedGlassCapturer::LightSourceForwardVector' has a wrong offset!");
static_assert(offsetof(AStainedGlassCapturer, LightSourceUpVector) == 0x0002C0, "Member 'AStainedGlassCapturer::LightSourceUpVector' has a wrong offset!");
static_assert(offsetof(AStainedGlassCapturer, LightSourceRightVector) == 0x0002D8, "Member 'AStainedGlassCapturer::LightSourceRightVector' has a wrong offset!");
static_assert(offsetof(AStainedGlassCapturer, LightRotation) == 0x0002F0, "Member 'AStainedGlassCapturer::LightRotation' has a wrong offset!");
static_assert(offsetof(AStainedGlassCapturer, GlassObjects) == 0x000308, "Member 'AStainedGlassCapturer::GlassObjects' has a wrong offset!");
static_assert(offsetof(AStainedGlassCapturer, BakedGlassTexture) == 0x000318, "Member 'AStainedGlassCapturer::BakedGlassTexture' has a wrong offset!");
static_assert(offsetof(AStainedGlassCapturer, MaterialParameterCollection) == 0x000320, "Member 'AStainedGlassCapturer::MaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(AStainedGlassCapturer, TextureExportFolder) == 0x000328, "Member 'AStainedGlassCapturer::TextureExportFolder' has a wrong offset!");
static_assert(offsetof(AStainedGlassCapturer, CaptureResolution) == 0x000338, "Member 'AStainedGlassCapturer::CaptureResolution' has a wrong offset!");
static_assert(offsetof(AStainedGlassCapturer, PercentageBorderOffset) == 0x00033C, "Member 'AStainedGlassCapturer::PercentageBorderOffset' has a wrong offset!");

// Class Altar.VSteeringBehavior_DropOffLedge
// 0x0000 (0x0168 - 0x0168)
class UVSteeringBehavior_DropOffLedge final : public USteeringBehavior_DropOffLedge
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSteeringBehavior_DropOffLedge">();
	}
	static class UVSteeringBehavior_DropOffLedge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSteeringBehavior_DropOffLedge>();
	}
};
static_assert(alignof(UVSteeringBehavior_DropOffLedge) == 0x000008, "Wrong alignment on UVSteeringBehavior_DropOffLedge");
static_assert(sizeof(UVSteeringBehavior_DropOffLedge) == 0x000168, "Wrong size on UVSteeringBehavior_DropOffLedge");

// Class Altar.StainedGlassSubsystem
// 0x0010 (0x0050 - 0x0040)
class UStainedGlassSubsystem final : public UTickableWorldSubsystem
{
public:
	TArray<class AStainedGlassCapturer*>          CapturerArray;                                     // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StainedGlassSubsystem">();
	}
	static class UStainedGlassSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStainedGlassSubsystem>();
	}
};
static_assert(alignof(UStainedGlassSubsystem) == 0x000008, "Wrong alignment on UStainedGlassSubsystem");
static_assert(sizeof(UStainedGlassSubsystem) == 0x000050, "Wrong size on UStainedGlassSubsystem");
static_assert(offsetof(UStainedGlassSubsystem, CapturerArray) == 0x000040, "Member 'UStainedGlassSubsystem::CapturerArray' has a wrong offset!");

// Class Altar.VAltarAchievementBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAltarAchievementBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ResetAchievements();
	static void TriggerAchievement(EVAltarAchievement Achievement);
	static void UndoAchievement(EVAltarAchievement Achievement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarAchievementBlueprintLibrary">();
	}
	static class UVAltarAchievementBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarAchievementBlueprintLibrary>();
	}
};
static_assert(alignof(UVAltarAchievementBlueprintLibrary) == 0x000008, "Wrong alignment on UVAltarAchievementBlueprintLibrary");
static_assert(sizeof(UVAltarAchievementBlueprintLibrary) == 0x000028, "Wrong size on UVAltarAchievementBlueprintLibrary");

// Class Altar.StringPalette
// 0x0018 (0x0048 - 0x0030)
class UStringPalette final : public UNifType
{
public:
	TArray<uint8>                                 Palette;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int64                                         Length;                                            // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StringPalette">();
	}
	static class UStringPalette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStringPalette>();
	}
};
static_assert(alignof(UStringPalette) == 0x000008, "Wrong alignment on UStringPalette");
static_assert(sizeof(UStringPalette) == 0x000048, "Wrong size on UStringPalette");
static_assert(offsetof(UStringPalette, Palette) == 0x000030, "Member 'UStringPalette::Palette' has a wrong offset!");
static_assert(offsetof(UStringPalette, Length) == 0x000040, "Member 'UStringPalette::Length' has a wrong offset!");

// Class Altar.TBC
// 0x0010 (0x0040 - 0x0030)
class UTBC final : public UNifType
{
public:
	float                                         T;                                                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         C;                                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TBC">();
	}
	static class UTBC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTBC>();
	}
};
static_assert(alignof(UTBC) == 0x000008, "Wrong alignment on UTBC");
static_assert(sizeof(UTBC) == 0x000040, "Wrong size on UTBC");
static_assert(offsetof(UTBC, T) == 0x000030, "Member 'UTBC::T' has a wrong offset!");
static_assert(offsetof(UTBC, B) == 0x000034, "Member 'UTBC::B' has a wrong offset!");
static_assert(offsetof(UTBC, C) == 0x000038, "Member 'UTBC::C' has a wrong offset!");

// Class Altar.VSingleAttackAnimInstance
// 0x0010 (0x03D0 - 0x03C0)
class UVSingleAttackAnimInstance final : public UVLeftRightAttackAnimInstance
{
public:
	struct FMeleeAttackSingle                     AnimSet;                                           // 0x03B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSingleAttackAnimInstance">();
	}
	static class UVSingleAttackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSingleAttackAnimInstance>();
	}
};
static_assert(alignof(UVSingleAttackAnimInstance) == 0x000010, "Wrong alignment on UVSingleAttackAnimInstance");
static_assert(sizeof(UVSingleAttackAnimInstance) == 0x0003D0, "Wrong size on UVSingleAttackAnimInstance");
static_assert(offsetof(UVSingleAttackAnimInstance, AnimSet) == 0x0003B8, "Member 'UVSingleAttackAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VAltarNavigableButton
// 0x0010 (0x1660 - 0x1650)
#pragma pack(push, 0x1)
class alignas(0x10) UVAltarNavigableButton : public UVNavigableButton
{
public:
	struct FGameplayTag                           LayerTag;                                          // 0x1650(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableButton">();
	}
	static class UVAltarNavigableButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableButton>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVAltarNavigableButton) == 0x000010, "Wrong alignment on UVAltarNavigableButton");
static_assert(sizeof(UVAltarNavigableButton) == 0x001660, "Wrong size on UVAltarNavigableButton");
static_assert(offsetof(UVAltarNavigableButton, LayerTag) == 0x001650, "Member 'UVAltarNavigableButton::LayerTag' has a wrong offset!");

// Class Altar.VAltarButtonImagePaddingCorrection
// 0x03D0 (0x1A30 - 0x1660)
class UVAltarButtonImagePaddingCorrection final : public UVAltarNavigableButton
{
public:
	class UVOriginalImageTile*                    ButtonImage;                                       // 0x1658(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FButtonCorrectionData                  CorrectionData;                                    // 0x1660(0x03C0)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A20[0x10];                                    // 0x1A20(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCorrectionDataUpdated(const struct FButtonCorrectionData& Value);
	void SetCorrectionData(const struct FButtonCorrectionData& Value);
	void UpdateButtonImageCorrectionData();

	const struct FButtonCorrectionData GetCorrectionData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarButtonImagePaddingCorrection">();
	}
	static class UVAltarButtonImagePaddingCorrection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarButtonImagePaddingCorrection>();
	}
};
static_assert(alignof(UVAltarButtonImagePaddingCorrection) == 0x000010, "Wrong alignment on UVAltarButtonImagePaddingCorrection");
static_assert(sizeof(UVAltarButtonImagePaddingCorrection) == 0x001A30, "Wrong size on UVAltarButtonImagePaddingCorrection");
static_assert(offsetof(UVAltarButtonImagePaddingCorrection, ButtonImage) == 0x001658, "Member 'UVAltarButtonImagePaddingCorrection::ButtonImage' has a wrong offset!");
static_assert(offsetof(UVAltarButtonImagePaddingCorrection, CorrectionData) == 0x001660, "Member 'UVAltarButtonImagePaddingCorrection::CorrectionData' has a wrong offset!");

// Class Altar.VBaseUIGameSaveData
// 0x0008 (0x0038 - 0x0030)
class UVBaseUIGameSaveData : public UVBaseAltarSaveData
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBaseUIGameSaveData">();
	}
	static class UVBaseUIGameSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBaseUIGameSaveData>();
	}
};
static_assert(alignof(UVBaseUIGameSaveData) == 0x000008, "Wrong alignment on UVBaseUIGameSaveData");
static_assert(sizeof(UVBaseUIGameSaveData) == 0x000038, "Wrong size on UVBaseUIGameSaveData");

// Class Altar.VAltarConsole
// 0x0008 (0x0138 - 0x0130)
class UVAltarConsole final : public UConsole
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarConsole">();
	}
	static class UVAltarConsole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarConsole>();
	}
};
static_assert(alignof(UVAltarConsole) == 0x000008, "Wrong alignment on UVAltarConsole");
static_assert(sizeof(UVAltarConsole) == 0x000138, "Wrong size on UVAltarConsole");

// Class Altar.TESActorBase
// 0x0040 (0x01D0 - 0x0190)
class UTESActorBase : public UTESBoundObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESActorBaseData*                      InheritedActorBaseData;                            // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeleton>               Skeleton;                                          // 0x01A8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESActorBase">();
	}
	static class UTESActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESActorBase>();
	}
};
static_assert(alignof(UTESActorBase) == 0x000008, "Wrong alignment on UTESActorBase");
static_assert(sizeof(UTESActorBase) == 0x0001D0, "Wrong size on UTESActorBase");
static_assert(offsetof(UTESActorBase, FullName) == 0x000190, "Member 'UTESActorBase::FullName' has a wrong offset!");
static_assert(offsetof(UTESActorBase, InheritedActorBaseData) == 0x0001A0, "Member 'UTESActorBase::InheritedActorBaseData' has a wrong offset!");
static_assert(offsetof(UTESActorBase, Skeleton) == 0x0001A8, "Member 'UTESActorBase::Skeleton' has a wrong offset!");

// Class Altar.TESActorBaseData
// 0x0008 (0x0030 - 0x0028)
class UTESActorBaseData final : public UTESBaseFormComponent
{
public:
	struct FACTOR_BASE_DATA                       ActorData;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESActorBaseData">();
	}
	static class UTESActorBaseData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESActorBaseData>();
	}
};
static_assert(alignof(UTESActorBaseData) == 0x000008, "Wrong alignment on UTESActorBaseData");
static_assert(sizeof(UTESActorBaseData) == 0x000030, "Wrong size on UTESActorBaseData");
static_assert(offsetof(UTESActorBaseData, ActorData) == 0x000028, "Member 'UTESActorBaseData::ActorData' has a wrong offset!");

// Class Altar.VAltarBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAltarBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EGPUType GetGPUBrand();
	static void GetUsedVRAMMB(int32& Total, int32& Used);
	static bool IsGameRunningOnSSD();
	static void IsHardwareAcceleratedGPUSchedulingEnabled_BP(EExecBranch* OutExecPin);
	static void SetUpscalingOptions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarBlueprintFunctionLibrary">();
	}
	static class UVAltarBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UVAltarBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UVAltarBlueprintFunctionLibrary");
static_assert(sizeof(UVAltarBlueprintFunctionLibrary) == 0x000028, "Wrong size on UVAltarBlueprintFunctionLibrary");

// Class Altar.VAltarDialogButtonListWidget
// 0x0000 (0x04C8 - 0x04C8)
class UVAltarDialogButtonListWidget : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarDialogButtonListWidget">();
	}
	static class UVAltarDialogButtonListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarDialogButtonListWidget>();
	}
};
static_assert(alignof(UVAltarDialogButtonListWidget) == 0x000008, "Wrong alignment on UVAltarDialogButtonListWidget");
static_assert(sizeof(UVAltarDialogButtonListWidget) == 0x0004C8, "Wrong size on UVAltarDialogButtonListWidget");

// Class Altar.TESAmmo
// 0x00E0 (0x0270 - 0x0190)
class UTESAmmo final : public UTESBoundObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStreamableRenderAsset>  NewQuiverMesh;                                     // 0x01C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStreamableRenderAsset>  NewProjectileMesh;                                 // 0x01F0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EquipableBlueprintClass;                           // 0x0218(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FiredAmmoBlueprintClass;                           // 0x0240(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmmoMass;                                          // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSoftObjectPtr<class UStaticMesh> GetProjectileStaticMesh();
	TSoftObjectPtr<class UStaticMesh> GetQuiverStaticMesh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESAmmo">();
	}
	static class UTESAmmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESAmmo>();
	}
};
static_assert(alignof(UTESAmmo) == 0x000008, "Wrong alignment on UTESAmmo");
static_assert(sizeof(UTESAmmo) == 0x000270, "Wrong size on UTESAmmo");
static_assert(offsetof(UTESAmmo, FullName) == 0x000190, "Member 'UTESAmmo::FullName' has a wrong offset!");
static_assert(offsetof(UTESAmmo, NewMesh) == 0x0001A0, "Member 'UTESAmmo::NewMesh' has a wrong offset!");
static_assert(offsetof(UTESAmmo, NewQuiverMesh) == 0x0001C8, "Member 'UTESAmmo::NewQuiverMesh' has a wrong offset!");
static_assert(offsetof(UTESAmmo, NewProjectileMesh) == 0x0001F0, "Member 'UTESAmmo::NewProjectileMesh' has a wrong offset!");
static_assert(offsetof(UTESAmmo, EquipableBlueprintClass) == 0x000218, "Member 'UTESAmmo::EquipableBlueprintClass' has a wrong offset!");
static_assert(offsetof(UTESAmmo, FiredAmmoBlueprintClass) == 0x000240, "Member 'UTESAmmo::FiredAmmoBlueprintClass' has a wrong offset!");
static_assert(offsetof(UTESAmmo, AmmoMass) == 0x000268, "Member 'UTESAmmo::AmmoMass' has a wrong offset!");

// Class Altar.VAIProcedureExecution_Wander
// 0x0010 (0x0050 - 0x0040)
class UVAIProcedureExecution_Wander final : public UVAIProcedureExecution_Base
{
public:
	class UVAIProcedureExecution_TRAVEL*          InternalTravelProcedure;                           // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpecialIdleAnimationStarted(class UAnimSequenceBase* AnimAsset);
	void OnSpecialIdleAnimationStopped();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_Wander">();
	}
	static class UVAIProcedureExecution_Wander* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_Wander>();
	}
};
static_assert(alignof(UVAIProcedureExecution_Wander) == 0x000008, "Wrong alignment on UVAIProcedureExecution_Wander");
static_assert(sizeof(UVAIProcedureExecution_Wander) == 0x000050, "Wrong size on UVAIProcedureExecution_Wander");
static_assert(offsetof(UVAIProcedureExecution_Wander, InternalTravelProcedure) == 0x000040, "Member 'UVAIProcedureExecution_Wander::InternalTravelProcedure' has a wrong offset!");

// Class Altar.TESCell
// 0x0068 (0x0140 - 0x00D8)
class UTESCell final : public UTESForm
{
public:
	struct FCellInteriorData                      InteriorCellData;                                  // 0x00D8(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCellExteriorData                      ExteriorCellData;                                  // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         CellFlags;                                         // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTESWorldSpace*                         WorldSpace;                                        // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESPathGrid*                           PathGrid;                                          // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetDataX() const;
	int32 GetDataY() const;
	class UTESLandscape* GetLandscape() const;
	bool HasWater() const;
	bool IsInterior() const;
	bool IsPersistent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESCell">();
	}
	static class UTESCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESCell>();
	}
};
static_assert(alignof(UTESCell) == 0x000008, "Wrong alignment on UTESCell");
static_assert(sizeof(UTESCell) == 0x000140, "Wrong size on UTESCell");
static_assert(offsetof(UTESCell, InteriorCellData) == 0x0000D8, "Member 'UTESCell::InteriorCellData' has a wrong offset!");
static_assert(offsetof(UTESCell, ExteriorCellData) == 0x000118, "Member 'UTESCell::ExteriorCellData' has a wrong offset!");
static_assert(offsetof(UTESCell, CellFlags) == 0x000120, "Member 'UTESCell::CellFlags' has a wrong offset!");
static_assert(offsetof(UTESCell, WorldSpace) == 0x000128, "Member 'UTESCell::WorldSpace' has a wrong offset!");
static_assert(offsetof(UTESCell, PathGrid) == 0x000130, "Member 'UTESCell::PathGrid' has a wrong offset!");

// Class Altar.TESClass
// 0x0000 (0x00D8 - 0x00D8)
class UTESClass final : public UTESForm
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESClass">();
	}
	static class UTESClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESClass>();
	}
};
static_assert(alignof(UTESClass) == 0x000008, "Wrong alignment on UTESClass");
static_assert(sizeof(UTESClass) == 0x0000D8, "Wrong size on UTESClass");

// Class Altar.TESClimate
// 0x0038 (0x0110 - 0x00D8)
class UTESClimate final : public UTESForm
{
public:
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTESWeatherList                        WeatherList;                                       // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UATMPreset*                             Preset;                                            // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunriseBegin;                                      // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunriseEnd;                                        // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunsetBegin;                                       // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunsetEnd;                                         // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Volatility;                                        // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MoonPhasesDays;                                    // 0x0109(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMasser;                                        // 0x010A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSecunda;                                       // 0x010B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESClimate">();
	}
	static class UTESClimate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESClimate>();
	}
};
static_assert(alignof(UTESClimate) == 0x000008, "Wrong alignment on UTESClimate");
static_assert(sizeof(UTESClimate) == 0x000110, "Wrong size on UTESClimate");
static_assert(offsetof(UTESClimate, WeatherList) == 0x0000E0, "Member 'UTESClimate::WeatherList' has a wrong offset!");
static_assert(offsetof(UTESClimate, Preset) == 0x0000F0, "Member 'UTESClimate::Preset' has a wrong offset!");
static_assert(offsetof(UTESClimate, SunriseBegin) == 0x0000F8, "Member 'UTESClimate::SunriseBegin' has a wrong offset!");
static_assert(offsetof(UTESClimate, SunriseEnd) == 0x0000FC, "Member 'UTESClimate::SunriseEnd' has a wrong offset!");
static_assert(offsetof(UTESClimate, SunsetBegin) == 0x000100, "Member 'UTESClimate::SunsetBegin' has a wrong offset!");
static_assert(offsetof(UTESClimate, SunsetEnd) == 0x000104, "Member 'UTESClimate::SunsetEnd' has a wrong offset!");
static_assert(offsetof(UTESClimate, Volatility) == 0x000108, "Member 'UTESClimate::Volatility' has a wrong offset!");
static_assert(offsetof(UTESClimate, MoonPhasesDays) == 0x000109, "Member 'UTESClimate::MoonPhasesDays' has a wrong offset!");
static_assert(offsetof(UTESClimate, bUseMasser) == 0x00010A, "Member 'UTESClimate::bUseMasser' has a wrong offset!");
static_assert(offsetof(UTESClimate, bUseSecunda) == 0x00010B, "Member 'UTESClimate::bUseSecunda' has a wrong offset!");

// Class Altar.VAnimNotify_ActionNotifyState
// 0x0018 (0x0048 - 0x0030)
class UVAnimNotify_ActionNotifyState : public UAnimNotifyState
{
public:
	struct FGameplayTag                           BeginActionEventTag;                               // 0x0030(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EndActionEventTag;                                 // 0x0038(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveWhenOwnerInvisible;                         // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_ActionNotifyState">();
	}
	static class UVAnimNotify_ActionNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_ActionNotifyState>();
	}
};
static_assert(alignof(UVAnimNotify_ActionNotifyState) == 0x000008, "Wrong alignment on UVAnimNotify_ActionNotifyState");
static_assert(sizeof(UVAnimNotify_ActionNotifyState) == 0x000048, "Wrong size on UVAnimNotify_ActionNotifyState");
static_assert(offsetof(UVAnimNotify_ActionNotifyState, BeginActionEventTag) == 0x000030, "Member 'UVAnimNotify_ActionNotifyState::BeginActionEventTag' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_ActionNotifyState, EndActionEventTag) == 0x000038, "Member 'UVAnimNotify_ActionNotifyState::EndActionEventTag' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_ActionNotifyState, bActiveWhenOwnerInvisible) == 0x000040, "Member 'UVAnimNotify_ActionNotifyState::bActiveWhenOwnerInvisible' has a wrong offset!");

// Class Altar.TESCondition
// 0x0000 (0x0028 - 0x0028)
class UTESCondition final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESCondition">();
	}
	static class UTESCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESCondition>();
	}
};
static_assert(alignof(UTESCondition) == 0x000008, "Wrong alignment on UTESCondition");
static_assert(sizeof(UTESCondition) == 0x000028, "Wrong size on UTESCondition");

// Class Altar.VAltarCinematicLevelSequenceActor
// 0x0058 (0x0390 - 0x0338)
class AVAltarCinematicLevelSequenceActor : public ALevelSequenceActor
{
public:
	EVCinematicType                               CinematicType;                                     // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, TSoftClassPtr<class UClass>> ActorBindings;                                    // 0x0340(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarCinematicLevelSequenceActor">();
	}
	static class AVAltarCinematicLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAltarCinematicLevelSequenceActor>();
	}
};
static_assert(alignof(AVAltarCinematicLevelSequenceActor) == 0x000008, "Wrong alignment on AVAltarCinematicLevelSequenceActor");
static_assert(sizeof(AVAltarCinematicLevelSequenceActor) == 0x000390, "Wrong size on AVAltarCinematicLevelSequenceActor");
static_assert(offsetof(AVAltarCinematicLevelSequenceActor, CinematicType) == 0x000338, "Member 'AVAltarCinematicLevelSequenceActor::CinematicType' has a wrong offset!");
static_assert(offsetof(AVAltarCinematicLevelSequenceActor, ActorBindings) == 0x000340, "Member 'AVAltarCinematicLevelSequenceActor::ActorBindings' has a wrong offset!");

// Class Altar.TESConditionItem
// 0x0018 (0x0040 - 0x0028)
class UTESConditionItem final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESConditionItem">();
	}
	static class UTESConditionItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESConditionItem>();
	}
};
static_assert(alignof(UTESConditionItem) == 0x000008, "Wrong alignment on UTESConditionItem");
static_assert(sizeof(UTESConditionItem) == 0x000040, "Wrong size on UTESConditionItem");

// Class Altar.TESCreature
// 0x0060 (0x0230 - 0x01D0)
class UTESCreature final : public UTESActorBase
{
public:
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01D0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimBlueprint>          AnimBlueprint;                                     // 0x01F8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVBloodColor                                  BloodColor;                                        // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseScale;                                         // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESModelList*                          InheritedModelList;                                // 0x0228(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESCreature">();
	}
	static class UTESCreature* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESCreature>();
	}
};
static_assert(alignof(UTESCreature) == 0x000008, "Wrong alignment on UTESCreature");
static_assert(sizeof(UTESCreature) == 0x000230, "Wrong size on UTESCreature");
static_assert(offsetof(UTESCreature, NewMesh) == 0x0001D0, "Member 'UTESCreature::NewMesh' has a wrong offset!");
static_assert(offsetof(UTESCreature, AnimBlueprint) == 0x0001F8, "Member 'UTESCreature::AnimBlueprint' has a wrong offset!");
static_assert(offsetof(UTESCreature, BloodColor) == 0x000220, "Member 'UTESCreature::BloodColor' has a wrong offset!");
static_assert(offsetof(UTESCreature, BaseScale) == 0x000224, "Member 'UTESCreature::BaseScale' has a wrong offset!");
static_assert(offsetof(UTESCreature, InheritedModelList) == 0x000228, "Member 'UTESCreature::InheritedModelList' has a wrong offset!");

// Class Altar.TESEffectSetting
// 0x01E0 (0x02B8 - 0x00D8)
class UTESEffectSetting final : public UTESForm
{
public:
	class FString                                 FullName;                                          // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TextureIcon;                                       // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTESForm>                AssociatedItem;                                    // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTESEffectShader>        EffectShader;                                      // 0x0138(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTESEffectShader>        EnchantEffect;                                     // 0x0160(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        AssociatedItemID;                                  // 0x0188(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        EffectShaderID;                                    // 0x018C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        EnchantEffectID;                                   // 0x0190(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AVMagicSpellVFXBlueprint>   CastingBlueprintClass;                             // 0x0198(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVMagicSpellVFXBlueprint>   ProjectileBlueprintClass;                          // 0x01A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVMagicSpellVFXBlueprint>   AreaEffectBlueprintClass;                          // 0x01A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVMagicSpellVFXBlueprint>   HitEffectBlueprintClass;                           // 0x01B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlueprintParameters                   BlueprintCastingParameters;                        // 0x01B8(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlueprintParameters                   BlueprintProjectileParameters;                     // 0x01E8(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlueprintParameters                   BlueprintAreaEffectParameters;                     // 0x0218(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlueprintParameters                   BlueprintHitEffectParameters;                      // 0x0248(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MaxDurationBeforeDestroyed;                        // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketNameForCastingAttachment;                    // 0x027C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketNameForHitEffectAttachment;                  // 0x0284(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagAppliedOnStart;                                 // 0x0290(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHasUseFlag;                                       // 0x02B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int64 GetAssociatedItemID();
	int64 GetEffectShaderID();
	int64 GetEnchantEffectID();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESEffectSetting">();
	}
	static class UTESEffectSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESEffectSetting>();
	}
};
static_assert(alignof(UTESEffectSetting) == 0x000008, "Wrong alignment on UTESEffectSetting");
static_assert(sizeof(UTESEffectSetting) == 0x0002B8, "Wrong size on UTESEffectSetting");
static_assert(offsetof(UTESEffectSetting, FullName) == 0x0000D8, "Member 'UTESEffectSetting::FullName' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, TextureIcon) == 0x0000E8, "Member 'UTESEffectSetting::TextureIcon' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, AssociatedItem) == 0x000110, "Member 'UTESEffectSetting::AssociatedItem' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, EffectShader) == 0x000138, "Member 'UTESEffectSetting::EffectShader' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, EnchantEffect) == 0x000160, "Member 'UTESEffectSetting::EnchantEffect' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, AssociatedItemID) == 0x000188, "Member 'UTESEffectSetting::AssociatedItemID' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, EffectShaderID) == 0x00018C, "Member 'UTESEffectSetting::EffectShaderID' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, EnchantEffectID) == 0x000190, "Member 'UTESEffectSetting::EnchantEffectID' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, CastingBlueprintClass) == 0x000198, "Member 'UTESEffectSetting::CastingBlueprintClass' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, ProjectileBlueprintClass) == 0x0001A0, "Member 'UTESEffectSetting::ProjectileBlueprintClass' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, AreaEffectBlueprintClass) == 0x0001A8, "Member 'UTESEffectSetting::AreaEffectBlueprintClass' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, HitEffectBlueprintClass) == 0x0001B0, "Member 'UTESEffectSetting::HitEffectBlueprintClass' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, BlueprintCastingParameters) == 0x0001B8, "Member 'UTESEffectSetting::BlueprintCastingParameters' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, BlueprintProjectileParameters) == 0x0001E8, "Member 'UTESEffectSetting::BlueprintProjectileParameters' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, BlueprintAreaEffectParameters) == 0x000218, "Member 'UTESEffectSetting::BlueprintAreaEffectParameters' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, BlueprintHitEffectParameters) == 0x000248, "Member 'UTESEffectSetting::BlueprintHitEffectParameters' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, MaxDurationBeforeDestroyed) == 0x000278, "Member 'UTESEffectSetting::MaxDurationBeforeDestroyed' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, SocketNameForCastingAttachment) == 0x00027C, "Member 'UTESEffectSetting::SocketNameForCastingAttachment' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, SocketNameForHitEffectAttachment) == 0x000284, "Member 'UTESEffectSetting::SocketNameForHitEffectAttachment' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, TagAppliedOnStart) == 0x000290, "Member 'UTESEffectSetting::TagAppliedOnStart' has a wrong offset!");
static_assert(offsetof(UTESEffectSetting, bHasUseFlag) == 0x0002B0, "Member 'UTESEffectSetting::bHasUseFlag' has a wrong offset!");

// Class Altar.VAnimNotify_DrawArrow
// 0x0000 (0x0038 - 0x0038)
class UVAnimNotify_DrawArrow final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_DrawArrow">();
	}
	static class UVAnimNotify_DrawArrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_DrawArrow>();
	}
};
static_assert(alignof(UVAnimNotify_DrawArrow) == 0x000008, "Wrong alignment on UVAnimNotify_DrawArrow");
static_assert(sizeof(UVAnimNotify_DrawArrow) == 0x000038, "Wrong size on UVAnimNotify_DrawArrow");

// Class Altar.TESEffectShader
// 0x0068 (0x0140 - 0x00D8)
class UTESEffectShader : public UTESForm
{
public:
	TSubclassOf<class AVStatusEffectVFXBlueprint> StatusEffectVFXBlueprintClass;                     // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStatusEffectAnimationSettings         AnimationSettings;                                 // 0x00E0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      OverlayMaterial;                                   // 0x00E8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   DefaultVFXColors;                                  // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EVBodyTextureEffectColors>             ColorUsages;                                       // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCanSwitchMaterial;                                // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVPriorityTypeOnPawn                          PriorityTypeOnPawn;                                // 0x0131(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x2];                                      // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HighPriorityValue;                                 // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPresentOnWeapons;                               // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESEffectShader">();
	}
	static class UTESEffectShader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESEffectShader>();
	}
};
static_assert(alignof(UTESEffectShader) == 0x000008, "Wrong alignment on UTESEffectShader");
static_assert(sizeof(UTESEffectShader) == 0x000140, "Wrong size on UTESEffectShader");
static_assert(offsetof(UTESEffectShader, StatusEffectVFXBlueprintClass) == 0x0000D8, "Member 'UTESEffectShader::StatusEffectVFXBlueprintClass' has a wrong offset!");
static_assert(offsetof(UTESEffectShader, AnimationSettings) == 0x0000E0, "Member 'UTESEffectShader::AnimationSettings' has a wrong offset!");
static_assert(offsetof(UTESEffectShader, OverlayMaterial) == 0x0000E8, "Member 'UTESEffectShader::OverlayMaterial' has a wrong offset!");
static_assert(offsetof(UTESEffectShader, DefaultVFXColors) == 0x000110, "Member 'UTESEffectShader::DefaultVFXColors' has a wrong offset!");
static_assert(offsetof(UTESEffectShader, ColorUsages) == 0x000120, "Member 'UTESEffectShader::ColorUsages' has a wrong offset!");
static_assert(offsetof(UTESEffectShader, bCanSwitchMaterial) == 0x000130, "Member 'UTESEffectShader::bCanSwitchMaterial' has a wrong offset!");
static_assert(offsetof(UTESEffectShader, PriorityTypeOnPawn) == 0x000131, "Member 'UTESEffectShader::PriorityTypeOnPawn' has a wrong offset!");
static_assert(offsetof(UTESEffectShader, HighPriorityValue) == 0x000134, "Member 'UTESEffectShader::HighPriorityValue' has a wrong offset!");
static_assert(offsetof(UTESEffectShader, bIsPresentOnWeapons) == 0x000138, "Member 'UTESEffectShader::bIsPresentOnWeapons' has a wrong offset!");

// Class Altar.VSpellMakingMenuViewModel
// 0x0070 (0x0140 - 0x00D0)
class UVSpellMakingMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnEffectSettingsMenuOpen;                          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEffectSettingsMenuClose;                         // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSucessSoundTrigger;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<struct FLegacyEffectsItemProperties>   KnownEffectsItems;                                 // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FLegacySpellMakingCost                 SpellMakingCost;                                   // 0x0110(0x000C)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RequiredEffectsText;                               // 0x0120(0x0018)(NativeAccessSpecifierPrivate)
	EOriginalInventoryMenuSortType                SortType;                                          // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSortReversed;                                   // 0x0139(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRequiredEffectVisible;                          // 0x013A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13B[0x5];                                      // 0x013B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendClickedAddedEffect(int32 Index_0, bool bWantToDelete);
	void RegisterSendClickedCreate(const class FText& NewSpellName);
	void RegisterSendClickedExit();
	void RegisterSendClickedKnownEffect(int32 Index_0, bool bWantToDelete);
	void SetIsSortReversed(bool bNewIsSortReversed);
	void SetKnownEffectsItems(const TArray<struct FLegacyEffectsItemProperties>& Value);
	void SetRequiredEffectsText(const class FText& Value);
	void SetRequiredEffectVisibility(bool bNewVisibility);
	void SetSortType(const EOriginalInventoryMenuSortType& NewSortType);
	void SetSpellMakingCost(const struct FLegacySpellMakingCost& Value);

	const TArray<struct FLegacyEffectsItemProperties> GetKnownEffectsItems() const;
	const class FText GetRequiredEffectsText() const;
	EOriginalInventoryMenuSortType GetSortType() const;
	const struct FLegacySpellMakingCost GetSpellMakingCost() const;
	bool IsRequiredEffectVisible() const;
	bool IsSortReversed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSpellMakingMenuViewModel">();
	}
	static class UVSpellMakingMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSpellMakingMenuViewModel>();
	}
};
static_assert(alignof(UVSpellMakingMenuViewModel) == 0x000008, "Wrong alignment on UVSpellMakingMenuViewModel");
static_assert(sizeof(UVSpellMakingMenuViewModel) == 0x000140, "Wrong size on UVSpellMakingMenuViewModel");
static_assert(offsetof(UVSpellMakingMenuViewModel, OnEffectSettingsMenuOpen) == 0x0000D0, "Member 'UVSpellMakingMenuViewModel::OnEffectSettingsMenuOpen' has a wrong offset!");
static_assert(offsetof(UVSpellMakingMenuViewModel, OnEffectSettingsMenuClose) == 0x0000E0, "Member 'UVSpellMakingMenuViewModel::OnEffectSettingsMenuClose' has a wrong offset!");
static_assert(offsetof(UVSpellMakingMenuViewModel, OnSucessSoundTrigger) == 0x0000F0, "Member 'UVSpellMakingMenuViewModel::OnSucessSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVSpellMakingMenuViewModel, KnownEffectsItems) == 0x000100, "Member 'UVSpellMakingMenuViewModel::KnownEffectsItems' has a wrong offset!");
static_assert(offsetof(UVSpellMakingMenuViewModel, SpellMakingCost) == 0x000110, "Member 'UVSpellMakingMenuViewModel::SpellMakingCost' has a wrong offset!");
static_assert(offsetof(UVSpellMakingMenuViewModel, RequiredEffectsText) == 0x000120, "Member 'UVSpellMakingMenuViewModel::RequiredEffectsText' has a wrong offset!");
static_assert(offsetof(UVSpellMakingMenuViewModel, SortType) == 0x000138, "Member 'UVSpellMakingMenuViewModel::SortType' has a wrong offset!");
static_assert(offsetof(UVSpellMakingMenuViewModel, bIsSortReversed) == 0x000139, "Member 'UVSpellMakingMenuViewModel::bIsSortReversed' has a wrong offset!");
static_assert(offsetof(UVSpellMakingMenuViewModel, bIsRequiredEffectVisible) == 0x00013A, "Member 'UVSpellMakingMenuViewModel::bIsRequiredEffectVisible' has a wrong offset!");

// Class Altar.VAltarAkComponent
// 0x0000 (0x04B0 - 0x04B0)
class UVAltarAkComponent final : public UAkComponent
{
public:
	void ForceUpdateGameObjectPosition();

	bool BPF_HasActiveEvents() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarAkComponent">();
	}
	static class UVAltarAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarAkComponent>();
	}
};
static_assert(alignof(UVAltarAkComponent) == 0x000010, "Wrong alignment on UVAltarAkComponent");
static_assert(sizeof(UVAltarAkComponent) == 0x0004B0, "Wrong size on UVAltarAkComponent");

// Class Altar.TESEnchantment
// 0x0000 (0x00F8 - 0x00F8)
class UTESEnchantment final : public UTESMagicItemForm
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESEnchantment">();
	}
	static class UTESEnchantment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESEnchantment>();
	}
};
static_assert(alignof(UTESEnchantment) == 0x000008, "Wrong alignment on UTESEnchantment");
static_assert(sizeof(UTESEnchantment) == 0x0000F8, "Wrong size on UTESEnchantment");

// Class Altar.TESEyes
// 0x0020 (0x00F8 - 0x00D8)
class UTESEyes final : public UTESForm
{
public:
	class FString                                 FullName;                                          // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     NewMaterial;                                       // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Flags_0;                                           // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESEyes">();
	}
	static class UTESEyes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESEyes>();
	}
};
static_assert(alignof(UTESEyes) == 0x000008, "Wrong alignment on UTESEyes");
static_assert(sizeof(UTESEyes) == 0x0000F8, "Wrong size on UTESEyes");
static_assert(offsetof(UTESEyes, FullName) == 0x0000D8, "Member 'UTESEyes::FullName' has a wrong offset!");
static_assert(offsetof(UTESEyes, NewMaterial) == 0x0000E8, "Member 'UTESEyes::NewMaterial' has a wrong offset!");
static_assert(offsetof(UTESEyes, Flags_0) == 0x0000F0, "Member 'UTESEyes::Flags_0' has a wrong offset!");

// Class Altar.VAnimNotify_FootStep
// 0x0000 (0x0038 - 0x0038)
class UVAnimNotify_FootStep : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_FootStep">();
	}
	static class UVAnimNotify_FootStep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_FootStep>();
	}
};
static_assert(alignof(UVAnimNotify_FootStep) == 0x000008, "Wrong alignment on UVAnimNotify_FootStep");
static_assert(sizeof(UVAnimNotify_FootStep) == 0x000038, "Wrong size on UVAnimNotify_FootStep");

// Class Altar.VAnimNotify_FootStepVFX
// 0x0010 (0x0048 - 0x0038)
class UVAnimNotify_FootStepVFX final : public UVAnimNotify_FootStep
{
public:
	class FName                                   BoneName;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  OwnerActor;                                        // 0x0040(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_FootStepVFX">();
	}
	static class UVAnimNotify_FootStepVFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_FootStepVFX>();
	}
};
static_assert(alignof(UVAnimNotify_FootStepVFX) == 0x000008, "Wrong alignment on UVAnimNotify_FootStepVFX");
static_assert(sizeof(UVAnimNotify_FootStepVFX) == 0x000048, "Wrong size on UVAnimNotify_FootStepVFX");
static_assert(offsetof(UVAnimNotify_FootStepVFX, BoneName) == 0x000038, "Member 'UVAnimNotify_FootStepVFX::BoneName' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_FootStepVFX, OwnerActor) == 0x000040, "Member 'UVAnimNotify_FootStepVFX::OwnerActor' has a wrong offset!");

// Class Altar.VAltarEntitlementBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAltarEntitlementBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool HasDeluxeEntitlement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarEntitlementBlueprintLibrary">();
	}
	static class UVAltarEntitlementBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarEntitlementBlueprintLibrary>();
	}
};
static_assert(alignof(UVAltarEntitlementBlueprintLibrary) == 0x000008, "Wrong alignment on UVAltarEntitlementBlueprintLibrary");
static_assert(sizeof(UVAltarEntitlementBlueprintLibrary) == 0x000028, "Wrong size on UVAltarEntitlementBlueprintLibrary");

// Class Altar.TESObjectACTI
// 0x0038 (0x01C8 - 0x0190)
class UTESObjectACTI : public UTESBoundObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimBlueprint>          PosePairingAnimBlueprint;                          // 0x01A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectACTI">();
	}
	static class UTESObjectACTI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectACTI>();
	}
};
static_assert(alignof(UTESObjectACTI) == 0x000008, "Wrong alignment on UTESObjectACTI");
static_assert(sizeof(UTESObjectACTI) == 0x0001C8, "Wrong size on UTESObjectACTI");
static_assert(offsetof(UTESObjectACTI, FullName) == 0x000190, "Member 'UTESObjectACTI::FullName' has a wrong offset!");
static_assert(offsetof(UTESObjectACTI, PosePairingAnimBlueprint) == 0x0001A0, "Member 'UTESObjectACTI::PosePairingAnimBlueprint' has a wrong offset!");

// Class Altar.TESFlora
// 0x0028 (0x01F0 - 0x01C8)
class UTESFlora final : public UTESObjectACTI
{
public:
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESFlora">();
	}
	static class UTESFlora* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESFlora>();
	}
};
static_assert(alignof(UTESFlora) == 0x000008, "Wrong alignment on UTESFlora");
static_assert(sizeof(UTESFlora) == 0x0001F0, "Wrong size on UTESFlora");
static_assert(offsetof(UTESFlora, NewMesh) == 0x0001C8, "Member 'UTESFlora::NewMesh' has a wrong offset!");

// Class Altar.TESFurniture
// 0x0028 (0x01F0 - 0x01C8)
class UTESFurniture final : public UTESObjectACTI
{
public:
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESFurniture">();
	}
	static class UTESFurniture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESFurniture>();
	}
};
static_assert(alignof(UTESFurniture) == 0x000008, "Wrong alignment on UTESFurniture");
static_assert(sizeof(UTESFurniture) == 0x0001F0, "Wrong size on UTESFurniture");
static_assert(offsetof(UTESFurniture, NewMesh) == 0x0001C8, "Member 'UTESFurniture::NewMesh' has a wrong offset!");

// Class Altar.VAnimNotify_PlayFootStep
// 0x0018 (0x0050 - 0x0038)
class UVAnimNotify_PlayFootStep final : public UVAnimNotify_FootStep
{
public:
	class UAkAudioEvent*                          FootstepEventOverride;                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachName;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  OwnerActor;                                        // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_PlayFootStep">();
	}
	static class UVAnimNotify_PlayFootStep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_PlayFootStep>();
	}
};
static_assert(alignof(UVAnimNotify_PlayFootStep) == 0x000008, "Wrong alignment on UVAnimNotify_PlayFootStep");
static_assert(sizeof(UVAnimNotify_PlayFootStep) == 0x000050, "Wrong size on UVAnimNotify_PlayFootStep");
static_assert(offsetof(UVAnimNotify_PlayFootStep, FootstepEventOverride) == 0x000038, "Member 'UVAnimNotify_PlayFootStep::FootstepEventOverride' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_PlayFootStep, AttachName) == 0x000040, "Member 'UVAnimNotify_PlayFootStep::AttachName' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_PlayFootStep, OwnerActor) == 0x000048, "Member 'UVAnimNotify_PlayFootStep::OwnerActor' has a wrong offset!");

// Class Altar.TESGameSetting
// 0x0018 (0x00F0 - 0x00D8)
class UTESGameSetting final : public UTESForm
{
public:
	int32                                         IntValue;                                          // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringValue;                                       // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESGameSetting">();
	}
	static class UTESGameSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESGameSetting>();
	}
};
static_assert(alignof(UTESGameSetting) == 0x000008, "Wrong alignment on UTESGameSetting");
static_assert(sizeof(UTESGameSetting) == 0x0000F0, "Wrong size on UTESGameSetting");
static_assert(offsetof(UTESGameSetting, IntValue) == 0x0000D8, "Member 'UTESGameSetting::IntValue' has a wrong offset!");
static_assert(offsetof(UTESGameSetting, FloatValue) == 0x0000DC, "Member 'UTESGameSetting::FloatValue' has a wrong offset!");
static_assert(offsetof(UTESGameSetting, StringValue) == 0x0000E0, "Member 'UTESGameSetting::StringValue' has a wrong offset!");

// Class Altar.VAltarButton
// 0x0020 (0x1610 - 0x15F0)
#pragma pack(push, 0x1)
class alignas(0x10) UVAltarButton : public UNavigationButton
{
public:
	class FText                                   ButtonText;                                        // 0x15E8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	bool                                          ControllerActive;                                  // 0x1600(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1601[0x7];                                     // 0x1601(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeInputMethod(ECommonInputType InputType);
	void ForceSynchronizeProperties();
	void OnButtonTextUpdated(const class FText& Value);
	void OnControllerActiveUpdated(const bool Value);
	void OnSynchronizeProperties();
	void SetButtonText(const class FText& Value);
	void SetControllerActive(const bool Value);

	class FText GetButtonText() const;
	bool GetControllerActive() const;
	float GetControllerButtonIconCropX() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarButton">();
	}
	static class UVAltarButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarButton>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVAltarButton) == 0x000010, "Wrong alignment on UVAltarButton");
static_assert(sizeof(UVAltarButton) == 0x001610, "Wrong size on UVAltarButton");
static_assert(offsetof(UVAltarButton, ButtonText) == 0x0015E8, "Member 'UVAltarButton::ButtonText' has a wrong offset!");
static_assert(offsetof(UVAltarButton, ControllerActive) == 0x001600, "Member 'UVAltarButton::ControllerActive' has a wrong offset!");

// Class Altar.TESGrass
// 0x0020 (0x01B0 - 0x0190)
class UTESGrass final : public UTESBoundObject
{
public:
	struct FTESGrassData                          Data;                                              // 0x0190(0x0020)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESGrass">();
	}
	static class UTESGrass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESGrass>();
	}
};
static_assert(alignof(UTESGrass) == 0x000008, "Wrong alignment on UTESGrass");
static_assert(sizeof(UTESGrass) == 0x0001B0, "Wrong size on UTESGrass");
static_assert(offsetof(UTESGrass, Data) == 0x000190, "Member 'UTESGrass::Data' has a wrong offset!");

// Class Altar.VLegacySaveLoadMenuItem
// 0x0028 (0x0050 - 0x0028)
class UVLegacySaveLoadMenuItem final : public UObject
{
public:
	class FText                                   Text;                                              // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	class FString                                 SaveGameSlot;                                      // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetSlotName(const class FString& NewSlotName);
	void SetText(const class FText& Value);

	class FString GetSlotName() const;
	const class FText GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacySaveLoadMenuItem">();
	}
	static class UVLegacySaveLoadMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacySaveLoadMenuItem>();
	}
};
static_assert(alignof(UVLegacySaveLoadMenuItem) == 0x000008, "Wrong alignment on UVLegacySaveLoadMenuItem");
static_assert(sizeof(UVLegacySaveLoadMenuItem) == 0x000050, "Wrong size on UVLegacySaveLoadMenuItem");
static_assert(offsetof(UVLegacySaveLoadMenuItem, Text) == 0x000028, "Member 'UVLegacySaveLoadMenuItem::Text' has a wrong offset!");
static_assert(offsetof(UVLegacySaveLoadMenuItem, SaveGameSlot) == 0x000040, "Member 'UVLegacySaveLoadMenuItem::SaveGameSlot' has a wrong offset!");

// Class Altar.TESHair
// 0x0020 (0x00F8 - 0x00D8)
class UTESHair final : public UTESForm
{
public:
	class FString                                 FullName;                                          // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVCharacterHairPiece_Hair*              NewMesh;                                           // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Flags_0;                                           // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESHair">();
	}
	static class UTESHair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESHair>();
	}
};
static_assert(alignof(UTESHair) == 0x000008, "Wrong alignment on UTESHair");
static_assert(sizeof(UTESHair) == 0x0000F8, "Wrong size on UTESHair");
static_assert(offsetof(UTESHair, FullName) == 0x0000D8, "Member 'UTESHair::FullName' has a wrong offset!");
static_assert(offsetof(UTESHair, NewMesh) == 0x0000E8, "Member 'UTESHair::NewMesh' has a wrong offset!");
static_assert(offsetof(UTESHair, Flags_0) == 0x0000F0, "Member 'UTESHair::Flags_0' has a wrong offset!");

// Class Altar.VAltarNavigableScrollBox
// 0x0020 (0x0508 - 0x04E8)
class UVAltarNavigableScrollBox : public UVNavigableScrollBox
{
public:
	uint8                                         Pad_4E8[0x8];                                      // 0x04E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVModernScrollbar*                      AssociatedScrollbar;                               // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                NoScrollbarWidget;                                 // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnScrollbarValueChanged(float NewValue);
	void OnScrollBoxValuesChanged(float MinScrollbarValue, float MaxScrollbarValue, float CurrentScrollbarValue, float ThumbFractionSize);
	void OnUserScrolled(float NewValue);
	void UpdateLockState(bool bNewLockState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableScrollBox">();
	}
	static class UVAltarNavigableScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableScrollBox>();
	}
};
static_assert(alignof(UVAltarNavigableScrollBox) == 0x000008, "Wrong alignment on UVAltarNavigableScrollBox");
static_assert(sizeof(UVAltarNavigableScrollBox) == 0x000508, "Wrong size on UVAltarNavigableScrollBox");
static_assert(offsetof(UVAltarNavigableScrollBox, AssociatedScrollbar) == 0x0004F0, "Member 'UVAltarNavigableScrollBox::AssociatedScrollbar' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableScrollBox, NoScrollbarWidget) == 0x0004F8, "Member 'UVAltarNavigableScrollBox::NoScrollbarWidget' has a wrong offset!");

// Class Altar.TESHeader
// 0x0020 (0x0048 - 0x0028)
class UTESHeader final : public UObject
{
public:
	int64                                         FormID;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Length;                                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Flags_0;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Type;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESHeader">();
	}
	static class UTESHeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESHeader>();
	}
};
static_assert(alignof(UTESHeader) == 0x000008, "Wrong alignment on UTESHeader");
static_assert(sizeof(UTESHeader) == 0x000048, "Wrong size on UTESHeader");
static_assert(offsetof(UTESHeader, FormID) == 0x000028, "Member 'UTESHeader::FormID' has a wrong offset!");
static_assert(offsetof(UTESHeader, Length) == 0x000030, "Member 'UTESHeader::Length' has a wrong offset!");
static_assert(offsetof(UTESHeader, Flags_0) == 0x000038, "Member 'UTESHeader::Flags_0' has a wrong offset!");
static_assert(offsetof(UTESHeader, Type) == 0x000040, "Member 'UTESHeader::Type' has a wrong offset!");

// Class Altar.TESTexture
// 0x0010 (0x0038 - 0x0028)
class UTESTexture : public UTESBaseFormComponent
{
public:
	class FString                                 TextureName;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESTexture">();
	}
	static class UTESTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESTexture>();
	}
};
static_assert(alignof(UTESTexture) == 0x000008, "Wrong alignment on UTESTexture");
static_assert(sizeof(UTESTexture) == 0x000038, "Wrong size on UTESTexture");
static_assert(offsetof(UTESTexture, TextureName) == 0x000028, "Member 'UTESTexture::TextureName' has a wrong offset!");

// Class Altar.VEntityDetailsDebugMenu
// 0x0010 (0x04F8 - 0x04E8)
class UVEntityDetailsDebugMenu final : public UVAltarMenu
{
public:
	TWeakObjectPtr<class AVPairedPawn>            ControlledPairedPawn;                              // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityDebugIndex;                                  // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEntityDetailsDebugMenu">();
	}
	static class UVEntityDetailsDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEntityDetailsDebugMenu>();
	}
};
static_assert(alignof(UVEntityDetailsDebugMenu) == 0x000008, "Wrong alignment on UVEntityDetailsDebugMenu");
static_assert(sizeof(UVEntityDetailsDebugMenu) == 0x0004F8, "Wrong size on UVEntityDetailsDebugMenu");
static_assert(offsetof(UVEntityDetailsDebugMenu, ControlledPairedPawn) == 0x0004E8, "Member 'UVEntityDetailsDebugMenu::ControlledPairedPawn' has a wrong offset!");
static_assert(offsetof(UVEntityDetailsDebugMenu, EntityDebugIndex) == 0x0004F0, "Member 'UVEntityDetailsDebugMenu::EntityDebugIndex' has a wrong offset!");

// Class Altar.VAltarMediaPlayer
// 0x00D0 (0x0390 - 0x02C0)
class UVAltarMediaPlayer final : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(const class FString& OpenedUrl)> OnVideoOpenned;                   // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVideoCompleted;                                  // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UImage*                                 VideoRenderer;                                     // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMediaTexture>           Soft_MediaTexture;                                 // 0x02E8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMediaPlayer>            Soft_MediaPlayer;                                  // 0x0310(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterial>               Soft_MediaTextureMaterial;                         // 0x0338(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMediaSource>            Soft_MediaSource;                                  // 0x0360(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void Close();
	void Internal_OnVideoCompleted();
	void Internal_OnVideoOpenned(const class FString& OpenedUrl);
	bool IsOpenned();
	bool IsPlaying();
	bool Open();
	bool Pause();
	bool Play();
	bool PlayFromStart();
	bool PlayFromTimeStamp(float Timestamp);
	bool Prepare();
	bool Seek(float Timestamp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarMediaPlayer">();
	}
	static class UVAltarMediaPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarMediaPlayer>();
	}
};
static_assert(alignof(UVAltarMediaPlayer) == 0x000008, "Wrong alignment on UVAltarMediaPlayer");
static_assert(sizeof(UVAltarMediaPlayer) == 0x000390, "Wrong size on UVAltarMediaPlayer");
static_assert(offsetof(UVAltarMediaPlayer, OnVideoOpenned) == 0x0002C0, "Member 'UVAltarMediaPlayer::OnVideoOpenned' has a wrong offset!");
static_assert(offsetof(UVAltarMediaPlayer, OnVideoCompleted) == 0x0002D0, "Member 'UVAltarMediaPlayer::OnVideoCompleted' has a wrong offset!");
static_assert(offsetof(UVAltarMediaPlayer, VideoRenderer) == 0x0002E0, "Member 'UVAltarMediaPlayer::VideoRenderer' has a wrong offset!");
static_assert(offsetof(UVAltarMediaPlayer, Soft_MediaTexture) == 0x0002E8, "Member 'UVAltarMediaPlayer::Soft_MediaTexture' has a wrong offset!");
static_assert(offsetof(UVAltarMediaPlayer, Soft_MediaPlayer) == 0x000310, "Member 'UVAltarMediaPlayer::Soft_MediaPlayer' has a wrong offset!");
static_assert(offsetof(UVAltarMediaPlayer, Soft_MediaTextureMaterial) == 0x000338, "Member 'UVAltarMediaPlayer::Soft_MediaTextureMaterial' has a wrong offset!");
static_assert(offsetof(UVAltarMediaPlayer, Soft_MediaSource) == 0x000360, "Member 'UVAltarMediaPlayer::Soft_MediaSource' has a wrong offset!");

// Class Altar.TESIcon
// 0x0000 (0x0038 - 0x0038)
class UTESIcon final : public UTESTexture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESIcon">();
	}
	static class UTESIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESIcon>();
	}
};
static_assert(alignof(UTESIcon) == 0x000008, "Wrong alignment on UTESIcon");
static_assert(sizeof(UTESIcon) == 0x000038, "Wrong size on UTESIcon");

// Class Altar.TESIdleForm
// 0x0038 (0x0110 - 0x00D8)
class UTESIdleForm final : public UTESForm
{
public:
	TSoftObjectPtr<class UAnimSequenceBase>       AnimSequence;                                      // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OriginalPath;                                      // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESIdleForm">();
	}
	static class UTESIdleForm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESIdleForm>();
	}
};
static_assert(alignof(UTESIdleForm) == 0x000008, "Wrong alignment on UTESIdleForm");
static_assert(sizeof(UTESIdleForm) == 0x000110, "Wrong size on UTESIdleForm");
static_assert(offsetof(UTESIdleForm, AnimSequence) == 0x0000D8, "Member 'UTESIdleForm::AnimSequence' has a wrong offset!");
static_assert(offsetof(UTESIdleForm, OriginalPath) == 0x000100, "Member 'UTESIdleForm::OriginalPath' has a wrong offset!");

// Class Altar.VSubLevelsHolder
// 0x0008 (0x0030 - 0x0028)
class UVSubLevelsHolder final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSubLevelsHolder">();
	}
	static class UVSubLevelsHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSubLevelsHolder>();
	}
};
static_assert(alignof(UVSubLevelsHolder) == 0x000008, "Wrong alignment on UVSubLevelsHolder");
static_assert(sizeof(UVSubLevelsHolder) == 0x000030, "Wrong size on UVSubLevelsHolder");

// Class Altar.VAltarNavigableWidgetSwitcher
// 0x0008 (0x04E8 - 0x04E0)
class UVAltarNavigableWidgetSwitcher : public UVNavigableWidgetSwitcher
{
public:
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableWidgetSwitcher">();
	}
	static class UVAltarNavigableWidgetSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableWidgetSwitcher>();
	}
};
static_assert(alignof(UVAltarNavigableWidgetSwitcher) == 0x000008, "Wrong alignment on UVAltarNavigableWidgetSwitcher");
static_assert(sizeof(UVAltarNavigableWidgetSwitcher) == 0x0004E8, "Wrong size on UVAltarNavigableWidgetSwitcher");

// Class Altar.TESIngredientItem
// 0x0028 (0x01D8 - 0x01B0)
class UTESIngredientItem final : public UTESMagicItemObject
{
public:
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01B0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESIngredientItem">();
	}
	static class UTESIngredientItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESIngredientItem>();
	}
};
static_assert(alignof(UTESIngredientItem) == 0x000008, "Wrong alignment on UTESIngredientItem");
static_assert(sizeof(UTESIngredientItem) == 0x0001D8, "Wrong size on UTESIngredientItem");
static_assert(offsetof(UTESIngredientItem, NewMesh) == 0x0001B0, "Member 'UTESIngredientItem::NewMesh' has a wrong offset!");

// Class Altar.TESObjectMISC
// 0x0060 (0x01F0 - 0x0190)
class UTESObjectMISC : public UTESBoundObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TextureIcon;                                       // 0x01A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectMISC">();
	}
	static class UTESObjectMISC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectMISC>();
	}
};
static_assert(alignof(UTESObjectMISC) == 0x000008, "Wrong alignment on UTESObjectMISC");
static_assert(sizeof(UTESObjectMISC) == 0x0001F0, "Wrong size on UTESObjectMISC");
static_assert(offsetof(UTESObjectMISC, FullName) == 0x000190, "Member 'UTESObjectMISC::FullName' has a wrong offset!");
static_assert(offsetof(UTESObjectMISC, TextureIcon) == 0x0001A0, "Member 'UTESObjectMISC::TextureIcon' has a wrong offset!");
static_assert(offsetof(UTESObjectMISC, NewMesh) == 0x0001C8, "Member 'UTESObjectMISC::NewMesh' has a wrong offset!");

// Class Altar.VEquipUnequipCharacterAnimInstance
// 0x0010 (0x03B0 - 0x03A0)
#pragma pack(push, 0x1)
class alignas(0x10) UVEquipUnequipCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	bool                                          bHasEquipRequest;                                  // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasUnequipRequest;                                // 0x03A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A2[0x6];                                      // 0x03A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsSneaking() const;
	bool IsStanding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEquipUnequipCharacterAnimInstance">();
	}
	static class UVEquipUnequipCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEquipUnequipCharacterAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVEquipUnequipCharacterAnimInstance) == 0x000010, "Wrong alignment on UVEquipUnequipCharacterAnimInstance");
static_assert(sizeof(UVEquipUnequipCharacterAnimInstance) == 0x0003B0, "Wrong size on UVEquipUnequipCharacterAnimInstance");
static_assert(offsetof(UVEquipUnequipCharacterAnimInstance, bHasEquipRequest) == 0x0003A0, "Member 'UVEquipUnequipCharacterAnimInstance::bHasEquipRequest' has a wrong offset!");
static_assert(offsetof(UVEquipUnequipCharacterAnimInstance, bHasUnequipRequest) == 0x0003A1, "Member 'UVEquipUnequipCharacterAnimInstance::bHasUnequipRequest' has a wrong offset!");

// Class Altar.VEquipUnequipSSSwimSingle
// 0x0040 (0x03F0 - 0x03B0)
class UVEquipUnequipSSSwimSingle : public UVEquipUnequipCharacterAnimInstance
{
public:
	struct FEquipUnequipStandSneakSwimSingleData  LayerData;                                         // 0x03A8(0x0030)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      EquipAnim;                                         // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      UnequipAnim;                                       // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEquipEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnUnEquipEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEquipUnequipSSSwimSingle">();
	}
	static class UVEquipUnequipSSSwimSingle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEquipUnequipSSSwimSingle>();
	}
};
static_assert(alignof(UVEquipUnequipSSSwimSingle) == 0x000010, "Wrong alignment on UVEquipUnequipSSSwimSingle");
static_assert(sizeof(UVEquipUnequipSSSwimSingle) == 0x0003F0, "Wrong size on UVEquipUnequipSSSwimSingle");
static_assert(offsetof(UVEquipUnequipSSSwimSingle, LayerData) == 0x0003A8, "Member 'UVEquipUnequipSSSwimSingle::LayerData' has a wrong offset!");
static_assert(offsetof(UVEquipUnequipSSSwimSingle, EquipAnim) == 0x0003D8, "Member 'UVEquipUnequipSSSwimSingle::EquipAnim' has a wrong offset!");
static_assert(offsetof(UVEquipUnequipSSSwimSingle, UnequipAnim) == 0x0003E0, "Member 'UVEquipUnequipSSSwimSingle::UnequipAnim' has a wrong offset!");

// Class Altar.TESKey
// 0x0000 (0x01F0 - 0x01F0)
class UTESKey final : public UTESObjectMISC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESKey">();
	}
	static class UTESKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESKey>();
	}
};
static_assert(alignof(UTESKey) == 0x000008, "Wrong alignment on UTESKey");
static_assert(sizeof(UTESKey) == 0x0001F0, "Wrong size on UTESKey");

// Class Altar.TESLandscape
// 0x0150 (0x0228 - 0x00D8)
class UTESLandscape final : public UTESForm
{
public:
	uint8                                         Pad_D8[0x100];                                     // 0x00D8(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	class UTESCell*                               ParentCell;                                        // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TESOriginHeight;                                   // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TESMinHeight;                                      // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TESMaxHeight;                                      // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTESHeightmapData                      HeightmapData;                                     // 0x01F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UTESLandTexture*                        TESLandBaseTexture;                                // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CreateHeightmapData(bool bFlipYAxis, bool bKeepSouthWestVertices, float ZScaleMinHeight, float ZScaleMaxHeight, float WorldSpaceOffsetY);
	class UTexture2D* GetHeightmapTexture(bool bFlipYAxis);
	class UTESLandTexture* GetLandBaseTexture();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESLandscape">();
	}
	static class UTESLandscape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESLandscape>();
	}
};
static_assert(alignof(UTESLandscape) == 0x000008, "Wrong alignment on UTESLandscape");
static_assert(sizeof(UTESLandscape) == 0x000228, "Wrong size on UTESLandscape");
static_assert(offsetof(UTESLandscape, ParentCell) == 0x0001D8, "Member 'UTESLandscape::ParentCell' has a wrong offset!");
static_assert(offsetof(UTESLandscape, TESOriginHeight) == 0x0001E0, "Member 'UTESLandscape::TESOriginHeight' has a wrong offset!");
static_assert(offsetof(UTESLandscape, TESMinHeight) == 0x0001E4, "Member 'UTESLandscape::TESMinHeight' has a wrong offset!");
static_assert(offsetof(UTESLandscape, TESMaxHeight) == 0x0001E8, "Member 'UTESLandscape::TESMaxHeight' has a wrong offset!");
static_assert(offsetof(UTESLandscape, HeightmapData) == 0x0001F0, "Member 'UTESLandscape::HeightmapData' has a wrong offset!");
static_assert(offsetof(UTESLandscape, TESLandBaseTexture) == 0x000220, "Member 'UTESLandscape::TESLandBaseTexture' has a wrong offset!");

// Class Altar.VAltarOnlineStoreBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAltarOnlineStoreBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetDeluxeStoreId();
	static void OpenContentChangePopup();
	static void OpenStoreDeluxe();
	static void OpenStoreForId(const class FString& ProductId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarOnlineStoreBlueprintLibrary">();
	}
	static class UVAltarOnlineStoreBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarOnlineStoreBlueprintLibrary>();
	}
};
static_assert(alignof(UVAltarOnlineStoreBlueprintLibrary) == 0x000008, "Wrong alignment on UVAltarOnlineStoreBlueprintLibrary");
static_assert(sizeof(UVAltarOnlineStoreBlueprintLibrary) == 0x000028, "Wrong size on UVAltarOnlineStoreBlueprintLibrary");

// Class Altar.TESLandTexture
// 0x0068 (0x0140 - 0x00D8)
class UTESLandTexture final : public UTESForm
{
public:
	TSoftObjectPtr<class UTexture2D>              Texture;                                           // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SpecularExponent;                                  // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTextureHavokData                      HavokData;                                         // 0x0101(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTESGrass*>                      Grasses;                                           // 0x0108(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FString                                 TextureName;                                       // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESLandTexture">();
	}
	static class UTESLandTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESLandTexture>();
	}
};
static_assert(alignof(UTESLandTexture) == 0x000008, "Wrong alignment on UTESLandTexture");
static_assert(sizeof(UTESLandTexture) == 0x000140, "Wrong size on UTESLandTexture");
static_assert(offsetof(UTESLandTexture, Texture) == 0x0000D8, "Member 'UTESLandTexture::Texture' has a wrong offset!");
static_assert(offsetof(UTESLandTexture, SpecularExponent) == 0x000100, "Member 'UTESLandTexture::SpecularExponent' has a wrong offset!");
static_assert(offsetof(UTESLandTexture, HavokData) == 0x000101, "Member 'UTESLandTexture::HavokData' has a wrong offset!");
static_assert(offsetof(UTESLandTexture, Grasses) == 0x000108, "Member 'UTESLandTexture::Grasses' has a wrong offset!");
static_assert(offsetof(UTESLandTexture, TextureName) == 0x000118, "Member 'UTESLandTexture::TextureName' has a wrong offset!");

// Class Altar.TESLevCreature
// 0x0008 (0x0198 - 0x0190)
class UTESLevCreature final : public UTESBoundObject
{
public:
	class UTESLeveledList*                        InheritedLeveledList;                              // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESLevCreature">();
	}
	static class UTESLevCreature* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESLevCreature>();
	}
};
static_assert(alignof(UTESLevCreature) == 0x000008, "Wrong alignment on UTESLevCreature");
static_assert(sizeof(UTESLevCreature) == 0x000198, "Wrong size on UTESLevCreature");
static_assert(offsetof(UTESLevCreature, InheritedLeveledList) == 0x000190, "Member 'UTESLevCreature::InheritedLeveledList' has a wrong offset!");

// Class Altar.VFadeWidget
// 0x0038 (0x0520 - 0x04E8)
class UVFadeWidget : public UVAltarMenu
{
public:
	class UImage*                                 FadeScreen;                                        // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarWidget*                          LoadingImage;                                      // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       FadeAnimation;                                     // 0x04F8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_500[0x20];                                     // 0x0500(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadeAnimationBegin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFadeWidget">();
	}
	static class UVFadeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVFadeWidget>();
	}
};
static_assert(alignof(UVFadeWidget) == 0x000008, "Wrong alignment on UVFadeWidget");
static_assert(sizeof(UVFadeWidget) == 0x000520, "Wrong size on UVFadeWidget");
static_assert(offsetof(UVFadeWidget, FadeScreen) == 0x0004E8, "Member 'UVFadeWidget::FadeScreen' has a wrong offset!");
static_assert(offsetof(UVFadeWidget, LoadingImage) == 0x0004F0, "Member 'UVFadeWidget::LoadingImage' has a wrong offset!");
static_assert(offsetof(UVFadeWidget, FadeAnimation) == 0x0004F8, "Member 'UVFadeWidget::FadeAnimation' has a wrong offset!");

// Class Altar.VAltarNavigableInputKeySelector
// 0x0080 (0x05D0 - 0x0550)
class UVAltarNavigableInputKeySelector : public UVNavigableInputKeySelector
{
public:
	TMap<struct FKey, class FText>                LocalizedKeys;                                     // 0x0550(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UVNavigableInputKeySelector* Widget, int32 SelectorIndex)> OnWidgetFocussedDelegate; // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         SelectorIndex;                                     // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                DefaultBackgroundOverlay;                          // 0x05B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x10];                                     // 0x05C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNewlyReboundKeyToInputSystem(const struct FKey& NewlyReboundKey);
	class FText GetHintKeyText(const struct FKey& InKey);
	void RequestRefreshIconImageBrush(const struct FSlateBrush& NewBrush);
	void RequestRefreshIconImageVisibility(ESlateVisibility NewVisibility);
	void RequestRefreshLabelText(const class FText& NewText);
	void RequestRefreshLabelVisibility(ESlateVisibility NewVisibility);
	void ResfreshInputDisplay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableInputKeySelector">();
	}
	static class UVAltarNavigableInputKeySelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableInputKeySelector>();
	}
};
static_assert(alignof(UVAltarNavigableInputKeySelector) == 0x000008, "Wrong alignment on UVAltarNavigableInputKeySelector");
static_assert(sizeof(UVAltarNavigableInputKeySelector) == 0x0005D0, "Wrong size on UVAltarNavigableInputKeySelector");
static_assert(offsetof(UVAltarNavigableInputKeySelector, LocalizedKeys) == 0x000550, "Member 'UVAltarNavigableInputKeySelector::LocalizedKeys' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableInputKeySelector, OnWidgetFocussedDelegate) == 0x0005A0, "Member 'UVAltarNavigableInputKeySelector::OnWidgetFocussedDelegate' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableInputKeySelector, SelectorIndex) == 0x0005B0, "Member 'UVAltarNavigableInputKeySelector::SelectorIndex' has a wrong offset!");
static_assert(offsetof(UVAltarNavigableInputKeySelector, DefaultBackgroundOverlay) == 0x0005B8, "Member 'UVAltarNavigableInputKeySelector::DefaultBackgroundOverlay' has a wrong offset!");

// Class Altar.TESLeveledList
// 0x0018 (0x0040 - 0x0028)
class UTESLeveledList final : public UTESBaseFormComponent
{
public:
	TArray<struct FLEVELED_OBJECT>                LeveledItems;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         ChanceNone;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Flags_0;                                           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESLeveledList">();
	}
	static class UTESLeveledList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESLeveledList>();
	}
};
static_assert(alignof(UTESLeveledList) == 0x000008, "Wrong alignment on UTESLeveledList");
static_assert(sizeof(UTESLeveledList) == 0x000040, "Wrong size on UTESLeveledList");
static_assert(offsetof(UTESLeveledList, LeveledItems) == 0x000028, "Member 'UTESLeveledList::LeveledItems' has a wrong offset!");
static_assert(offsetof(UTESLeveledList, ChanceNone) == 0x000038, "Member 'UTESLeveledList::ChanceNone' has a wrong offset!");
static_assert(offsetof(UTESLeveledList, Flags_0) == 0x00003C, "Member 'UTESLeveledList::Flags_0' has a wrong offset!");

// Class Altar.TESLevItem
// 0x0000 (0x0190 - 0x0190)
class UTESLevItem final : public UTESBoundObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESLevItem">();
	}
	static class UTESLevItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESLevItem>();
	}
};
static_assert(alignof(UTESLevItem) == 0x000008, "Wrong alignment on UTESLevItem");
static_assert(sizeof(UTESLevItem) == 0x000190, "Wrong size on UTESLevItem");

// Class Altar.VAltarPlayerCameraManager
// 0x0770 (0x2B70 - 0x2400)
class AVAltarPlayerCameraManager : public APlayerCameraManager
{
public:
	uint8                                         Pad_2400[0x18];                                    // 0x2400(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVCameraSettingData                    CurrentCameraSettingData;                          // 0x2418(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UCurveFloat*                            OverridedEaseCurveTransition;                      // 0x24C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverridedTransitionDuration;                       // 0x24D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D4[0x4];                                     // 0x24D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAudioListener*                        AudioListener;                                     // 0x24D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVStateMachineComponent*                StateMachineComponent;                             // 0x24E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CameraTags;                                        // 0x24E8(0x0008)(Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LastCameraTags;                                    // 0x24F0(0x0008)(Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  VanityCamAllowedActionTags;                        // 0x24F8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  VanityCamAllowedLocomotionTags;                    // 0x2518(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTimerHandle                           CameraShakeTimerHandle;                            // 0x2538(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2540[0x630];                                   // 0x2540(0x0630)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeCameraTags(const struct FGameplayTag& NewCameraTags);
	void EnterDialogueCamera();
	void ForceSetDialogueFOV(float DesiredFOV, bool bIsInPersuasion);
	void OnCameraTagsChanged(const struct FGameplayTagContainer& CurrentTags, const struct FGameplayTagContainer& PreviousTags);
	void OverrideTransitionDuration(float NewOverrideDuration);
	void OverrideTransitionEaseCurve(class UCurveFloat* NewOverrideCurve);
	void ResetFromInputVanityCameraTimer();
	void RestartFromPauseVanityCameraTimer();
	void SetCurrentCameraSetting(const struct FVCameraSettings& CameraSettingsRow);
	void SetDesiredOverridePitchAngle(float desiredAngle);
	void SetVanityCameraTimer();
	void StopVanityCameraTimer();
	void TakeControlOfCameraPitch(bool bShouldTakeControl);
	void UpdateCamera(float DeltaTime);
	void UpdateDialogueCamera(float DeltaTime, bool bIsInPersuasion);

	bool CanEnterInVanityCamera() const;
	struct FGameplayTag GetCurrentCameraTag() const;
	struct FGameplayTag GetLastCameraTag() const;
	bool HasTagsToEnterVanityCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarPlayerCameraManager">();
	}
	static class AVAltarPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAltarPlayerCameraManager>();
	}
};
static_assert(alignof(AVAltarPlayerCameraManager) == 0x000010, "Wrong alignment on AVAltarPlayerCameraManager");
static_assert(sizeof(AVAltarPlayerCameraManager) == 0x002B70, "Wrong size on AVAltarPlayerCameraManager");
static_assert(offsetof(AVAltarPlayerCameraManager, CurrentCameraSettingData) == 0x002418, "Member 'AVAltarPlayerCameraManager::CurrentCameraSettingData' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerCameraManager, OverridedEaseCurveTransition) == 0x0024C8, "Member 'AVAltarPlayerCameraManager::OverridedEaseCurveTransition' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerCameraManager, OverridedTransitionDuration) == 0x0024D0, "Member 'AVAltarPlayerCameraManager::OverridedTransitionDuration' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerCameraManager, AudioListener) == 0x0024D8, "Member 'AVAltarPlayerCameraManager::AudioListener' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerCameraManager, StateMachineComponent) == 0x0024E0, "Member 'AVAltarPlayerCameraManager::StateMachineComponent' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerCameraManager, CameraTags) == 0x0024E8, "Member 'AVAltarPlayerCameraManager::CameraTags' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerCameraManager, LastCameraTags) == 0x0024F0, "Member 'AVAltarPlayerCameraManager::LastCameraTags' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerCameraManager, VanityCamAllowedActionTags) == 0x0024F8, "Member 'AVAltarPlayerCameraManager::VanityCamAllowedActionTags' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerCameraManager, VanityCamAllowedLocomotionTags) == 0x002518, "Member 'AVAltarPlayerCameraManager::VanityCamAllowedLocomotionTags' has a wrong offset!");
static_assert(offsetof(AVAltarPlayerCameraManager, CameraShakeTimerHandle) == 0x002538, "Member 'AVAltarPlayerCameraManager::CameraShakeTimerHandle' has a wrong offset!");

// Class Altar.TESBoundAnimObject
// 0x0000 (0x0190 - 0x0190)
class UTESBoundAnimObject : public UTESBoundObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESBoundAnimObject">();
	}
	static class UTESBoundAnimObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESBoundAnimObject>();
	}
};
static_assert(alignof(UTESBoundAnimObject) == 0x000008, "Wrong alignment on UTESBoundAnimObject");
static_assert(sizeof(UTESBoundAnimObject) == 0x000190, "Wrong size on UTESBoundAnimObject");

// Class Altar.VUIStateSubsystem
// 0x0028 (0x0058 - 0x0030)
class UVUIStateSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void(EHUDVisibility Flag, bool bAdded)> OnHUDVisbilityChanged;          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bGloballyVisible)> OnHUDGlobalVisbilityChanged;               // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EHUDVisibility                                HUDVisibility;                                     // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsVisibleGlobal;                                  // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayerInDialog;                                 // 0x0052(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const bool AddOrRemoveHUDVisibilityFlag(EHUDVisibility Flag, bool bAdd);
	const bool GetGlobalVisibility();
	const EHUDVisibility GetHUDVisibilityMask();
	const bool HUDVisibilityContains(EHUDVisibility Flag);
	const bool SetGlobalVisibility(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VUIStateSubsystem">();
	}
	static class UVUIStateSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVUIStateSubsystem>();
	}
};
static_assert(alignof(UVUIStateSubsystem) == 0x000008, "Wrong alignment on UVUIStateSubsystem");
static_assert(sizeof(UVUIStateSubsystem) == 0x000058, "Wrong size on UVUIStateSubsystem");
static_assert(offsetof(UVUIStateSubsystem, OnHUDVisbilityChanged) == 0x000030, "Member 'UVUIStateSubsystem::OnHUDVisbilityChanged' has a wrong offset!");
static_assert(offsetof(UVUIStateSubsystem, OnHUDGlobalVisbilityChanged) == 0x000040, "Member 'UVUIStateSubsystem::OnHUDGlobalVisbilityChanged' has a wrong offset!");
static_assert(offsetof(UVUIStateSubsystem, HUDVisibility) == 0x000050, "Member 'UVUIStateSubsystem::HUDVisibility' has a wrong offset!");
static_assert(offsetof(UVUIStateSubsystem, bIsVisibleGlobal) == 0x000051, "Member 'UVUIStateSubsystem::bIsVisibleGlobal' has a wrong offset!");
static_assert(offsetof(UVUIStateSubsystem, bIsPlayerInDialog) == 0x000052, "Member 'UVUIStateSubsystem::bIsPlayerInDialog' has a wrong offset!");

// Class Altar.TESObjectLIGH
// 0x0068 (0x01F8 - 0x0190)
class UTESObjectLIGH final : public UTESBoundAnimObject
{
public:
	struct FOBJ_LIGH                              Data;                                              // 0x0190(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Fade;                                              // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FullName;                                          // 0x01C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Texture;                                           // 0x01D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectLIGH">();
	}
	static class UTESObjectLIGH* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectLIGH>();
	}
};
static_assert(alignof(UTESObjectLIGH) == 0x000008, "Wrong alignment on UTESObjectLIGH");
static_assert(sizeof(UTESObjectLIGH) == 0x0001F8, "Wrong size on UTESObjectLIGH");
static_assert(offsetof(UTESObjectLIGH, Data) == 0x000190, "Member 'UTESObjectLIGH::Data' has a wrong offset!");
static_assert(offsetof(UTESObjectLIGH, Fade) == 0x0001B8, "Member 'UTESObjectLIGH::Fade' has a wrong offset!");
static_assert(offsetof(UTESObjectLIGH, FullName) == 0x0001C0, "Member 'UTESObjectLIGH::FullName' has a wrong offset!");
static_assert(offsetof(UTESObjectLIGH, Texture) == 0x0001D0, "Member 'UTESObjectLIGH::Texture' has a wrong offset!");

// Class Altar.VFastTransitionSubSystem
// 0x0008 (0x0038 - 0x0030)
class UVFastTransitionSubSystem final : public UGameInstanceSubsystem
{
public:
	class UVFastTransition*                       FastTransition;                                    // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFastTransitionSubSystem">();
	}
	static class UVFastTransitionSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVFastTransitionSubSystem>();
	}
};
static_assert(alignof(UVFastTransitionSubSystem) == 0x000008, "Wrong alignment on UVFastTransitionSubSystem");
static_assert(sizeof(UVFastTransitionSubSystem) == 0x000038, "Wrong size on UVFastTransitionSubSystem");
static_assert(offsetof(UVFastTransitionSubSystem, FastTransition) == 0x000030, "Member 'UVFastTransitionSubSystem::FastTransition' has a wrong offset!");

// Class Altar.VAltarHapticFeedbacksBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAltarHapticFeedbacksBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyDeviceProperty(TSubclassOf<class UInputDeviceProperty> DeviceProp);
	static void ClearAllHaptics();
	static bool IsDevicePropertyActive(TSubclassOf<class UInputDeviceProperty> DeviceProp);
	static void OnFreezeHandleHaptics(bool bIsFreezing);
	static void RemoveDeviceProperty(TSubclassOf<class UInputDeviceProperty> DeviceProp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarHapticFeedbacksBlueprintLibrary">();
	}
	static class UVAltarHapticFeedbacksBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarHapticFeedbacksBlueprintLibrary>();
	}
};
static_assert(alignof(UVAltarHapticFeedbacksBlueprintLibrary) == 0x000008, "Wrong alignment on UVAltarHapticFeedbacksBlueprintLibrary");
static_assert(sizeof(UVAltarHapticFeedbacksBlueprintLibrary) == 0x000028, "Wrong size on UVAltarHapticFeedbacksBlueprintLibrary");

// Class Altar.TESModel
// 0x0018 (0x0040 - 0x0028)
class UTESModel final : public UTESBaseFormComponent
{
public:
	class FString                                 Model;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTESTextureList                        TextureList;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESModel">();
	}
	static class UTESModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESModel>();
	}
};
static_assert(alignof(UTESModel) == 0x000008, "Wrong alignment on UTESModel");
static_assert(sizeof(UTESModel) == 0x000040, "Wrong size on UTESModel");
static_assert(offsetof(UTESModel, Model) == 0x000028, "Member 'UTESModel::Model' has a wrong offset!");
static_assert(offsetof(UTESModel, TextureList) == 0x000038, "Member 'UTESModel::TextureList' has a wrong offset!");

// Class Altar.TESModelList
// 0x0010 (0x0038 - 0x0028)
class UTESModelList final : public UTESBaseFormComponent
{
public:
	TArray<class FString>                         Models;                                            // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESModelList">();
	}
	static class UTESModelList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESModelList>();
	}
};
static_assert(alignof(UTESModelList) == 0x000008, "Wrong alignment on UTESModelList");
static_assert(sizeof(UTESModelList) == 0x000038, "Wrong size on UTESModelList");
static_assert(offsetof(UTESModelList, Models) == 0x000028, "Member 'UTESModelList::Models' has a wrong offset!");

// Class Altar.VAIProcedureExecution_TRAVEL
// 0x00B0 (0x00F0 - 0x0040)
class UVAIProcedureExecution_TRAVEL final : public UVAIProcedureExecution_Base
{
public:
	uint8                                         Pad_40[0xB0];                                      // 0x0040(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAcceptanceRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_TRAVEL">();
	}
	static class UVAIProcedureExecution_TRAVEL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_TRAVEL>();
	}
};
static_assert(alignof(UVAIProcedureExecution_TRAVEL) == 0x000008, "Wrong alignment on UVAIProcedureExecution_TRAVEL");
static_assert(sizeof(UVAIProcedureExecution_TRAVEL) == 0x0000F0, "Wrong size on UVAIProcedureExecution_TRAVEL");

// Class Altar.TESNPC
// 0x0098 (0x0268 - 0x01D0)
class UTESNPC final : public UTESActorBase
{
public:
	struct FOblivionNPCFaceGenData                OblivionFaceGenDataOffset;                         // 0x01D0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UTESRace*                               InheritedRace;                                     // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTESHair>                Hair;                                              // 0x0208(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTESEyes>                Eyes;                                              // 0x0230(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterSex                                 Sex;                                               // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultRaceAndSexPreset;                       // 0x0259(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseProceduralHead;                                // 0x025A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B[0x5];                                      // 0x025B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UVCharacterPhenotypeData*               CharacterPhenotypeData;                            // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESNPC">();
	}
	static class UTESNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESNPC>();
	}
};
static_assert(alignof(UTESNPC) == 0x000008, "Wrong alignment on UTESNPC");
static_assert(sizeof(UTESNPC) == 0x000268, "Wrong size on UTESNPC");
static_assert(offsetof(UTESNPC, OblivionFaceGenDataOffset) == 0x0001D0, "Member 'UTESNPC::OblivionFaceGenDataOffset' has a wrong offset!");
static_assert(offsetof(UTESNPC, InheritedRace) == 0x000200, "Member 'UTESNPC::InheritedRace' has a wrong offset!");
static_assert(offsetof(UTESNPC, Hair) == 0x000208, "Member 'UTESNPC::Hair' has a wrong offset!");
static_assert(offsetof(UTESNPC, Eyes) == 0x000230, "Member 'UTESNPC::Eyes' has a wrong offset!");
static_assert(offsetof(UTESNPC, Sex) == 0x000258, "Member 'UTESNPC::Sex' has a wrong offset!");
static_assert(offsetof(UTESNPC, bUseDefaultRaceAndSexPreset) == 0x000259, "Member 'UTESNPC::bUseDefaultRaceAndSexPreset' has a wrong offset!");
static_assert(offsetof(UTESNPC, bUseProceduralHead) == 0x00025A, "Member 'UTESNPC::bUseProceduralHead' has a wrong offset!");
static_assert(offsetof(UTESNPC, CharacterPhenotypeData) == 0x000260, "Member 'UTESNPC::CharacterPhenotypeData' has a wrong offset!");

// Class Altar.TESBoundTreeObject
// 0x0000 (0x0190 - 0x0190)
class UTESBoundTreeObject : public UTESBoundObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESBoundTreeObject">();
	}
	static class UTESBoundTreeObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESBoundTreeObject>();
	}
};
static_assert(alignof(UTESBoundTreeObject) == 0x000008, "Wrong alignment on UTESBoundTreeObject");
static_assert(sizeof(UTESBoundTreeObject) == 0x000190, "Wrong size on UTESBoundTreeObject");

// Class Altar.VAltarNavigationSystemModuleConfig
// 0x0000 (0x0060 - 0x0060)
class UVAltarNavigationSystemModuleConfig final : public UNavigationSystemModuleConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigationSystemModuleConfig">();
	}
	static class UVAltarNavigationSystemModuleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigationSystemModuleConfig>();
	}
};
static_assert(alignof(UVAltarNavigationSystemModuleConfig) == 0x000008, "Wrong alignment on UVAltarNavigationSystemModuleConfig");
static_assert(sizeof(UVAltarNavigationSystemModuleConfig) == 0x000060, "Wrong size on UVAltarNavigationSystemModuleConfig");

// Class Altar.TESObjectAPPA
// 0x0038 (0x01C8 - 0x0190)
class UTESObjectAPPA final : public UTESBoundObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectAPPA">();
	}
	static class UTESObjectAPPA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectAPPA>();
	}
};
static_assert(alignof(UTESObjectAPPA) == 0x000008, "Wrong alignment on UTESObjectAPPA");
static_assert(sizeof(UTESObjectAPPA) == 0x0001C8, "Wrong size on UTESObjectAPPA");
static_assert(offsetof(UTESObjectAPPA, FullName) == 0x000190, "Member 'UTESObjectAPPA::FullName' has a wrong offset!");
static_assert(offsetof(UTESObjectAPPA, NewMesh) == 0x0001A0, "Member 'UTESObjectAPPA::NewMesh' has a wrong offset!");

// Class Altar.TESObjectARMO
// 0x0020 (0x01B0 - 0x0190)
class UTESObjectARMO final : public UTESBoundObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESBipedModelForm*                     InheritedBipedModel;                               // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShield;                                         // 0x01A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectARMO">();
	}
	static class UTESObjectARMO* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectARMO>();
	}
};
static_assert(alignof(UTESObjectARMO) == 0x000008, "Wrong alignment on UTESObjectARMO");
static_assert(sizeof(UTESObjectARMO) == 0x0001B0, "Wrong size on UTESObjectARMO");
static_assert(offsetof(UTESObjectARMO, FullName) == 0x000190, "Member 'UTESObjectARMO::FullName' has a wrong offset!");
static_assert(offsetof(UTESObjectARMO, InheritedBipedModel) == 0x0001A0, "Member 'UTESObjectARMO::InheritedBipedModel' has a wrong offset!");
static_assert(offsetof(UTESObjectARMO, bIsShield) == 0x0001A8, "Member 'UTESObjectARMO::bIsShield' has a wrong offset!");

// Class Altar.VLegacyIngredientItem
// 0x0040 (0x0068 - 0x0028)
class UVLegacyIngredientItem final : public UObject
{
public:
	struct FLegacyIngredientItemProperties        Properties;                                        // 0x0028(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void SetProperties(const struct FLegacyIngredientItemProperties& Value);

	int32 GetIndex() const;
	const struct FLegacyIngredientItemProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyIngredientItem">();
	}
	static class UVLegacyIngredientItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyIngredientItem>();
	}
};
static_assert(alignof(UVLegacyIngredientItem) == 0x000008, "Wrong alignment on UVLegacyIngredientItem");
static_assert(sizeof(UVLegacyIngredientItem) == 0x000068, "Wrong size on UVLegacyIngredientItem");
static_assert(offsetof(UVLegacyIngredientItem, Properties) == 0x000028, "Member 'UVLegacyIngredientItem::Properties' has a wrong offset!");

// Class Altar.TESObjectBOOK
// 0x0038 (0x01C8 - 0x0190)
class UTESObjectBOOK final : public UTESBoundObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectBOOK">();
	}
	static class UTESObjectBOOK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectBOOK>();
	}
};
static_assert(alignof(UTESObjectBOOK) == 0x000008, "Wrong alignment on UTESObjectBOOK");
static_assert(sizeof(UTESObjectBOOK) == 0x0001C8, "Wrong size on UTESObjectBOOK");
static_assert(offsetof(UTESObjectBOOK, FullName) == 0x000190, "Member 'UTESObjectBOOK::FullName' has a wrong offset!");
static_assert(offsetof(UTESObjectBOOK, NewMesh) == 0x0001A0, "Member 'UTESObjectBOOK::NewMesh' has a wrong offset!");

// Class Altar.TESObjectCLOT
// 0x0018 (0x01A8 - 0x0190)
class UTESObjectCLOT final : public UTESBoundObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESBipedModelForm*                     InheritedBipedModel;                               // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectCLOT">();
	}
	static class UTESObjectCLOT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectCLOT>();
	}
};
static_assert(alignof(UTESObjectCLOT) == 0x000008, "Wrong alignment on UTESObjectCLOT");
static_assert(sizeof(UTESObjectCLOT) == 0x0001A8, "Wrong size on UTESObjectCLOT");
static_assert(offsetof(UTESObjectCLOT, FullName) == 0x000190, "Member 'UTESObjectCLOT::FullName' has a wrong offset!");
static_assert(offsetof(UTESObjectCLOT, InheritedBipedModel) == 0x0001A0, "Member 'UTESObjectCLOT::InheritedBipedModel' has a wrong offset!");

// Class Altar.VTransformPairable
// 0x0000 (0x0000 - 0x0000)
class IVTransformPairable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTransformPairable">();
	}
	static class IVTransformPairable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVTransformPairable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IVTransformPairable) == 0x000001, "Wrong alignment on IVTransformPairable");
static_assert(sizeof(IVTransformPairable) == 0x000001, "Wrong size on IVTransformPairable");

// Class Altar.VAltarNavigableCarousel
// 0x0008 (0x0500 - 0x04F8)
class UVAltarNavigableCarousel : public UVNavigableCarousel
{
public:
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableCarousel">();
	}
	static class UVAltarNavigableCarousel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableCarousel>();
	}
};
static_assert(alignof(UVAltarNavigableCarousel) == 0x000008, "Wrong alignment on UVAltarNavigableCarousel");
static_assert(sizeof(UVAltarNavigableCarousel) == 0x000500, "Wrong size on UVAltarNavigableCarousel");

// Class Altar.TESObjectCONT
// 0x0038 (0x01C8 - 0x0190)
class UTESObjectCONT final : public UTESBoundAnimObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStreamableRenderAsset>  NewMesh;                                           // 0x01A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectCONT">();
	}
	static class UTESObjectCONT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectCONT>();
	}
};
static_assert(alignof(UTESObjectCONT) == 0x000008, "Wrong alignment on UTESObjectCONT");
static_assert(sizeof(UTESObjectCONT) == 0x0001C8, "Wrong size on UTESObjectCONT");
static_assert(offsetof(UTESObjectCONT, FullName) == 0x000190, "Member 'UTESObjectCONT::FullName' has a wrong offset!");
static_assert(offsetof(UTESObjectCONT, NewMesh) == 0x0001A0, "Member 'UTESObjectCONT::NewMesh' has a wrong offset!");

// Class Altar.TESObjectDOOR
// 0x0010 (0x01A0 - 0x0190)
class UTESObjectDOOR final : public UTESBoundAnimObject
{
public:
	class FString                                 FullName;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectDOOR">();
	}
	static class UTESObjectDOOR* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectDOOR>();
	}
};
static_assert(alignof(UTESObjectDOOR) == 0x000008, "Wrong alignment on UTESObjectDOOR");
static_assert(sizeof(UTESObjectDOOR) == 0x0001A0, "Wrong size on UTESObjectDOOR");
static_assert(offsetof(UTESObjectDOOR, FullName) == 0x000190, "Member 'UTESObjectDOOR::FullName' has a wrong offset!");

// Class Altar.ActionStateStartBehavior
// 0x0030 (0x0060 - 0x0030)
class UActionStateStartBehavior final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnEnded;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UActionStateStartBehavior* StartBehaviorFromTag(const struct FGameplayTag& BehaviorTag, class UVActorBehaviorBase** StartedBehavior, class UVAltarActionState* OuterState);
	static class UActionStateStartBehavior* StartBehaviorFromTemplate(class UVActorBehaviorBase* BehaviorTemplate, class UVActorBehaviorBase** StartedBehavior, class UVAltarActionState* OuterState);

	void OnBehaviorEnded(bool bIsCanceled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionStateStartBehavior">();
	}
	static class UActionStateStartBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionStateStartBehavior>();
	}
};
static_assert(alignof(UActionStateStartBehavior) == 0x000008, "Wrong alignment on UActionStateStartBehavior");
static_assert(sizeof(UActionStateStartBehavior) == 0x000060, "Wrong size on UActionStateStartBehavior");
static_assert(offsetof(UActionStateStartBehavior, OnEnded) == 0x000030, "Member 'UActionStateStartBehavior::OnEnded' has a wrong offset!");

// Class Altar.TESObjectREFR
// 0x0060 (0x0138 - 0x00D8)
class UTESObjectREFR final : public UTESForm
{
public:
	struct FOBJ_REFR                              Data;                                              // 0x00D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         RefScale;                                          // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTESCell*                               ParentCell;                                        // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectREFR">();
	}
	static class UTESObjectREFR* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectREFR>();
	}
};
static_assert(alignof(UTESObjectREFR) == 0x000008, "Wrong alignment on UTESObjectREFR");
static_assert(sizeof(UTESObjectREFR) == 0x000138, "Wrong size on UTESObjectREFR");
static_assert(offsetof(UTESObjectREFR, Data) == 0x0000D8, "Member 'UTESObjectREFR::Data' has a wrong offset!");
static_assert(offsetof(UTESObjectREFR, RefScale) == 0x000128, "Member 'UTESObjectREFR::RefScale' has a wrong offset!");
static_assert(offsetof(UTESObjectREFR, ParentCell) == 0x000130, "Member 'UTESObjectREFR::ParentCell' has a wrong offset!");

// Class Altar.VAltarPresetInstanceUserData
// 0x0008 (0x0030 - 0x0028)
class UVAltarPresetInstanceUserData final : public UATMPresetInstanceUserData
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarPresetInstanceUserData">();
	}
	static class UVAltarPresetInstanceUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarPresetInstanceUserData>();
	}
};
static_assert(alignof(UVAltarPresetInstanceUserData) == 0x000008, "Wrong alignment on UVAltarPresetInstanceUserData");
static_assert(sizeof(UVAltarPresetInstanceUserData) == 0x000030, "Wrong size on UVAltarPresetInstanceUserData");

// Class Altar.TESObjectTREE
// 0x0098 (0x0228 - 0x0190)
class UTESObjectTREE final : public UTESBoundTreeObject
{
public:
	TSoftObjectPtr<class UFoliageType>            Foliage;                                           // 0x0190(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TextureIcon;                                       // 0x01B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 SeedArray;                                         // 0x01E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FOBJ_TREE                              Data;                                              // 0x01F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BillboardSize;                                     // 0x0210(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESObjectTREE">();
	}
	static class UTESObjectTREE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESObjectTREE>();
	}
};
static_assert(alignof(UTESObjectTREE) == 0x000008, "Wrong alignment on UTESObjectTREE");
static_assert(sizeof(UTESObjectTREE) == 0x000228, "Wrong size on UTESObjectTREE");
static_assert(offsetof(UTESObjectTREE, Foliage) == 0x000190, "Member 'UTESObjectTREE::Foliage' has a wrong offset!");
static_assert(offsetof(UTESObjectTREE, TextureIcon) == 0x0001B8, "Member 'UTESObjectTREE::TextureIcon' has a wrong offset!");
static_assert(offsetof(UTESObjectTREE, SeedArray) == 0x0001E0, "Member 'UTESObjectTREE::SeedArray' has a wrong offset!");
static_assert(offsetof(UTESObjectTREE, Data) == 0x0001F0, "Member 'UTESObjectTREE::Data' has a wrong offset!");
static_assert(offsetof(UTESObjectTREE, BillboardSize) == 0x000210, "Member 'UTESObjectTREE::BillboardSize' has a wrong offset!");

// Class Altar.VAltarBinkMediaPlayer
// 0x00E0 (0x03A0 - 0x02C0)
class UVAltarBinkMediaPlayer : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(const class FString& OpenedUrl)> OnVideoOpenned;                   // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVideoCompleted;                                  // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UImage*                                 VideoRenderer;                                     // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBinkMediaTexture>       Soft_MediaTexture;                                 // 0x02E8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBinkMediaPlayer>        Soft_MediaPlayer;                                  // 0x0310(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterial>               Soft_MediaTextureMaterial;                         // 0x0338(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 URL;                                               // 0x0360(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BaseVideoSize;                                     // 0x0370(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoesHaveSubtitle;                                 // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x3];                                      // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeDuration;                                      // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVAltarBinkVideoTimestampTable*         SubtitleData;                                      // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x10];                                     // 0x0390(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void Close();
	void EndCurrentSubtitle();
	void Internal_OnVideoCompleted();
	void Internal_OnVideoOpenned(const class FString& OpenedUrl);
	void LaunchFadeOut();
	void ManageSubtitle();
	void OnStartNextSubtitle(const class FText& SubtitleText);
	void OnStopCurrentSubtitle();
	bool Open();
	bool OpenUrl(const class FString& NewUrl);
	bool Pause();
	bool Play();
	bool PlayFromStart();
	bool PlayFromTimeStamp(float Timestamp);
	bool Prepare();
	bool Seek(float Timestamp);
	void StartNextSubtitle();
	void StartSubtitleFadeOut();

	class FString GetCurrentPath() const;
	bool HaveReachedFadeOutTimer() const;
	bool HaveReachedNextEndTimer() const;
	bool HaveReachedNextStartTimer() const;
	bool IsOpened() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarBinkMediaPlayer">();
	}
	static class UVAltarBinkMediaPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarBinkMediaPlayer>();
	}
};
static_assert(alignof(UVAltarBinkMediaPlayer) == 0x000008, "Wrong alignment on UVAltarBinkMediaPlayer");
static_assert(sizeof(UVAltarBinkMediaPlayer) == 0x0003A0, "Wrong size on UVAltarBinkMediaPlayer");
static_assert(offsetof(UVAltarBinkMediaPlayer, OnVideoOpenned) == 0x0002C0, "Member 'UVAltarBinkMediaPlayer::OnVideoOpenned' has a wrong offset!");
static_assert(offsetof(UVAltarBinkMediaPlayer, OnVideoCompleted) == 0x0002D0, "Member 'UVAltarBinkMediaPlayer::OnVideoCompleted' has a wrong offset!");
static_assert(offsetof(UVAltarBinkMediaPlayer, VideoRenderer) == 0x0002E0, "Member 'UVAltarBinkMediaPlayer::VideoRenderer' has a wrong offset!");
static_assert(offsetof(UVAltarBinkMediaPlayer, Soft_MediaTexture) == 0x0002E8, "Member 'UVAltarBinkMediaPlayer::Soft_MediaTexture' has a wrong offset!");
static_assert(offsetof(UVAltarBinkMediaPlayer, Soft_MediaPlayer) == 0x000310, "Member 'UVAltarBinkMediaPlayer::Soft_MediaPlayer' has a wrong offset!");
static_assert(offsetof(UVAltarBinkMediaPlayer, Soft_MediaTextureMaterial) == 0x000338, "Member 'UVAltarBinkMediaPlayer::Soft_MediaTextureMaterial' has a wrong offset!");
static_assert(offsetof(UVAltarBinkMediaPlayer, URL) == 0x000360, "Member 'UVAltarBinkMediaPlayer::URL' has a wrong offset!");
static_assert(offsetof(UVAltarBinkMediaPlayer, BaseVideoSize) == 0x000370, "Member 'UVAltarBinkMediaPlayer::BaseVideoSize' has a wrong offset!");
static_assert(offsetof(UVAltarBinkMediaPlayer, bDoesHaveSubtitle) == 0x000380, "Member 'UVAltarBinkMediaPlayer::bDoesHaveSubtitle' has a wrong offset!");
static_assert(offsetof(UVAltarBinkMediaPlayer, FadeDuration) == 0x000384, "Member 'UVAltarBinkMediaPlayer::FadeDuration' has a wrong offset!");
static_assert(offsetof(UVAltarBinkMediaPlayer, SubtitleData) == 0x000388, "Member 'UVAltarBinkMediaPlayer::SubtitleData' has a wrong offset!");

// Class Altar.TESPackage
// 0x0000 (0x00D8 - 0x00D8)
class UTESPackage final : public UTESForm
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESPackage">();
	}
	static class UTESPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESPackage>();
	}
};
static_assert(alignof(UTESPackage) == 0x000008, "Wrong alignment on UTESPackage");
static_assert(sizeof(UTESPackage) == 0x0000D8, "Wrong size on UTESPackage");

// Class Altar.TESPathGrid
// 0x0090 (0x0168 - 0x00D8)
class UTESPathGrid final : public UTESForm
{
public:
	class UTESCell*                               ParentCell;                                        // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumGridDataPoints;                                 // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPathGridPointData>             PathGridPointsData;                                // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<int32>                                 Connections;                                       // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FIntergridConnection>           IntergridConnections;                              // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<class UTESObjectREFR*, struct FPathGridPointDataArray> LinkedPoints;                        // 0x0118(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESPathGrid">();
	}
	static class UTESPathGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESPathGrid>();
	}
};
static_assert(alignof(UTESPathGrid) == 0x000008, "Wrong alignment on UTESPathGrid");
static_assert(sizeof(UTESPathGrid) == 0x000168, "Wrong size on UTESPathGrid");
static_assert(offsetof(UTESPathGrid, ParentCell) == 0x0000D8, "Member 'UTESPathGrid::ParentCell' has a wrong offset!");
static_assert(offsetof(UTESPathGrid, NumGridDataPoints) == 0x0000E0, "Member 'UTESPathGrid::NumGridDataPoints' has a wrong offset!");
static_assert(offsetof(UTESPathGrid, PathGridPointsData) == 0x0000E8, "Member 'UTESPathGrid::PathGridPointsData' has a wrong offset!");
static_assert(offsetof(UTESPathGrid, Connections) == 0x0000F8, "Member 'UTESPathGrid::Connections' has a wrong offset!");
static_assert(offsetof(UTESPathGrid, IntergridConnections) == 0x000108, "Member 'UTESPathGrid::IntergridConnections' has a wrong offset!");
static_assert(offsetof(UTESPathGrid, LinkedPoints) == 0x000118, "Member 'UTESPathGrid::LinkedPoints' has a wrong offset!");

// Class Altar.VAltarNavigableTileView
// 0x0008 (0x0538 - 0x0530)
class UVAltarNavigableTileView : public UVNavigableTileView
{
public:
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableTileView">();
	}
	static class UVAltarNavigableTileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableTileView>();
	}
};
static_assert(alignof(UVAltarNavigableTileView) == 0x000008, "Wrong alignment on UVAltarNavigableTileView");
static_assert(sizeof(UVAltarNavigableTileView) == 0x000538, "Wrong size on UVAltarNavigableTileView");

// Class Altar.TESQuest
// 0x0000 (0x00D8 - 0x00D8)
class UTESQuest final : public UTESForm
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESQuest">();
	}
	static class UTESQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESQuest>();
	}
};
static_assert(alignof(UTESQuest) == 0x000008, "Wrong alignment on UTESQuest");
static_assert(sizeof(UTESQuest) == 0x0000D8, "Wrong size on UTESQuest");

// Class Altar.VLRPrepareAttackAnimInstance
// 0x0010 (0x03D0 - 0x03C0)
class UVLRPrepareAttackAnimInstance : public UVLeftRightAttackAnimInstance
{
public:
	class UAnimSequenceBase*                      PrepareAttackAnim;                                 // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AttackLeftAnim;                                    // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AttackRightAnim;                                   // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPrepareAttackEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLRPrepareAttackAnimInstance">();
	}
	static class UVLRPrepareAttackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLRPrepareAttackAnimInstance>();
	}
};
static_assert(alignof(UVLRPrepareAttackAnimInstance) == 0x000010, "Wrong alignment on UVLRPrepareAttackAnimInstance");
static_assert(sizeof(UVLRPrepareAttackAnimInstance) == 0x0003D0, "Wrong size on UVLRPrepareAttackAnimInstance");
static_assert(offsetof(UVLRPrepareAttackAnimInstance, PrepareAttackAnim) == 0x0003B8, "Member 'UVLRPrepareAttackAnimInstance::PrepareAttackAnim' has a wrong offset!");
static_assert(offsetof(UVLRPrepareAttackAnimInstance, AttackLeftAnim) == 0x0003C0, "Member 'UVLRPrepareAttackAnimInstance::AttackLeftAnim' has a wrong offset!");
static_assert(offsetof(UVLRPrepareAttackAnimInstance, AttackRightAnim) == 0x0003C8, "Member 'UVLRPrepareAttackAnimInstance::AttackRightAnim' has a wrong offset!");

// Class Altar.VStandSwimPowerAnimInstance
// 0x0070 (0x0440 - 0x03D0)
class UVStandSwimPowerAnimInstance final : public UVLRPrepareAttackAnimInstance
{
public:
	struct FStandSwimMeleeAttackPowerSingle       AnimSet;                                           // 0x03D0(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStandSwimPowerAnimInstance">();
	}
	static class UVStandSwimPowerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStandSwimPowerAnimInstance>();
	}
};
static_assert(alignof(UVStandSwimPowerAnimInstance) == 0x000010, "Wrong alignment on UVStandSwimPowerAnimInstance");
static_assert(sizeof(UVStandSwimPowerAnimInstance) == 0x000440, "Wrong size on UVStandSwimPowerAnimInstance");
static_assert(offsetof(UVStandSwimPowerAnimInstance, AnimSet) == 0x0003D0, "Member 'UVStandSwimPowerAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.TESRace
// 0x0078 (0x0150 - 0x00D8)
class UTESRace final : public UTESForm
{
public:
	class FString                                 FullName;                                          // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOblivionNPCFaceGenData                MeanOblivionFaceGenData;                           // 0x00E8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EVBloodColor                                  BloodColor;                                        // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRaceData                              Data;                                              // 0x0120(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FRaceBody>                      MaleFullBodies;                                    // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRaceBody>                      FemaleFullBodies;                                  // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	struct FRaceBody GetRaceBodyBySex(ECharacterSex Sex, int32 BodyIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESRace">();
	}
	static class UTESRace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESRace>();
	}
};
static_assert(alignof(UTESRace) == 0x000008, "Wrong alignment on UTESRace");
static_assert(sizeof(UTESRace) == 0x000150, "Wrong size on UTESRace");
static_assert(offsetof(UTESRace, FullName) == 0x0000D8, "Member 'UTESRace::FullName' has a wrong offset!");
static_assert(offsetof(UTESRace, MeanOblivionFaceGenData) == 0x0000E8, "Member 'UTESRace::MeanOblivionFaceGenData' has a wrong offset!");
static_assert(offsetof(UTESRace, BloodColor) == 0x000118, "Member 'UTESRace::BloodColor' has a wrong offset!");
static_assert(offsetof(UTESRace, Data) == 0x000120, "Member 'UTESRace::Data' has a wrong offset!");
static_assert(offsetof(UTESRace, MaleFullBodies) == 0x000130, "Member 'UTESRace::MaleFullBodies' has a wrong offset!");
static_assert(offsetof(UTESRace, FemaleFullBodies) == 0x000140, "Member 'UTESRace::FemaleFullBodies' has a wrong offset!");

// Class Altar.TESRegion
// 0x0020 (0x00F8 - 0x00D8)
class UTESRegion final : public UTESForm
{
public:
	TArray<struct FTESRegionPointList>            PointLists;                                        // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESRegion">();
	}
	static class UTESRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESRegion>();
	}
};
static_assert(alignof(UTESRegion) == 0x000008, "Wrong alignment on UTESRegion");
static_assert(sizeof(UTESRegion) == 0x0000F8, "Wrong size on UTESRegion");
static_assert(offsetof(UTESRegion, PointLists) == 0x0000D8, "Member 'UTESRegion::PointLists' has a wrong offset!");

// Class Altar.VAltarUIHelper
// 0x0000 (0x0028 - 0x0028)
class UVAltarUIHelper final : public UBlueprintFunctionLibrary
{
public:
	static void CopyToClipboard(const class FString& InTextToCopy);
	static bool DeprojectActorViewScreenPointToWorld(class UCameraComponent* InCameraComponent, const struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection);
	static void DisplayCreditsWidget(bool bNewVisibility, class FName CreditMenuName);
	static class UActorComponent* FindComponentByName(const class AActor* InActor, const TSubclassOf<class UActorComponent> ComponentClass, const class FName& InName);
	static void GetActorBoundsRestricted(const class AActor* InActor, const TArray<class UClass*>& ExcludedClasses, const TArray<class FName>& ExcludedActorComponentNames, bool bOnlyCollidingComponents, struct FVector* OutOrigin, struct FVector* OutBoxExtent, bool bIncludeFromChildActors);
	static int32 GetGreatestCommonDivisor(int32 A, int32 B);
	static bool IsBox2DInsideBox2D(const struct FBox2D& InBox, const struct FBox2D& InEnclosingBox);
	static bool IsPointInsideBox2D(const struct FBox2D& InBox, const struct FVector2D& InPointToCheck);
	static void MarkActorComponentRenderStateDirty(class UActorComponent* InActorComponent);
	static void SetSceneComponentHiddenInGameRestricted(class USceneComponent* InSceneComponent, bool bNewHidden, bool bPropagateToChildren, const TArray<class UClass*>& ExcludedClasses);
	static void SetVisibilityRestricted(class USceneComponent* InSceneComponent, bool bNewVisibility, bool bPropagateToChildren, const TArray<class UClass*>& ExcludedClasses);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarUIHelper">();
	}
	static class UVAltarUIHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarUIHelper>();
	}
};
static_assert(alignof(UVAltarUIHelper) == 0x000008, "Wrong alignment on UVAltarUIHelper");
static_assert(sizeof(UVAltarUIHelper) == 0x000028, "Wrong size on UVAltarUIHelper");

// Class Altar.TESSigilStone
// 0x0000 (0x01F0 - 0x01F0)
class UTESSigilStone final : public UTESObjectMISC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESSigilStone">();
	}
	static class UTESSigilStone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESSigilStone>();
	}
};
static_assert(alignof(UTESSigilStone) == 0x000008, "Wrong alignment on UTESSigilStone");
static_assert(sizeof(UTESSigilStone) == 0x0001F0, "Wrong size on UTESSigilStone");

// Class Altar.VWeaponsPairingComponent
// 0x00D8 (0x0190 - 0x00B8)
class UVWeaponsPairingComponent final : public UVActorPairingComponent
{
public:
	TMulticastInlineDelegate<void(const class AVWeapon* WeaponActor)> OnWeaponFormChanged;           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AVQuiver* QuiverActor, bool bEquipping)> OnQuiverFormChanged; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AActor* TorchActor, bool bEquipping)> OnTorchActorChanged; // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AActor* TorchActor, bool bEquipping)> OnTorchVisibilityChanged; // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AVShield* ShieldActor, bool bEquipping)> OnShieldFormChanged; // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AActor* ShieldActor, bool bEquipping)> OnShieldVisibilityChanged; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsWeaponDrawn)> OnWeaponDrawnStateChanged;                   // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UVStatusEffectOnPawn*                   WantedStatusEffect;                                // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ArrowStaticMeshComponent;                          // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTESObjectWEAP*                         WeaponForm;                                        // 0x0148(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AVWeapon*                               WeaponActor;                                       // 0x0150(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTESObjectARMO*                         ShieldForm;                                        // 0x0158(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AVShield*                               ShieldActor;                                       // 0x0160(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTESAmmo*                               QuiverForm;                                        // 0x0168(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AVQuiver*                               QuiverActor;                                       // 0x0170(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TorchActor;                                        // 0x0180(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallTextureEffectBroadcastStartOnQuiver(class AVQuiver* Quiver, bool bEquipping);
	void CallTextureEffectBroadcastStartOnShield(class AVShield* Shield, bool bEquipping);
	void CallTextureEffectBroadcastStartOnWeapon(class AVWeapon* Weapon);
	void ReleaseArrow();
	void SetArrowMeshComponent(class UStaticMeshComponent* NewArrowMeshComponent);
	void SetWeaponDrawn(bool bIsDrawn);

	struct FTransform GetAttachedArrowLocation() const;
	class AVQuiver* GetEquippedQuiverActor() const;
	class UTESAmmo* GetEquippedQuiverForm() const;
	class AVShield* GetEquippedShieldActor() const;
	class UTESObjectARMO* GetEquippedShieldForm() const;
	class AActor* GetEquippedTorchActor() const;
	class AVWeapon* GetEquippedWeaponActor() const;
	class UTESObjectWEAP* GetEquippedWeaponForm() const;
	struct FGameplayTag GetEquippedWeaponGameplayTag() const;
	float GetMainWeaponReach() const;
	bool HasShieldEquipped() const;
	bool IsQuiverAttached() const;
	bool IsTorchHeld() const;
	bool IsWeaponDrawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWeaponsPairingComponent">();
	}
	static class UVWeaponsPairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVWeaponsPairingComponent>();
	}
};
static_assert(alignof(UVWeaponsPairingComponent) == 0x000008, "Wrong alignment on UVWeaponsPairingComponent");
static_assert(sizeof(UVWeaponsPairingComponent) == 0x000190, "Wrong size on UVWeaponsPairingComponent");
static_assert(offsetof(UVWeaponsPairingComponent, OnWeaponFormChanged) == 0x0000B8, "Member 'UVWeaponsPairingComponent::OnWeaponFormChanged' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, OnQuiverFormChanged) == 0x0000C8, "Member 'UVWeaponsPairingComponent::OnQuiverFormChanged' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, OnTorchActorChanged) == 0x0000D8, "Member 'UVWeaponsPairingComponent::OnTorchActorChanged' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, OnTorchVisibilityChanged) == 0x0000E8, "Member 'UVWeaponsPairingComponent::OnTorchVisibilityChanged' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, OnShieldFormChanged) == 0x0000F8, "Member 'UVWeaponsPairingComponent::OnShieldFormChanged' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, OnShieldVisibilityChanged) == 0x000108, "Member 'UVWeaponsPairingComponent::OnShieldVisibilityChanged' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, OnWeaponDrawnStateChanged) == 0x000118, "Member 'UVWeaponsPairingComponent::OnWeaponDrawnStateChanged' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, WantedStatusEffect) == 0x000128, "Member 'UVWeaponsPairingComponent::WantedStatusEffect' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, ArrowStaticMeshComponent) == 0x000138, "Member 'UVWeaponsPairingComponent::ArrowStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, WeaponForm) == 0x000148, "Member 'UVWeaponsPairingComponent::WeaponForm' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, WeaponActor) == 0x000150, "Member 'UVWeaponsPairingComponent::WeaponActor' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, ShieldForm) == 0x000158, "Member 'UVWeaponsPairingComponent::ShieldForm' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, ShieldActor) == 0x000160, "Member 'UVWeaponsPairingComponent::ShieldActor' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, QuiverForm) == 0x000168, "Member 'UVWeaponsPairingComponent::QuiverForm' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, QuiverActor) == 0x000170, "Member 'UVWeaponsPairingComponent::QuiverActor' has a wrong offset!");
static_assert(offsetof(UVWeaponsPairingComponent, TorchActor) == 0x000180, "Member 'UVWeaponsPairingComponent::TorchActor' has a wrong offset!");

// Class Altar.TESSoulGem
// 0x0000 (0x01F0 - 0x01F0)
class UTESSoulGem final : public UTESObjectMISC
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESSoulGem">();
	}
	static class UTESSoulGem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESSoulGem>();
	}
};
static_assert(alignof(UTESSoulGem) == 0x000008, "Wrong alignment on UTESSoulGem");
static_assert(sizeof(UTESSoulGem) == 0x0001F0, "Wrong size on UTESSoulGem");

// Class Altar.TESSound
// 0x0038 (0x01C8 - 0x0190)
class UTESSound final : public UTESBoundAnimObject
{
public:
	struct FTESSoundData                          SoundData;                                         // 0x0190(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USoundWave>>      SoundWaves;                                        // 0x01A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 SoundPath;                                         // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESSound">();
	}
	static class UTESSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESSound>();
	}
};
static_assert(alignof(UTESSound) == 0x000008, "Wrong alignment on UTESSound");
static_assert(sizeof(UTESSound) == 0x0001C8, "Wrong size on UTESSound");
static_assert(offsetof(UTESSound, SoundData) == 0x000190, "Member 'UTESSound::SoundData' has a wrong offset!");
static_assert(offsetof(UTESSound, SoundWaves) == 0x0001A8, "Member 'UTESSound::SoundWaves' has a wrong offset!");
static_assert(offsetof(UTESSound, SoundPath) == 0x0001B8, "Member 'UTESSound::SoundPath' has a wrong offset!");

// Class Altar.VAmbientSound
// 0x0018 (0x02B0 - 0x0298)
class AVAmbientSound final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AmbientEvent;                                      // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopAmbientEvent;                                  // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAmbientSound">();
	}
	static class AVAmbientSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAmbientSound>();
	}
};
static_assert(alignof(AVAmbientSound) == 0x000008, "Wrong alignment on AVAmbientSound");
static_assert(sizeof(AVAmbientSound) == 0x0002B0, "Wrong size on AVAmbientSound");
static_assert(offsetof(AVAmbientSound, AmbientEvent) == 0x0002A0, "Member 'AVAmbientSound::AmbientEvent' has a wrong offset!");
static_assert(offsetof(AVAmbientSound, StopAmbientEvent) == 0x0002A8, "Member 'AVAmbientSound::StopAmbientEvent' has a wrong offset!");

// Class Altar.TESSubSpace
// 0x0018 (0x01A8 - 0x0190)
class UTESSubSpace final : public UTESBoundObject
{
public:
	struct FVector                                Dimensions;                                        // 0x0190(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESSubSpace">();
	}
	static class UTESSubSpace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESSubSpace>();
	}
};
static_assert(alignof(UTESSubSpace) == 0x000008, "Wrong alignment on UTESSubSpace");
static_assert(sizeof(UTESSubSpace) == 0x0001A8, "Wrong size on UTESSubSpace");
static_assert(offsetof(UTESSubSpace, Dimensions) == 0x000190, "Member 'UTESSubSpace::Dimensions' has a wrong offset!");

// Class Altar.TestAnimCharacterBase
// 0x00B0 (0x0730 - 0x0680)
class ATestAnimCharacterBase final : public ACharacter
{
public:
	uint8                                         Pad_678[0x10];                                     // 0x0678(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttackRaycastStart;                                // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTestAnimInstanceBase*                  AnimInstance;                                      // 0x0690(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRange;                                       // 0x0698(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69C[0x6C];                                     // 0x069C(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          TurnTowardsMovement;                               // 0x0708(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasWeaponDrawn;                                    // 0x0709(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsInDamageSection;                                 // 0x070A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70B[0x5];                                      // 0x070B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentAimPosition;                                // 0x0710(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_728[0x8];                                      // 0x0728(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttemptStartAttack(EAttackActionType AttackType);
	void EnterCombatMode();
	void LeaveCombatMode();
	struct FHitResult MeleeAttackRaycast();
	void MoveTowardsFromControlRotation(const struct FVector2D& Direction, bool Run);
	void OnAnimDamageSectionEnd();
	void OnAnimDamageSectionStart();
	void OnAnimJumpStarted();
	void OnHitImpact(const struct FVector& ImpactPoint, class UPrimitiveComponent* HitComponent);
	void ScanHit();
	void SetAimPosition(const struct FVector& AimPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestAnimCharacterBase">();
	}
	static class ATestAnimCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestAnimCharacterBase>();
	}
};
static_assert(alignof(ATestAnimCharacterBase) == 0x000010, "Wrong alignment on ATestAnimCharacterBase");
static_assert(sizeof(ATestAnimCharacterBase) == 0x000730, "Wrong size on ATestAnimCharacterBase");
static_assert(offsetof(ATestAnimCharacterBase, AttackRaycastStart) == 0x000688, "Member 'ATestAnimCharacterBase::AttackRaycastStart' has a wrong offset!");
static_assert(offsetof(ATestAnimCharacterBase, AnimInstance) == 0x000690, "Member 'ATestAnimCharacterBase::AnimInstance' has a wrong offset!");
static_assert(offsetof(ATestAnimCharacterBase, AttackRange) == 0x000698, "Member 'ATestAnimCharacterBase::AttackRange' has a wrong offset!");
static_assert(offsetof(ATestAnimCharacterBase, TurnTowardsMovement) == 0x000708, "Member 'ATestAnimCharacterBase::TurnTowardsMovement' has a wrong offset!");
static_assert(offsetof(ATestAnimCharacterBase, HasWeaponDrawn) == 0x000709, "Member 'ATestAnimCharacterBase::HasWeaponDrawn' has a wrong offset!");
static_assert(offsetof(ATestAnimCharacterBase, IsInDamageSection) == 0x00070A, "Member 'ATestAnimCharacterBase::IsInDamageSection' has a wrong offset!");
static_assert(offsetof(ATestAnimCharacterBase, CurrentAimPosition) == 0x000710, "Member 'ATestAnimCharacterBase::CurrentAimPosition' has a wrong offset!");

// Class Altar.VAnimNotifyState_FacialPose
// 0x0010 (0x0040 - 0x0030)
class UVAnimNotifyState_FacialPose final : public UAnimNotifyState
{
public:
	bool                                          bShouldOverrideMontage;                            // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFacialPoseType                               FacialPose;                                        // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FacialPoseBlendWeight;                             // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UVFacialCharacterAnimInstance> FacialAnimInstanceClass;                        // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateFacialPose(const class AActor* OwnerActor, const EFacialPoseType AnimNotifyFacialPose, const float AnimNotifyBlendWeight, const bool bShouldOverrideFacialPose, const bool bIsAnimNotifyBegin) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotifyState_FacialPose">();
	}
	static class UVAnimNotifyState_FacialPose* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotifyState_FacialPose>();
	}
};
static_assert(alignof(UVAnimNotifyState_FacialPose) == 0x000008, "Wrong alignment on UVAnimNotifyState_FacialPose");
static_assert(sizeof(UVAnimNotifyState_FacialPose) == 0x000040, "Wrong size on UVAnimNotifyState_FacialPose");
static_assert(offsetof(UVAnimNotifyState_FacialPose, bShouldOverrideMontage) == 0x000030, "Member 'UVAnimNotifyState_FacialPose::bShouldOverrideMontage' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_FacialPose, FacialPose) == 0x000031, "Member 'UVAnimNotifyState_FacialPose::FacialPose' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_FacialPose, FacialPoseBlendWeight) == 0x000034, "Member 'UVAnimNotifyState_FacialPose::FacialPoseBlendWeight' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_FacialPose, FacialAnimInstanceClass) == 0x000038, "Member 'UVAnimNotifyState_FacialPose::FacialAnimInstanceClass' has a wrong offset!");

// Class Altar.VStandSwimSimpleAttackAnimInstance
// 0x0030 (0x0400 - 0x03D0)
class UVStandSwimSimpleAttackAnimInstance final : public UVLRPrepareAttackAnimInstance
{
public:
	struct FStandSwimMeleeAttackSimple            AnimSet;                                           // 0x03D0(0x0028)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStandSwimSimpleAttackAnimInstance">();
	}
	static class UVStandSwimSimpleAttackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStandSwimSimpleAttackAnimInstance>();
	}
};
static_assert(alignof(UVStandSwimSimpleAttackAnimInstance) == 0x000010, "Wrong alignment on UVStandSwimSimpleAttackAnimInstance");
static_assert(sizeof(UVStandSwimSimpleAttackAnimInstance) == 0x000400, "Wrong size on UVStandSwimSimpleAttackAnimInstance");
static_assert(offsetof(UVStandSwimSimpleAttackAnimInstance, AnimSet) == 0x0003D0, "Member 'UVStandSwimSimpleAttackAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.TestAnimInstanceBase
// 0x0090 (0x03E0 - 0x0350)
class UTestAnimInstanceBase final : public UAnimInstance
{
public:
	TMulticastInlineDelegate<void()>              OnJumpStarted;                                     // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDamageSectionStart;                              // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDamageSectionEnd;                                // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         FullJogSpeed;                                      // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          JumpAnimation;                                     // 0x0380(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactionPhysicsBlendDuration;                   // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactionPhysicsImpulseMagnitude;                // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           HitReactionIgnoredBones;                           // 0x0390(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CurrentTargetSpeed;                                // 0x03A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsFalling;                                         // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CurrentEffectiveSpeed;                             // 0x03C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AllowNextAttack();
	bool AttemptAttackAnimation(EAttackActionType AttackActionType, const struct FAnimCharacterAttackStartInfo& AttackStartInfo);
	TArray<struct FAttackMovesetItem> ChooseNextAttackMoveset(EAttackActionType AttackActionType, const struct FAnimCharacterAttackStartInfo& AttackStartInfo);
	void DisallowNextAttack();
	void PlayJumpAnimation();
	void ProcessDamageReaction(float Damage, const struct FMeleeAttackDamageEvent& DamageEvent);
	void ResetAttackChain();
	void SetTargetForwardSpeed(float TargetSpeed);
	void SetTargetRightSpeed(float TargetSpeed);
	void SignalFallEnded();
	void SignalFallStarted();
	void StartPhysicsBlendFromBone(class FName BoneName, float Duration, const struct FVector& StartImpulse);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestAnimInstanceBase">();
	}
	static class UTestAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestAnimInstanceBase>();
	}
};
static_assert(alignof(UTestAnimInstanceBase) == 0x000010, "Wrong alignment on UTestAnimInstanceBase");
static_assert(sizeof(UTestAnimInstanceBase) == 0x0003E0, "Wrong size on UTestAnimInstanceBase");
static_assert(offsetof(UTestAnimInstanceBase, OnJumpStarted) == 0x000348, "Member 'UTestAnimInstanceBase::OnJumpStarted' has a wrong offset!");
static_assert(offsetof(UTestAnimInstanceBase, OnDamageSectionStart) == 0x000358, "Member 'UTestAnimInstanceBase::OnDamageSectionStart' has a wrong offset!");
static_assert(offsetof(UTestAnimInstanceBase, OnDamageSectionEnd) == 0x000368, "Member 'UTestAnimInstanceBase::OnDamageSectionEnd' has a wrong offset!");
static_assert(offsetof(UTestAnimInstanceBase, FullJogSpeed) == 0x000378, "Member 'UTestAnimInstanceBase::FullJogSpeed' has a wrong offset!");
static_assert(offsetof(UTestAnimInstanceBase, JumpAnimation) == 0x000380, "Member 'UTestAnimInstanceBase::JumpAnimation' has a wrong offset!");
static_assert(offsetof(UTestAnimInstanceBase, HitReactionPhysicsBlendDuration) == 0x000388, "Member 'UTestAnimInstanceBase::HitReactionPhysicsBlendDuration' has a wrong offset!");
static_assert(offsetof(UTestAnimInstanceBase, HitReactionPhysicsImpulseMagnitude) == 0x00038C, "Member 'UTestAnimInstanceBase::HitReactionPhysicsImpulseMagnitude' has a wrong offset!");
static_assert(offsetof(UTestAnimInstanceBase, HitReactionIgnoredBones) == 0x000390, "Member 'UTestAnimInstanceBase::HitReactionIgnoredBones' has a wrong offset!");
static_assert(offsetof(UTestAnimInstanceBase, CurrentTargetSpeed) == 0x0003A8, "Member 'UTestAnimInstanceBase::CurrentTargetSpeed' has a wrong offset!");
static_assert(offsetof(UTestAnimInstanceBase, IsFalling) == 0x0003B8, "Member 'UTestAnimInstanceBase::IsFalling' has a wrong offset!");
static_assert(offsetof(UTestAnimInstanceBase, CurrentEffectiveSpeed) == 0x0003C0, "Member 'UTestAnimInstanceBase::CurrentEffectiveSpeed' has a wrong offset!");

// Class Altar.TESTopic
// 0x0000 (0x00D8 - 0x00D8)
class UTESTopic final : public UTESForm
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESTopic">();
	}
	static class UTESTopic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESTopic>();
	}
};
static_assert(alignof(UTESTopic) == 0x000008, "Wrong alignment on UTESTopic");
static_assert(sizeof(UTESTopic) == 0x0000D8, "Wrong size on UTESTopic");

// Class Altar.TESTopicInfo
// 0x0010 (0x00E8 - 0x00D8)
class UTESTopicInfo final : public UTESForm
{
public:
	TArray<struct FTESResponse>                   Responses;                                         // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESTopicInfo">();
	}
	static class UTESTopicInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESTopicInfo>();
	}
};
static_assert(alignof(UTESTopicInfo) == 0x000008, "Wrong alignment on UTESTopicInfo");
static_assert(sizeof(UTESTopicInfo) == 0x0000E8, "Wrong size on UTESTopicInfo");
static_assert(offsetof(UTESTopicInfo, Responses) == 0x0000D8, "Member 'UTESTopicInfo::Responses' has a wrong offset!");

// Class Altar.VSettingsGlobalSubsystem
// 0x0050 (0x0080 - 0x0030)
class UVSettingsGlobalSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void(const class FText& PopupText, int32 ModIndex)> OnRequestSaveLoadPopup; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& NewCommand)> OnSettingsBroadcastDelagete;     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UVModernSettingWidget* ChangedSettings)> OnSettingsChangedDelegete; // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UVModernSettingWidget* ChangedSettings)> OnRequestTimedRevertPopup; // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewLockState)> OnUpdateSettingsLockState;                     // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void RequestBroadcastOnRequestTimedRevertPopup(class UVModernSettingWidget* ChangedSettings);
	void RequestBroadcastOnSettingsChanged(class UVModernSettingWidget* ChangedSettings);
	void RequestBroadcastOnUpdateSettingsLockState(bool NewLockState);
	void RequestBroadcastSettings(const class FString& CommandToBroadcast);
	void RequestSaveLoadPopup(const class FText& PopupText, int32 ModIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSettingsGlobalSubsystem">();
	}
	static class UVSettingsGlobalSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSettingsGlobalSubsystem>();
	}
};
static_assert(alignof(UVSettingsGlobalSubsystem) == 0x000008, "Wrong alignment on UVSettingsGlobalSubsystem");
static_assert(sizeof(UVSettingsGlobalSubsystem) == 0x000080, "Wrong size on UVSettingsGlobalSubsystem");
static_assert(offsetof(UVSettingsGlobalSubsystem, OnRequestSaveLoadPopup) == 0x000030, "Member 'UVSettingsGlobalSubsystem::OnRequestSaveLoadPopup' has a wrong offset!");
static_assert(offsetof(UVSettingsGlobalSubsystem, OnSettingsBroadcastDelagete) == 0x000040, "Member 'UVSettingsGlobalSubsystem::OnSettingsBroadcastDelagete' has a wrong offset!");
static_assert(offsetof(UVSettingsGlobalSubsystem, OnSettingsChangedDelegete) == 0x000050, "Member 'UVSettingsGlobalSubsystem::OnSettingsChangedDelegete' has a wrong offset!");
static_assert(offsetof(UVSettingsGlobalSubsystem, OnRequestTimedRevertPopup) == 0x000060, "Member 'UVSettingsGlobalSubsystem::OnRequestTimedRevertPopup' has a wrong offset!");
static_assert(offsetof(UVSettingsGlobalSubsystem, OnUpdateSettingsLockState) == 0x000070, "Member 'UVSettingsGlobalSubsystem::OnUpdateSettingsLockState' has a wrong offset!");

// Class Altar.TESWaterForm
// 0x00B8 (0x0190 - 0x00D8)
class UTESWaterForm final : public UTESForm
{
public:
	TSoftObjectPtr<class UTexture2D>              Texture;                                           // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ALPHA;                                             // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Flags_0;                                           // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWaterShaderData                       WaterData;                                         // 0x0108(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 MaterialID;                                        // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESWaterForm">();
	}
	static class UTESWaterForm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESWaterForm>();
	}
};
static_assert(alignof(UTESWaterForm) == 0x000008, "Wrong alignment on UTESWaterForm");
static_assert(sizeof(UTESWaterForm) == 0x000190, "Wrong size on UTESWaterForm");
static_assert(offsetof(UTESWaterForm, Texture) == 0x0000D8, "Member 'UTESWaterForm::Texture' has a wrong offset!");
static_assert(offsetof(UTESWaterForm, ALPHA) == 0x000100, "Member 'UTESWaterForm::ALPHA' has a wrong offset!");
static_assert(offsetof(UTESWaterForm, Flags_0) == 0x000104, "Member 'UTESWaterForm::Flags_0' has a wrong offset!");
static_assert(offsetof(UTESWaterForm, WaterData) == 0x000108, "Member 'UTESWaterForm::WaterData' has a wrong offset!");
static_assert(offsetof(UTESWaterForm, MaterialID) == 0x000180, "Member 'UTESWaterForm::MaterialID' has a wrong offset!");

// Class Altar.VAnimNotifyState_TrailVFX
// 0x0008 (0x0038 - 0x0030)
class UVAnimNotifyState_TrailVFX final : public UAnimNotifyState
{
public:
	class FName                                   BoneNameUsedToAttack;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotifyState_TrailVFX">();
	}
	static class UVAnimNotifyState_TrailVFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotifyState_TrailVFX>();
	}
};
static_assert(alignof(UVAnimNotifyState_TrailVFX) == 0x000008, "Wrong alignment on UVAnimNotifyState_TrailVFX");
static_assert(sizeof(UVAnimNotifyState_TrailVFX) == 0x000038, "Wrong size on UVAnimNotifyState_TrailVFX");
static_assert(offsetof(UVAnimNotifyState_TrailVFX, BoneNameUsedToAttack) == 0x000030, "Member 'UVAnimNotifyState_TrailVFX::BoneNameUsedToAttack' has a wrong offset!");

// Class Altar.TESWeather
// 0x0008 (0x00E0 - 0x00D8)
class UTESWeather final : public UTESForm
{
public:
	class UATMEventPreset*                        Preset;                                            // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESWeather">();
	}
	static class UTESWeather* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESWeather>();
	}
};
static_assert(alignof(UTESWeather) == 0x000008, "Wrong alignment on UTESWeather");
static_assert(sizeof(UTESWeather) == 0x0000E0, "Wrong size on UTESWeather");
static_assert(offsetof(UTESWeather, Preset) == 0x0000D8, "Member 'UTESWeather::Preset' has a wrong offset!");

// Class Altar.TESWorldSpace
// 0x0178 (0x0250 - 0x00D8)
class UTESWorldSpace final : public UTESForm
{
public:
	struct FWorldMapLandscapeSettings             LandscapeGenerationSettings;                       // 0x00D8(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWorldMapLandscapeInfo                 LandscapeGenerationInfo;                           // 0x0100(0x0060)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Flags_0;                                           // 0x0160(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 CellFileOffsets;                                   // 0x0168(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTESClimate*                            Climate;                                           // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESWaterForm*                          WorldWater;                                        // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESWorldSpace*                         ParentWorld;                                       // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWorldMapData                          WorldMapData;                                      // 0x0190(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MinimumCoord;                                      // 0x01B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaximumCoord;                                      // 0x01C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESTexture*                            Texture;                                           // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UTESCell*>                  CellMap;                                           // 0x01E8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTESCell*                               PersistentCell;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTESCell* GetCellAtGridXY(int32 X, int32 Y);

	int32 GetCellsGridMaxX() const;
	int32 GetCellsGridMaxY() const;
	int32 GetCellsGridMinX() const;
	int32 GetCellsGridMinY() const;
	int32 GetCellsGridSizeX() const;
	int32 GetCellsGridSizeY() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TESWorldSpace">();
	}
	static class UTESWorldSpace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTESWorldSpace>();
	}
};
static_assert(alignof(UTESWorldSpace) == 0x000008, "Wrong alignment on UTESWorldSpace");
static_assert(sizeof(UTESWorldSpace) == 0x000250, "Wrong size on UTESWorldSpace");
static_assert(offsetof(UTESWorldSpace, LandscapeGenerationSettings) == 0x0000D8, "Member 'UTESWorldSpace::LandscapeGenerationSettings' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, LandscapeGenerationInfo) == 0x000100, "Member 'UTESWorldSpace::LandscapeGenerationInfo' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, Flags_0) == 0x000160, "Member 'UTESWorldSpace::Flags_0' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, CellFileOffsets) == 0x000168, "Member 'UTESWorldSpace::CellFileOffsets' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, Climate) == 0x000178, "Member 'UTESWorldSpace::Climate' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, WorldWater) == 0x000180, "Member 'UTESWorldSpace::WorldWater' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, ParentWorld) == 0x000188, "Member 'UTESWorldSpace::ParentWorld' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, WorldMapData) == 0x000190, "Member 'UTESWorldSpace::WorldMapData' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, MinimumCoord) == 0x0001B0, "Member 'UTESWorldSpace::MinimumCoord' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, MaximumCoord) == 0x0001C8, "Member 'UTESWorldSpace::MaximumCoord' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, Texture) == 0x0001E0, "Member 'UTESWorldSpace::Texture' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, CellMap) == 0x0001E8, "Member 'UTESWorldSpace::CellMap' has a wrong offset!");
static_assert(offsetof(UTESWorldSpace, PersistentCell) == 0x000238, "Member 'UTESWorldSpace::PersistentCell' has a wrong offset!");

// Class Altar.TexDesc
// 0x0088 (0x00B8 - 0x0030)
class UTexDesc final : public UNifType
{
public:
	class UNiImage*                               Image;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiSourceTexture*                       Source;                                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETexClampMode                                 ClampMode;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETexFilterMode                                FilterMode;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTexturingMapFlags                     Flags_0;                                           // 0x0048(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAnisotropy;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         UVSet;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PS2L;                                              // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PS2K;                                              // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x2];                                       // 0x0060(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          HasTextureTransform;                               // 0x0062(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Translation;                                       // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformMethod                              TransformMethodFlag;                               // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TexDesc">();
	}
	static class UTexDesc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTexDesc>();
	}
};
static_assert(alignof(UTexDesc) == 0x000008, "Wrong alignment on UTexDesc");
static_assert(sizeof(UTexDesc) == 0x0000B8, "Wrong size on UTexDesc");
static_assert(offsetof(UTexDesc, Image) == 0x000030, "Member 'UTexDesc::Image' has a wrong offset!");
static_assert(offsetof(UTexDesc, Source) == 0x000038, "Member 'UTexDesc::Source' has a wrong offset!");
static_assert(offsetof(UTexDesc, ClampMode) == 0x000040, "Member 'UTexDesc::ClampMode' has a wrong offset!");
static_assert(offsetof(UTexDesc, FilterMode) == 0x000044, "Member 'UTexDesc::FilterMode' has a wrong offset!");
static_assert(offsetof(UTexDesc, Flags_0) == 0x000048, "Member 'UTexDesc::Flags_0' has a wrong offset!");
static_assert(offsetof(UTexDesc, MaxAnisotropy) == 0x00004C, "Member 'UTexDesc::MaxAnisotropy' has a wrong offset!");
static_assert(offsetof(UTexDesc, UVSet) == 0x000050, "Member 'UTexDesc::UVSet' has a wrong offset!");
static_assert(offsetof(UTexDesc, PS2L) == 0x000058, "Member 'UTexDesc::PS2L' has a wrong offset!");
static_assert(offsetof(UTexDesc, PS2K) == 0x00005C, "Member 'UTexDesc::PS2K' has a wrong offset!");
static_assert(offsetof(UTexDesc, HasTextureTransform) == 0x000062, "Member 'UTexDesc::HasTextureTransform' has a wrong offset!");
static_assert(offsetof(UTexDesc, Translation) == 0x000068, "Member 'UTexDesc::Translation' has a wrong offset!");
static_assert(offsetof(UTexDesc, Scale) == 0x000080, "Member 'UTexDesc::Scale' has a wrong offset!");
static_assert(offsetof(UTexDesc, Rotation) == 0x000098, "Member 'UTexDesc::Rotation' has a wrong offset!");
static_assert(offsetof(UTexDesc, TransformMethodFlag) == 0x00009C, "Member 'UTexDesc::TransformMethodFlag' has a wrong offset!");
static_assert(offsetof(UTexDesc, Center) == 0x0000A0, "Member 'UTexDesc::Center' has a wrong offset!");

// Class Altar.TextKey
// 0x0040 (0x0070 - 0x0030)
class UTextKey final : public UNifType
{
public:
	float                                         Time;                                              // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNifString                             Value;                                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FNifString                             Forward;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FNifString                             Backward;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UTBC*                                   TBC;                                               // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextKey">();
	}
	static class UTextKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextKey>();
	}
};
static_assert(alignof(UTextKey) == 0x000008, "Wrong alignment on UTextKey");
static_assert(sizeof(UTextKey) == 0x000070, "Wrong size on UTextKey");
static_assert(offsetof(UTextKey, Time) == 0x000030, "Member 'UTextKey::Time' has a wrong offset!");
static_assert(offsetof(UTextKey, Value) == 0x000038, "Member 'UTextKey::Value' has a wrong offset!");
static_assert(offsetof(UTextKey, Forward) == 0x000048, "Member 'UTextKey::Forward' has a wrong offset!");
static_assert(offsetof(UTextKey, Backward) == 0x000058, "Member 'UTextKey::Backward' has a wrong offset!");
static_assert(offsetof(UTextKey, TBC) == 0x000068, "Member 'UTextKey::TBC' has a wrong offset!");

// Class Altar.VPhenotypeCustomizationSession
// 0x0010 (0x0038 - 0x0028)
class UVPhenotypeCustomizationSession final : public UObject
{
public:
	class AVPairedCharacter*                      LinkedCharacter;                                   // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVCharacterPhenotypeDataFilter                Filter;                                            // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndSession();
	void RefreshCharacter();
	void ResetCharacterToPreset(const class UVCharacterPhenotypePreset* Preset);
	void SetEyeMaterial(class UMaterialInterface* Material, int32 CustomisationIndex, bool bShouldRefreshCharacter);
	void SetFaceBaseMesh(class USkeletalMesh* FaceBaseMesh, bool bShouldRefreshCharacter);
	void SetFaceMorphAxisValue(class FName Name_0, float Value, bool bShouldRefreshCharacter);
	void SetFaceSkinMaterial(class FName MaterialSlotName, class UMaterialInterface* Material, bool bShouldRefreshCharacter);
	void SetHairPiece(EVFacialHairType HairType, class UVCharacterHairPieceBase* HairPiece, int32 CustomisationIndex, bool bShouldRefreshCharacter);
	void SetRace(class UTESRace* NewRace, bool bShouldRefreshCharacter);
	void SetSenescenceValue(int32 NewValue, bool bShouldRefreshCharacter);
	void SetSex(ECharacterSex Sex, bool bShouldRefreshCharacter);
	void SetSkinColorParameter(class FName ParameterName, const struct FColor& Value, bool bShouldRefreshCharacter);
	void SetSkinParameter(class FName ParameterName, float Value, bool bShouldRefreshCharacter);
	void StartFromCharacter(class AVPairedCharacter* Character, bool DestroyCharacterOnSessionEnd);
	void StartFromScratch(class UWorld* InWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPhenotypeCustomizationSession">();
	}
	static class UVPhenotypeCustomizationSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPhenotypeCustomizationSession>();
	}
};
static_assert(alignof(UVPhenotypeCustomizationSession) == 0x000008, "Wrong alignment on UVPhenotypeCustomizationSession");
static_assert(sizeof(UVPhenotypeCustomizationSession) == 0x000038, "Wrong size on UVPhenotypeCustomizationSession");
static_assert(offsetof(UVPhenotypeCustomizationSession, LinkedCharacter) == 0x000028, "Member 'UVPhenotypeCustomizationSession::LinkedCharacter' has a wrong offset!");
static_assert(offsetof(UVPhenotypeCustomizationSession, Filter) == 0x000030, "Member 'UVPhenotypeCustomizationSession::Filter' has a wrong offset!");

// Class Altar.TriangleData
// 0x0038 (0x0068 - 0x0030)
class UTriangleData final : public UNifType
{
public:
	struct FVector                                Triangle;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeldingInfo;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Normal;                                            // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriangleData">();
	}
	static class UTriangleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriangleData>();
	}
};
static_assert(alignof(UTriangleData) == 0x000008, "Wrong alignment on UTriangleData");
static_assert(sizeof(UTriangleData) == 0x000068, "Wrong size on UTriangleData");
static_assert(offsetof(UTriangleData, Triangle) == 0x000030, "Member 'UTriangleData::Triangle' has a wrong offset!");
static_assert(offsetof(UTriangleData, WeldingInfo) == 0x000048, "Member 'UTriangleData::WeldingInfo' has a wrong offset!");
static_assert(offsetof(UTriangleData, Normal) == 0x000050, "Member 'UTriangleData::Normal' has a wrong offset!");

// Class Altar.UE5AltarPairingActor
// 0x0000 (0x0298 - 0x0298)
class AUE5AltarPairingActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UE5AltarPairingActor">();
	}
	static class AUE5AltarPairingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUE5AltarPairingActor>();
	}
};
static_assert(alignof(AUE5AltarPairingActor) == 0x000008, "Wrong alignment on AUE5AltarPairingActor");
static_assert(sizeof(AUE5AltarPairingActor) == 0x000298, "Wrong size on AUE5AltarPairingActor");

// Class Altar.UserInputTextSaveData
// 0x0060 (0x0090 - 0x0030)
class UUserInputTextSaveData final : public UVBaseAltarSaveData
{
public:
	TMulticastInlineDelegate<void(class UUserInputTextSaveData* SaveData)> OnSaveDataUpdated;        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class FText>              UserInputTextsMap;                                 // 0x0040(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserInputTextSaveData">();
	}
	static class UUserInputTextSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserInputTextSaveData>();
	}
};
static_assert(alignof(UUserInputTextSaveData) == 0x000008, "Wrong alignment on UUserInputTextSaveData");
static_assert(sizeof(UUserInputTextSaveData) == 0x000090, "Wrong size on UUserInputTextSaveData");
static_assert(offsetof(UUserInputTextSaveData, OnSaveDataUpdated) == 0x000030, "Member 'UUserInputTextSaveData::OnSaveDataUpdated' has a wrong offset!");
static_assert(offsetof(UUserInputTextSaveData, UserInputTextsMap) == 0x000040, "Member 'UUserInputTextSaveData::UserInputTextsMap' has a wrong offset!");

// Class Altar.VCinematicSubsystem
// 0x0030 (0x0060 - 0x0030)
class UVCinematicSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void()>              BP_OnLevelSequenceEnd;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVCinematicSaveData*                    CinematicSaveData;                                 // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelSequenceEnd();
	void StartInGameCinematic();

	bool IsPlayingCinematic() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCinematicSubsystem">();
	}
	static class UVCinematicSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCinematicSubsystem>();
	}
};
static_assert(alignof(UVCinematicSubsystem) == 0x000008, "Wrong alignment on UVCinematicSubsystem");
static_assert(sizeof(UVCinematicSubsystem) == 0x000060, "Wrong size on UVCinematicSubsystem");
static_assert(offsetof(UVCinematicSubsystem, BP_OnLevelSequenceEnd) == 0x000030, "Member 'UVCinematicSubsystem::BP_OnLevelSequenceEnd' has a wrong offset!");
static_assert(offsetof(UVCinematicSubsystem, CinematicSaveData) == 0x000048, "Member 'UVCinematicSubsystem::CinematicSaveData' has a wrong offset!");

// Class Altar.VAltarBowTriggerResistance
// 0x0000 (0x00C0 - 0x00C0)
class UVAltarBowTriggerResistance final : public UInputDeviceTriggerResistanceProperty
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarBowTriggerResistance">();
	}
	static class UVAltarBowTriggerResistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarBowTriggerResistance>();
	}
};
static_assert(alignof(UVAltarBowTriggerResistance) == 0x000008, "Wrong alignment on UVAltarBowTriggerResistance");
static_assert(sizeof(UVAltarBowTriggerResistance) == 0x0000C0, "Wrong size on UVAltarBowTriggerResistance");

// Class Altar.VAltarFatigueTriggerResistance
// 0x0000 (0x00C0 - 0x00C0)
class UVAltarFatigueTriggerResistance final : public UInputDeviceTriggerResistanceProperty
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarFatigueTriggerResistance">();
	}
	static class UVAltarFatigueTriggerResistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarFatigueTriggerResistance>();
	}
};
static_assert(alignof(UVAltarFatigueTriggerResistance) == 0x000008, "Wrong alignment on UVAltarFatigueTriggerResistance");
static_assert(sizeof(UVAltarFatigueTriggerResistance) == 0x0000C0, "Wrong size on UVAltarFatigueTriggerResistance");

// Class Altar.UVAltarUserInputTextSubsystem
// 0x0008 (0x0038 - 0x0030)
class UUVAltarUserInputTextSubsystem final : public UGameInstanceSubsystem
{
public:
	class UUserInputTextSaveData*                 UserInputTextSaveData;                             // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UVAltarUserInputTextSubsystem">();
	}
	static class UUVAltarUserInputTextSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUVAltarUserInputTextSubsystem>();
	}
};
static_assert(alignof(UUVAltarUserInputTextSubsystem) == 0x000008, "Wrong alignment on UUVAltarUserInputTextSubsystem");
static_assert(sizeof(UUVAltarUserInputTextSubsystem) == 0x000038, "Wrong size on UUVAltarUserInputTextSubsystem");
static_assert(offsetof(UUVAltarUserInputTextSubsystem, UserInputTextSaveData) == 0x000030, "Member 'UUVAltarUserInputTextSubsystem::UserInputTextSaveData' has a wrong offset!");

// Class Altar.VClassItemObject
// 0x00A8 (0x00D0 - 0x0028)
class UVClassItemObject final : public UObject
{
public:
	struct FPlayerClassItemProperties             Properties;                                        // 0x0028(0x00A0)(NativeAccessSpecifierPrivate)
	bool                                          bIsSelected;                                       // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsSelected(bool bNewSelectionState);
	void SetProperties(const struct FPlayerClassItemProperties& NewProperties);

	const struct FPlayerClassItemProperties GetProperties() const;
	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VClassItemObject">();
	}
	static class UVClassItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVClassItemObject>();
	}
};
static_assert(alignof(UVClassItemObject) == 0x000008, "Wrong alignment on UVClassItemObject");
static_assert(sizeof(UVClassItemObject) == 0x0000D0, "Wrong size on UVClassItemObject");
static_assert(offsetof(UVClassItemObject, Properties) == 0x000028, "Member 'UVClassItemObject::Properties' has a wrong offset!");
static_assert(offsetof(UVClassItemObject, bIsSelected) == 0x0000C8, "Member 'UVClassItemObject::bIsSelected' has a wrong offset!");

// Class Altar.VActivableStatic
// 0x0008 (0x03A0 - 0x0398)
class AVActivableStatic final : public AVActivable
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AttachNativeSceneComponentsToRoot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VActivableStatic">();
	}
	static class AVActivableStatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVActivableStatic>();
	}
};
static_assert(alignof(AVActivableStatic) == 0x000008, "Wrong alignment on AVActivableStatic");
static_assert(sizeof(AVActivableStatic) == 0x0003A0, "Wrong size on AVActivableStatic");
static_assert(offsetof(AVActivableStatic, StaticMeshComponent) == 0x000398, "Member 'AVActivableStatic::StaticMeshComponent' has a wrong offset!");

// Class Altar.VActivatableWidgetStack
// 0x0018 (0x02C8 - 0x02B0)
class UVActivatableWidgetStack final : public UCommonActivatableWidgetStack
{
public:
	class UCommonActivatableWidget*               LastDisplayedWidget;                               // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UVUINavigationGlobalSubsystem> UINavigationSubsystem;                       // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UVAltarUISubsystem>      AltarUISubsystem;                                  // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VActivatableWidgetStack">();
	}
	static class UVActivatableWidgetStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVActivatableWidgetStack>();
	}
};
static_assert(alignof(UVActivatableWidgetStack) == 0x000008, "Wrong alignment on UVActivatableWidgetStack");
static_assert(sizeof(UVActivatableWidgetStack) == 0x0002C8, "Wrong size on UVActivatableWidgetStack");
static_assert(offsetof(UVActivatableWidgetStack, LastDisplayedWidget) == 0x0002B0, "Member 'UVActivatableWidgetStack::LastDisplayedWidget' has a wrong offset!");
static_assert(offsetof(UVActivatableWidgetStack, UINavigationSubsystem) == 0x0002B8, "Member 'UVActivatableWidgetStack::UINavigationSubsystem' has a wrong offset!");
static_assert(offsetof(UVActivatableWidgetStack, AltarUISubsystem) == 0x0002C0, "Member 'UVActivatableWidgetStack::AltarUISubsystem' has a wrong offset!");

// Class Altar.VActiveEffectsPairingComponent
// 0x0010 (0x00C8 - 0x00B8)
class UVActiveEffectsPairingComponent final : public UVActorPairingComponent
{
public:
	TArray<struct FVActiveEffectsData>            ActiveEffectList;                                  // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VActiveEffectsPairingComponent">();
	}
	static class UVActiveEffectsPairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVActiveEffectsPairingComponent>();
	}
};
static_assert(alignof(UVActiveEffectsPairingComponent) == 0x000008, "Wrong alignment on UVActiveEffectsPairingComponent");
static_assert(sizeof(UVActiveEffectsPairingComponent) == 0x0000C8, "Wrong size on UVActiveEffectsPairingComponent");
static_assert(offsetof(UVActiveEffectsPairingComponent, ActiveEffectList) == 0x0000B8, "Member 'UVActiveEffectsPairingComponent::ActiveEffectList' has a wrong offset!");

// Class Altar.VActorBehaviorBase
// 0x0028 (0x0050 - 0x0028)
class UVActorBehaviorBase : public UObject
{
public:
	TMulticastInlineDelegate<void(bool bInterrupted)> OnEnded;                                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndBehavior();
	void Interrupt();
	void OnEnd(bool bInterrupted);
	void OnInit();
	void OnUpdate(float DeltaTime);

	class AVPairedPawn* GetControlledPawn() const;
	float GetElapsedTime() const;
	class UVAltarActionState* GetOuterState() const;
	EVActorBehaviorState GetState() const;
	bool HasEnded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VActorBehaviorBase">();
	}
	static class UVActorBehaviorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVActorBehaviorBase>();
	}
};
static_assert(alignof(UVActorBehaviorBase) == 0x000008, "Wrong alignment on UVActorBehaviorBase");
static_assert(sizeof(UVActorBehaviorBase) == 0x000050, "Wrong size on UVActorBehaviorBase");
static_assert(offsetof(UVActorBehaviorBase, OnEnded) == 0x000028, "Member 'UVActorBehaviorBase::OnEnded' has a wrong offset!");

// Class Altar.VSkillsMenuViewModel
// 0x0060 (0x0130 - 0x00D0)
class UVSkillsMenuViewModel final : public UVViewModelBase
{
public:
	TArray<struct FSkillsMenuItemProperties>      Items;                                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FSkillsMenuProperties                  Properties;                                        // 0x00E0(0x0050)(NativeAccessSpecifierPrivate)

public:
	void RegisterSendClickedBack();
	void RegisterSendClickedDone();
	void RegisterSendClickedItem(int32 ID);
	void RegisterSendCustomClassName(const class FText& NewClassName);
	void RegisterSendMultipleClicksBack(int32 NumberOfClicksToEmulate);
	void RegisterSendMultipleClicksDone(int32 NumberOfClicksToEmulate);
	void SetItems(const TArray<struct FSkillsMenuItemProperties>& Data);
	void SetProperties(const struct FSkillsMenuProperties& Data);
	void UpdateItemSelection(int32 ItemIndex, bool bNewSelectionState);
	void UpdateListAfterItemSelectionChanged();

	const TArray<struct FSkillsMenuItemProperties> GetItems() const;
	const struct FSkillsMenuProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSkillsMenuViewModel">();
	}
	static class UVSkillsMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSkillsMenuViewModel>();
	}
};
static_assert(alignof(UVSkillsMenuViewModel) == 0x000008, "Wrong alignment on UVSkillsMenuViewModel");
static_assert(sizeof(UVSkillsMenuViewModel) == 0x000130, "Wrong size on UVSkillsMenuViewModel");
static_assert(offsetof(UVSkillsMenuViewModel, Items) == 0x0000D0, "Member 'UVSkillsMenuViewModel::Items' has a wrong offset!");
static_assert(offsetof(UVSkillsMenuViewModel, Properties) == 0x0000E0, "Member 'UVSkillsMenuViewModel::Properties' has a wrong offset!");

// Class Altar.VActorBehaviorMap
// 0x0050 (0x0078 - 0x0028)
class UVActorBehaviorMap : public UObject
{
public:
	TMap<struct FGameplayTag, class UVActorBehaviorBase*> TagToBehaviorMap;                          // 0x0028(0x0050)(Edit, ExportObject, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	class UVActorBehaviorBase* GetBehaviorForTag(const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VActorBehaviorMap">();
	}
	static class UVActorBehaviorMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVActorBehaviorMap>();
	}
};
static_assert(alignof(UVActorBehaviorMap) == 0x000008, "Wrong alignment on UVActorBehaviorMap");
static_assert(sizeof(UVActorBehaviorMap) == 0x000078, "Wrong size on UVActorBehaviorMap");
static_assert(offsetof(UVActorBehaviorMap, TagToBehaviorMap) == 0x000028, "Member 'UVActorBehaviorMap::TagToBehaviorMap' has a wrong offset!");

// Class Altar.VActorBehaviorCollection
// 0x0010 (0x0040 - 0x0030)
class UVActorBehaviorCollection final : public UDataAsset
{
public:
	TArray<class UVActorBehaviorBase*>            Behaviors;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VActorBehaviorCollection">();
	}
	static class UVActorBehaviorCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVActorBehaviorCollection>();
	}
};
static_assert(alignof(UVActorBehaviorCollection) == 0x000008, "Wrong alignment on UVActorBehaviorCollection");
static_assert(sizeof(UVActorBehaviorCollection) == 0x000040, "Wrong size on UVActorBehaviorCollection");
static_assert(offsetof(UVActorBehaviorCollection, Behaviors) == 0x000030, "Member 'UVActorBehaviorCollection::Behaviors' has a wrong offset!");

// Class Altar.VActorValuesPairingComponent
// 0x00C8 (0x0180 - 0x00B8)
class UVActorValuesPairingComponent final : public UVActorPairingComponent
{
public:
	TMulticastInlineDelegate<void(float PreviousEquippedEncumbrance, float NewEquippedEncumbrance)> OnEquippedEncumbranceChanged; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0xA8];                                      // 0x00C8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnAllActorValueChanged;                            // 0x0170(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BindOnActorValueChanged(EVActorValues ActorValueToListen, const TDelegate<void(EVActorValues ActorValue, float PreviousBaseValue, float PreviousModifiedValue, float NewBaseValue, float NewModifiedValue)>& Callback);
	void BindOnAnyActorValueChanged(const TSet<EVActorValues>& ActorValuesToListen, const TDelegate<void(EVActorValues ActorValue, float PreviousBaseValue, float PreviousModifiedValue, float NewBaseValue, float NewModifiedValue)>& Callback);
	void NotifyAllNewValues();
	void UnBindOnActorValueChanged(EVActorValues ActorValueToListen, const TDelegate<void(EVActorValues ActorValue, float PreviousBaseValue, float PreviousModifiedValue, float NewBaseValue, float NewModifiedValue)>& Callback);
	void UnBindOnAnyActorValueChanged(const TDelegate<void(EVActorValues ActorValue, float PreviousBaseValue, float PreviousModifiedValue, float NewBaseValue, float NewModifiedValue)>& Callback);

	EVSkillLevel GetBaseSkillLevel(EVSkill Skill) const;
	float GetEquippedEncumbrance() const;
	float GetFloatBaseActorValue(EVActorValues ValueWanted) const;
	float GetFloatModifiedActorValue(EVActorValues ValueWanted) const;
	int32 GetIntBaseActorValue(EVActorValues ValueWanted) const;
	int32 GetIntModifiedActorValue(EVActorValues ValueWanted) const;
	EVSkillLevel GetModifiedSkillLevel(EVSkill Skill) const;
	uint8 GetUIntBaseActorValue(EVActorValues ValueWanted) const;
	uint8 GetUIntModifiedActorValue(EVActorValues ValueWanted) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VActorValuesPairingComponent">();
	}
	static class UVActorValuesPairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVActorValuesPairingComponent>();
	}
};
static_assert(alignof(UVActorValuesPairingComponent) == 0x000008, "Wrong alignment on UVActorValuesPairingComponent");
static_assert(sizeof(UVActorValuesPairingComponent) == 0x000180, "Wrong size on UVActorValuesPairingComponent");
static_assert(offsetof(UVActorValuesPairingComponent, OnEquippedEncumbranceChanged) == 0x0000B8, "Member 'UVActorValuesPairingComponent::OnEquippedEncumbranceChanged' has a wrong offset!");
static_assert(offsetof(UVActorValuesPairingComponent, OnAllActorValueChanged) == 0x000170, "Member 'UVActorValuesPairingComponent::OnAllActorValueChanged' has a wrong offset!");

// Class Altar.VAnimNotify_SpecialBloodVFX
// 0x0000 (0x0038 - 0x0038)
class UVAnimNotify_SpecialBloodVFX final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_SpecialBloodVFX">();
	}
	static class UVAnimNotify_SpecialBloodVFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_SpecialBloodVFX>();
	}
};
static_assert(alignof(UVAnimNotify_SpecialBloodVFX) == 0x000008, "Wrong alignment on UVAnimNotify_SpecialBloodVFX");
static_assert(sizeof(UVAnimNotify_SpecialBloodVFX) == 0x000038, "Wrong size on UVAnimNotify_SpecialBloodVFX");

// Class Altar.VSigilStoneMenuViewModel
// 0x0130 (0x0200 - 0x00D0)
class UVSigilStoneMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnSucessSoundTrigger;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FItemToEnchantInfo                     ItemToEnchantInfo;                                 // 0x00E0(0x0020)(NativeAccessSpecifierPrivate)
	struct FSoulGemInfo                           SigilStoneInfo;                                    // 0x0100(0x0028)(NativeAccessSpecifierPrivate)
	struct FModernEffectItemData                  GearEffect;                                        // 0x0128(0x0060)(NativeAccessSpecifierPrivate)
	struct FModernEffectItemData                  WeaponEffect;                                      // 0x0188(0x0060)(NativeAccessSpecifierPrivate)
	TArray<struct FModernSigilStoneMenuItemProperties> ItemsList;                                    // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	EOriginalInventoryMenuSortType                SortType;                                          // 0x01F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSortReversed;                                   // 0x01F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FA[0x6];                                      // 0x01FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendClickOnCreateButton(const class FString& NewEnchantedItemName);
	void RegisterSendClickOnExitButton();
	void RegisterSendClickOnItemButton();
	void RegisterSendHoverAnItemToEnchant(int32 ItemIndex);
	void SetGearEffect(const struct FModernEffectItemData& NewAvailableEffect);
	void SetIsSortReversed(bool bNewIsSortReversed);
	void SetItemsList(const TArray<struct FModernSigilStoneMenuItemProperties>& NewList);
	void SetItemToEnchantInfo(const struct FItemToEnchantInfo& NewItemToEnchantInfo);
	void SetSigilStoneInfo(const struct FSoulGemInfo& NewSigilStoneInfo);
	void SetSortType(const EOriginalInventoryMenuSortType& NewSortType);
	void SetWeaponEffect(const struct FModernEffectItemData& NewAvailableEffect);

	const struct FModernEffectItemData GetGearEffect() const;
	const TArray<struct FModernSigilStoneMenuItemProperties> GetItemsList() const;
	const struct FItemToEnchantInfo GetItemToEnchantInfo() const;
	const struct FSoulGemInfo GetSigilStoneInfo() const;
	EOriginalInventoryMenuSortType GetSortType() const;
	const struct FModernEffectItemData GetWeaponEffect() const;
	bool IsSortReversed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSigilStoneMenuViewModel">();
	}
	static class UVSigilStoneMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSigilStoneMenuViewModel>();
	}
};
static_assert(alignof(UVSigilStoneMenuViewModel) == 0x000008, "Wrong alignment on UVSigilStoneMenuViewModel");
static_assert(sizeof(UVSigilStoneMenuViewModel) == 0x000200, "Wrong size on UVSigilStoneMenuViewModel");
static_assert(offsetof(UVSigilStoneMenuViewModel, OnSucessSoundTrigger) == 0x0000D0, "Member 'UVSigilStoneMenuViewModel::OnSucessSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVSigilStoneMenuViewModel, ItemToEnchantInfo) == 0x0000E0, "Member 'UVSigilStoneMenuViewModel::ItemToEnchantInfo' has a wrong offset!");
static_assert(offsetof(UVSigilStoneMenuViewModel, SigilStoneInfo) == 0x000100, "Member 'UVSigilStoneMenuViewModel::SigilStoneInfo' has a wrong offset!");
static_assert(offsetof(UVSigilStoneMenuViewModel, GearEffect) == 0x000128, "Member 'UVSigilStoneMenuViewModel::GearEffect' has a wrong offset!");
static_assert(offsetof(UVSigilStoneMenuViewModel, WeaponEffect) == 0x000188, "Member 'UVSigilStoneMenuViewModel::WeaponEffect' has a wrong offset!");
static_assert(offsetof(UVSigilStoneMenuViewModel, ItemsList) == 0x0001E8, "Member 'UVSigilStoneMenuViewModel::ItemsList' has a wrong offset!");
static_assert(offsetof(UVSigilStoneMenuViewModel, SortType) == 0x0001F8, "Member 'UVSigilStoneMenuViewModel::SortType' has a wrong offset!");
static_assert(offsetof(UVSigilStoneMenuViewModel, bIsSortReversed) == 0x0001F9, "Member 'UVSigilStoneMenuViewModel::bIsSortReversed' has a wrong offset!");

// Class Altar.VLegacyEffectItem
// 0x0060 (0x0088 - 0x0028)
class UVLegacyEffectItem final : public UObject
{
public:
	struct FLegacyAddedEffectItemProperties       Properties;                                        // 0x0028(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void SetProperties(const struct FLegacyAddedEffectItemProperties& Value);

	const struct FLegacyAddedEffectItemProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyEffectItem">();
	}
	static class UVLegacyEffectItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyEffectItem>();
	}
};
static_assert(alignof(UVLegacyEffectItem) == 0x000008, "Wrong alignment on UVLegacyEffectItem");
static_assert(sizeof(UVLegacyEffectItem) == 0x000088, "Wrong size on UVLegacyEffectItem");
static_assert(offsetof(UVLegacyEffectItem, Properties) == 0x000028, "Member 'UVLegacyEffectItem::Properties' has a wrong offset!");

// Class Altar.VModernEffectItem
// 0x0060 (0x0088 - 0x0028)
class UVModernEffectItem final : public UObject
{
public:
	struct FModernEffectItemData                  Properties;                                        // 0x0028(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void SetProperties(const struct FModernEffectItemData& Value);

	const struct FModernEffectItemData GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernEffectItem">();
	}
	static class UVModernEffectItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernEffectItem>();
	}
};
static_assert(alignof(UVModernEffectItem) == 0x000008, "Wrong alignment on UVModernEffectItem");
static_assert(sizeof(UVModernEffectItem) == 0x000088, "Wrong size on UVModernEffectItem");
static_assert(offsetof(UVModernEffectItem, Properties) == 0x000028, "Member 'UVModernEffectItem::Properties' has a wrong offset!");

// Class Altar.VAddedEffectsListViewModel
// 0x0020 (0x00F0 - 0x00D0)
class UVAddedEffectsListViewModel final : public UVViewModelBase
{
public:
	TArray<struct FLegacyAddedEffectItemProperties> AddedEffectsList;                                // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FModernEffectItemData>          ModernAddedItemEffectsList;                        // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void SetAddedEffectsList(const TArray<struct FLegacyAddedEffectItemProperties>& NewAddedEffectsList);
	void SetModernAddedItemEffectsList(const TArray<struct FModernEffectItemData>& NewModernAddedItemEffectsList);

	const TArray<struct FLegacyAddedEffectItemProperties> GetAddedEffectsList() const;
	const TArray<struct FModernEffectItemData> GetModernAddedItemEffectsList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAddedEffectsListViewModel">();
	}
	static class UVAddedEffectsListViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAddedEffectsListViewModel>();
	}
};
static_assert(alignof(UVAddedEffectsListViewModel) == 0x000008, "Wrong alignment on UVAddedEffectsListViewModel");
static_assert(sizeof(UVAddedEffectsListViewModel) == 0x0000F0, "Wrong size on UVAddedEffectsListViewModel");
static_assert(offsetof(UVAddedEffectsListViewModel, AddedEffectsList) == 0x0000D0, "Member 'UVAddedEffectsListViewModel::AddedEffectsList' has a wrong offset!");
static_assert(offsetof(UVAddedEffectsListViewModel, ModernAddedItemEffectsList) == 0x0000E0, "Member 'UVAddedEffectsListViewModel::ModernAddedItemEffectsList' has a wrong offset!");

// Class Altar.VATMPlayingWidget
// 0x0010 (0x01A8 - 0x0198)
class UVATMPlayingWidget final : public UContentWidget
{
public:
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VATMPlayingWidget">();
	}
	static class UVATMPlayingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVATMPlayingWidget>();
	}
};
static_assert(alignof(UVATMPlayingWidget) == 0x000008, "Wrong alignment on UVATMPlayingWidget");
static_assert(sizeof(UVATMPlayingWidget) == 0x0001A8, "Wrong size on UVATMPlayingWidget");

// Class Altar.VAltarCursor
// 0x0000 (0x02C0 - 0x02C0)
class UVAltarCursor : public UUserWidget
{
public:
	static void SetCursorVisibility(bool bVisible);

	void OnUpdateCursorSize(float Delta);
	void OnUpdateCursorVisibility(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarCursor">();
	}
	static class UVAltarCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarCursor>();
	}
};
static_assert(alignof(UVAltarCursor) == 0x000008, "Wrong alignment on UVAltarCursor");
static_assert(sizeof(UVAltarCursor) == 0x0002C0, "Wrong size on UVAltarCursor");

// Class Altar.VAICombatMovement_ACTOR
// 0x0018 (0x0058 - 0x0040)
class UVAICombatMovement_ACTOR final : public UVAIProcedureExecution_Base
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     ActiveFilterClass;                                 // 0x0048(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAICombatMovement_ACTOR">();
	}
	static class UVAICombatMovement_ACTOR* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAICombatMovement_ACTOR>();
	}
};
static_assert(alignof(UVAICombatMovement_ACTOR) == 0x000008, "Wrong alignment on UVAICombatMovement_ACTOR");
static_assert(sizeof(UVAICombatMovement_ACTOR) == 0x000058, "Wrong size on UVAICombatMovement_ACTOR");
static_assert(offsetof(UVAICombatMovement_ACTOR, ActiveFilterClass) == 0x000048, "Member 'UVAICombatMovement_ACTOR::ActiveFilterClass' has a wrong offset!");

// Class Altar.VAICombatMovement_IDLE
// 0x0000 (0x0040 - 0x0040)
class UVAICombatMovement_IDLE final : public UVAIProcedureExecution_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAICombatMovement_IDLE">();
	}
	static class UVAICombatMovement_IDLE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAICombatMovement_IDLE>();
	}
};
static_assert(alignof(UVAICombatMovement_IDLE) == 0x000008, "Wrong alignment on UVAICombatMovement_IDLE");
static_assert(sizeof(UVAICombatMovement_IDLE) == 0x000040, "Wrong size on UVAICombatMovement_IDLE");

// Class Altar.VAudioPlayable
// 0x0000 (0x0000 - 0x0000)
class IVAudioPlayable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAudioPlayable">();
	}
	static class IVAudioPlayable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVAudioPlayable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IVAudioPlayable) == 0x000001, "Wrong alignment on IVAudioPlayable");
static_assert(sizeof(IVAudioPlayable) == 0x000001, "Wrong size on IVAudioPlayable");

// Class Altar.VAIHack_TeleportUrielSeptimSanctum
// 0x0070 (0x0340 - 0x02D0)
class AVAIHack_TeleportUrielSeptimSanctum final : public AVolume
{
public:
	struct FTransform                             TeleportTransform;                                 // 0x02D0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeactivateTeleport();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIHack_TeleportUrielSeptimSanctum">();
	}
	static class AVAIHack_TeleportUrielSeptimSanctum* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAIHack_TeleportUrielSeptimSanctum>();
	}
};
static_assert(alignof(AVAIHack_TeleportUrielSeptimSanctum) == 0x000010, "Wrong alignment on AVAIHack_TeleportUrielSeptimSanctum");
static_assert(sizeof(AVAIHack_TeleportUrielSeptimSanctum) == 0x000340, "Wrong size on AVAIHack_TeleportUrielSeptimSanctum");
static_assert(offsetof(AVAIHack_TeleportUrielSeptimSanctum, TeleportTransform) == 0x0002D0, "Member 'AVAIHack_TeleportUrielSeptimSanctum::TeleportTransform' has a wrong offset!");

// Class Altar.VAimOffsetCharacterAnimInstance
// 0x0040 (0x0390 - 0x0350)
class UVAimOffsetCharacterAnimInstance : public UAnimInstance
{
public:
	class UBlendSpace*                            AimBlendSpace;                                     // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               TargetAimOffset;                                   // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               CurrentAimOffset;                                  // 0x0368(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AimSpeed;                                          // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanAim;                                           // 0x0384(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_385[0xB];                                      // 0x0385(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAimOffsetCharacterAnimInstance">();
	}
	static class UVAimOffsetCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAimOffsetCharacterAnimInstance>();
	}
};
static_assert(alignof(UVAimOffsetCharacterAnimInstance) == 0x000010, "Wrong alignment on UVAimOffsetCharacterAnimInstance");
static_assert(sizeof(UVAimOffsetCharacterAnimInstance) == 0x000390, "Wrong size on UVAimOffsetCharacterAnimInstance");
static_assert(offsetof(UVAimOffsetCharacterAnimInstance, AimBlendSpace) == 0x000348, "Member 'UVAimOffsetCharacterAnimInstance::AimBlendSpace' has a wrong offset!");
static_assert(offsetof(UVAimOffsetCharacterAnimInstance, TargetAimOffset) == 0x000350, "Member 'UVAimOffsetCharacterAnimInstance::TargetAimOffset' has a wrong offset!");
static_assert(offsetof(UVAimOffsetCharacterAnimInstance, CurrentAimOffset) == 0x000368, "Member 'UVAimOffsetCharacterAnimInstance::CurrentAimOffset' has a wrong offset!");
static_assert(offsetof(UVAimOffsetCharacterAnimInstance, AimSpeed) == 0x000380, "Member 'UVAimOffsetCharacterAnimInstance::AimSpeed' has a wrong offset!");
static_assert(offsetof(UVAimOffsetCharacterAnimInstance, bCanAim) == 0x000384, "Member 'UVAimOffsetCharacterAnimInstance::bCanAim' has a wrong offset!");

// Class Altar.VAvailableEffectsListViewModel
// 0x0010 (0x00E0 - 0x00D0)
class UVAvailableEffectsListViewModel final : public UVViewModelBase
{
public:
	TArray<struct FAvailableEffectData>           AvailableEffects;                                  // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void SetAvailableEffects(const TArray<struct FAvailableEffectData>& NewAvailableEffects);

	const TArray<struct FAvailableEffectData> GetAvailableEffects() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAvailableEffectsListViewModel">();
	}
	static class UVAvailableEffectsListViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAvailableEffectsListViewModel>();
	}
};
static_assert(alignof(UVAvailableEffectsListViewModel) == 0x000008, "Wrong alignment on UVAvailableEffectsListViewModel");
static_assert(sizeof(UVAvailableEffectsListViewModel) == 0x0000E0, "Wrong size on UVAvailableEffectsListViewModel");
static_assert(offsetof(UVAvailableEffectsListViewModel, AvailableEffects) == 0x0000D0, "Member 'UVAvailableEffectsListViewModel::AvailableEffects' has a wrong offset!");

// Class Altar.VAIPackageExecutionOverride_180976
// 0x0008 (0x0030 - 0x0028)
class UVAIPackageExecutionOverride_180976 final : public UVAIPackageExecutionOverride
{
public:
	class AVPairedPawn*                           Renault;                                           // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIPackageExecutionOverride_180976">();
	}
	static class UVAIPackageExecutionOverride_180976* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIPackageExecutionOverride_180976>();
	}
};
static_assert(alignof(UVAIPackageExecutionOverride_180976) == 0x000008, "Wrong alignment on UVAIPackageExecutionOverride_180976");
static_assert(sizeof(UVAIPackageExecutionOverride_180976) == 0x000030, "Wrong size on UVAIPackageExecutionOverride_180976");
static_assert(offsetof(UVAIPackageExecutionOverride_180976, Renault) == 0x000028, "Member 'UVAIPackageExecutionOverride_180976::Renault' has a wrong offset!");

// Class Altar.VAIPackageExecutionOverride_207593
// 0x0008 (0x0030 - 0x0028)
class UVAIPackageExecutionOverride_207593 final : public UVAIPackageExecutionOverride
{
public:
	class AVPairedPawn*                           UrielSeptim;                                       // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIPackageExecutionOverride_207593">();
	}
	static class UVAIPackageExecutionOverride_207593* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIPackageExecutionOverride_207593>();
	}
};
static_assert(alignof(UVAIPackageExecutionOverride_207593) == 0x000008, "Wrong alignment on UVAIPackageExecutionOverride_207593");
static_assert(sizeof(UVAIPackageExecutionOverride_207593) == 0x000030, "Wrong size on UVAIPackageExecutionOverride_207593");
static_assert(offsetof(UVAIPackageExecutionOverride_207593, UrielSeptim) == 0x000028, "Member 'UVAIPackageExecutionOverride_207593::UrielSeptim' has a wrong offset!");

// Class Altar.VAltarRichInputActionDecorator
// 0x0368 (0x0390 - 0x0028)
class UVAltarRichInputActionDecorator : public URichTextBlockDecorator
{
public:
	TSubclassOf<class UVAltarBoundActionButton>   BoundActionClass;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        KeyTextStyle;                                      // 0x0030(0x0340)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x18];                                     // 0x0370(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DT_InputActions;                                   // 0x0388(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarRichInputActionDecorator">();
	}
	static class UVAltarRichInputActionDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarRichInputActionDecorator>();
	}
};
static_assert(alignof(UVAltarRichInputActionDecorator) == 0x000010, "Wrong alignment on UVAltarRichInputActionDecorator");
static_assert(sizeof(UVAltarRichInputActionDecorator) == 0x000390, "Wrong size on UVAltarRichInputActionDecorator");
static_assert(offsetof(UVAltarRichInputActionDecorator, BoundActionClass) == 0x000028, "Member 'UVAltarRichInputActionDecorator::BoundActionClass' has a wrong offset!");
static_assert(offsetof(UVAltarRichInputActionDecorator, KeyTextStyle) == 0x000030, "Member 'UVAltarRichInputActionDecorator::KeyTextStyle' has a wrong offset!");
static_assert(offsetof(UVAltarRichInputActionDecorator, DT_InputActions) == 0x000388, "Member 'UVAltarRichInputActionDecorator::DT_InputActions' has a wrong offset!");

// Class Altar.VAIPackageExecutionOverride_207638
// 0x0010 (0x0038 - 0x0028)
class UVAIPackageExecutionOverride_207638 final : public UVAIPackageExecutionOverride
{
public:
	class AVPairedPawn*                           Renault;                                           // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AVPairedPawn*                           UrielSeptim;                                       // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIPackageExecutionOverride_207638">();
	}
	static class UVAIPackageExecutionOverride_207638* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIPackageExecutionOverride_207638>();
	}
};
static_assert(alignof(UVAIPackageExecutionOverride_207638) == 0x000008, "Wrong alignment on UVAIPackageExecutionOverride_207638");
static_assert(sizeof(UVAIPackageExecutionOverride_207638) == 0x000038, "Wrong size on UVAIPackageExecutionOverride_207638");
static_assert(offsetof(UVAIPackageExecutionOverride_207638, Renault) == 0x000028, "Member 'UVAIPackageExecutionOverride_207638::Renault' has a wrong offset!");
static_assert(offsetof(UVAIPackageExecutionOverride_207638, UrielSeptim) == 0x000030, "Member 'UVAIPackageExecutionOverride_207638::UrielSeptim' has a wrong offset!");

// Class Altar.VAIPackageExecutionOverride_324150
// 0x0000 (0x0028 - 0x0028)
class UVAIPackageExecutionOverride_324150 final : public UVAIPackageExecutionOverride
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIPackageExecutionOverride_324150">();
	}
	static class UVAIPackageExecutionOverride_324150* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIPackageExecutionOverride_324150>();
	}
};
static_assert(alignof(UVAIPackageExecutionOverride_324150) == 0x000008, "Wrong alignment on UVAIPackageExecutionOverride_324150");
static_assert(sizeof(UVAIPackageExecutionOverride_324150) == 0x000028, "Wrong size on UVAIPackageExecutionOverride_324150");

// Class Altar.VAIPackageExecutionOverride_389582
// 0x0000 (0x0028 - 0x0028)
class UVAIPackageExecutionOverride_389582 final : public UVAIPackageExecutionOverride
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIPackageExecutionOverride_389582">();
	}
	static class UVAIPackageExecutionOverride_389582* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIPackageExecutionOverride_389582>();
	}
};
static_assert(alignof(UVAIPackageExecutionOverride_389582) == 0x000008, "Wrong alignment on UVAIPackageExecutionOverride_389582");
static_assert(sizeof(UVAIPackageExecutionOverride_389582) == 0x000028, "Wrong size on UVAIPackageExecutionOverride_389582");

// Class Altar.VAltarSaveGame
// 0x00D8 (0x0100 - 0x0028)
class UVAltarSaveGame final : public USaveGame
{
public:
	TArray<uint8>                                 OblivionData;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVSaveGameDetails                      SaveGameDetails;                                   // 0x0038(0x00B8)(NativeAccessSpecifierPublic)
	TArray<struct FSerializedAltarSaveData>       SerializedAltarSaveDataArray;                      // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarSaveGame">();
	}
	static class UVAltarSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarSaveGame>();
	}
};
static_assert(alignof(UVAltarSaveGame) == 0x000008, "Wrong alignment on UVAltarSaveGame");
static_assert(sizeof(UVAltarSaveGame) == 0x000100, "Wrong size on UVAltarSaveGame");
static_assert(offsetof(UVAltarSaveGame, OblivionData) == 0x000028, "Member 'UVAltarSaveGame::OblivionData' has a wrong offset!");
static_assert(offsetof(UVAltarSaveGame, SaveGameDetails) == 0x000038, "Member 'UVAltarSaveGame::SaveGameDetails' has a wrong offset!");
static_assert(offsetof(UVAltarSaveGame, SerializedAltarSaveDataArray) == 0x0000F0, "Member 'UVAltarSaveGame::SerializedAltarSaveDataArray' has a wrong offset!");

// Class Altar.VAIProcedureExecution_Acquire
// 0x0008 (0x0048 - 0x0040)
class UVAIProcedureExecution_Acquire final : public UVAIProcedureExecution_Base
{
public:
	class UVAIProcedureExecution_ACTIVATE*        InternalActivateProcedure;                         // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UVAIProcedureExecution_ACTIVATE* GetInternalActivateProcedure() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_Acquire">();
	}
	static class UVAIProcedureExecution_Acquire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_Acquire>();
	}
};
static_assert(alignof(UVAIProcedureExecution_Acquire) == 0x000008, "Wrong alignment on UVAIProcedureExecution_Acquire");
static_assert(sizeof(UVAIProcedureExecution_Acquire) == 0x000048, "Wrong size on UVAIProcedureExecution_Acquire");
static_assert(offsetof(UVAIProcedureExecution_Acquire, InternalActivateProcedure) == 0x000040, "Member 'UVAIProcedureExecution_Acquire::InternalActivateProcedure' has a wrong offset!");

// Class Altar.VAIProcedureExecution_Eat
// 0x0010 (0x0050 - 0x0040)
class UVAIProcedureExecution_Eat final : public UVAIProcedureExecution_Base
{
public:
	class UVAIProcedureExecution_Acquire*         InternalAcquireProcedure;                          // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAIProcedureExecution_ACTIVATE*        InternalActivateProcedure;                         // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_Eat">();
	}
	static class UVAIProcedureExecution_Eat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_Eat>();
	}
};
static_assert(alignof(UVAIProcedureExecution_Eat) == 0x000008, "Wrong alignment on UVAIProcedureExecution_Eat");
static_assert(sizeof(UVAIProcedureExecution_Eat) == 0x000050, "Wrong size on UVAIProcedureExecution_Eat");
static_assert(offsetof(UVAIProcedureExecution_Eat, InternalAcquireProcedure) == 0x000040, "Member 'UVAIProcedureExecution_Eat::InternalAcquireProcedure' has a wrong offset!");
static_assert(offsetof(UVAIProcedureExecution_Eat, InternalActivateProcedure) == 0x000048, "Member 'UVAIProcedureExecution_Eat::InternalActivateProcedure' has a wrong offset!");

// Class Altar.VAltarSpringArmComponent
// 0x0010 (0x03B0 - 0x03A0)
class UVAltarSpringArmComponent final : public USpringArmComponent
{
public:
	float                                         CameraRotationLagSpeedPitch;                       // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRotationLagSpeedYaw;                         // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarSpringArmComponent">();
	}
	static class UVAltarSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarSpringArmComponent>();
	}
};
static_assert(alignof(UVAltarSpringArmComponent) == 0x000010, "Wrong alignment on UVAltarSpringArmComponent");
static_assert(sizeof(UVAltarSpringArmComponent) == 0x0003B0, "Wrong size on UVAltarSpringArmComponent");
static_assert(offsetof(UVAltarSpringArmComponent, CameraRotationLagSpeedPitch) == 0x0003A0, "Member 'UVAltarSpringArmComponent::CameraRotationLagSpeedPitch' has a wrong offset!");
static_assert(offsetof(UVAltarSpringArmComponent, CameraRotationLagSpeedYaw) == 0x0003A4, "Member 'UVAltarSpringArmComponent::CameraRotationLagSpeedYaw' has a wrong offset!");

// Class Altar.VAIProcedureExecution_Flee
// 0x0008 (0x0048 - 0x0040)
class UVAIProcedureExecution_Flee final : public UVAIProcedureExecution_Base
{
public:
	class UVAIProcedureExecution_TRAVEL*          InternalTravelProcedure;                           // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_Flee">();
	}
	static class UVAIProcedureExecution_Flee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_Flee>();
	}
};
static_assert(alignof(UVAIProcedureExecution_Flee) == 0x000008, "Wrong alignment on UVAIProcedureExecution_Flee");
static_assert(sizeof(UVAIProcedureExecution_Flee) == 0x000048, "Wrong size on UVAIProcedureExecution_Flee");
static_assert(offsetof(UVAIProcedureExecution_Flee, InternalTravelProcedure) == 0x000040, "Member 'UVAIProcedureExecution_Flee::InternalTravelProcedure' has a wrong offset!");

// Class Altar.VAIProcedureExecution_ObserveCombat
// 0x0008 (0x0048 - 0x0040)
class UVAIProcedureExecution_ObserveCombat final : public UVAIProcedureExecution_Base
{
public:
	class UVAIProcedureExecution_TRAVEL*          InternalTravelProcedure;                           // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_ObserveCombat">();
	}
	static class UVAIProcedureExecution_ObserveCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_ObserveCombat>();
	}
};
static_assert(alignof(UVAIProcedureExecution_ObserveCombat) == 0x000008, "Wrong alignment on UVAIProcedureExecution_ObserveCombat");
static_assert(sizeof(UVAIProcedureExecution_ObserveCombat) == 0x000048, "Wrong size on UVAIProcedureExecution_ObserveCombat");
static_assert(offsetof(UVAIProcedureExecution_ObserveCombat, InternalTravelProcedure) == 0x000040, "Member 'UVAIProcedureExecution_ObserveCombat::InternalTravelProcedure' has a wrong offset!");

// Class Altar.VAltarTextBlock
// 0x0010 (0x03B0 - 0x03A0)
class UVAltarTextBlock final : public UCommonTextBlock
{
public:
	EVModernTextBlockFontSizeChannel              FontSizeChannel;                                   // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultFontSize;                                   // 0x039C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyFontSizeScaling;                             // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LocalLargeScaleDelta;                              // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LocalSmallScaleDelta;                              // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeinitializeTextBlock();
	void InitializeTextBlock();
	void RefreshFontSizeDelta();
	void SetDefaultFontSize(float NewFontSize);
	void SetFontSize(int32 FontSizeDelta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarTextBlock">();
	}
	static class UVAltarTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarTextBlock>();
	}
};
static_assert(alignof(UVAltarTextBlock) == 0x000010, "Wrong alignment on UVAltarTextBlock");
static_assert(sizeof(UVAltarTextBlock) == 0x0003B0, "Wrong size on UVAltarTextBlock");
static_assert(offsetof(UVAltarTextBlock, FontSizeChannel) == 0x000398, "Member 'UVAltarTextBlock::FontSizeChannel' has a wrong offset!");
static_assert(offsetof(UVAltarTextBlock, DefaultFontSize) == 0x00039C, "Member 'UVAltarTextBlock::DefaultFontSize' has a wrong offset!");
static_assert(offsetof(UVAltarTextBlock, bApplyFontSizeScaling) == 0x0003A0, "Member 'UVAltarTextBlock::bApplyFontSizeScaling' has a wrong offset!");
static_assert(offsetof(UVAltarTextBlock, LocalLargeScaleDelta) == 0x0003A4, "Member 'UVAltarTextBlock::LocalLargeScaleDelta' has a wrong offset!");
static_assert(offsetof(UVAltarTextBlock, LocalSmallScaleDelta) == 0x0003A8, "Member 'UVAltarTextBlock::LocalSmallScaleDelta' has a wrong offset!");

// Class Altar.VAIProcedureExecution_Sleep
// 0x0010 (0x0050 - 0x0040)
class UVAIProcedureExecution_Sleep final : public UVAIProcedureExecution_Base
{
public:
	class UVAIProcedureExecution_TRAVEL*          InternalTravelProcedure;                           // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 TargetBedActor;                                    // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UVAIProcedureExecution_TRAVEL* GetInternalProcedure() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_Sleep">();
	}
	static class UVAIProcedureExecution_Sleep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_Sleep>();
	}
};
static_assert(alignof(UVAIProcedureExecution_Sleep) == 0x000008, "Wrong alignment on UVAIProcedureExecution_Sleep");
static_assert(sizeof(UVAIProcedureExecution_Sleep) == 0x000050, "Wrong size on UVAIProcedureExecution_Sleep");
static_assert(offsetof(UVAIProcedureExecution_Sleep, InternalTravelProcedure) == 0x000040, "Member 'UVAIProcedureExecution_Sleep::InternalTravelProcedure' has a wrong offset!");
static_assert(offsetof(UVAIProcedureExecution_Sleep, TargetBedActor) == 0x000048, "Member 'UVAIProcedureExecution_Sleep::TargetBedActor' has a wrong offset!");

// Class Altar.VAIProcedureExecution_Surface
// 0x0000 (0x0040 - 0x0040)
class UVAIProcedureExecution_Surface final : public UVAIProcedureExecution_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_Surface">();
	}
	static class UVAIProcedureExecution_Surface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_Surface>();
	}
};
static_assert(alignof(UVAIProcedureExecution_Surface) == 0x000008, "Wrong alignment on UVAIProcedureExecution_Surface");
static_assert(sizeof(UVAIProcedureExecution_Surface) == 0x000040, "Wrong size on UVAIProcedureExecution_Surface");

// Class Altar.VAIProcedureExecution_USE_ITEM
// 0x0030 (0x0070 - 0x0040)
class UVAIProcedureExecution_USE_ITEM final : public UVAIProcedureExecution_Base
{
public:
	class UVAIProcedureExecution_ACTIVATE*        InternalActivateProcedure;                         // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0060(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpecialIdleEnded();
	void SetUsedObjectFormId(int32 iUsedObjectFormId);

	class AActor* GetTarget() const;
	int32 GetUsageCount() const;
	float GetUsageRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_USE_ITEM">();
	}
	static class UVAIProcedureExecution_USE_ITEM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_USE_ITEM>();
	}
};
static_assert(alignof(UVAIProcedureExecution_USE_ITEM) == 0x000008, "Wrong alignment on UVAIProcedureExecution_USE_ITEM");
static_assert(sizeof(UVAIProcedureExecution_USE_ITEM) == 0x000070, "Wrong size on UVAIProcedureExecution_USE_ITEM");
static_assert(offsetof(UVAIProcedureExecution_USE_ITEM, InternalActivateProcedure) == 0x000040, "Member 'UVAIProcedureExecution_USE_ITEM::InternalActivateProcedure' has a wrong offset!");
static_assert(offsetof(UVAIProcedureExecution_USE_ITEM, TargetActor) == 0x000060, "Member 'UVAIProcedureExecution_USE_ITEM::TargetActor' has a wrong offset!");

// Class Altar.VModernAlchemyEffect
// 0x0048 (0x0070 - 0x0028)
class UVModernAlchemyEffect final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsSelected(const bool Value);
	void SetProperties(const struct FModernItemEffectProperties& Value);

	const struct FModernItemEffectProperties GetProperties() const;
	const bool IsEffectSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernAlchemyEffect">();
	}
	static class UVModernAlchemyEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernAlchemyEffect>();
	}
};
static_assert(alignof(UVModernAlchemyEffect) == 0x000008, "Wrong alignment on UVModernAlchemyEffect");
static_assert(sizeof(UVModernAlchemyEffect) == 0x000070, "Wrong size on UVModernAlchemyEffect");

// Class Altar.VAlchemyMenuViewModel
// 0x00B8 (0x0188 - 0x00D0)
class UVAlchemyMenuViewModel final : public UVViewModelBase
{
public:
	TArray<struct FModernApparatusProperties>     ApparatusProperties;                               // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FText                                   PotionName;                                        // 0x00E0(0x0018)(NativeAccessSpecifierPrivate)
	class FText                                   PotionDefaultNameKey;                              // 0x00F8(0x0018)(NativeAccessSpecifierPrivate)
	class FText                                   LocalizedDefaultPotion;                            // 0x0110(0x0018)(NativeAccessSpecifierPrivate)
	float                                         PotionWeight;                                      // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PotionPrice;                                       // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLegacyIngredientItemProperties> IngredientItems;                                  // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FLegacyIngredientItemProperties> ItemsList;                                        // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FModernItemEffectProperties>    CurrentItemEffects;                                // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCreateButtonEnable;                             // 0x0170(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_171[0x17];                                     // 0x0171(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClearAllFiltersClicked();
	void OnEffectFilterClicked(const class FString& EffectName);
	void OnMustContainSelectedFiltersClicked();
	void RegisterSendClickedCreate(const class FText& NewPotionName);
	void RegisterSendClickedExit();
	void RegisterSendClickedIngredient(int32 Index_0);
	void RegisterSendClickedItem(int32 ItemIndex);
	void SetApparatusProperties(const TArray<struct FModernApparatusProperties>& NewProperties);
	void SetCreateButtonEnable(bool bNewValue);
	void SetCurrentItemEffects(const TArray<struct FModernItemEffectProperties>& NewEffectsProperties);
	void SetEffectFiltersSelectedNames(const TArray<class FString>& NewEffectFiltersSelected);
	void SetIngredientItems(const TArray<struct FLegacyIngredientItemProperties>& NewItems);
	void SetItemsList(const TArray<struct FLegacyIngredientItemProperties>& NewIngredients);
	void SetPotionDefaultNameAndKey(const class FText& NewLocalizedPotionName, const class FText& AssiosiatedKey);
	void SetPotionName(const class FText& NewPotionName);
	void SetPotionPrice(int32 NewPrice);
	void SetPotionWeight(float NewWeight);
	TArray<struct FModernItemEffectProperties> SortEffectsListByName(const TArray<struct FModernItemEffectProperties>& Effects);
	void UpdateDisplayedItems();

	const TArray<struct FModernApparatusProperties> GetApparatusProperties() const;
	bool GetCreateButtonEnable() const;
	const TArray<struct FModernItemEffectProperties> GetCurrentItemEffects() const;
	const TArray<class FString> GetEffectFiltersSelectedNames() const;
	const TArray<struct FLegacyIngredientItemProperties> GetIngredientItems() const;
	const TArray<struct FLegacyIngredientItemProperties> GetItemsList() const;
	const class FText GetLocalizedPotionDefaultName() const;
	const class FText GetPotionDefaultNameKey() const;
	const class FText GetPotionName() const;
	const int32 GetPotionPrice() const;
	const float GetPotionWeight() const;
	bool HasEffectOnFilter(const struct FLegacyIngredientItemProperties& Item) const;
	bool MustContainAllSelectedFilters() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAlchemyMenuViewModel">();
	}
	static class UVAlchemyMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAlchemyMenuViewModel>();
	}
};
static_assert(alignof(UVAlchemyMenuViewModel) == 0x000008, "Wrong alignment on UVAlchemyMenuViewModel");
static_assert(sizeof(UVAlchemyMenuViewModel) == 0x000188, "Wrong size on UVAlchemyMenuViewModel");
static_assert(offsetof(UVAlchemyMenuViewModel, ApparatusProperties) == 0x0000D0, "Member 'UVAlchemyMenuViewModel::ApparatusProperties' has a wrong offset!");
static_assert(offsetof(UVAlchemyMenuViewModel, PotionName) == 0x0000E0, "Member 'UVAlchemyMenuViewModel::PotionName' has a wrong offset!");
static_assert(offsetof(UVAlchemyMenuViewModel, PotionDefaultNameKey) == 0x0000F8, "Member 'UVAlchemyMenuViewModel::PotionDefaultNameKey' has a wrong offset!");
static_assert(offsetof(UVAlchemyMenuViewModel, LocalizedDefaultPotion) == 0x000110, "Member 'UVAlchemyMenuViewModel::LocalizedDefaultPotion' has a wrong offset!");
static_assert(offsetof(UVAlchemyMenuViewModel, PotionWeight) == 0x000128, "Member 'UVAlchemyMenuViewModel::PotionWeight' has a wrong offset!");
static_assert(offsetof(UVAlchemyMenuViewModel, PotionPrice) == 0x00012C, "Member 'UVAlchemyMenuViewModel::PotionPrice' has a wrong offset!");
static_assert(offsetof(UVAlchemyMenuViewModel, IngredientItems) == 0x000130, "Member 'UVAlchemyMenuViewModel::IngredientItems' has a wrong offset!");
static_assert(offsetof(UVAlchemyMenuViewModel, ItemsList) == 0x000140, "Member 'UVAlchemyMenuViewModel::ItemsList' has a wrong offset!");
static_assert(offsetof(UVAlchemyMenuViewModel, CurrentItemEffects) == 0x000150, "Member 'UVAlchemyMenuViewModel::CurrentItemEffects' has a wrong offset!");
static_assert(offsetof(UVAlchemyMenuViewModel, bIsCreateButtonEnable) == 0x000170, "Member 'UVAlchemyMenuViewModel::bIsCreateButtonEnable' has a wrong offset!");

// Class Altar.VAltarActionState
// 0x0020 (0x00A8 - 0x0088)
class UVAltarActionState : public UVState
{
public:
	TWeakObjectPtr<class AVPairedPawn>            PairedPawn;                                        // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActionStateFinished;                            // 0x0090(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UVActorBehaviorBase*>            ActiveBehaviors;                                   // 0x0098(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	class UVActorBehaviorBase* CreateBehaviorFromTag(const struct FGameplayTag& BehaviorTag);
	class UVActorBehaviorBase* CreateBehaviorFromTemplate(class UVActorBehaviorBase* BehaviorTemplate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarActionState">();
	}
	static class UVAltarActionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarActionState>();
	}
};
static_assert(alignof(UVAltarActionState) == 0x000008, "Wrong alignment on UVAltarActionState");
static_assert(sizeof(UVAltarActionState) == 0x0000A8, "Wrong size on UVAltarActionState");
static_assert(offsetof(UVAltarActionState, PairedPawn) == 0x000088, "Member 'UVAltarActionState::PairedPawn' has a wrong offset!");
static_assert(offsetof(UVAltarActionState, bIsActionStateFinished) == 0x000090, "Member 'UVAltarActionState::bIsActionStateFinished' has a wrong offset!");
static_assert(offsetof(UVAltarActionState, ActiveBehaviors) == 0x000098, "Member 'UVAltarActionState::ActiveBehaviors' has a wrong offset!");

// Class Altar.VAltarActionWidget
// 0x0000 (0x0490 - 0x0490)
class UVAltarActionWidget : public UCommonActionWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarActionWidget">();
	}
	static class UVAltarActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarActionWidget>();
	}
};
static_assert(alignof(UVAltarActionWidget) == 0x000010, "Wrong alignment on UVAltarActionWidget");
static_assert(sizeof(UVAltarActionWidget) == 0x000490, "Wrong size on UVAltarActionWidget");

// Class Altar.VAltarAkPortalComponent
// 0x0010 (0x04A0 - 0x0490)
class UVAltarAkPortalComponent final : public UAkPortalComponent
{
public:
	float                                         MaxOcclusion;                                      // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_494[0xC];                                      // 0x0494(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarAkPortalComponent">();
	}
	static class UVAltarAkPortalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarAkPortalComponent>();
	}
};
static_assert(alignof(UVAltarAkPortalComponent) == 0x000010, "Wrong alignment on UVAltarAkPortalComponent");
static_assert(sizeof(UVAltarAkPortalComponent) == 0x0004A0, "Wrong size on UVAltarAkPortalComponent");
static_assert(offsetof(UVAltarAkPortalComponent, MaxOcclusion) == 0x000490, "Member 'UVAltarAkPortalComponent::MaxOcclusion' has a wrong offset!");

// Class Altar.VAltarBinkVideoTimestampTable
// 0x0010 (0x00C0 - 0x00B0)
class UVAltarBinkVideoTimestampTable final : public UDataTable
{
public:
	TArray<struct FVideoTimestampTableRow>        TimeStamps;                                        // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarBinkVideoTimestampTable">();
	}
	static class UVAltarBinkVideoTimestampTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarBinkVideoTimestampTable>();
	}
};
static_assert(alignof(UVAltarBinkVideoTimestampTable) == 0x000008, "Wrong alignment on UVAltarBinkVideoTimestampTable");
static_assert(sizeof(UVAltarBinkVideoTimestampTable) == 0x0000C0, "Wrong size on UVAltarBinkVideoTimestampTable");
static_assert(offsetof(UVAltarBinkVideoTimestampTable, TimeStamps) == 0x0000B0, "Member 'UVAltarBinkVideoTimestampTable::TimeStamps' has a wrong offset!");

// Class Altar.VAltarBlueprintTable
// 0x0058 (0x0108 - 0x00B0)
class UVAltarBlueprintTable final : public UDataTable
{
public:
	TMap<uint32, TSoftObjectPtr<class UVModdableBlueprint>> BlueprintsMap;                           // 0x00B0(0x0050)(Edit, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarBlueprintTable">();
	}
	static class UVAltarBlueprintTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarBlueprintTable>();
	}
};
static_assert(alignof(UVAltarBlueprintTable) == 0x000008, "Wrong alignment on UVAltarBlueprintTable");
static_assert(sizeof(UVAltarBlueprintTable) == 0x000108, "Wrong size on UVAltarBlueprintTable");
static_assert(offsetof(UVAltarBlueprintTable, BlueprintsMap) == 0x0000B0, "Member 'UVAltarBlueprintTable::BlueprintsMap' has a wrong offset!");

// Class Altar.VAltarBoundActionButton
// 0x0090 (0x1630 - 0x15A0)
class UVAltarBoundActionButton : public UCommonBoundActionButton
{
public:
	class UMaterialInterface*                     KeyboardMat;                                       // 0x1598(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FKey, class FText>                LocalizedKeys;                                     // 0x15A0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         HoldTreshold;                                      // 0x15F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15F4[0x4];                                     // 0x15F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           BoundInputAction;                                  // 0x15F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputMappingContext*                   MappingContext;                                    // 0x1600(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   CachedInputActionDescription;                      // 0x1608(0x0018)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1620[0x10];                                    // 0x1620(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetHintKeyText(const struct FKey& InKey);
	class FText GetInputActionKeyText(class UInputAction* InInputAction, class UInputMappingContext* InInputMappingContext);
	void HoldTriggerCancel();
	void HoldTriggerStart();
	void SetDescriptionText(const class FText& NewText);
	void SetInputAction(class UInputAction* NewBinding, const class FText& OverrideActionText, class UInputMappingContext* NewMappingContext);

	const class UInputAction* GetBoundInputAction() const;
	float GetHoldTreshold() const;
	class UCommonTextBlock* GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarBoundActionButton">();
	}
	static class UVAltarBoundActionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarBoundActionButton>();
	}
};
static_assert(alignof(UVAltarBoundActionButton) == 0x000010, "Wrong alignment on UVAltarBoundActionButton");
static_assert(sizeof(UVAltarBoundActionButton) == 0x001630, "Wrong size on UVAltarBoundActionButton");
static_assert(offsetof(UVAltarBoundActionButton, KeyboardMat) == 0x001598, "Member 'UVAltarBoundActionButton::KeyboardMat' has a wrong offset!");
static_assert(offsetof(UVAltarBoundActionButton, LocalizedKeys) == 0x0015A0, "Member 'UVAltarBoundActionButton::LocalizedKeys' has a wrong offset!");
static_assert(offsetof(UVAltarBoundActionButton, HoldTreshold) == 0x0015F0, "Member 'UVAltarBoundActionButton::HoldTreshold' has a wrong offset!");
static_assert(offsetof(UVAltarBoundActionButton, BoundInputAction) == 0x0015F8, "Member 'UVAltarBoundActionButton::BoundInputAction' has a wrong offset!");
static_assert(offsetof(UVAltarBoundActionButton, MappingContext) == 0x001600, "Member 'UVAltarBoundActionButton::MappingContext' has a wrong offset!");
static_assert(offsetof(UVAltarBoundActionButton, CachedInputActionDescription) == 0x001608, "Member 'UVAltarBoundActionButton::CachedInputActionDescription' has a wrong offset!");

// Class Altar.VAltarCameraActor
// 0x0060 (0x0A10 - 0x09B0)
class AVAltarCameraActor final : public ACameraActor
{
public:
	class UMaterial*                              ImageCalibrationMat;                               // 0x09B0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ImageCalibrationMID;                               // 0x09B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              SepiaToneMenuBackgroundMat;                        // 0x09C0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SepiaToneMenuBackgroundMID;                        // 0x09C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVCharacterFadeInOutComponent*          CharacterFadeInOutComponent;                       // 0x09D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D8[0x38];                                     // 0x09D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarCameraActor">();
	}
	static class AVAltarCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAltarCameraActor>();
	}
};
static_assert(alignof(AVAltarCameraActor) == 0x000010, "Wrong alignment on AVAltarCameraActor");
static_assert(sizeof(AVAltarCameraActor) == 0x000A10, "Wrong size on AVAltarCameraActor");
static_assert(offsetof(AVAltarCameraActor, ImageCalibrationMat) == 0x0009B0, "Member 'AVAltarCameraActor::ImageCalibrationMat' has a wrong offset!");
static_assert(offsetof(AVAltarCameraActor, ImageCalibrationMID) == 0x0009B8, "Member 'AVAltarCameraActor::ImageCalibrationMID' has a wrong offset!");
static_assert(offsetof(AVAltarCameraActor, SepiaToneMenuBackgroundMat) == 0x0009C0, "Member 'AVAltarCameraActor::SepiaToneMenuBackgroundMat' has a wrong offset!");
static_assert(offsetof(AVAltarCameraActor, SepiaToneMenuBackgroundMID) == 0x0009C8, "Member 'AVAltarCameraActor::SepiaToneMenuBackgroundMID' has a wrong offset!");
static_assert(offsetof(AVAltarCameraActor, CharacterFadeInOutComponent) == 0x0009D0, "Member 'AVAltarCameraActor::CharacterFadeInOutComponent' has a wrong offset!");

// Class Altar.VAltarCommonVideoPlayer
// 0x0030 (0x0310 - 0x02E0)
class UVAltarCommonVideoPlayer final : public UCommonVideoPlayer
{
public:
	TMulticastInlineDelegate<void()>              AltarOnMediaOpened;                                // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              AltarOnPlaybackComplete;                           // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_Close();
	void BP_Open();
	void BP_Pause();
	void BP_Play();
	void BP_PlayFromStart();
	void BP_Seek(float Timestamp);
	void BP_SetLooping(bool bShouldLoopPlayback);

	bool BP_IsPlaying() const;
	bool IsMediaOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarCommonVideoPlayer">();
	}
	static class UVAltarCommonVideoPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarCommonVideoPlayer>();
	}
};
static_assert(alignof(UVAltarCommonVideoPlayer) == 0x000010, "Wrong alignment on UVAltarCommonVideoPlayer");
static_assert(sizeof(UVAltarCommonVideoPlayer) == 0x000310, "Wrong size on UVAltarCommonVideoPlayer");
static_assert(offsetof(UVAltarCommonVideoPlayer, AltarOnMediaOpened) == 0x0002E0, "Member 'UVAltarCommonVideoPlayer::AltarOnMediaOpened' has a wrong offset!");
static_assert(offsetof(UVAltarCommonVideoPlayer, AltarOnPlaybackComplete) == 0x0002F0, "Member 'UVAltarCommonVideoPlayer::AltarOnPlaybackComplete' has a wrong offset!");

// Class Altar.VAltarCreditsTable
// 0x0000 (0x00B0 - 0x00B0)
class UVAltarCreditsTable final : public UDataTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarCreditsTable">();
	}
	static class UVAltarCreditsTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarCreditsTable>();
	}
};
static_assert(alignof(UVAltarCreditsTable) == 0x000008, "Wrong alignment on UVAltarCreditsTable");
static_assert(sizeof(UVAltarCreditsTable) == 0x0000B0, "Wrong size on UVAltarCreditsTable");

// Class Altar.VAltarEditableTextViewModel
// 0x0098 (0x0100 - 0x0068)
class UVAltarEditableTextViewModel final : public UMVVMViewModelBase
{
public:
	struct FUserInputTextPair                     UserInputTextPair;                                 // 0x0068(0x0028)(NativeAccessSpecifierPrivate)
	EUserInputTextValidityCode                    UserInputTextValidityCode;                         // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldCheckIfTextIsEmpty;                         // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldCheckForInvalidCharacter;                   // 0x0092(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldCheckForWhiteSpaceOnly;                     // 0x0093(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldCheckIfTextIsTooLong;                       // 0x0094(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTextSize;                                       // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ValidCharactersStrings;                            // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x50];                                      // 0x00B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearData();
	void SetMaxTextSize(int32 NewValue);
	void SetShouldCheckForInvalidCharacter(bool NewValue);
	void SetShouldCheckForWhiteSpaceOnly(bool NewValue);
	void SetShouldCheckIfTextIsEmpty(bool NewValue);
	void SetShouldCheckIfTextIsTooLong(bool NewValue);
	void SetUserInputText(const class FText& NewUserInputText);
	void SetUserInputTextPair(const struct FUserInputTextPair& NewUserInputTextPair);
	void SetUserInputTextValidityCode(EUserInputTextValidityCode NewValidityCode);
	void SetValidCharacters(const TArray<class FString>& NewValidCharacters);

	int32 GetMaxTextSize() const;
	const class FText GetUserInputText() const;
	const struct FUserInputTextPair GetUserInputTextPair() const;
	EUserInputTextValidityCode GetUserInputTextValidityCode() const;
	const TArray<class FString> GetValidCharacters() const;
	bool ShouldCheckForInvalidCharacter() const;
	bool ShouldCheckForWhiteSpaceOnly() const;
	bool ShouldCheckIfTextIsEmpty() const;
	bool ShouldCheckIfTextIsTooLong() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarEditableTextViewModel">();
	}
	static class UVAltarEditableTextViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarEditableTextViewModel>();
	}
};
static_assert(alignof(UVAltarEditableTextViewModel) == 0x000008, "Wrong alignment on UVAltarEditableTextViewModel");
static_assert(sizeof(UVAltarEditableTextViewModel) == 0x000100, "Wrong size on UVAltarEditableTextViewModel");
static_assert(offsetof(UVAltarEditableTextViewModel, UserInputTextPair) == 0x000068, "Member 'UVAltarEditableTextViewModel::UserInputTextPair' has a wrong offset!");
static_assert(offsetof(UVAltarEditableTextViewModel, UserInputTextValidityCode) == 0x000090, "Member 'UVAltarEditableTextViewModel::UserInputTextValidityCode' has a wrong offset!");
static_assert(offsetof(UVAltarEditableTextViewModel, bShouldCheckIfTextIsEmpty) == 0x000091, "Member 'UVAltarEditableTextViewModel::bShouldCheckIfTextIsEmpty' has a wrong offset!");
static_assert(offsetof(UVAltarEditableTextViewModel, bShouldCheckForInvalidCharacter) == 0x000092, "Member 'UVAltarEditableTextViewModel::bShouldCheckForInvalidCharacter' has a wrong offset!");
static_assert(offsetof(UVAltarEditableTextViewModel, bShouldCheckForWhiteSpaceOnly) == 0x000093, "Member 'UVAltarEditableTextViewModel::bShouldCheckForWhiteSpaceOnly' has a wrong offset!");
static_assert(offsetof(UVAltarEditableTextViewModel, bShouldCheckIfTextIsTooLong) == 0x000094, "Member 'UVAltarEditableTextViewModel::bShouldCheckIfTextIsTooLong' has a wrong offset!");
static_assert(offsetof(UVAltarEditableTextViewModel, MaxTextSize) == 0x000098, "Member 'UVAltarEditableTextViewModel::MaxTextSize' has a wrong offset!");
static_assert(offsetof(UVAltarEditableTextViewModel, ValidCharactersStrings) == 0x0000A0, "Member 'UVAltarEditableTextViewModel::ValidCharactersStrings' has a wrong offset!");

// Class Altar.VAltarGameDateTimeSystem
// 0x0010 (0x0040 - 0x0030)
class UVAltarGameDateTimeSystem final : public UGameInstanceSubsystem
{
public:
	struct FOblivionDateTimeInfo                  Dateinfo;                                          // 0x0030(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UVAltarGameDateTimeSystem* Get(class UWorld* World);

	struct FOblivionDateTimeInfo GetOblivionDateInfo() const;
	int32 GetOblivionDay() const;
	int32 GetOblivionGameDayPassed() const;
	int32 GetOblivionMonth() const;
	int32 GetOblivionYear() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarGameDateTimeSystem">();
	}
	static class UVAltarGameDateTimeSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarGameDateTimeSystem>();
	}
};
static_assert(alignof(UVAltarGameDateTimeSystem) == 0x000008, "Wrong alignment on UVAltarGameDateTimeSystem");
static_assert(sizeof(UVAltarGameDateTimeSystem) == 0x000040, "Wrong size on UVAltarGameDateTimeSystem");
static_assert(offsetof(UVAltarGameDateTimeSystem, Dateinfo) == 0x000030, "Member 'UVAltarGameDateTimeSystem::Dateinfo' has a wrong offset!");

// Class Altar.VAltarHud
// 0x0038 (0x03C0 - 0x0388)
class AVAltarHud final : public AHUD
{
public:
	bool                                          bOblivionDebugTextIsVisible;                       // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVDebugTextContent>             OblivionDebugTextContent;                          // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x20];                                     // 0x03A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UVPrimaryGameLayout* GetPrimaryGameLayout() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarHud">();
	}
	static class AVAltarHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAltarHud>();
	}
};
static_assert(alignof(AVAltarHud) == 0x000008, "Wrong alignment on AVAltarHud");
static_assert(sizeof(AVAltarHud) == 0x0003C0, "Wrong size on AVAltarHud");
static_assert(offsetof(AVAltarHud, bOblivionDebugTextIsVisible) == 0x000388, "Member 'AVAltarHud::bOblivionDebugTextIsVisible' has a wrong offset!");
static_assert(offsetof(AVAltarHud, OblivionDebugTextContent) == 0x000390, "Member 'AVAltarHud::OblivionDebugTextContent' has a wrong offset!");

// Class Altar.VAltarMoonActor
// 0x0000 (0x0298 - 0x0298)
class AVAltarMoonActor final : public AActor
{
public:
	void SetMoonState(float RotateRevolution, float RotateAxisAltitude, EMoonPhase InPhase, float PhaseProgress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarMoonActor">();
	}
	static class AVAltarMoonActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAltarMoonActor>();
	}
};
static_assert(alignof(AVAltarMoonActor) == 0x000008, "Wrong alignment on AVAltarMoonActor");
static_assert(sizeof(AVAltarMoonActor) == 0x000298, "Wrong size on AVAltarMoonActor");

// Class Altar.VAltarNavigableCommonUserWidget
// 0x0008 (0x0390 - 0x0388)
class UVAltarNavigableCommonUserWidget : public UVNavigableCommonUserWidgetBase
{
public:
	struct FGameplayTag                           LayerTag;                                          // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableCommonUserWidget">();
	}
	static class UVAltarNavigableCommonUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableCommonUserWidget>();
	}
};
static_assert(alignof(UVAltarNavigableCommonUserWidget) == 0x000008, "Wrong alignment on UVAltarNavigableCommonUserWidget");
static_assert(sizeof(UVAltarNavigableCommonUserWidget) == 0x000390, "Wrong size on UVAltarNavigableCommonUserWidget");
static_assert(offsetof(UVAltarNavigableCommonUserWidget, LayerTag) == 0x000388, "Member 'UVAltarNavigableCommonUserWidget::LayerTag' has a wrong offset!");

// Class Altar.VAltarNavigableHorizontalBox
// 0x0008 (0x04E0 - 0x04D8)
class UVAltarNavigableHorizontalBox : public UVNavigableHorizontalBox
{
public:
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableHorizontalBox">();
	}
	static class UVAltarNavigableHorizontalBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableHorizontalBox>();
	}
};
static_assert(alignof(UVAltarNavigableHorizontalBox) == 0x000008, "Wrong alignment on UVAltarNavigableHorizontalBox");
static_assert(sizeof(UVAltarNavigableHorizontalBox) == 0x0004E0, "Wrong size on UVAltarNavigableHorizontalBox");

// Class Altar.VAltarNavigableListView
// 0x0010 (0x0550 - 0x0540)
class UVAltarNavigableListView : public UVNavigableListView
{
public:
	uint8                                         Pad_540[0x8];                                      // 0x0540(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVModernScrollbar*                      AssociatedScrollbar;                               // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnListViewScrolled(float ItemOffset, float DistanceRemaining);
	void OnListViewValuesChanged(float MinScrollbarValue, float MaxScrollbarValue, float CurrentScrollbarValue, float ThumbFractionSize);
	void OnScrollbarValueChanged(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableListView">();
	}
	static class UVAltarNavigableListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableListView>();
	}
};
static_assert(alignof(UVAltarNavigableListView) == 0x000008, "Wrong alignment on UVAltarNavigableListView");
static_assert(sizeof(UVAltarNavigableListView) == 0x000550, "Wrong size on UVAltarNavigableListView");
static_assert(offsetof(UVAltarNavigableListView, AssociatedScrollbar) == 0x000548, "Member 'UVAltarNavigableListView::AssociatedScrollbar' has a wrong offset!");

// Class Altar.VAltarNavigableVerticalBox
// 0x0008 (0x04E0 - 0x04D8)
class UVAltarNavigableVerticalBox final : public UVNavigableVerticalBox
{
public:
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigableVerticalBox">();
	}
	static class UVAltarNavigableVerticalBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigableVerticalBox>();
	}
};
static_assert(alignof(UVAltarNavigableVerticalBox) == 0x000008, "Wrong alignment on UVAltarNavigableVerticalBox");
static_assert(sizeof(UVAltarNavigableVerticalBox) == 0x0004E0, "Wrong size on UVAltarNavigableVerticalBox");

// Class Altar.VAltarNavigationSystem
// 0x00D0 (0x1670 - 0x15A0)
class UVAltarNavigationSystem final : public UNavigationSystemV1
{
public:
	uint8                                         Pad_15A0[0x68];                                    // 0x15A0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideRuntimeWorldPartitionDataGatheringMode;   // 0x1608(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ENavDataGatheringModeConfig                   RuntimeWorldPartitionDataGatheringMode;            // 0x1609(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFilterImplicitGeometryDirtyAreas;                 // 0x160A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowExplicitDoubleDressingDirtyAreas;            // 0x160B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOnlyUnlockNavGenerationForDoubleDressing;         // 0x160C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160D[0x3];                                     // 0x160D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ANavigationDataChunkActor*>        LoadedNavigationDataChunkActors;                   // 0x1610(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	class UNavMeshLandmarkMetaClustersSubsystem*  NavMeshLandmarkClustersSubsystem;                  // 0x1660(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1668[0x8];                                     // 0x1668(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNavigationDataEndPlay(const class AActor* Actor, const EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNavigationSystem">();
	}
	static class UVAltarNavigationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNavigationSystem>();
	}
};
static_assert(alignof(UVAltarNavigationSystem) == 0x000008, "Wrong alignment on UVAltarNavigationSystem");
static_assert(sizeof(UVAltarNavigationSystem) == 0x001670, "Wrong size on UVAltarNavigationSystem");
static_assert(offsetof(UVAltarNavigationSystem, bOverrideRuntimeWorldPartitionDataGatheringMode) == 0x001608, "Member 'UVAltarNavigationSystem::bOverrideRuntimeWorldPartitionDataGatheringMode' has a wrong offset!");
static_assert(offsetof(UVAltarNavigationSystem, RuntimeWorldPartitionDataGatheringMode) == 0x001609, "Member 'UVAltarNavigationSystem::RuntimeWorldPartitionDataGatheringMode' has a wrong offset!");
static_assert(offsetof(UVAltarNavigationSystem, bFilterImplicitGeometryDirtyAreas) == 0x00160A, "Member 'UVAltarNavigationSystem::bFilterImplicitGeometryDirtyAreas' has a wrong offset!");
static_assert(offsetof(UVAltarNavigationSystem, bAllowExplicitDoubleDressingDirtyAreas) == 0x00160B, "Member 'UVAltarNavigationSystem::bAllowExplicitDoubleDressingDirtyAreas' has a wrong offset!");
static_assert(offsetof(UVAltarNavigationSystem, bOnlyUnlockNavGenerationForDoubleDressing) == 0x00160C, "Member 'UVAltarNavigationSystem::bOnlyUnlockNavGenerationForDoubleDressing' has a wrong offset!");
static_assert(offsetof(UVAltarNavigationSystem, LoadedNavigationDataChunkActors) == 0x001610, "Member 'UVAltarNavigationSystem::LoadedNavigationDataChunkActors' has a wrong offset!");
static_assert(offsetof(UVAltarNavigationSystem, NavMeshLandmarkClustersSubsystem) == 0x001660, "Member 'UVAltarNavigationSystem::NavMeshLandmarkClustersSubsystem' has a wrong offset!");

// Class Altar.VAltarNotificationBaseWidget
// 0x0000 (0x02E8 - 0x02E8)
class UVAltarNotificationBaseWidget : public UCommonUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarNotificationBaseWidget">();
	}
	static class UVAltarNotificationBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarNotificationBaseWidget>();
	}
};
static_assert(alignof(UVAltarNotificationBaseWidget) == 0x000008, "Wrong alignment on UVAltarNotificationBaseWidget");
static_assert(sizeof(UVAltarNotificationBaseWidget) == 0x0002E8, "Wrong size on UVAltarNotificationBaseWidget");

// Class Altar.VAltarPathFollowingComponent
// 0x0008 (0x02E8 - 0x02E0)
class UVAltarPathFollowingComponent final : public USteeringBehaviorsPathFollowingComponent
{
public:
	bool                                          bStrafingAllowed;                                  // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDirectPawnTrackingAllowed;                        // 0x02E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInDebugMode;                                      // 0x02E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E3[0x5];                                      // 0x02E3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarPathFollowingComponent">();
	}
	static class UVAltarPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarPathFollowingComponent>();
	}
};
static_assert(alignof(UVAltarPathFollowingComponent) == 0x000008, "Wrong alignment on UVAltarPathFollowingComponent");
static_assert(sizeof(UVAltarPathFollowingComponent) == 0x0002E8, "Wrong size on UVAltarPathFollowingComponent");
static_assert(offsetof(UVAltarPathFollowingComponent, bStrafingAllowed) == 0x0002E0, "Member 'UVAltarPathFollowingComponent::bStrafingAllowed' has a wrong offset!");
static_assert(offsetof(UVAltarPathFollowingComponent, bDirectPawnTrackingAllowed) == 0x0002E1, "Member 'UVAltarPathFollowingComponent::bDirectPawnTrackingAllowed' has a wrong offset!");
static_assert(offsetof(UVAltarPathFollowingComponent, bInDebugMode) == 0x0002E2, "Member 'UVAltarPathFollowingComponent::bInDebugMode' has a wrong offset!");

// Class Altar.VAltarPersuasionMenuSaveData
// 0x0010 (0x0048 - 0x0038)
class UVAltarPersuasionMenuSaveData final : public UVBaseUIGameSaveData
{
public:
	TArray<uint32>                                PersuadedCharacters;                               // 0x0038(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarPersuasionMenuSaveData">();
	}
	static class UVAltarPersuasionMenuSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarPersuasionMenuSaveData>();
	}
};
static_assert(alignof(UVAltarPersuasionMenuSaveData) == 0x000008, "Wrong alignment on UVAltarPersuasionMenuSaveData");
static_assert(sizeof(UVAltarPersuasionMenuSaveData) == 0x000048, "Wrong size on UVAltarPersuasionMenuSaveData");
static_assert(offsetof(UVAltarPersuasionMenuSaveData, PersuadedCharacters) == 0x000038, "Member 'UVAltarPersuasionMenuSaveData::PersuadedCharacters' has a wrong offset!");

// Class Altar.VAltarRenderingToolsSubsystem
// 0x0010 (0x0040 - 0x0030)
class UVAltarRenderingToolsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SSScateringSetForegroundWorldUnitGlobalScale(float Scale);
	void SSScateringSetWorldUnitGlobalScale(float Scale);

	double FirstPersonClippingFixApplyOnActorComponent(const class UObject* WorldContextObject, class USceneComponent* TargetComponent, const struct FVector& RelativeLocation, bool bAutoEstimatePlayerOwnership, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult) const;
	struct FVector FirstPersonClippingFixGetOffset(const class UObject* WorldContextObject, const struct FVector& WorldPosition, bool bAutoEstimatePlayerOwnership, double* Weight, struct FVector* NewWorldPosition) const;
	struct FVector FirstPersonClippingFixGetOffsetFromCamera(const class UObject* WorldContextObject, const struct FVector& WorldPosition, bool bAutoEstimatePlayerOwnership, const struct FMinimalViewInfo& InViewInfo, double* Weight, struct FVector* NewWorldPosition) const;
	double FirstPersonClippingFixGetWeight(const class UObject* WorldContextObject, const struct FVector& WorldPosition, bool bAutoEstimatePlayerOwnership) const;
	double FirstPersonClippingFixGetWeightFromCamera(const class UObject* WorldContextObject, const struct FVector& WorldPosition, bool bAutoEstimatePlayerOwnership, const struct FMinimalViewInfo& InViewInfo) const;
	struct FVector HomogeneousToCartesianCoordinates(const struct FVector4& HomogeneousCoordinates) const;
	struct FVector ScaleInDepth(const struct FVector& WorldPosition, double Scale, const struct FMatrix& CameraViewProjection, const struct FMatrix& CameraInverseViewProjection) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarRenderingToolsSubsystem">();
	}
	static class UVAltarRenderingToolsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarRenderingToolsSubsystem>();
	}
};
static_assert(alignof(UVAltarRenderingToolsSubsystem) == 0x000008, "Wrong alignment on UVAltarRenderingToolsSubsystem");
static_assert(sizeof(UVAltarRenderingToolsSubsystem) == 0x000040, "Wrong size on UVAltarRenderingToolsSubsystem");

// Class Altar.VAltarRichPresenceBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAltarRichPresenceBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void UpdateRichPresence(const class FString& PresenceData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarRichPresenceBlueprintLibrary">();
	}
	static class UVAltarRichPresenceBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarRichPresenceBlueprintLibrary>();
	}
};
static_assert(alignof(UVAltarRichPresenceBlueprintLibrary) == 0x000008, "Wrong alignment on UVAltarRichPresenceBlueprintLibrary");
static_assert(sizeof(UVAltarRichPresenceBlueprintLibrary) == 0x000028, "Wrong size on UVAltarRichPresenceBlueprintLibrary");

// Class Altar.VAltarRichTextBlock
// 0x0010 (0x08F0 - 0x08E0)
class UVAltarRichTextBlock final : public UCommonRichTextBlock
{
public:
	EVModernRichTextBlockFontSizeChannel          FontSizeChannel;                                   // 0x08D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D9[0x3];                                      // 0x08D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultFontSize;                                   // 0x08DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyFontSizeScaling;                             // 0x08E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E1[0x3];                                      // 0x08E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LocalLargeScaleDelta;                              // 0x08E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LocalSmallScaleDelta;                              // 0x08E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8EC[0x4];                                      // 0x08EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeinitializeRichTextBlock();
	void InitializeRichTextBlock();
	void SetDefaultFontSize(int32 NewFontSize);
	void SetFontSize(int32 FontSizeDelta);
	void SetLineHeightPercentage(float NewLineHeightPercentage);
	void SetWrappedAt(float NewWrappedAt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarRichTextBlock">();
	}
	static class UVAltarRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarRichTextBlock>();
	}
};
static_assert(alignof(UVAltarRichTextBlock) == 0x000010, "Wrong alignment on UVAltarRichTextBlock");
static_assert(sizeof(UVAltarRichTextBlock) == 0x0008F0, "Wrong size on UVAltarRichTextBlock");
static_assert(offsetof(UVAltarRichTextBlock, FontSizeChannel) == 0x0008D8, "Member 'UVAltarRichTextBlock::FontSizeChannel' has a wrong offset!");
static_assert(offsetof(UVAltarRichTextBlock, DefaultFontSize) == 0x0008DC, "Member 'UVAltarRichTextBlock::DefaultFontSize' has a wrong offset!");
static_assert(offsetof(UVAltarRichTextBlock, bApplyFontSizeScaling) == 0x0008E0, "Member 'UVAltarRichTextBlock::bApplyFontSizeScaling' has a wrong offset!");
static_assert(offsetof(UVAltarRichTextBlock, LocalLargeScaleDelta) == 0x0008E4, "Member 'UVAltarRichTextBlock::LocalLargeScaleDelta' has a wrong offset!");
static_assert(offsetof(UVAltarRichTextBlock, LocalSmallScaleDelta) == 0x0008E8, "Member 'UVAltarRichTextBlock::LocalSmallScaleDelta' has a wrong offset!");

// Class Altar.VAltarSaveContainer
// 0x0018 (0x0040 - 0x0028)
class UVAltarSaveContainer final : public USaveGame
{
public:
	uint16                                        SaveVersion;                                       // 0x0028(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EVAltarCompressionMethod                      CompressionMethod;                                 // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 AltarSaveData;                                     // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarSaveContainer">();
	}
	static class UVAltarSaveContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarSaveContainer>();
	}
};
static_assert(alignof(UVAltarSaveContainer) == 0x000008, "Wrong alignment on UVAltarSaveContainer");
static_assert(sizeof(UVAltarSaveContainer) == 0x000040, "Wrong size on UVAltarSaveContainer");
static_assert(offsetof(UVAltarSaveContainer, SaveVersion) == 0x000028, "Member 'UVAltarSaveContainer::SaveVersion' has a wrong offset!");
static_assert(offsetof(UVAltarSaveContainer, CompressionMethod) == 0x00002C, "Member 'UVAltarSaveContainer::CompressionMethod' has a wrong offset!");
static_assert(offsetof(UVAltarSaveContainer, AltarSaveData) == 0x000030, "Member 'UVAltarSaveContainer::AltarSaveData' has a wrong offset!");

// Class Altar.VAltarSaveMetaData
// 0x00C8 (0x00F0 - 0x0028)
class UVAltarSaveMetaData final : public USaveGame
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FVSaveGameDetails> AllSavesDetails;                                   // 0x0050(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FVSaveNumbers>      SaveCounter;                                       // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarSaveMetaData">();
	}
	static class UVAltarSaveMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarSaveMetaData>();
	}
};
static_assert(alignof(UVAltarSaveMetaData) == 0x000008, "Wrong alignment on UVAltarSaveMetaData");
static_assert(sizeof(UVAltarSaveMetaData) == 0x0000F0, "Wrong size on UVAltarSaveMetaData");
static_assert(offsetof(UVAltarSaveMetaData, AllSavesDetails) == 0x000050, "Member 'UVAltarSaveMetaData::AllSavesDetails' has a wrong offset!");
static_assert(offsetof(UVAltarSaveMetaData, SaveCounter) == 0x0000A0, "Member 'UVAltarSaveMetaData::SaveCounter' has a wrong offset!");

// Class Altar.VAltarSaveIdentificationData
// 0x0028 (0x0058 - 0x0030)
class UVAltarSaveIdentificationData final : public UVBaseAltarSaveData
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  CharacterId;                                       // 0x0038(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  SaveID;                                            // 0x0048(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarSaveIdentificationData">();
	}
	static class UVAltarSaveIdentificationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarSaveIdentificationData>();
	}
};
static_assert(alignof(UVAltarSaveIdentificationData) == 0x000008, "Wrong alignment on UVAltarSaveIdentificationData");
static_assert(sizeof(UVAltarSaveIdentificationData) == 0x000058, "Wrong size on UVAltarSaveIdentificationData");
static_assert(offsetof(UVAltarSaveIdentificationData, CharacterId) == 0x000038, "Member 'UVAltarSaveIdentificationData::CharacterId' has a wrong offset!");
static_assert(offsetof(UVAltarSaveIdentificationData, SaveID) == 0x000048, "Member 'UVAltarSaveIdentificationData::SaveID' has a wrong offset!");

// Class Altar.VAltarSaveSystem
// 0x01B0 (0x01E0 - 0x0030)
class UVAltarSaveSystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnPreLoadAllAltarDataDelegate;                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPostLoadAllAltarDataDelegate;                    // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bAgreed)>  OnDeleteMessageDeleted;                            // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UVAltarSaveGame* SaveGame)> OnAsyncSaveStarted;        // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UVAltarSaveGame* SaveGame)> OnAsyncSaveComplete;       // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x48];                                      // 0x0080(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAltarSaveMetaData*                    AltarSaveMetaData;                                 // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVSaveLoadingContext>           AsyncMetaDataContext;                              // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAltarSaveGame*                        AltarSaveGameInFlight;                             // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UVBaseAltarSaveData*> AltarSaveDataArray;                                // 0x0100(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         UserIndex;                                         // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154[0x8C];                                     // 0x0154(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAsyncSaveComplete_Delegate(const class UVAltarSaveGame* SaveGame);
	void RequestScreenshotAfterLevelChange();
	void SetProvisionScreenshot(int32 SizeX, int32 SizeY, const TArray<struct FColor>& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarSaveSystem">();
	}
	static class UVAltarSaveSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarSaveSystem>();
	}
};
static_assert(alignof(UVAltarSaveSystem) == 0x000008, "Wrong alignment on UVAltarSaveSystem");
static_assert(sizeof(UVAltarSaveSystem) == 0x0001E0, "Wrong size on UVAltarSaveSystem");
static_assert(offsetof(UVAltarSaveSystem, OnPreLoadAllAltarDataDelegate) == 0x000030, "Member 'UVAltarSaveSystem::OnPreLoadAllAltarDataDelegate' has a wrong offset!");
static_assert(offsetof(UVAltarSaveSystem, OnPostLoadAllAltarDataDelegate) == 0x000040, "Member 'UVAltarSaveSystem::OnPostLoadAllAltarDataDelegate' has a wrong offset!");
static_assert(offsetof(UVAltarSaveSystem, OnDeleteMessageDeleted) == 0x000050, "Member 'UVAltarSaveSystem::OnDeleteMessageDeleted' has a wrong offset!");
static_assert(offsetof(UVAltarSaveSystem, OnAsyncSaveStarted) == 0x000060, "Member 'UVAltarSaveSystem::OnAsyncSaveStarted' has a wrong offset!");
static_assert(offsetof(UVAltarSaveSystem, OnAsyncSaveComplete) == 0x000070, "Member 'UVAltarSaveSystem::OnAsyncSaveComplete' has a wrong offset!");
static_assert(offsetof(UVAltarSaveSystem, AltarSaveMetaData) == 0x0000C8, "Member 'UVAltarSaveSystem::AltarSaveMetaData' has a wrong offset!");
static_assert(offsetof(UVAltarSaveSystem, AsyncMetaDataContext) == 0x0000D0, "Member 'UVAltarSaveSystem::AsyncMetaDataContext' has a wrong offset!");
static_assert(offsetof(UVAltarSaveSystem, AltarSaveGameInFlight) == 0x0000F8, "Member 'UVAltarSaveSystem::AltarSaveGameInFlight' has a wrong offset!");
static_assert(offsetof(UVAltarSaveSystem, AltarSaveDataArray) == 0x000100, "Member 'UVAltarSaveSystem::AltarSaveDataArray' has a wrong offset!");
static_assert(offsetof(UVAltarSaveSystem, UserIndex) == 0x000150, "Member 'UVAltarSaveSystem::UserIndex' has a wrong offset!");

// Class Altar.VAltarStarsActor
// 0x0000 (0x0298 - 0x0298)
class AVAltarStarsActor : public AActor
{
public:
	void SetStarsState(float AxisX, float AxisY, float AxisZ, float Angle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarStarsActor">();
	}
	static class AVAltarStarsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAltarStarsActor>();
	}
};
static_assert(alignof(AVAltarStarsActor) == 0x000008, "Wrong alignment on AVAltarStarsActor");
static_assert(sizeof(AVAltarStarsActor) == 0x000298, "Wrong size on AVAltarStarsActor");

// Class Altar.VAltarSunActor
// 0x0000 (0x0298 - 0x0298)
class AVAltarSunActor final : public AActor
{
public:
	void SetSunState(float AxisX, float AxisY, float AxisZ, float SunriseBegin, float SunsetEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarSunActor">();
	}
	static class AVAltarSunActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAltarSunActor>();
	}
};
static_assert(alignof(AVAltarSunActor) == 0x000008, "Wrong alignment on AVAltarSunActor");
static_assert(sizeof(AVAltarSunActor) == 0x000298, "Wrong size on AVAltarSunActor");

// Class Altar.VAltarTelemetrySubsystem
// 0x01A8 (0x01D8 - 0x0030)
class UVAltarTelemetrySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInitialized;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeBetweenPerformanceHeartbeatSends;           // 0x0044(0x0004)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<EMenus>                                  IgnoredMenus;                                      // 0x0048(0x0050)(Edit, Config, EditConst, NativeAccessSpecifierPrivate)
	int32                                         ObserveEveryNumFrame;                              // 0x0098(0x0004)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreAutoSavesForPerformanceHeartbeat;           // 0x009C(0x0001)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisablePerformanceHeartbeatInMainMenu;            // 0x009D(0x0001)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GreatFrameTimeThreshold;                           // 0x00A0(0x0004)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GoodFrameTimeThreshold;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AcceptableFrameTimeThreshold;                      // 0x00A8(0x0004)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PoorFrameTimeThreshold;                            // 0x00AC(0x0004)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0xD4];                                      // 0x00B0(0x00D4)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBetweenCharacterPlaytimeUpdates;               // 0x0184(0x0004)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x4D];                                     // 0x0188(0x004D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIgnoreQuestEventsInMainMenu;                      // 0x01D5(0x0001)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D6[0x2];                                      // 0x01D6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ObserveCurrentFrameData();
	void OnAppActivationStateChanged(const bool bIsFocused);
	void OnBISessionIDChanged(const class FString& NewBISessionID);
	void OnFadeToBlackBegin();
	void OnFadeToGameEnd();
	void OnSaveComplete(const class UVAltarSaveGame* SaveGame);
	void OnSaveStarted(const class UVAltarSaveGame* SaveGame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarTelemetrySubsystem">();
	}
	static class UVAltarTelemetrySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarTelemetrySubsystem>();
	}
};
static_assert(alignof(UVAltarTelemetrySubsystem) == 0x000008, "Wrong alignment on UVAltarTelemetrySubsystem");
static_assert(sizeof(UVAltarTelemetrySubsystem) == 0x0001D8, "Wrong size on UVAltarTelemetrySubsystem");
static_assert(offsetof(UVAltarTelemetrySubsystem, bIsInitialized) == 0x000040, "Member 'UVAltarTelemetrySubsystem::bIsInitialized' has a wrong offset!");
static_assert(offsetof(UVAltarTelemetrySubsystem, MinTimeBetweenPerformanceHeartbeatSends) == 0x000044, "Member 'UVAltarTelemetrySubsystem::MinTimeBetweenPerformanceHeartbeatSends' has a wrong offset!");
static_assert(offsetof(UVAltarTelemetrySubsystem, IgnoredMenus) == 0x000048, "Member 'UVAltarTelemetrySubsystem::IgnoredMenus' has a wrong offset!");
static_assert(offsetof(UVAltarTelemetrySubsystem, ObserveEveryNumFrame) == 0x000098, "Member 'UVAltarTelemetrySubsystem::ObserveEveryNumFrame' has a wrong offset!");
static_assert(offsetof(UVAltarTelemetrySubsystem, bIgnoreAutoSavesForPerformanceHeartbeat) == 0x00009C, "Member 'UVAltarTelemetrySubsystem::bIgnoreAutoSavesForPerformanceHeartbeat' has a wrong offset!");
static_assert(offsetof(UVAltarTelemetrySubsystem, bDisablePerformanceHeartbeatInMainMenu) == 0x00009D, "Member 'UVAltarTelemetrySubsystem::bDisablePerformanceHeartbeatInMainMenu' has a wrong offset!");
static_assert(offsetof(UVAltarTelemetrySubsystem, GreatFrameTimeThreshold) == 0x0000A0, "Member 'UVAltarTelemetrySubsystem::GreatFrameTimeThreshold' has a wrong offset!");
static_assert(offsetof(UVAltarTelemetrySubsystem, GoodFrameTimeThreshold) == 0x0000A4, "Member 'UVAltarTelemetrySubsystem::GoodFrameTimeThreshold' has a wrong offset!");
static_assert(offsetof(UVAltarTelemetrySubsystem, AcceptableFrameTimeThreshold) == 0x0000A8, "Member 'UVAltarTelemetrySubsystem::AcceptableFrameTimeThreshold' has a wrong offset!");
static_assert(offsetof(UVAltarTelemetrySubsystem, PoorFrameTimeThreshold) == 0x0000AC, "Member 'UVAltarTelemetrySubsystem::PoorFrameTimeThreshold' has a wrong offset!");
static_assert(offsetof(UVAltarTelemetrySubsystem, TimeBetweenCharacterPlaytimeUpdates) == 0x000184, "Member 'UVAltarTelemetrySubsystem::TimeBetweenCharacterPlaytimeUpdates' has a wrong offset!");
static_assert(offsetof(UVAltarTelemetrySubsystem, bIgnoreQuestEventsInMainMenu) == 0x0001D5, "Member 'UVAltarTelemetrySubsystem::bIgnoreQuestEventsInMainMenu' has a wrong offset!");

// Class Altar.VAltarTextSubsystem
// 0x0028 (0x0058 - 0x0030)
class UVAltarTextSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<class UVAltarTextBlock*>               AltarTextBlocks;                                   // 0x0030(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UVAltarRichTextBlock*>           AltarRichTextBlocks;                               // 0x0040(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterAltarRichTextBlock(class UVAltarRichTextBlock* NewAltarRichTextBlock);
	void RegisterAltarTextBlock(class UVAltarTextBlock* NewAltarTextBlock);
	void UnregisterAltarRichTextBlock(class UVAltarRichTextBlock* AltarRichTextBlock);
	void UnregisterAltarTextBlock(class UVAltarTextBlock* AltarTextBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarTextSubsystem">();
	}
	static class UVAltarTextSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarTextSubsystem>();
	}
};
static_assert(alignof(UVAltarTextSubsystem) == 0x000008, "Wrong alignment on UVAltarTextSubsystem");
static_assert(sizeof(UVAltarTextSubsystem) == 0x000058, "Wrong size on UVAltarTextSubsystem");
static_assert(offsetof(UVAltarTextSubsystem, AltarTextBlocks) == 0x000030, "Member 'UVAltarTextSubsystem::AltarTextBlocks' has a wrong offset!");
static_assert(offsetof(UVAltarTextSubsystem, AltarRichTextBlocks) == 0x000040, "Member 'UVAltarTextSubsystem::AltarRichTextBlocks' has a wrong offset!");

// Class Altar.VStandSwimPowerSimpleAnimInstance
// 0x0040 (0x03F0 - 0x03B0)
class UVStandSwimPowerSimpleAnimInstance final : public UVMeleeAttackAnimInstance
{
public:
	struct FStandSwimMeleeAttackPowerSingleSimple AnimSet;                                           // 0x03B0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimSequence*                          IdleAnim;                                          // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStandSwimPowerSimpleAnimInstance">();
	}
	static class UVStandSwimPowerSimpleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStandSwimPowerSimpleAnimInstance>();
	}
};
static_assert(alignof(UVStandSwimPowerSimpleAnimInstance) == 0x000010, "Wrong alignment on UVStandSwimPowerSimpleAnimInstance");
static_assert(sizeof(UVStandSwimPowerSimpleAnimInstance) == 0x0003F0, "Wrong size on UVStandSwimPowerSimpleAnimInstance");
static_assert(offsetof(UVStandSwimPowerSimpleAnimInstance, AnimSet) == 0x0003B0, "Member 'UVStandSwimPowerSimpleAnimInstance::AnimSet' has a wrong offset!");
static_assert(offsetof(UVStandSwimPowerSimpleAnimInstance, IdleAnim) == 0x0003E0, "Member 'UVStandSwimPowerSimpleAnimInstance::IdleAnim' has a wrong offset!");

// Class Altar.VAltarTimeOfDayActor
// 0x0020 (0x04D0 - 0x04B0)
class AVAltarTimeOfDayActor final : public AATMTimeOfDayActor
{
public:
	class AVAltarMoonActor*                       MoonMasser;                                        // 0x04B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVAltarMoonActor*                       MoonSecunda;                                       // 0x04B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVAltarStarsActor*                      Stars;                                             // 0x04C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVAltarSunActor*                        Sun;                                               // 0x04C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarTimeOfDayActor">();
	}
	static class AVAltarTimeOfDayActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAltarTimeOfDayActor>();
	}
};
static_assert(alignof(AVAltarTimeOfDayActor) == 0x000008, "Wrong alignment on AVAltarTimeOfDayActor");
static_assert(sizeof(AVAltarTimeOfDayActor) == 0x0004D0, "Wrong size on AVAltarTimeOfDayActor");
static_assert(offsetof(AVAltarTimeOfDayActor, MoonMasser) == 0x0004B0, "Member 'AVAltarTimeOfDayActor::MoonMasser' has a wrong offset!");
static_assert(offsetof(AVAltarTimeOfDayActor, MoonSecunda) == 0x0004B8, "Member 'AVAltarTimeOfDayActor::MoonSecunda' has a wrong offset!");
static_assert(offsetof(AVAltarTimeOfDayActor, Stars) == 0x0004C0, "Member 'AVAltarTimeOfDayActor::Stars' has a wrong offset!");
static_assert(offsetof(AVAltarTimeOfDayActor, Sun) == 0x0004C8, "Member 'AVAltarTimeOfDayActor::Sun' has a wrong offset!");

// Class Altar.VAltarUISettings
// 0x0048 (0x0080 - 0x0038)
class UVAltarUISettings final : public UDeveloperSettings
{
public:
	TSubclassOf<class UVPrimaryGameLayout>        PrimaryGameLayoutDefaultClass;                     // 0x0038(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        MenuDefaultsTable;                                 // 0x0040(0x0020)(Edit, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        NavigationMappingsTable;                           // 0x0060(0x0020)(Edit, ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarUISettings">();
	}
	static class UVAltarUISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarUISettings>();
	}
};
static_assert(alignof(UVAltarUISettings) == 0x000008, "Wrong alignment on UVAltarUISettings");
static_assert(sizeof(UVAltarUISettings) == 0x000080, "Wrong size on UVAltarUISettings");
static_assert(offsetof(UVAltarUISettings, PrimaryGameLayoutDefaultClass) == 0x000038, "Member 'UVAltarUISettings::PrimaryGameLayoutDefaultClass' has a wrong offset!");
static_assert(offsetof(UVAltarUISettings, MenuDefaultsTable) == 0x000040, "Member 'UVAltarUISettings::MenuDefaultsTable' has a wrong offset!");
static_assert(offsetof(UVAltarUISettings, NavigationMappingsTable) == 0x000060, "Member 'UVAltarUISettings::NavigationMappingsTable' has a wrong offset!");

// Class Altar.VAltarUISubsystem
// 0x0158 (0x0188 - 0x0030)
class UVAltarUISubsystem final : public UGameInstanceSubsystem
{
public:
	class AVAltarHud*                             PrimaryHud;                                        // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAltarMenuDefaultsTable*               MenuDefaultsTable;                                 // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UVViewModelBase_Deprecated>, class UVViewModelBase_Deprecated*> ViewModelsMap_Deprecated; // 0x0040(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<struct FWidgetContext, class UVAltarMenu*> WidgetsMap;                                      // 0x0090(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bIsInputHintsVisible;                              // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsHUDVisible;                                     // 0x00E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMenuVisible;                                    // 0x00E2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E3[0x5];                                       // 0x00E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SavePlayerNameText;                                // 0x00E8(0x0018)(NativeAccessSpecifierPrivate)
	int32                                         SavePlayerLevel;                                   // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         UpdatedPlayerLevel;                                // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELoadingScreenType                            CurrentLoadingScreenLoadContext;                   // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InventoryHoveredObjectActor;                       // 0x0110(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTESForm*                               InventoryHoveredObjectForm;                        // 0x0118(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELegacyPlayerMenuPage                         LastPlayerMenuTab;                                 // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AVGlobalLighting*>               AllGlobalLightingActors;                           // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AExponentialHeightFog*>          AllExponentialHeightFogs;                          // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnLeftMouseButtonReleased;                         // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(bool bIsHidden)> OnToggleInputHintVisibility;                      // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(bool bIsHidden)> OnToggleHUDVisibility;                            // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceGameplayInputMode();
	void ForceUIInputMode(bool bShowMouseCursor);
	void RegisterExponentialHeightFog(class AExponentialHeightFog* InNewExponentialHeightFog);
	void RegisterGlobalLightingActor(class AVGlobalLighting* InNewGlobalLightingActor);
	void SetCurrentLoadingScreenContext(const ELoadingScreenType InNewLoadingScreenContext);
	void SetInventoryHoveredObjectActor(class AActor* InNewActor);
	void SetInventoryHoveredObjectForm(class UTESForm* InNewForm);
	void SetPlayerLevelFromLastLoadedSave(const int32 InNewPlayerLevel);
	void SetPlayerLevelFromLevelUp(const int32 InNewPlayerLevel);
	void SetPlayerNameTextFromLastLoadedSave(const class FText& InNewPlayerName);
	void ToggleHUDVisibility(bool bIsVisible);
	void ToggleInputHintVisibility(bool bIsVisible);
	void TryGetBrushFromKey(const struct FKey& InKey, struct FSlateBrush* OutBrush);
	void UnregisterExponentialHeightFog(class AExponentialHeightFog* InExponentialHeightFog);
	void UnregisterGlobalLightingActor(class AVGlobalLighting* InGlobalLightingActor);

	TArray<class AExponentialHeightFog*> GetAllExponentialHeightFogs() const;
	EVCountryGroup GetCoutryGroup() const;
	ELoadingScreenType GetCurrentLoadingScreenContext() const;
	int32 GetCurrentUpdatedPlayerLevel() const;
	TArray<class AVGlobalLighting*> GetGlobalLightingActors() const;
	class AActor* GetInventoryHoveredObjectActor() const;
	class UTESForm* GetInventoryHoveredObjectForm() const;
	TSoftClassPtr<class UClass> GetMenuDefaultClass(TSoftClassPtr<class UClass> MenuClass) const;
	struct FGameplayTag GetMenuDefaultLayer(TSoftClassPtr<class UClass> MenuClass) const;
	EModernCategoryPlatormFlag GetPlatformTag() const;
	int32 GetPlayerLevelFromLastLoadedSave() const;
	class FText GetPlayerNameTextFromLastLoadedSave() const;
	class UVPrimaryGameLayout* GetPrimaryGameLayout() const;
	const bool IsHUDVisible() const;
	const bool IsInputHintsVisible() const;
	bool IsMenuVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarUISubsystem">();
	}
	static class UVAltarUISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarUISubsystem>();
	}
};
static_assert(alignof(UVAltarUISubsystem) == 0x000008, "Wrong alignment on UVAltarUISubsystem");
static_assert(sizeof(UVAltarUISubsystem) == 0x000188, "Wrong size on UVAltarUISubsystem");
static_assert(offsetof(UVAltarUISubsystem, PrimaryHud) == 0x000030, "Member 'UVAltarUISubsystem::PrimaryHud' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, MenuDefaultsTable) == 0x000038, "Member 'UVAltarUISubsystem::MenuDefaultsTable' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, ViewModelsMap_Deprecated) == 0x000040, "Member 'UVAltarUISubsystem::ViewModelsMap_Deprecated' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, WidgetsMap) == 0x000090, "Member 'UVAltarUISubsystem::WidgetsMap' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, bIsInputHintsVisible) == 0x0000E0, "Member 'UVAltarUISubsystem::bIsInputHintsVisible' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, bIsHUDVisible) == 0x0000E1, "Member 'UVAltarUISubsystem::bIsHUDVisible' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, bIsMenuVisible) == 0x0000E2, "Member 'UVAltarUISubsystem::bIsMenuVisible' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, SavePlayerNameText) == 0x0000E8, "Member 'UVAltarUISubsystem::SavePlayerNameText' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, SavePlayerLevel) == 0x000100, "Member 'UVAltarUISubsystem::SavePlayerLevel' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, UpdatedPlayerLevel) == 0x000104, "Member 'UVAltarUISubsystem::UpdatedPlayerLevel' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, CurrentLoadingScreenLoadContext) == 0x000108, "Member 'UVAltarUISubsystem::CurrentLoadingScreenLoadContext' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, InventoryHoveredObjectActor) == 0x000110, "Member 'UVAltarUISubsystem::InventoryHoveredObjectActor' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, InventoryHoveredObjectForm) == 0x000118, "Member 'UVAltarUISubsystem::InventoryHoveredObjectForm' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, LastPlayerMenuTab) == 0x000120, "Member 'UVAltarUISubsystem::LastPlayerMenuTab' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, AllGlobalLightingActors) == 0x000128, "Member 'UVAltarUISubsystem::AllGlobalLightingActors' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, AllExponentialHeightFogs) == 0x000138, "Member 'UVAltarUISubsystem::AllExponentialHeightFogs' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, OnLeftMouseButtonReleased) == 0x000148, "Member 'UVAltarUISubsystem::OnLeftMouseButtonReleased' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, OnToggleInputHintVisibility) == 0x000158, "Member 'UVAltarUISubsystem::OnToggleInputHintVisibility' has a wrong offset!");
static_assert(offsetof(UVAltarUISubsystem, OnToggleHUDVisibility) == 0x000168, "Member 'UVAltarUISubsystem::OnToggleHUDVisibility' has a wrong offset!");

// Class Altar.VAnimationObjectPairingComponent
// 0x0070 (0x0128 - 0x00B8)
class UVAnimationObjectPairingComponent final : public UVActorPairingComponent
{
public:
	bool                                          bIgnoreUnsupportedAnimationsSilently;              // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          OpenAnimationSequence;                             // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CloseAnimationSequence;                            // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UAnimSequence*>     AnimationSequences;                                // 0x00D0(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bForceOptimizations;                               // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayAnimActivable(class USkeletalMeshComponent* SkeletalMeshComponent, const class FString& AnimationName);
	void SetAnimActivable(class USkeletalMeshComponent* SkeletalMeshComponent, const class FString& AnimationName, float PosRatio, bool bPlayAnimation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimationObjectPairingComponent">();
	}
	static class UVAnimationObjectPairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimationObjectPairingComponent>();
	}
};
static_assert(alignof(UVAnimationObjectPairingComponent) == 0x000008, "Wrong alignment on UVAnimationObjectPairingComponent");
static_assert(sizeof(UVAnimationObjectPairingComponent) == 0x000128, "Wrong size on UVAnimationObjectPairingComponent");
static_assert(offsetof(UVAnimationObjectPairingComponent, bIgnoreUnsupportedAnimationsSilently) == 0x0000B8, "Member 'UVAnimationObjectPairingComponent::bIgnoreUnsupportedAnimationsSilently' has a wrong offset!");
static_assert(offsetof(UVAnimationObjectPairingComponent, OpenAnimationSequence) == 0x0000C0, "Member 'UVAnimationObjectPairingComponent::OpenAnimationSequence' has a wrong offset!");
static_assert(offsetof(UVAnimationObjectPairingComponent, CloseAnimationSequence) == 0x0000C8, "Member 'UVAnimationObjectPairingComponent::CloseAnimationSequence' has a wrong offset!");
static_assert(offsetof(UVAnimationObjectPairingComponent, AnimationSequences) == 0x0000D0, "Member 'UVAnimationObjectPairingComponent::AnimationSequences' has a wrong offset!");
static_assert(offsetof(UVAnimationObjectPairingComponent, bForceOptimizations) == 0x000120, "Member 'UVAnimationObjectPairingComponent::bForceOptimizations' has a wrong offset!");

// Class Altar.VAnimationPairingComponent
// 0x0098 (0x0150 - 0x00B8)
class UVAnimationPairingComponent final : public UVActorPairingComponent
{
public:
	TMulticastInlineDelegate<void(const struct FOblivionSourcedCharacterAnimationState& Old, const struct FOblivionSourcedCharacterAnimationState& New)> OnAnimationStateChange; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EOblivionAnimSection Section)> OnAnimationSkip;                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UAnimSequenceBase* AnimationAsset)> OnSpecialIdleAnimationStart; // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSpecialIdleAnimationStop;                        // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool ShouldBeMoving)> OnSpecialIdleAnimation_WantToMove;           // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UAnimSequence* AnimationAsset)> OnDynamicIdleAnimationChange; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 WeaponType, bool IsShieldEquipped, bool IsTorchEquipped)> OnEquippedWeaponChange; // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bCanPerformSpecialIdles;                           // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOblivionSourcedCharacterAnimationState LatestOblivionCharacterAnimationState;            // 0x0130(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimationPairingComponent">();
	}
	static class UVAnimationPairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimationPairingComponent>();
	}
};
static_assert(alignof(UVAnimationPairingComponent) == 0x000008, "Wrong alignment on UVAnimationPairingComponent");
static_assert(sizeof(UVAnimationPairingComponent) == 0x000150, "Wrong size on UVAnimationPairingComponent");
static_assert(offsetof(UVAnimationPairingComponent, OnAnimationStateChange) == 0x0000B8, "Member 'UVAnimationPairingComponent::OnAnimationStateChange' has a wrong offset!");
static_assert(offsetof(UVAnimationPairingComponent, OnAnimationSkip) == 0x0000C8, "Member 'UVAnimationPairingComponent::OnAnimationSkip' has a wrong offset!");
static_assert(offsetof(UVAnimationPairingComponent, OnSpecialIdleAnimationStart) == 0x0000D8, "Member 'UVAnimationPairingComponent::OnSpecialIdleAnimationStart' has a wrong offset!");
static_assert(offsetof(UVAnimationPairingComponent, OnSpecialIdleAnimationStop) == 0x0000E8, "Member 'UVAnimationPairingComponent::OnSpecialIdleAnimationStop' has a wrong offset!");
static_assert(offsetof(UVAnimationPairingComponent, OnSpecialIdleAnimation_WantToMove) == 0x0000F8, "Member 'UVAnimationPairingComponent::OnSpecialIdleAnimation_WantToMove' has a wrong offset!");
static_assert(offsetof(UVAnimationPairingComponent, OnDynamicIdleAnimationChange) == 0x000108, "Member 'UVAnimationPairingComponent::OnDynamicIdleAnimationChange' has a wrong offset!");
static_assert(offsetof(UVAnimationPairingComponent, OnEquippedWeaponChange) == 0x000118, "Member 'UVAnimationPairingComponent::OnEquippedWeaponChange' has a wrong offset!");
static_assert(offsetof(UVAnimationPairingComponent, bCanPerformSpecialIdles) == 0x000128, "Member 'UVAnimationPairingComponent::bCanPerformSpecialIdles' has a wrong offset!");
static_assert(offsetof(UVAnimationPairingComponent, LatestOblivionCharacterAnimationState) == 0x000130, "Member 'UVAnimationPairingComponent::LatestOblivionCharacterAnimationState' has a wrong offset!");

// Class Altar.VAnimNotifyState_ImpactSystem
// 0x0058 (0x0088 - 0x0030)
class UVAnimNotifyState_ImpactSystem final : public UAnimNotifyState
{
public:
	class FName                                   BoneNameUsedToAttack;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UVHitBoxComponent>> HitBoxList;                                      // 0x0038(0x0010)(ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UStaticMeshComponent>    StaticMeshWeaponComp;                              // 0x0048(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UStaticMeshSocket>       WeaponSocket;                                      // 0x0050(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WantedDirection;                                   // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BloodWantedDirection;                              // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotifyState_ImpactSystem">();
	}
	static class UVAnimNotifyState_ImpactSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotifyState_ImpactSystem>();
	}
};
static_assert(alignof(UVAnimNotifyState_ImpactSystem) == 0x000008, "Wrong alignment on UVAnimNotifyState_ImpactSystem");
static_assert(sizeof(UVAnimNotifyState_ImpactSystem) == 0x000088, "Wrong size on UVAnimNotifyState_ImpactSystem");
static_assert(offsetof(UVAnimNotifyState_ImpactSystem, BoneNameUsedToAttack) == 0x000030, "Member 'UVAnimNotifyState_ImpactSystem::BoneNameUsedToAttack' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_ImpactSystem, HitBoxList) == 0x000038, "Member 'UVAnimNotifyState_ImpactSystem::HitBoxList' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_ImpactSystem, StaticMeshWeaponComp) == 0x000048, "Member 'UVAnimNotifyState_ImpactSystem::StaticMeshWeaponComp' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_ImpactSystem, WeaponSocket) == 0x000050, "Member 'UVAnimNotifyState_ImpactSystem::WeaponSocket' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_ImpactSystem, WantedDirection) == 0x000058, "Member 'UVAnimNotifyState_ImpactSystem::WantedDirection' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_ImpactSystem, BloodWantedDirection) == 0x000070, "Member 'UVAnimNotifyState_ImpactSystem::BloodWantedDirection' has a wrong offset!");

// Class Altar.VAnimNotifyState_SetHitReactRatio
// 0x0010 (0x0040 - 0x0030)
class UVAnimNotifyState_SetHitReactRatio final : public UAnimNotifyState
{
public:
	TSubclassOf<class UVHitReactionAnimInstance>  AnimInstanceClass;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactRatio;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotifyState_SetHitReactRatio">();
	}
	static class UVAnimNotifyState_SetHitReactRatio* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotifyState_SetHitReactRatio>();
	}
};
static_assert(alignof(UVAnimNotifyState_SetHitReactRatio) == 0x000008, "Wrong alignment on UVAnimNotifyState_SetHitReactRatio");
static_assert(sizeof(UVAnimNotifyState_SetHitReactRatio) == 0x000040, "Wrong size on UVAnimNotifyState_SetHitReactRatio");
static_assert(offsetof(UVAnimNotifyState_SetHitReactRatio, AnimInstanceClass) == 0x000030, "Member 'UVAnimNotifyState_SetHitReactRatio::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_SetHitReactRatio, HitReactRatio) == 0x000038, "Member 'UVAnimNotifyState_SetHitReactRatio::HitReactRatio' has a wrong offset!");

// Class Altar.VAnimNotifyState_UseItemProp
// 0x0060 (0x0090 - 0x0030)
class UVAnimNotifyState_UseItemProp final : public UAnimNotifyState
{
public:
	bool                                          bClearOtherPropsAtStart;                           // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceRespawnProps;                                // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class AVPropItem>>           PropItemClasses;                                   // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         PropDestroyDelay;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotifyState_UseItemProp">();
	}
	static class UVAnimNotifyState_UseItemProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotifyState_UseItemProp>();
	}
};
static_assert(alignof(UVAnimNotifyState_UseItemProp) == 0x000008, "Wrong alignment on UVAnimNotifyState_UseItemProp");
static_assert(sizeof(UVAnimNotifyState_UseItemProp) == 0x000090, "Wrong size on UVAnimNotifyState_UseItemProp");
static_assert(offsetof(UVAnimNotifyState_UseItemProp, bClearOtherPropsAtStart) == 0x000030, "Member 'UVAnimNotifyState_UseItemProp::bClearOtherPropsAtStart' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_UseItemProp, bForceRespawnProps) == 0x000031, "Member 'UVAnimNotifyState_UseItemProp::bForceRespawnProps' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_UseItemProp, PropItemClasses) == 0x000038, "Member 'UVAnimNotifyState_UseItemProp::PropItemClasses' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_UseItemProp, PropDestroyDelay) == 0x000088, "Member 'UVAnimNotifyState_UseItemProp::PropDestroyDelay' has a wrong offset!");

// Class Altar.VAnimNotifyState_WarpToHorseSaddle
// 0x0010 (0x0040 - 0x0030)
class UVAnimNotifyState_WarpToHorseSaddle final : public UAnimNotifyState
{
public:
	class FName                                   DockWarpTargetName;                                // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HorseSaddleSocket;                                 // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotifyState_WarpToHorseSaddle">();
	}
	static class UVAnimNotifyState_WarpToHorseSaddle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotifyState_WarpToHorseSaddle>();
	}
};
static_assert(alignof(UVAnimNotifyState_WarpToHorseSaddle) == 0x000008, "Wrong alignment on UVAnimNotifyState_WarpToHorseSaddle");
static_assert(sizeof(UVAnimNotifyState_WarpToHorseSaddle) == 0x000040, "Wrong size on UVAnimNotifyState_WarpToHorseSaddle");
static_assert(offsetof(UVAnimNotifyState_WarpToHorseSaddle, DockWarpTargetName) == 0x000030, "Member 'UVAnimNotifyState_WarpToHorseSaddle::DockWarpTargetName' has a wrong offset!");
static_assert(offsetof(UVAnimNotifyState_WarpToHorseSaddle, HorseSaddleSocket) == 0x000038, "Member 'UVAnimNotifyState_WarpToHorseSaddle::HorseSaddleSocket' has a wrong offset!");

// Class Altar.VAnimNotifyState_WarpToLocation
// 0x0000 (0x0038 - 0x0038)
class UVAnimNotifyState_WarpToLocation final : public UAnimNotifyState_MotionWarping
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotifyState_WarpToLocation">();
	}
	static class UVAnimNotifyState_WarpToLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotifyState_WarpToLocation>();
	}
};
static_assert(alignof(UVAnimNotifyState_WarpToLocation) == 0x000008, "Wrong alignment on UVAnimNotifyState_WarpToLocation");
static_assert(sizeof(UVAnimNotifyState_WarpToLocation) == 0x000038, "Wrong size on UVAnimNotifyState_WarpToLocation");

// Class Altar.VAnimNotify_ActionCameraTracking
// 0x0028 (0x0070 - 0x0048)
class UVAnimNotify_ActionCameraTracking final : public UVAnimNotify_ActionNotifyState
{
public:
	struct FCameraTrackingSettings                CameraSettings;                                    // 0x0048(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ShouldIgnoreTrackingOnTargetedPawn(class AVPairedPawn* ControlledPawn, class AVPairedPawn* TargetedPawn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_ActionCameraTracking">();
	}
	static class UVAnimNotify_ActionCameraTracking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_ActionCameraTracking>();
	}
};
static_assert(alignof(UVAnimNotify_ActionCameraTracking) == 0x000008, "Wrong alignment on UVAnimNotify_ActionCameraTracking");
static_assert(sizeof(UVAnimNotify_ActionCameraTracking) == 0x000070, "Wrong size on UVAnimNotify_ActionCameraTracking");
static_assert(offsetof(UVAnimNotify_ActionCameraTracking, CameraSettings) == 0x000048, "Member 'UVAnimNotify_ActionCameraTracking::CameraSettings' has a wrong offset!");

// Class Altar.VAnimNotify_ActionMeleeHitWindow
// 0x0038 (0x0080 - 0x0048)
class UVAnimNotify_ActionMeleeHitWindow final : public UVAnimNotify_ActionNotifyState
{
public:
	struct FVector                                BaseHitboxExtent;                                  // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BaseHitboxCenterOffset;                            // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalDegreeAngleLimit;                          // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalDegreeAngleLimit;                        // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FBox ComputeHitbox() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_ActionMeleeHitWindow">();
	}
	static class UVAnimNotify_ActionMeleeHitWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_ActionMeleeHitWindow>();
	}
};
static_assert(alignof(UVAnimNotify_ActionMeleeHitWindow) == 0x000008, "Wrong alignment on UVAnimNotify_ActionMeleeHitWindow");
static_assert(sizeof(UVAnimNotify_ActionMeleeHitWindow) == 0x000080, "Wrong size on UVAnimNotify_ActionMeleeHitWindow");
static_assert(offsetof(UVAnimNotify_ActionMeleeHitWindow, BaseHitboxExtent) == 0x000048, "Member 'UVAnimNotify_ActionMeleeHitWindow::BaseHitboxExtent' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_ActionMeleeHitWindow, BaseHitboxCenterOffset) == 0x000060, "Member 'UVAnimNotify_ActionMeleeHitWindow::BaseHitboxCenterOffset' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_ActionMeleeHitWindow, VerticalDegreeAngleLimit) == 0x000078, "Member 'UVAnimNotify_ActionMeleeHitWindow::VerticalDegreeAngleLimit' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_ActionMeleeHitWindow, HorizontalDegreeAngleLimit) == 0x00007C, "Member 'UVAnimNotify_ActionMeleeHitWindow::HorizontalDegreeAngleLimit' has a wrong offset!");

// Class Altar.VAnimNotify_ActionNotify
// 0x0010 (0x0048 - 0x0038)
class UVAnimNotify_ActionNotify : public UAnimNotify
{
public:
	struct FGameplayTag                           ActionEventTag;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveWhenOwnerInvisible;                         // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TriggerEventOnAnimatedAction(class AVPairedPawn* PairedPawn, class UVPawnAnimatedAction* AnimatedAction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_ActionNotify">();
	}
	static class UVAnimNotify_ActionNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_ActionNotify>();
	}
};
static_assert(alignof(UVAnimNotify_ActionNotify) == 0x000008, "Wrong alignment on UVAnimNotify_ActionNotify");
static_assert(sizeof(UVAnimNotify_ActionNotify) == 0x000048, "Wrong size on UVAnimNotify_ActionNotify");
static_assert(offsetof(UVAnimNotify_ActionNotify, ActionEventTag) == 0x000038, "Member 'UVAnimNotify_ActionNotify::ActionEventTag' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_ActionNotify, bActiveWhenOwnerInvisible) == 0x000040, "Member 'UVAnimNotify_ActionNotify::bActiveWhenOwnerInvisible' has a wrong offset!");

// Class Altar.VAnimNotify_ReleaseArrow
// 0x0000 (0x0038 - 0x0038)
class UVAnimNotify_ReleaseArrow final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_ReleaseArrow">();
	}
	static class UVAnimNotify_ReleaseArrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_ReleaseArrow>();
	}
};
static_assert(alignof(UVAnimNotify_ReleaseArrow) == 0x000008, "Wrong alignment on UVAnimNotify_ReleaseArrow");
static_assert(sizeof(UVAnimNotify_ReleaseArrow) == 0x000038, "Wrong size on UVAnimNotify_ReleaseArrow");

// Class Altar.VAnimNotify_FloorTrapOpening
// 0x0008 (0x0040 - 0x0038)
class UVAnimNotify_FloorTrapOpening final : public UAnimNotify
{
public:
	bool                                          bIsOpening;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_FloorTrapOpening">();
	}
	static class UVAnimNotify_FloorTrapOpening* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_FloorTrapOpening>();
	}
};
static_assert(alignof(UVAnimNotify_FloorTrapOpening) == 0x000008, "Wrong alignment on UVAnimNotify_FloorTrapOpening");
static_assert(sizeof(UVAnimNotify_FloorTrapOpening) == 0x000040, "Wrong size on UVAnimNotify_FloorTrapOpening");
static_assert(offsetof(UVAnimNotify_FloorTrapOpening, bIsOpening) == 0x000038, "Member 'UVAnimNotify_FloorTrapOpening::bIsOpening' has a wrong offset!");

// Class Altar.VAnimNotify_HitMelee
// 0x0000 (0x0038 - 0x0038)
class UVAnimNotify_HitMelee final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_HitMelee">();
	}
	static class UVAnimNotify_HitMelee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_HitMelee>();
	}
};
static_assert(alignof(UVAnimNotify_HitMelee) == 0x000008, "Wrong alignment on UVAnimNotify_HitMelee");
static_assert(sizeof(UVAnimNotify_HitMelee) == 0x000038, "Wrong size on UVAnimNotify_HitMelee");

// Class Altar.VAnimNotify_JumpNotify
// 0x0010 (0x0048 - 0x0038)
class UVAnimNotify_JumpNotify final : public UAnimNotify
{
public:
	bool                                          bClearJumpInputTagOnNotify;                        // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HorizontalVelocityMultiplier;                      // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalJumpHeightMultiplier;                      // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_JumpNotify">();
	}
	static class UVAnimNotify_JumpNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_JumpNotify>();
	}
};
static_assert(alignof(UVAnimNotify_JumpNotify) == 0x000008, "Wrong alignment on UVAnimNotify_JumpNotify");
static_assert(sizeof(UVAnimNotify_JumpNotify) == 0x000048, "Wrong size on UVAnimNotify_JumpNotify");
static_assert(offsetof(UVAnimNotify_JumpNotify, bClearJumpInputTagOnNotify) == 0x000038, "Member 'UVAnimNotify_JumpNotify::bClearJumpInputTagOnNotify' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_JumpNotify, HorizontalVelocityMultiplier) == 0x00003C, "Member 'UVAnimNotify_JumpNotify::HorizontalVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_JumpNotify, VerticalJumpHeightMultiplier) == 0x000040, "Member 'UVAnimNotify_JumpNotify::VerticalJumpHeightMultiplier' has a wrong offset!");

// Class Altar.VAnimNotify_PlayEquipUnequip
// 0x0010 (0x0048 - 0x0038)
class UVAnimNotify_PlayEquipUnequip final : public UAnimNotify
{
public:
	class FName                                   AttachName;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVEquipAction                                 EquipAction;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_PlayEquipUnequip">();
	}
	static class UVAnimNotify_PlayEquipUnequip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_PlayEquipUnequip>();
	}
};
static_assert(alignof(UVAnimNotify_PlayEquipUnequip) == 0x000008, "Wrong alignment on UVAnimNotify_PlayEquipUnequip");
static_assert(sizeof(UVAnimNotify_PlayEquipUnequip) == 0x000048, "Wrong size on UVAnimNotify_PlayEquipUnequip");
static_assert(offsetof(UVAnimNotify_PlayEquipUnequip, AttachName) == 0x000038, "Member 'UVAnimNotify_PlayEquipUnequip::AttachName' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_PlayEquipUnequip, EquipAction) == 0x000040, "Member 'UVAnimNotify_PlayEquipUnequip::EquipAction' has a wrong offset!");

// Class Altar.VAnimNotify_PlayOpenCloseSound
// 0x0010 (0x0048 - 0x0038)
class UVAnimNotify_PlayOpenCloseSound final : public UAnimNotify
{
public:
	class FName                                   AttachName;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVOpenCloseAction                             Action;                                            // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_PlayOpenCloseSound">();
	}
	static class UVAnimNotify_PlayOpenCloseSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_PlayOpenCloseSound>();
	}
};
static_assert(alignof(UVAnimNotify_PlayOpenCloseSound) == 0x000008, "Wrong alignment on UVAnimNotify_PlayOpenCloseSound");
static_assert(sizeof(UVAnimNotify_PlayOpenCloseSound) == 0x000048, "Wrong size on UVAnimNotify_PlayOpenCloseSound");
static_assert(offsetof(UVAnimNotify_PlayOpenCloseSound, AttachName) == 0x000038, "Member 'UVAnimNotify_PlayOpenCloseSound::AttachName' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_PlayOpenCloseSound, Action) == 0x000040, "Member 'UVAnimNotify_PlayOpenCloseSound::Action' has a wrong offset!");

// Class Altar.VAnimNotify_PlayWwiseSound
// 0x0010 (0x0048 - 0x0038)
class UVAnimNotify_PlayWwiseSound final : public UAnimNotify
{
public:
	class UAkAudioEvent*                          SoundEvent;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachName;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_PlayWwiseSound">();
	}
	static class UVAnimNotify_PlayWwiseSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_PlayWwiseSound>();
	}
};
static_assert(alignof(UVAnimNotify_PlayWwiseSound) == 0x000008, "Wrong alignment on UVAnimNotify_PlayWwiseSound");
static_assert(sizeof(UVAnimNotify_PlayWwiseSound) == 0x000048, "Wrong size on UVAnimNotify_PlayWwiseSound");
static_assert(offsetof(UVAnimNotify_PlayWwiseSound, SoundEvent) == 0x000038, "Member 'UVAnimNotify_PlayWwiseSound::SoundEvent' has a wrong offset!");
static_assert(offsetof(UVAnimNotify_PlayWwiseSound, AttachName) == 0x000040, "Member 'UVAnimNotify_PlayWwiseSound::AttachName' has a wrong offset!");

// Class Altar.VAnimNotify_ReleaseCast
// 0x0008 (0x0040 - 0x0038)
class UVAnimNotify_ReleaseCast final : public UAnimNotify
{
public:
	bool                                          bIsStaffNotify;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAnimNotify_ReleaseCast">();
	}
	static class UVAnimNotify_ReleaseCast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAnimNotify_ReleaseCast>();
	}
};
static_assert(alignof(UVAnimNotify_ReleaseCast) == 0x000008, "Wrong alignment on UVAnimNotify_ReleaseCast");
static_assert(sizeof(UVAnimNotify_ReleaseCast) == 0x000040, "Wrong size on UVAnimNotify_ReleaseCast");
static_assert(offsetof(UVAnimNotify_ReleaseCast, bIsStaffNotify) == 0x000038, "Member 'UVAnimNotify_ReleaseCast::bIsStaffNotify' has a wrong offset!");

// Class Altar.VArmor_Light
// 0x0000 (0x0370 - 0x0370)
class AVArmor_Light final : public AVArmor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VArmor_Light">();
	}
	static class AVArmor_Light* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVArmor_Light>();
	}
};
static_assert(alignof(AVArmor_Light) == 0x000008, "Wrong alignment on AVArmor_Light");
static_assert(sizeof(AVArmor_Light) == 0x000370, "Wrong size on AVArmor_Light");

// Class Altar.VArmor_Heavy
// 0x0000 (0x0370 - 0x0370)
class AVArmor_Heavy final : public AVArmor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VArmor_Heavy">();
	}
	static class AVArmor_Heavy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVArmor_Heavy>();
	}
};
static_assert(alignof(AVArmor_Heavy) == 0x000008, "Wrong alignment on AVArmor_Heavy");
static_assert(sizeof(AVArmor_Heavy) == 0x000370, "Wrong size on AVArmor_Heavy");

// Class Altar.VAssetNameDebugWidget
// 0x0010 (0x02D0 - 0x02C0)
class UVAssetNameDebugWidget : public UUserWidget
{
public:
	class FString                                 AssetName;                                         // 0x02C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void TraceToFirstAsset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAssetNameDebugWidget">();
	}
	static class UVAssetNameDebugWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAssetNameDebugWidget>();
	}
};
static_assert(alignof(UVAssetNameDebugWidget) == 0x000008, "Wrong alignment on UVAssetNameDebugWidget");
static_assert(sizeof(UVAssetNameDebugWidget) == 0x0002D0, "Wrong size on UVAssetNameDebugWidget");
static_assert(offsetof(UVAssetNameDebugWidget, AssetName) == 0x0002C0, "Member 'UVAssetNameDebugWidget::AssetName' has a wrong offset!");

// Class Altar.VATMRecordingWidget
// 0x0010 (0x01A8 - 0x0198)
class UVATMRecordingWidget final : public UContentWidget
{
public:
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VATMRecordingWidget">();
	}
	static class UVATMRecordingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVATMRecordingWidget>();
	}
};
static_assert(alignof(UVATMRecordingWidget) == 0x000008, "Wrong alignment on UVATMRecordingWidget");
static_assert(sizeof(UVATMRecordingWidget) == 0x0001A8, "Wrong size on UVATMRecordingWidget");

// Class Altar.VAudioHandlersSubsystem
// 0x0018 (0x0048 - 0x0030)
class UVAudioHandlersSubsystem final : public UGameInstanceSubsystem
{
public:
	class AVMusicPlayer*                          MusicPlayerActor;                                  // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVWeatherAudioPlayer*                   WeatherAudioPlayerActor;                           // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVWaterSoundFollower*                   WaterSoundFollowerActor;                           // 0x0040(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AVMusicPlayer* GetMusicPlayerActor();
	class AVWeatherAudioPlayer* GetWeatherAudioPlayerActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAudioHandlersSubsystem">();
	}
	static class UVAudioHandlersSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAudioHandlersSubsystem>();
	}
};
static_assert(alignof(UVAudioHandlersSubsystem) == 0x000008, "Wrong alignment on UVAudioHandlersSubsystem");
static_assert(sizeof(UVAudioHandlersSubsystem) == 0x000048, "Wrong size on UVAudioHandlersSubsystem");
static_assert(offsetof(UVAudioHandlersSubsystem, MusicPlayerActor) == 0x000030, "Member 'UVAudioHandlersSubsystem::MusicPlayerActor' has a wrong offset!");
static_assert(offsetof(UVAudioHandlersSubsystem, WeatherAudioPlayerActor) == 0x000038, "Member 'UVAudioHandlersSubsystem::WeatherAudioPlayerActor' has a wrong offset!");
static_assert(offsetof(UVAudioHandlersSubsystem, WaterSoundFollowerActor) == 0x000040, "Member 'UVAudioHandlersSubsystem::WaterSoundFollowerActor' has a wrong offset!");

// Class Altar.VAudioListener
// 0x0010 (0x02B0 - 0x02A0)
class UVAudioListener final : public USceneComponent
{
public:
	bool                                          bUseCameraOrientation;                             // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0xF];                                      // 0x02A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAudioListener">();
	}
	static class UVAudioListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAudioListener>();
	}
};
static_assert(alignof(UVAudioListener) == 0x000010, "Wrong alignment on UVAudioListener");
static_assert(sizeof(UVAudioListener) == 0x0002B0, "Wrong size on UVAudioListener");
static_assert(offsetof(UVAudioListener, bUseCameraOrientation) == 0x0002A0, "Member 'UVAudioListener::bUseCameraOrientation' has a wrong offset!");

// Class Altar.VAudioStatics
// 0x0000 (0x0028 - 0x0028)
class UVAudioStatics final : public UBlueprintFunctionLibrary
{
public:
	static void BPF_PostAudioEvent(class UAkAudioEvent* EventToPost);
	static void BPF_PostAudioEventAtLocation(class UAkAudioEvent* EventToPost, const struct FVector& Location, class UObject* WorldContext);
	static void BPF_PostAudioEventOnActor(class UAkAudioEvent* EventToPost, class AActor* Actor);
	static void BPF_PostAudioEventWithComponent(class UAkAudioEvent* EventToPost, class UAkComponent* Component);
	static bool PrepareAudioEvent(class UAkAudioEvent* EventToPrepare, bool bWhitelist);
	static void SetGlobalRTPCValue(class FName RTPCName, float RTPCValue, int32 InterpolationTimeInMs);
	static void SetRTPCValue(class AActor* Actor, class FName RTPCName, float RTPCValue, int32 InterpolationTimeInMs);
	static void SetState(class FName StateGroup, class FName StateValue);
	static void SetSwitch(class AActor* Actor, class FName SwitchGroup, class FName SwitchValue);
	static void UnloadAudioEvent(class UAkAudioEvent* EventToUnload, bool bAsync);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAudioStatics">();
	}
	static class UVAudioStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAudioStatics>();
	}
};
static_assert(alignof(UVAudioStatics) == 0x000008, "Wrong alignment on UVAudioStatics");
static_assert(sizeof(UVAudioStatics) == 0x000028, "Wrong size on UVAudioStatics");

// Class Altar.VAudioTriggerBox
// 0x0008 (0x02A0 - 0x0298)
class AVAudioTriggerBox : public AActor
{
public:
	class UBoxComponent*                          Box;                                               // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EnterBox(class AActor* OverlappedActor, class AActor* OtherActor);
	void ExitBox(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAudioTriggerBox">();
	}
	static class AVAudioTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAudioTriggerBox>();
	}
};
static_assert(alignof(AVAudioTriggerBox) == 0x000008, "Wrong alignment on AVAudioTriggerBox");
static_assert(sizeof(AVAudioTriggerBox) == 0x0002A0, "Wrong size on AVAudioTriggerBox");
static_assert(offsetof(AVAudioTriggerBox, Box) == 0x000298, "Member 'AVAudioTriggerBox::Box' has a wrong offset!");

// Class Altar.VAvailableEffectItem
// 0x0028 (0x0050 - 0x0028)
class UVAvailableEffectItem final : public UObject
{
public:
	struct FAvailableEffectData                   Properties;                                        // 0x0028(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void SetProperties(const struct FAvailableEffectData& Value);

	const struct FAvailableEffectData GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAvailableEffectItem">();
	}
	static class UVAvailableEffectItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAvailableEffectItem>();
	}
};
static_assert(alignof(UVAvailableEffectItem) == 0x000008, "Wrong alignment on UVAvailableEffectItem");
static_assert(sizeof(UVAvailableEffectItem) == 0x000050, "Wrong size on UVAvailableEffectItem");
static_assert(offsetof(UVAvailableEffectItem, Properties) == 0x000028, "Member 'UVAvailableEffectItem::Properties' has a wrong offset!");

// Class Altar.VBackgroundWidgetBase
// 0x0100 (0x0510 - 0x0410)
class UVBackgroundWidgetBase : public UCommonActivatableWidget
{
public:
	TMulticastInlineDelegate<void()>              OnBackgroundChanged;                               // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UImage*                                 Background;                                        // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            BackgroundImageBrush;                              // 0x0430(0x00D0)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x10];                                     // 0x0500(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnScreenShotcapturedDelegate(int32 InSizeX, int32 InSizeY, const TArray<struct FColor>& InImageData);
	void ReleaseCamera();
	void RequestCapture();
	void SetBackgroundImage(class UTexture2D* Image);

	struct FSlateBrush GetBackgroundImageBrush() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBackgroundWidgetBase">();
	}
	static class UVBackgroundWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBackgroundWidgetBase>();
	}
};
static_assert(alignof(UVBackgroundWidgetBase) == 0x000010, "Wrong alignment on UVBackgroundWidgetBase");
static_assert(sizeof(UVBackgroundWidgetBase) == 0x000510, "Wrong size on UVBackgroundWidgetBase");
static_assert(offsetof(UVBackgroundWidgetBase, OnBackgroundChanged) == 0x000410, "Member 'UVBackgroundWidgetBase::OnBackgroundChanged' has a wrong offset!");
static_assert(offsetof(UVBackgroundWidgetBase, Background) == 0x000420, "Member 'UVBackgroundWidgetBase::Background' has a wrong offset!");
static_assert(offsetof(UVBackgroundWidgetBase, BackgroundImageBrush) == 0x000430, "Member 'UVBackgroundWidgetBase::BackgroundImageBrush' has a wrong offset!");

// Class Altar.VLowerUpperBodyAnimInstance
// 0x0010 (0x03B0 - 0x03A0)
#pragma pack(push, 0x1)
class alignas(0x10) UVLowerUpperBodyAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	bool                                          bIsMoving;                                         // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLowerUpperBodyAnimInstance">();
	}
	static class UVLowerUpperBodyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLowerUpperBodyAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVLowerUpperBodyAnimInstance) == 0x000010, "Wrong alignment on UVLowerUpperBodyAnimInstance");
static_assert(sizeof(UVLowerUpperBodyAnimInstance) == 0x0003B0, "Wrong size on UVLowerUpperBodyAnimInstance");
static_assert(offsetof(UVLowerUpperBodyAnimInstance, bIsMoving) == 0x0003A0, "Member 'UVLowerUpperBodyAnimInstance::bIsMoving' has a wrong offset!");

// Class Altar.VBipedLowerUpperBodyAnimInstance
// 0x0020 (0x03D0 - 0x03B0)
class UVBipedLowerUpperBodyAnimInstance final : public UVLowerUpperBodyAnimInstance
{
public:
	struct FCreatureBipedBoneAnimationData        LayerData;                                         // 0x03A8(0x0020)(Edit, BlueprintVisible, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBipedLowerUpperBodyAnimInstance">();
	}
	static class UVBipedLowerUpperBodyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBipedLowerUpperBodyAnimInstance>();
	}
};
static_assert(alignof(UVBipedLowerUpperBodyAnimInstance) == 0x000010, "Wrong alignment on UVBipedLowerUpperBodyAnimInstance");
static_assert(sizeof(UVBipedLowerUpperBodyAnimInstance) == 0x0003D0, "Wrong size on UVBipedLowerUpperBodyAnimInstance");
static_assert(offsetof(UVBipedLowerUpperBodyAnimInstance, LayerData) == 0x0003A8, "Member 'UVBipedLowerUpperBodyAnimInstance::LayerData' has a wrong offset!");

// Class Altar.VBlackListNavLinkCustomComponent
// 0x0050 (0x0230 - 0x01E0)
class UVBlackListNavLinkCustomComponent final : public UVDoorNavLinkCustomComponent
{
public:
	TSet<class AActor*>                           ActorsBlacklist;                                   // 0x01E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBlackListNavLinkCustomComponent">();
	}
	static class UVBlackListNavLinkCustomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBlackListNavLinkCustomComponent>();
	}
};
static_assert(alignof(UVBlackListNavLinkCustomComponent) == 0x000008, "Wrong alignment on UVBlackListNavLinkCustomComponent");
static_assert(sizeof(UVBlackListNavLinkCustomComponent) == 0x000230, "Wrong size on UVBlackListNavLinkCustomComponent");
static_assert(offsetof(UVBlackListNavLinkCustomComponent, ActorsBlacklist) == 0x0001E0, "Member 'UVBlackListNavLinkCustomComponent::ActorsBlacklist' has a wrong offset!");

// Class Altar.VBlendSpaceSpeedsUserData
// 0x0020 (0x0048 - 0x0028)
class UVBlendSpaceSpeedsUserData final : public UAssetUserData
{
public:
	TArray<float>                                 SlowestAnimSpeeds;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FastestAnimSpeeds;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBlendSpaceSpeedsUserData">();
	}
	static class UVBlendSpaceSpeedsUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBlendSpaceSpeedsUserData>();
	}
};
static_assert(alignof(UVBlendSpaceSpeedsUserData) == 0x000008, "Wrong alignment on UVBlendSpaceSpeedsUserData");
static_assert(sizeof(UVBlendSpaceSpeedsUserData) == 0x000048, "Wrong size on UVBlendSpaceSpeedsUserData");
static_assert(offsetof(UVBlendSpaceSpeedsUserData, SlowestAnimSpeeds) == 0x000028, "Member 'UVBlendSpaceSpeedsUserData::SlowestAnimSpeeds' has a wrong offset!");
static_assert(offsetof(UVBlendSpaceSpeedsUserData, FastestAnimSpeeds) == 0x000038, "Member 'UVBlendSpaceSpeedsUserData::FastestAnimSpeeds' has a wrong offset!");

// Class Altar.VBlinkHumanoidCharacterAnimInstance
// 0x0020 (0x0380 - 0x0360)
class UVBlinkHumanoidCharacterAnimInstance : public UVBlinkCharacterAnimInstance
{
public:
	class UCurveFloat*                            BlinkAnimCurve;                                    // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BlinkMorphTargetName;                              // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x18];                                     // 0x0368(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBlinkHumanoidCharacterAnimInstance">();
	}
	static class UVBlinkHumanoidCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBlinkHumanoidCharacterAnimInstance>();
	}
};
static_assert(alignof(UVBlinkHumanoidCharacterAnimInstance) == 0x000010, "Wrong alignment on UVBlinkHumanoidCharacterAnimInstance");
static_assert(sizeof(UVBlinkHumanoidCharacterAnimInstance) == 0x000380, "Wrong size on UVBlinkHumanoidCharacterAnimInstance");
static_assert(offsetof(UVBlinkHumanoidCharacterAnimInstance, BlinkAnimCurve) == 0x000358, "Member 'UVBlinkHumanoidCharacterAnimInstance::BlinkAnimCurve' has a wrong offset!");
static_assert(offsetof(UVBlinkHumanoidCharacterAnimInstance, BlinkMorphTargetName) == 0x000360, "Member 'UVBlinkHumanoidCharacterAnimInstance::BlinkMorphTargetName' has a wrong offset!");

// Class Altar.VBlockCharacterAnimInstance
// 0x0040 (0x03E0 - 0x03A0)
class UVBlockCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	bool                                          bIsPlayingBlockHit;                                // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEnterBlockState;                            // 0x03A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A2[0x6];                                      // 0x03A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlockShieldAnimationData              AnimSet;                                           // 0x03A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlockHitEnd(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnBlockHitEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

	bool GetShouldEnterBlockState() const;
	bool IsBlockingHit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBlockCharacterAnimInstance">();
	}
	static class UVBlockCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBlockCharacterAnimInstance>();
	}
};
static_assert(alignof(UVBlockCharacterAnimInstance) == 0x000010, "Wrong alignment on UVBlockCharacterAnimInstance");
static_assert(sizeof(UVBlockCharacterAnimInstance) == 0x0003E0, "Wrong size on UVBlockCharacterAnimInstance");
static_assert(offsetof(UVBlockCharacterAnimInstance, bIsPlayingBlockHit) == 0x0003A0, "Member 'UVBlockCharacterAnimInstance::bIsPlayingBlockHit' has a wrong offset!");
static_assert(offsetof(UVBlockCharacterAnimInstance, bShouldEnterBlockState) == 0x0003A1, "Member 'UVBlockCharacterAnimInstance::bShouldEnterBlockState' has a wrong offset!");
static_assert(offsetof(UVBlockCharacterAnimInstance, AnimSet) == 0x0003A8, "Member 'UVBlockCharacterAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VBlockShieldCharacterAnimInstance
// 0x0000 (0x03E0 - 0x03E0)
class UVBlockShieldCharacterAnimInstance : public UVBlockCharacterAnimInstance
{
public:
	void OnBlockShieldHitEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

	bool HasShield() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBlockShieldCharacterAnimInstance">();
	}
	static class UVBlockShieldCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBlockShieldCharacterAnimInstance>();
	}
};
static_assert(alignof(UVBlockShieldCharacterAnimInstance) == 0x000010, "Wrong alignment on UVBlockShieldCharacterAnimInstance");
static_assert(sizeof(UVBlockShieldCharacterAnimInstance) == 0x0003E0, "Wrong size on UVBlockShieldCharacterAnimInstance");

// Class Altar.VBloodSystemVFXBlueprint
// 0x0000 (0x02A0 - 0x02A0)
class AVBloodSystemVFXBlueprint : public AVVFXBlueprint
{
public:
	void OnStartPlay(float Damages, EVBloodColor BloodColor, bool bIsUsingWeapon, class AActor* Target, const class AActor* Attacker, float TargetMaxHP, bool bDoesBeginInFirstPerson, EVHitSourceType HitSourceType, const class UStaticMeshComponent* WeaponComp, const struct FVector_NetQuantizeNormal& ImpactNormal, EVHitSourceWeaponType HitWeaponType, const struct FVector& HitDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBloodSystemVFXBlueprint">();
	}
	static class AVBloodSystemVFXBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVBloodSystemVFXBlueprint>();
	}
};
static_assert(alignof(AVBloodSystemVFXBlueprint) == 0x000008, "Wrong alignment on AVBloodSystemVFXBlueprint");
static_assert(sizeof(AVBloodSystemVFXBlueprint) == 0x0002A0, "Wrong size on AVBloodSystemVFXBlueprint");

// Class Altar.VBookFormattingSystem
// 0x0000 (0x0028 - 0x0028)
class UVBookFormattingSystem final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBookFormattingSystem">();
	}
	static class UVBookFormattingSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBookFormattingSystem>();
	}
};
static_assert(alignof(UVBookFormattingSystem) == 0x000008, "Wrong alignment on UVBookFormattingSystem");
static_assert(sizeof(UVBookFormattingSystem) == 0x000028, "Wrong size on UVBookFormattingSystem");

// Class Altar.VBookMenuViewModel
// 0x0018 (0x00E8 - 0x00D0)
class UVBookMenuViewModel final : public UVViewModelBase
{
public:
	struct FLegacyBookProperties                  Properties;                                        // 0x00D0(0x0018)(NativeAccessSpecifierPrivate)

public:
	void RegisterSendCloseButtonClicked();
	void RegisterSendTakeButtonClicked();
	void SetProperties(const struct FLegacyBookProperties& NewProperties);

	const struct FLegacyBookProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBookMenuViewModel">();
	}
	static class UVBookMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBookMenuViewModel>();
	}
};
static_assert(alignof(UVBookMenuViewModel) == 0x000008, "Wrong alignment on UVBookMenuViewModel");
static_assert(sizeof(UVBookMenuViewModel) == 0x0000E8, "Wrong size on UVBookMenuViewModel");
static_assert(offsetof(UVBookMenuViewModel, Properties) == 0x0000D0, "Member 'UVBookMenuViewModel::Properties' has a wrong offset!");

// Class Altar.VBowAttackStandSneakAnimInstance
// 0x0050 (0x03F0 - 0x03A0)
class UVBowAttackStandSneakAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	class UAnimSequenceBase*                      StartAnim;                                         // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      LoopAnim;                                          // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      ReleaseAnim;                                       // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FStandSneakBowAttackAnimSet            AnimSet;                                           // 0x03B8(0x0038)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnReleaseEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStartEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

	bool IsSneaking() const;
	bool IsStanding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBowAttackStandSneakAnimInstance">();
	}
	static class UVBowAttackStandSneakAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBowAttackStandSneakAnimInstance>();
	}
};
static_assert(alignof(UVBowAttackStandSneakAnimInstance) == 0x000010, "Wrong alignment on UVBowAttackStandSneakAnimInstance");
static_assert(sizeof(UVBowAttackStandSneakAnimInstance) == 0x0003F0, "Wrong size on UVBowAttackStandSneakAnimInstance");
static_assert(offsetof(UVBowAttackStandSneakAnimInstance, StartAnim) == 0x0003A0, "Member 'UVBowAttackStandSneakAnimInstance::StartAnim' has a wrong offset!");
static_assert(offsetof(UVBowAttackStandSneakAnimInstance, LoopAnim) == 0x0003A8, "Member 'UVBowAttackStandSneakAnimInstance::LoopAnim' has a wrong offset!");
static_assert(offsetof(UVBowAttackStandSneakAnimInstance, ReleaseAnim) == 0x0003B0, "Member 'UVBowAttackStandSneakAnimInstance::ReleaseAnim' has a wrong offset!");
static_assert(offsetof(UVBowAttackStandSneakAnimInstance, AnimSet) == 0x0003B8, "Member 'UVBowAttackStandSneakAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VBuoyancyComponent
// 0x0010 (0x0218 - 0x0208)
class UVBuoyancyComponent : public UBuoyancyComponent
{
public:
	uint8                                         Pad_208[0x10];                                     // 0x0208(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VBuoyancyComponent">();
	}
	static class UVBuoyancyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVBuoyancyComponent>();
	}
};
static_assert(alignof(UVBuoyancyComponent) == 0x000008, "Wrong alignment on UVBuoyancyComponent");
static_assert(sizeof(UVBuoyancyComponent) == 0x000218, "Wrong size on UVBuoyancyComponent");

// Class Altar.VCharacterAnimInstance
// 0x0040 (0x0390 - 0x0350)
class UVCharacterAnimInstance final : public UAnimInstance
{
public:
	class UVAnimationPairingComponent*            LinkedAnimationPairingComponent;                   // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVCharacterStatePairingComponent*       LinkedCharacterStatePairingComponent;              // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVWeaponsPairingComponent*              LinkedWeaponsPairingComponent;                     // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterType                                CharacterType;                                     // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x3];                                      // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalAxis;                                      // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalAxis;                                    // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurningAxis;                                       // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsReleaseBowShoot;                                // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBowAttack;                                        // 0x0371(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBowAttackFollowUp;                                // 0x0372(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_373[0x1];                                      // 0x0373(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SequenceIdx;                                       // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFreezeAttack;                                     // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOblivionFrameSkip;                                // 0x0379(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPowerAttack;                                    // 0x037A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOnDynamicIdle;                                  // 0x037B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOnSpecialIdle;                                  // 0x037C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldBeMoving;                                   // 0x037D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37E[0x2];                                      // 0x037E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentSpecialIdleBlendTime;                       // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSpecialIdleBlend;                               // 0x0384(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_385[0xB];                                      // 0x0385(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetBlendTimeFromSequence(class UAnimationAsset* AnimSequence);

	void OnAnimationSkip(EOblivionAnimSection Section);
	void OnAnimationStateChanged(const struct FOblivionSourcedCharacterAnimationState& OldState, const struct FOblivionSourcedCharacterAnimationState& NewState);
	void OnAttackStarted(ECharacterAttackMove AttackMove);
	void OnBlockAttack();
	void OnBlockHit();
	void OnCastSpellRanged(uint8 Arm);
	void OnCastSpellSelf(uint8 Arm);
	void OnCastSpellTouch(uint8 Arm);
	void OnDodgeBackward();
	void OnDodgeForward();
	void OnDodgeLeft();
	void OnDodgeRight();
	void OnDynamicIdleAnimationChange(class UAnimSequence* Animation);
	void OnEquipStarted();
	void OnRecoil();
	void OnSpecialIdleAnimation_WantToMove(bool ShouldBeMoving);
	void OnSpecialIdleAnimationStart(class UAnimSequenceBase* Animation);
	void OnStaggered();
	void OnUnequipStarted();
	void UpdateInternalStateMachine(const struct FOblivionSourcedCharacterAnimationState& OldState, const struct FOblivionSourcedCharacterAnimationState& NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterAnimInstance">();
	}
	static class UVCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterAnimInstance>();
	}
};
static_assert(alignof(UVCharacterAnimInstance) == 0x000010, "Wrong alignment on UVCharacterAnimInstance");
static_assert(sizeof(UVCharacterAnimInstance) == 0x000390, "Wrong size on UVCharacterAnimInstance");
static_assert(offsetof(UVCharacterAnimInstance, LinkedAnimationPairingComponent) == 0x000348, "Member 'UVCharacterAnimInstance::LinkedAnimationPairingComponent' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, LinkedCharacterStatePairingComponent) == 0x000350, "Member 'UVCharacterAnimInstance::LinkedCharacterStatePairingComponent' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, LinkedWeaponsPairingComponent) == 0x000358, "Member 'UVCharacterAnimInstance::LinkedWeaponsPairingComponent' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, CharacterType) == 0x000360, "Member 'UVCharacterAnimInstance::CharacterType' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, VerticalAxis) == 0x000364, "Member 'UVCharacterAnimInstance::VerticalAxis' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, HorizontalAxis) == 0x000368, "Member 'UVCharacterAnimInstance::HorizontalAxis' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, TurningAxis) == 0x00036C, "Member 'UVCharacterAnimInstance::TurningAxis' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, bIsReleaseBowShoot) == 0x000370, "Member 'UVCharacterAnimInstance::bIsReleaseBowShoot' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, bBowAttack) == 0x000371, "Member 'UVCharacterAnimInstance::bBowAttack' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, bBowAttackFollowUp) == 0x000372, "Member 'UVCharacterAnimInstance::bBowAttackFollowUp' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, SequenceIdx) == 0x000374, "Member 'UVCharacterAnimInstance::SequenceIdx' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, bFreezeAttack) == 0x000378, "Member 'UVCharacterAnimInstance::bFreezeAttack' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, bOblivionFrameSkip) == 0x000379, "Member 'UVCharacterAnimInstance::bOblivionFrameSkip' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, bIsPowerAttack) == 0x00037A, "Member 'UVCharacterAnimInstance::bIsPowerAttack' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, bIsOnDynamicIdle) == 0x00037B, "Member 'UVCharacterAnimInstance::bIsOnDynamicIdle' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, bIsOnSpecialIdle) == 0x00037C, "Member 'UVCharacterAnimInstance::bIsOnSpecialIdle' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, bShouldBeMoving) == 0x00037D, "Member 'UVCharacterAnimInstance::bShouldBeMoving' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, CurrentSpecialIdleBlendTime) == 0x000380, "Member 'UVCharacterAnimInstance::CurrentSpecialIdleBlendTime' has a wrong offset!");
static_assert(offsetof(UVCharacterAnimInstance, bIsSpecialIdleBlend) == 0x000384, "Member 'UVCharacterAnimInstance::bIsSpecialIdleBlend' has a wrong offset!");

// Class Altar.VCharacterBodyPairingComponent
// 0x00A8 (0x0160 - 0x00B8)
class UVCharacterBodyPairingComponent final : public UVActorPairingComponent
{
public:
	TMulticastInlineDelegate<void(EBipedModularBodySlot Slot, const struct FVCharacterBodyPartProperties& Properties)> OnBodyPartPropertiesChanged; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVModularBody                          BodyPartOverride;                                  // 0x00C8(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<EBipedModularBodySlot, struct FVCharacterBodyPartProperties> SupportedSlotsMap;             // 0x0108(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	uint32                                        BodySectionBitMask;                                // 0x0158(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TSubclassOf<class AVModularBodyPartBase> GetClassFromSlot(EBipedModularBodySlot Slot);

	void EquipFormOnSlot(EBipedModularBodySlot Slot, const class UTESForm* form);
	void RefreshBodyParts();
	void RegisterSupportedSlot(EBipedModularBodySlot Slot);
	void SetNakedOnSlot(EBipedModularBodySlot Slot);
	void SetSlotCovered(EBipedModularBodySlot Slot, bool bIsCovered);

	const class UTESForm* GetBodyPartForm(EBipedModularBodySlot Slot) const;
	struct FVCharacterBodyPartProperties GetBodyPartProperties(EBipedModularBodySlot BodySlot) const;
	TArray<EBipedModularBodySlot> GetSupportedSlots() const;
	bool IsSlotCovered(EBipedModularBodySlot Slot) const;
	bool IsSlotSupported(EBipedModularBodySlot Slot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterBodyPairingComponent">();
	}
	static class UVCharacterBodyPairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterBodyPairingComponent>();
	}
};
static_assert(alignof(UVCharacterBodyPairingComponent) == 0x000008, "Wrong alignment on UVCharacterBodyPairingComponent");
static_assert(sizeof(UVCharacterBodyPairingComponent) == 0x000160, "Wrong size on UVCharacterBodyPairingComponent");
static_assert(offsetof(UVCharacterBodyPairingComponent, OnBodyPartPropertiesChanged) == 0x0000B8, "Member 'UVCharacterBodyPairingComponent::OnBodyPartPropertiesChanged' has a wrong offset!");
static_assert(offsetof(UVCharacterBodyPairingComponent, BodyPartOverride) == 0x0000C8, "Member 'UVCharacterBodyPairingComponent::BodyPartOverride' has a wrong offset!");
static_assert(offsetof(UVCharacterBodyPairingComponent, SupportedSlotsMap) == 0x000108, "Member 'UVCharacterBodyPairingComponent::SupportedSlotsMap' has a wrong offset!");
static_assert(offsetof(UVCharacterBodyPairingComponent, BodySectionBitMask) == 0x000158, "Member 'UVCharacterBodyPairingComponent::BodySectionBitMask' has a wrong offset!");

// Class Altar.VCharacterCreationPage
// 0x0038 (0x0500 - 0x04C8)
class UVCharacterCreationPage final : public UVAltarWidget
{
public:
	struct FVector                                CharacterPreviewTargetOffset;                      // 0x04C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharacterPreviewSocketOffset;                      // 0x04E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterPreviewSpringArmLength;                   // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FC[0x4];                                      // 0x04FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterCreationPage">();
	}
	static class UVCharacterCreationPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterCreationPage>();
	}
};
static_assert(alignof(UVCharacterCreationPage) == 0x000008, "Wrong alignment on UVCharacterCreationPage");
static_assert(sizeof(UVCharacterCreationPage) == 0x000500, "Wrong size on UVCharacterCreationPage");
static_assert(offsetof(UVCharacterCreationPage, CharacterPreviewTargetOffset) == 0x0004C8, "Member 'UVCharacterCreationPage::CharacterPreviewTargetOffset' has a wrong offset!");
static_assert(offsetof(UVCharacterCreationPage, CharacterPreviewSocketOffset) == 0x0004E0, "Member 'UVCharacterCreationPage::CharacterPreviewSocketOffset' has a wrong offset!");
static_assert(offsetof(UVCharacterCreationPage, CharacterPreviewSpringArmLength) == 0x0004F8, "Member 'UVCharacterCreationPage::CharacterPreviewSpringArmLength' has a wrong offset!");

// Class Altar.VCharacterHairPiece_Eyebrows
// 0x0000 (0x0128 - 0x0128)
class UVCharacterHairPiece_Eyebrows final : public UVCharacterHairPieceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterHairPiece_Eyebrows">();
	}
	static class UVCharacterHairPiece_Eyebrows* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterHairPiece_Eyebrows>();
	}
};
static_assert(alignof(UVCharacterHairPiece_Eyebrows) == 0x000008, "Wrong alignment on UVCharacterHairPiece_Eyebrows");
static_assert(sizeof(UVCharacterHairPiece_Eyebrows) == 0x000128, "Wrong size on UVCharacterHairPiece_Eyebrows");

// Class Altar.VCharacterHairPiece_Mustache
// 0x0000 (0x0128 - 0x0128)
class UVCharacterHairPiece_Mustache final : public UVCharacterHairPieceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterHairPiece_Mustache">();
	}
	static class UVCharacterHairPiece_Mustache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterHairPiece_Mustache>();
	}
};
static_assert(alignof(UVCharacterHairPiece_Mustache) == 0x000008, "Wrong alignment on UVCharacterHairPiece_Mustache");
static_assert(sizeof(UVCharacterHairPiece_Mustache) == 0x000128, "Wrong size on UVCharacterHairPiece_Mustache");

// Class Altar.VCharacterHairPiece_Beard
// 0x0000 (0x0128 - 0x0128)
class UVCharacterHairPiece_Beard final : public UVCharacterHairPieceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterHairPiece_Beard">();
	}
	static class UVCharacterHairPiece_Beard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterHairPiece_Beard>();
	}
};
static_assert(alignof(UVCharacterHairPiece_Beard) == 0x000008, "Wrong alignment on UVCharacterHairPiece_Beard");
static_assert(sizeof(UVCharacterHairPiece_Beard) == 0x000128, "Wrong size on UVCharacterHairPiece_Beard");

// Class Altar.VSettingsMenuViewModel
// 0x0008 (0x00D8 - 0x00D0)
class UVSettingsMenuViewModel final : public UVViewModelBase
{
public:
	int32                                         CurrentPageIndex;                                  // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendClickedButton(ELegacySettingsMenuIDs InButtonIndex);
	void RegisterSendGameDifficulty();
	void RegisterSendGameplaySaveSettings();
	void SetPageIndex(int32 NewPageIndex);

	class FText GetBuildInfo() const;
	int32 GetPageIndex() const;
	bool ThisIsForPluginCompliance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSettingsMenuViewModel">();
	}
	static class UVSettingsMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSettingsMenuViewModel>();
	}
};
static_assert(alignof(UVSettingsMenuViewModel) == 0x000008, "Wrong alignment on UVSettingsMenuViewModel");
static_assert(sizeof(UVSettingsMenuViewModel) == 0x0000D8, "Wrong size on UVSettingsMenuViewModel");
static_assert(offsetof(UVSettingsMenuViewModel, CurrentPageIndex) == 0x0000D0, "Member 'UVSettingsMenuViewModel::CurrentPageIndex' has a wrong offset!");

// Class Altar.VCharacterFaceMorphsSource
// 0x0058 (0x0088 - 0x0030)
class UVCharacterFaceMorphsSource final : public UDataAsset
{
public:
	class UVOblivionToAltarFaceMorphsConversionMap* OblivionFaceMorphsConversionMap;                 // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FCharacterFaceMorphAxis> MorphAxisMap;                                  // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterFaceMorphsSource">();
	}
	static class UVCharacterFaceMorphsSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterFaceMorphsSource>();
	}
};
static_assert(alignof(UVCharacterFaceMorphsSource) == 0x000008, "Wrong alignment on UVCharacterFaceMorphsSource");
static_assert(sizeof(UVCharacterFaceMorphsSource) == 0x000088, "Wrong size on UVCharacterFaceMorphsSource");
static_assert(offsetof(UVCharacterFaceMorphsSource, OblivionFaceMorphsConversionMap) == 0x000030, "Member 'UVCharacterFaceMorphsSource::OblivionFaceMorphsConversionMap' has a wrong offset!");
static_assert(offsetof(UVCharacterFaceMorphsSource, MorphAxisMap) == 0x000038, "Member 'UVCharacterFaceMorphsSource::MorphAxisMap' has a wrong offset!");

// Class Altar.VCharacterSkinParameterDefinitions
// 0x0140 (0x0170 - 0x0030)
class UVCharacterSkinParameterDefinitions final : public UDataAsset
{
public:
	TMap<class FName, struct FVCharacterSkinParameter> FaceSkinParameterIndexesMap;                  // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVCharacterSkinParameter> BodySkinParameterIndexesMap;                  // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVCharacterSkinParameter> HairColorParameterIndexesMap;                 // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      FaceMaterialSlotIndexesMap;                        // 0x0120(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterSkinParameterDefinitions">();
	}
	static class UVCharacterSkinParameterDefinitions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterSkinParameterDefinitions>();
	}
};
static_assert(alignof(UVCharacterSkinParameterDefinitions) == 0x000008, "Wrong alignment on UVCharacterSkinParameterDefinitions");
static_assert(sizeof(UVCharacterSkinParameterDefinitions) == 0x000170, "Wrong size on UVCharacterSkinParameterDefinitions");
static_assert(offsetof(UVCharacterSkinParameterDefinitions, FaceSkinParameterIndexesMap) == 0x000030, "Member 'UVCharacterSkinParameterDefinitions::FaceSkinParameterIndexesMap' has a wrong offset!");
static_assert(offsetof(UVCharacterSkinParameterDefinitions, BodySkinParameterIndexesMap) == 0x000080, "Member 'UVCharacterSkinParameterDefinitions::BodySkinParameterIndexesMap' has a wrong offset!");
static_assert(offsetof(UVCharacterSkinParameterDefinitions, HairColorParameterIndexesMap) == 0x0000D0, "Member 'UVCharacterSkinParameterDefinitions::HairColorParameterIndexesMap' has a wrong offset!");
static_assert(offsetof(UVCharacterSkinParameterDefinitions, FaceMaterialSlotIndexesMap) == 0x000120, "Member 'UVCharacterSkinParameterDefinitions::FaceMaterialSlotIndexesMap' has a wrong offset!");

// Class Altar.VCharacterFadeInOutComponent
// 0x0040 (0x00E0 - 0x00A0)
class UVCharacterFadeInOutComponent final : public UActorComponent
{
public:
	bool                                          bIsOwnerCamera;                                    // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x1F];                                      // 0x00A1(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	ECharacterFadeState                           FadeState;                                         // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMeshComponent*>                 CharacterMeshComponents;                           // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AActor*                                 CurrentActorBetweenCamAndPlayer;                   // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetDitherOnCharacterVisibleComponents(class AVPairedCharacter* PairedCharacter, bool bDoDither, float DitherScale);
	void SetDitherOnCreatureVisibleComponents(class AVPairedCreature* PairedCreature, bool bDoDither, float DitherScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterFadeInOutComponent">();
	}
	static class UVCharacterFadeInOutComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterFadeInOutComponent>();
	}
};
static_assert(alignof(UVCharacterFadeInOutComponent) == 0x000008, "Wrong alignment on UVCharacterFadeInOutComponent");
static_assert(sizeof(UVCharacterFadeInOutComponent) == 0x0000E0, "Wrong size on UVCharacterFadeInOutComponent");
static_assert(offsetof(UVCharacterFadeInOutComponent, bIsOwnerCamera) == 0x0000A0, "Member 'UVCharacterFadeInOutComponent::bIsOwnerCamera' has a wrong offset!");
static_assert(offsetof(UVCharacterFadeInOutComponent, FadeState) == 0x0000C0, "Member 'UVCharacterFadeInOutComponent::FadeState' has a wrong offset!");
static_assert(offsetof(UVCharacterFadeInOutComponent, CharacterMeshComponents) == 0x0000C8, "Member 'UVCharacterFadeInOutComponent::CharacterMeshComponents' has a wrong offset!");
static_assert(offsetof(UVCharacterFadeInOutComponent, CurrentActorBetweenCamAndPlayer) == 0x0000D8, "Member 'UVCharacterFadeInOutComponent::CurrentActorBetweenCamAndPlayer' has a wrong offset!");

// Class Altar.VCharacterStatePairingComponent
// 0x00D8 (0x0190 - 0x00B8)
class UVCharacterStatePairingComponent final : public UVActorPairingComponent
{
public:
	TMulticastInlineDelegate<void(const struct FPairedOblivionHitEvent& HitEvent)> OnHitActor;       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FPairedOblivionHitEvent& HitEvent)> OnHitTaken;       // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMiss;                                            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UVAnimationPairingComponent*            LinkedAnimationPairingComponent;                   // 0x00E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVWeaponsPairingComponent*              LinkedWeaponsPairingComponent;                     // 0x00F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSwimming;                                       // 0x00F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumping;                                        // 0x00FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x00FB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSneaking;                                       // 0x00FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDodging;                                        // 0x00FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlocking;                                       // 0x00FE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStaggered;                                      // 0x00FF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVCastType                                    SpellCastType;                                     // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasTorchEquipped;                                 // 0x0101(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPairedOblivionHitEvent                LatestHitTaken;                                    // 0x0108(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPairedOblivionHitEvent                LatestHitInflicted;                                // 0x0140(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewGhostState)> OnGhostStateChanged;                          // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsGhost;                                          // 0x0188(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateAnimationState(const class AVWeapon* WeaponActor);
	void UpdateInternalStateMachine(const struct FOblivionSourcedCharacterAnimationState& OldState, const struct FOblivionSourcedCharacterAnimationState& NewState);

	bool IsGhost() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCharacterStatePairingComponent">();
	}
	static class UVCharacterStatePairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCharacterStatePairingComponent>();
	}
};
static_assert(alignof(UVCharacterStatePairingComponent) == 0x000008, "Wrong alignment on UVCharacterStatePairingComponent");
static_assert(sizeof(UVCharacterStatePairingComponent) == 0x000190, "Wrong size on UVCharacterStatePairingComponent");
static_assert(offsetof(UVCharacterStatePairingComponent, OnHitActor) == 0x0000B8, "Member 'UVCharacterStatePairingComponent::OnHitActor' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, OnHitTaken) == 0x0000C8, "Member 'UVCharacterStatePairingComponent::OnHitTaken' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, OnMiss) == 0x0000D8, "Member 'UVCharacterStatePairingComponent::OnMiss' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, LinkedAnimationPairingComponent) == 0x0000E8, "Member 'UVCharacterStatePairingComponent::LinkedAnimationPairingComponent' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, LinkedWeaponsPairingComponent) == 0x0000F0, "Member 'UVCharacterStatePairingComponent::LinkedWeaponsPairingComponent' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, bIsRunning) == 0x0000F8, "Member 'UVCharacterStatePairingComponent::bIsRunning' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, bIsSwimming) == 0x0000F9, "Member 'UVCharacterStatePairingComponent::bIsSwimming' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, bIsJumping) == 0x0000FA, "Member 'UVCharacterStatePairingComponent::bIsJumping' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, bIsFalling) == 0x0000FB, "Member 'UVCharacterStatePairingComponent::bIsFalling' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, bIsSneaking) == 0x0000FC, "Member 'UVCharacterStatePairingComponent::bIsSneaking' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, bIsDodging) == 0x0000FD, "Member 'UVCharacterStatePairingComponent::bIsDodging' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, bIsBlocking) == 0x0000FE, "Member 'UVCharacterStatePairingComponent::bIsBlocking' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, bIsStaggered) == 0x0000FF, "Member 'UVCharacterStatePairingComponent::bIsStaggered' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, SpellCastType) == 0x000100, "Member 'UVCharacterStatePairingComponent::SpellCastType' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, bHasTorchEquipped) == 0x000101, "Member 'UVCharacterStatePairingComponent::bHasTorchEquipped' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, LatestHitTaken) == 0x000108, "Member 'UVCharacterStatePairingComponent::LatestHitTaken' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, LatestHitInflicted) == 0x000140, "Member 'UVCharacterStatePairingComponent::LatestHitInflicted' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, OnGhostStateChanged) == 0x000178, "Member 'UVCharacterStatePairingComponent::OnGhostStateChanged' has a wrong offset!");
static_assert(offsetof(UVCharacterStatePairingComponent, bIsGhost) == 0x000188, "Member 'UVCharacterStatePairingComponent::bIsGhost' has a wrong offset!");

// Class Altar.VClairvoyanceNavLinkCustomComponent
// 0x0000 (0x01E0 - 0x01E0)
class UVClairvoyanceNavLinkCustomComponent final : public UNavLinkCustomComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VClairvoyanceNavLinkCustomComponent">();
	}
	static class UVClairvoyanceNavLinkCustomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVClairvoyanceNavLinkCustomComponent>();
	}
};
static_assert(alignof(UVClairvoyanceNavLinkCustomComponent) == 0x000008, "Wrong alignment on UVClairvoyanceNavLinkCustomComponent");
static_assert(sizeof(UVClairvoyanceNavLinkCustomComponent) == 0x0001E0, "Wrong size on UVClairvoyanceNavLinkCustomComponent");

// Class Altar.VClairvoyanceNavLinkProxy
// 0x0000 (0x02E8 - 0x02E8)
class AVClairvoyanceNavLinkProxy final : public ANavLinkProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VClairvoyanceNavLinkProxy">();
	}
	static class AVClairvoyanceNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVClairvoyanceNavLinkProxy>();
	}
};
static_assert(alignof(AVClairvoyanceNavLinkProxy) == 0x000008, "Wrong alignment on AVClairvoyanceNavLinkProxy");
static_assert(sizeof(AVClairvoyanceNavLinkProxy) == 0x0002E8, "Wrong size on AVClairvoyanceNavLinkProxy");

// Class Altar.VSkillInfoObject
// 0x0020 (0x0048 - 0x0028)
class UVSkillInfoObject final : public UObject
{
public:
	struct FSkillInformation                      Properties;                                        // 0x0028(0x0020)(NativeAccessSpecifierPrivate)

public:
	void SetProperties(const struct FSkillInformation& NewProperties);

	const struct FSkillInformation GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSkillInfoObject">();
	}
	static class UVSkillInfoObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSkillInfoObject>();
	}
};
static_assert(alignof(UVSkillInfoObject) == 0x000008, "Wrong alignment on UVSkillInfoObject");
static_assert(sizeof(UVSkillInfoObject) == 0x000048, "Wrong size on UVSkillInfoObject");
static_assert(offsetof(UVSkillInfoObject, Properties) == 0x000028, "Member 'UVSkillInfoObject::Properties' has a wrong offset!");

// Class Altar.VClassMenuViewModel
// 0x0018 (0x00E8 - 0x00D0)
class UVClassMenuViewModel final : public UVViewModelBase
{
public:
	TArray<struct FPlayerClassItemProperties>     ClassList;                                         // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         FirstSelectedClassIndex;                           // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendClickedCreateButtonHandler();
	void RegisterSendClickedDoneButtonHandler();
	void RegisterSendClickedItemHandler(int32 InButtonIndex);
	void RegisterSendOnHoveredItemHandler(int32 InButtonIndex);
	void SetFirstSelectedClassIndex(int32 NewFirstSelectedClassIndex);

	const TArray<struct FPlayerClassItemProperties> GetClassList() const;
	int32 GetFirstSelectedClassIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VClassMenuViewModel">();
	}
	static class UVClassMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVClassMenuViewModel>();
	}
};
static_assert(alignof(UVClassMenuViewModel) == 0x000008, "Wrong alignment on UVClassMenuViewModel");
static_assert(sizeof(UVClassMenuViewModel) == 0x0000E8, "Wrong size on UVClassMenuViewModel");
static_assert(offsetof(UVClassMenuViewModel, ClassList) == 0x0000D0, "Member 'UVClassMenuViewModel::ClassList' has a wrong offset!");
static_assert(offsetof(UVClassMenuViewModel, FirstSelectedClassIndex) == 0x0000E0, "Member 'UVClassMenuViewModel::FirstSelectedClassIndex' has a wrong offset!");

// Class Altar.VCodexMenu
// 0x0008 (0x04F8 - 0x04F0)
class UVCodexMenu final : public UVLegacyPlayerSubMenuBase
{
public:
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCodexMenu">();
	}
	static class UVCodexMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCodexMenu>();
	}
};
static_assert(alignof(UVCodexMenu) == 0x000008, "Wrong alignment on UVCodexMenu");
static_assert(sizeof(UVCodexMenu) == 0x0004F8, "Wrong size on UVCodexMenu");

// Class Altar.VModernSaveLoadMenuItem
// 0x00B8 (0x00E0 - 0x0028)
class UVModernSaveLoadMenuItem final : public UObject
{
public:
	TMap<class FString, struct FVSaveGameDetails> AssignedSaves;                                     // 0x0028(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bNewExpanded)> OnExpandedStateChanged;                        // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0088(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	class FText                                   TimeText;                                          // 0x00A0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	class FString                                 SavePlayerName;                                    // 0x00B8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SaveGameSlot;                                      // 0x00C8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSectionHeader;                                  // 0x00D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInSaveMenu;                                     // 0x00D9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsExpanded;                                       // 0x00DA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAchievementDisabled;                            // 0x00DB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsAchievementDisabled(const bool InNewBool);
	void SetIsExpanded(const bool InNewBool);
	void SetIsInSaveMenu(const bool InNewBool);
	void SetIsSectionHeader(const bool InNewBool);
	void SetPlayerName(const class FString& NewPlayerName);
	void SetSlotName(const class FString& NewSlotName);
	void SetText(const class FText& Value);
	void SetTimeText(const class FText& Value);

	bool GetIsAchievementDisabled() const;
	bool GetIsExpanded() const;
	bool GetIsInSaveMenu() const;
	bool GetIsOnExpandedBound() const;
	bool GetIsSectionHeader() const;
	class FString GetPlayerName() const;
	class FString GetSlotName() const;
	const class FText GetText() const;
	const class FText GetTimeText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernSaveLoadMenuItem">();
	}
	static class UVModernSaveLoadMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernSaveLoadMenuItem>();
	}
};
static_assert(alignof(UVModernSaveLoadMenuItem) == 0x000008, "Wrong alignment on UVModernSaveLoadMenuItem");
static_assert(sizeof(UVModernSaveLoadMenuItem) == 0x0000E0, "Wrong size on UVModernSaveLoadMenuItem");
static_assert(offsetof(UVModernSaveLoadMenuItem, AssignedSaves) == 0x000028, "Member 'UVModernSaveLoadMenuItem::AssignedSaves' has a wrong offset!");
static_assert(offsetof(UVModernSaveLoadMenuItem, OnExpandedStateChanged) == 0x000078, "Member 'UVModernSaveLoadMenuItem::OnExpandedStateChanged' has a wrong offset!");
static_assert(offsetof(UVModernSaveLoadMenuItem, Text) == 0x000088, "Member 'UVModernSaveLoadMenuItem::Text' has a wrong offset!");
static_assert(offsetof(UVModernSaveLoadMenuItem, TimeText) == 0x0000A0, "Member 'UVModernSaveLoadMenuItem::TimeText' has a wrong offset!");
static_assert(offsetof(UVModernSaveLoadMenuItem, SavePlayerName) == 0x0000B8, "Member 'UVModernSaveLoadMenuItem::SavePlayerName' has a wrong offset!");
static_assert(offsetof(UVModernSaveLoadMenuItem, SaveGameSlot) == 0x0000C8, "Member 'UVModernSaveLoadMenuItem::SaveGameSlot' has a wrong offset!");
static_assert(offsetof(UVModernSaveLoadMenuItem, bIsSectionHeader) == 0x0000D8, "Member 'UVModernSaveLoadMenuItem::bIsSectionHeader' has a wrong offset!");
static_assert(offsetof(UVModernSaveLoadMenuItem, bIsInSaveMenu) == 0x0000D9, "Member 'UVModernSaveLoadMenuItem::bIsInSaveMenu' has a wrong offset!");
static_assert(offsetof(UVModernSaveLoadMenuItem, bIsExpanded) == 0x0000DA, "Member 'UVModernSaveLoadMenuItem::bIsExpanded' has a wrong offset!");
static_assert(offsetof(UVModernSaveLoadMenuItem, bIsAchievementDisabled) == 0x0000DB, "Member 'UVModernSaveLoadMenuItem::bIsAchievementDisabled' has a wrong offset!");

// Class Altar.VCodexMenuPage
// 0x0000 (0x04C8 - 0x04C8)
class UVCodexMenuPage final : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VCodexMenuPage">();
	}
	static class UVCodexMenuPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVCodexMenuPage>();
	}
};
static_assert(alignof(UVCodexMenuPage) == 0x000008, "Wrong alignment on UVCodexMenuPage");
static_assert(sizeof(UVCodexMenuPage) == 0x0004C8, "Wrong size on UVCodexMenuPage");

// Class Altar.VContainerMenuViewModel
// 0x0078 (0x01B0 - 0x0138)
class UVContainerMenuViewModel final : public UVInventoryMenuViewModel
{
public:
	TMulticastInlineDelegate<void(const bool bDoBuy)> OnPlayTransactionSound;                        // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const bool bIsDelayed)> OnPlayOpenAnimation;                       // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<struct FOriginalInventoryMenuItemProperties> ContainerItems;                              // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FLegacyContainerMenuButtonData         ButtonData;                                        // 0x0168(0x0002)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16A[0x6];                                      // 0x016A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyContainerMenuNpcData            NpcData;                                           // 0x0170(0x0020)(NativeAccessSpecifierPrivate)
	ELegacyContainerMenuType                      MenuType;                                          // 0x0190(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELegacyContainerMenuTab                       CurrentTab;                                        // 0x0191(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_192[0x6];                                      // 0x0192(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOriginalInventoryMenuItemProperties> CurrentPageItemsContainer;                   // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	ELegacyInventoryMenuPage                      CurrentPageContainer;                              // 0x01A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOriginalInventoryMenuSortType                SortTypeContainer;                                 // 0x01A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSortReversedContainer;                          // 0x01AA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSimpleContainer;                                // 0x01AB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendButtonExitHandler();
	void RegisterSendButtonHaggleHandler();
	void RegisterSendButtonSwitchToContainerHandler(bool ForceSwitch);
	void RegisterSendButtonSwitchToInventoryHandler(bool ForceSwitch);
	void RegisterSendButtonTakeAllHandler();
	void ReplaceCurrentPageItemsContainer(const TArray<struct FOriginalInventoryMenuItemProperties>& NewPageContainer);
	void SetButtonData(const struct FLegacyContainerMenuButtonData& NewButtonData);
	void SetContainerItems(const TArray<struct FOriginalInventoryMenuItemProperties>& NewContainerItems);
	void SetCurrentPageContainer(ELegacyInventoryMenuPage NewPage);
	void SetCurrentTab(ELegacyContainerMenuTab NewMenuTab);
	void SetIsSimpleContainer(bool bNewIsSimpleContainer);
	void SetIsSortReversedContainer(bool bNewIsSortReversedContainer);
	void SetMenuType(ELegacyContainerMenuType NewMenuType);
	void SetNpcData(const struct FLegacyContainerMenuNpcData& NewNPCData);
	void SetSortTypeContainer(const EOriginalInventoryMenuSortType& NewSortTypeContainer);

	const struct FLegacyContainerMenuButtonData GetButtonData() const;
	const TArray<struct FOriginalInventoryMenuItemProperties> GetContainerItems() const;
	ELegacyInventoryMenuPage GetCurrentPageContainer() const;
	const TArray<struct FOriginalInventoryMenuItemProperties> GetCurrentPageItemsContainer() const;
	ELegacyContainerMenuTab GetCurrentTab() const;
	bool GetIsSimpleContainer() const;
	bool GetIsSortReversedContainer() const;
	ELegacyContainerMenuType GetMenuType() const;
	const struct FLegacyContainerMenuNpcData GetNpcData() const;
	EOriginalInventoryMenuSortType GetSortTypeContainer() const;
	bool IsContainerTab() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VContainerMenuViewModel">();
	}
	static class UVContainerMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVContainerMenuViewModel>();
	}
};
static_assert(alignof(UVContainerMenuViewModel) == 0x000008, "Wrong alignment on UVContainerMenuViewModel");
static_assert(sizeof(UVContainerMenuViewModel) == 0x0001B0, "Wrong size on UVContainerMenuViewModel");
static_assert(offsetof(UVContainerMenuViewModel, OnPlayTransactionSound) == 0x000138, "Member 'UVContainerMenuViewModel::OnPlayTransactionSound' has a wrong offset!");
static_assert(offsetof(UVContainerMenuViewModel, OnPlayOpenAnimation) == 0x000148, "Member 'UVContainerMenuViewModel::OnPlayOpenAnimation' has a wrong offset!");
static_assert(offsetof(UVContainerMenuViewModel, ContainerItems) == 0x000158, "Member 'UVContainerMenuViewModel::ContainerItems' has a wrong offset!");
static_assert(offsetof(UVContainerMenuViewModel, ButtonData) == 0x000168, "Member 'UVContainerMenuViewModel::ButtonData' has a wrong offset!");
static_assert(offsetof(UVContainerMenuViewModel, NpcData) == 0x000170, "Member 'UVContainerMenuViewModel::NpcData' has a wrong offset!");
static_assert(offsetof(UVContainerMenuViewModel, MenuType) == 0x000190, "Member 'UVContainerMenuViewModel::MenuType' has a wrong offset!");
static_assert(offsetof(UVContainerMenuViewModel, CurrentTab) == 0x000191, "Member 'UVContainerMenuViewModel::CurrentTab' has a wrong offset!");
static_assert(offsetof(UVContainerMenuViewModel, CurrentPageItemsContainer) == 0x000198, "Member 'UVContainerMenuViewModel::CurrentPageItemsContainer' has a wrong offset!");
static_assert(offsetof(UVContainerMenuViewModel, CurrentPageContainer) == 0x0001A8, "Member 'UVContainerMenuViewModel::CurrentPageContainer' has a wrong offset!");
static_assert(offsetof(UVContainerMenuViewModel, SortTypeContainer) == 0x0001A9, "Member 'UVContainerMenuViewModel::SortTypeContainer' has a wrong offset!");
static_assert(offsetof(UVContainerMenuViewModel, bIsSortReversedContainer) == 0x0001AA, "Member 'UVContainerMenuViewModel::bIsSortReversedContainer' has a wrong offset!");
static_assert(offsetof(UVContainerMenuViewModel, bIsSimpleContainer) == 0x0001AB, "Member 'UVContainerMenuViewModel::bIsSimpleContainer' has a wrong offset!");

// Class Altar.VConversationIdleAnimInstance
// 0x0050 (0x03F0 - 0x03A0)
class UVConversationIdleAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	struct FConversationIdleData                  LayerData;                                         // 0x03A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CurrentAnimation;                                  // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanPlayAnimation;                                  // 0x03C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x03CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x20];                                     // 0x03D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsInDialogue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VConversationIdleAnimInstance">();
	}
	static class UVConversationIdleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVConversationIdleAnimInstance>();
	}
};
static_assert(alignof(UVConversationIdleAnimInstance) == 0x000010, "Wrong alignment on UVConversationIdleAnimInstance");
static_assert(sizeof(UVConversationIdleAnimInstance) == 0x0003F0, "Wrong size on UVConversationIdleAnimInstance");
static_assert(offsetof(UVConversationIdleAnimInstance, LayerData) == 0x0003A0, "Member 'UVConversationIdleAnimInstance::LayerData' has a wrong offset!");
static_assert(offsetof(UVConversationIdleAnimInstance, CurrentAnimation) == 0x0003C0, "Member 'UVConversationIdleAnimInstance::CurrentAnimation' has a wrong offset!");
static_assert(offsetof(UVConversationIdleAnimInstance, CanPlayAnimation) == 0x0003C8, "Member 'UVConversationIdleAnimInstance::CanPlayAnimation' has a wrong offset!");
static_assert(offsetof(UVConversationIdleAnimInstance, PlayRate) == 0x0003CC, "Member 'UVConversationIdleAnimInstance::PlayRate' has a wrong offset!");

// Class Altar.VDamageLogSubsystem
// 0x0000 (0x0030 - 0x0030)
class UVDamageLogSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDamageLogSubsystem">();
	}
	static class UVDamageLogSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDamageLogSubsystem>();
	}
};
static_assert(alignof(UVDamageLogSubsystem) == 0x000008, "Wrong alignment on UVDamageLogSubsystem");
static_assert(sizeof(UVDamageLogSubsystem) == 0x000030, "Wrong size on UVDamageLogSubsystem");

// Class Altar.VDeathVFXBlueprint
// 0x0000 (0x02A0 - 0x02A0)
class AVDeathVFXBlueprint final : public AVVFXBlueprint
{
public:
	void OnStartPlay(class AVPairedPawn* Pawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDeathVFXBlueprint">();
	}
	static class AVDeathVFXBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVDeathVFXBlueprint>();
	}
};
static_assert(alignof(AVDeathVFXBlueprint) == 0x000008, "Wrong alignment on AVDeathVFXBlueprint");
static_assert(sizeof(AVDeathVFXBlueprint) == 0x0002A0, "Wrong size on AVDeathVFXBlueprint");

// Class Altar.VOriginalVideoSettingWidget
// 0x0030 (0x04F8 - 0x04C8)
class UVOriginalVideoSettingWidget : public UVAltarWidget
{
public:
	class FText                                   Label;                                             // 0x04C8(0x0018)(BlueprintVisible, NativeAccessSpecifierPrivate)
	TArray<struct FOriginalVideoOption>           Options;                                           // 0x04E0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FFloatInterval                         ExtremalValue;                                     // 0x04F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRefresh();
	void SetExtremalValue(const struct FFloatInterval& Value);
	void SetLabel(const class FText& Value);
	void SetOptions(const TArray<struct FOriginalVideoOption>& Value);

	const struct FFloatInterval GetExtremalValue() const;
	const class FText GetLabel() const;
	const TArray<struct FOriginalVideoOption> GetOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOriginalVideoSettingWidget">();
	}
	static class UVOriginalVideoSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOriginalVideoSettingWidget>();
	}
};
static_assert(alignof(UVOriginalVideoSettingWidget) == 0x000008, "Wrong alignment on UVOriginalVideoSettingWidget");
static_assert(sizeof(UVOriginalVideoSettingWidget) == 0x0004F8, "Wrong size on UVOriginalVideoSettingWidget");
static_assert(offsetof(UVOriginalVideoSettingWidget, Label) == 0x0004C8, "Member 'UVOriginalVideoSettingWidget::Label' has a wrong offset!");
static_assert(offsetof(UVOriginalVideoSettingWidget, Options) == 0x0004E0, "Member 'UVOriginalVideoSettingWidget::Options' has a wrong offset!");
static_assert(offsetof(UVOriginalVideoSettingWidget, ExtremalValue) == 0x0004F0, "Member 'UVOriginalVideoSettingWidget::ExtremalValue' has a wrong offset!");

// Class Altar.VDebugGraphicsSettingWidget
// 0x0008 (0x0500 - 0x04F8)
class UVDebugGraphicsSettingWidget : public UVOriginalVideoSettingWidget
{
public:
	class UWidget*                                ParentWidget;                                      // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BindRefreshDelegate();
	void RefreshMenuOptions();

	void AddConsoleCommandToSave(const class FString& Command) const;
	const int32 HardwareRayTracingLightingMode() const;
	const bool IsHardrwareRayTracingOn() const;
	const bool IsHardwareRayTracingSupportedByBuild() const;
	const bool IsHardwareRayTracingSupportedByHardware() const;
	const int32 SoftwareRaytracingQuality() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDebugGraphicsSettingWidget">();
	}
	static class UVDebugGraphicsSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDebugGraphicsSettingWidget>();
	}
};
static_assert(alignof(UVDebugGraphicsSettingWidget) == 0x000008, "Wrong alignment on UVDebugGraphicsSettingWidget");
static_assert(sizeof(UVDebugGraphicsSettingWidget) == 0x000500, "Wrong size on UVDebugGraphicsSettingWidget");
static_assert(offsetof(UVDebugGraphicsSettingWidget, ParentWidget) == 0x0004F8, "Member 'UVDebugGraphicsSettingWidget::ParentWidget' has a wrong offset!");

// Class Altar.VDetectionLightingFakeSpotLightComponent
// 0x0000 (0x0440 - 0x0440)
class UVDetectionLightingFakeSpotLightComponent final : public USpotLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDetectionLightingFakeSpotLightComponent">();
	}
	static class UVDetectionLightingFakeSpotLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDetectionLightingFakeSpotLightComponent>();
	}
};
static_assert(alignof(UVDetectionLightingFakeSpotLightComponent) == 0x000010, "Wrong alignment on UVDetectionLightingFakeSpotLightComponent");
static_assert(sizeof(UVDetectionLightingFakeSpotLightComponent) == 0x000440, "Wrong size on UVDetectionLightingFakeSpotLightComponent");

// Class Altar.VDetectionLightingProfile
// 0x0048 (0x0078 - 0x0030)
class UVDetectionLightingProfile final : public UDataAsset
{
public:
	bool                                          bIsIgnoredForDetection;                            // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelfCollision;                              // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideObstructionLogic;                         // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeObstructed;                                  // 0x0033(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObstructionMultiplier;                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InverseSquaredFalloffAttenuationRadiusMultiplier;  // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCurveForIntensityOverride;                     // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LightIntensityOverTimeOverride;                    // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightIntensityOverride;                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCurveForIntensityMultiplier;                   // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LightIntensityMultiplierOverTime;                  // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightIntensityMultiplier;                          // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSourceRadiusForDistanceAttenuation;         // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DistanceAttenuationOverride;                       // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreInnerConeForAngularAttenuation;             // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AngularAttenuationOverride;                        // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDetectionLightingProfile">();
	}
	static class UVDetectionLightingProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDetectionLightingProfile>();
	}
};
static_assert(alignof(UVDetectionLightingProfile) == 0x000008, "Wrong alignment on UVDetectionLightingProfile");
static_assert(sizeof(UVDetectionLightingProfile) == 0x000078, "Wrong size on UVDetectionLightingProfile");
static_assert(offsetof(UVDetectionLightingProfile, bIsIgnoredForDetection) == 0x000030, "Member 'UVDetectionLightingProfile::bIsIgnoredForDetection' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, bIgnoreSelfCollision) == 0x000031, "Member 'UVDetectionLightingProfile::bIgnoreSelfCollision' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, bOverrideObstructionLogic) == 0x000032, "Member 'UVDetectionLightingProfile::bOverrideObstructionLogic' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, bCanBeObstructed) == 0x000033, "Member 'UVDetectionLightingProfile::bCanBeObstructed' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, ObstructionMultiplier) == 0x000034, "Member 'UVDetectionLightingProfile::ObstructionMultiplier' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, InverseSquaredFalloffAttenuationRadiusMultiplier) == 0x000038, "Member 'UVDetectionLightingProfile::InverseSquaredFalloffAttenuationRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, bUseCurveForIntensityOverride) == 0x00003C, "Member 'UVDetectionLightingProfile::bUseCurveForIntensityOverride' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, LightIntensityOverTimeOverride) == 0x000040, "Member 'UVDetectionLightingProfile::LightIntensityOverTimeOverride' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, LightIntensityOverride) == 0x000048, "Member 'UVDetectionLightingProfile::LightIntensityOverride' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, bUseCurveForIntensityMultiplier) == 0x00004C, "Member 'UVDetectionLightingProfile::bUseCurveForIntensityMultiplier' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, LightIntensityMultiplierOverTime) == 0x000050, "Member 'UVDetectionLightingProfile::LightIntensityMultiplierOverTime' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, LightIntensityMultiplier) == 0x000058, "Member 'UVDetectionLightingProfile::LightIntensityMultiplier' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, bIgnoreSourceRadiusForDistanceAttenuation) == 0x00005C, "Member 'UVDetectionLightingProfile::bIgnoreSourceRadiusForDistanceAttenuation' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, DistanceAttenuationOverride) == 0x000060, "Member 'UVDetectionLightingProfile::DistanceAttenuationOverride' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, bIgnoreInnerConeForAngularAttenuation) == 0x000068, "Member 'UVDetectionLightingProfile::bIgnoreInnerConeForAngularAttenuation' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingProfile, AngularAttenuationOverride) == 0x000070, "Member 'UVDetectionLightingProfile::AngularAttenuationOverride' has a wrong offset!");

// Class Altar.VDetectionLightingProfileComponent
// 0x0010 (0x02B0 - 0x02A0)
class UVDetectionLightingProfileComponent final : public USceneComponent
{
public:
	class UVDetectionLightingProfile*             DetectionLightingProfile;                          // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDetectionLightingProfileComponent">();
	}
	static class UVDetectionLightingProfileComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDetectionLightingProfileComponent>();
	}
};
static_assert(alignof(UVDetectionLightingProfileComponent) == 0x000010, "Wrong alignment on UVDetectionLightingProfileComponent");
static_assert(sizeof(UVDetectionLightingProfileComponent) == 0x0002B0, "Wrong size on UVDetectionLightingProfileComponent");
static_assert(offsetof(UVDetectionLightingProfileComponent, DetectionLightingProfile) == 0x0002A0, "Member 'UVDetectionLightingProfileComponent::DetectionLightingProfile' has a wrong offset!");

// Class Altar.VLegacyStatsMenuFaction
// 0x0058 (0x0080 - 0x0028)
class UVLegacyStatsMenuFaction final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFaction(const struct FLegacyStatsMenuFactionProperties& Value);

	const struct FLegacyStatsMenuFactionProperties GetFaction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyStatsMenuFaction">();
	}
	static class UVLegacyStatsMenuFaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyStatsMenuFaction>();
	}
};
static_assert(alignof(UVLegacyStatsMenuFaction) == 0x000008, "Wrong alignment on UVLegacyStatsMenuFaction");
static_assert(sizeof(UVLegacyStatsMenuFaction) == 0x000080, "Wrong size on UVLegacyStatsMenuFaction");

// Class Altar.VDetectionLightingSkylight
// 0x0008 (0x02A0 - 0x0298)
class AVDetectionLightingSkylight final : public AActor
{
public:
	class UCurveFloat*                            SkylightIntensityCurve;                            // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDetectionLightingSkylight">();
	}
	static class AVDetectionLightingSkylight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVDetectionLightingSkylight>();
	}
};
static_assert(alignof(AVDetectionLightingSkylight) == 0x000008, "Wrong alignment on AVDetectionLightingSkylight");
static_assert(sizeof(AVDetectionLightingSkylight) == 0x0002A0, "Wrong size on AVDetectionLightingSkylight");
static_assert(offsetof(AVDetectionLightingSkylight, SkylightIntensityCurve) == 0x000298, "Member 'AVDetectionLightingSkylight::SkylightIntensityCurve' has a wrong offset!");

// Class Altar.VDetectionLightingSubsystem
// 0x01A0 (0x01D0 - 0x0030)
class alignas(0x10) UVDetectionLightingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SkylightIntensityCurve;                            // 0x0080(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UVDetectionLightingProfile*             DefaultLightProfile;                               // 0x0098(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x130];                                     // 0x00A0(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static EVDetectionLightTag GetDetectionLightTag(const class AActor* LightActor);
	static const class FName GetTagName(const EVDetectionLightTag& LightTag);

	void OnLightComponentBeginPlay(const class ULightComponentBase* LightComponent);
	void OnPostWorldCreation(class UWorld* World);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDetectionLightingSubsystem">();
	}
	static class UVDetectionLightingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDetectionLightingSubsystem>();
	}
};
static_assert(alignof(UVDetectionLightingSubsystem) == 0x000010, "Wrong alignment on UVDetectionLightingSubsystem");
static_assert(sizeof(UVDetectionLightingSubsystem) == 0x0001D0, "Wrong size on UVDetectionLightingSubsystem");
static_assert(offsetof(UVDetectionLightingSubsystem, SkylightIntensityCurve) == 0x000080, "Member 'UVDetectionLightingSubsystem::SkylightIntensityCurve' has a wrong offset!");
static_assert(offsetof(UVDetectionLightingSubsystem, DefaultLightProfile) == 0x000098, "Member 'UVDetectionLightingSubsystem::DefaultLightProfile' has a wrong offset!");

// Class Altar.VDialogueMenuViewModel
// 0x0060 (0x0130 - 0x00D0)
class UVDialogueMenuViewModel final : public UVViewModelBase
{
public:
	TArray<struct FResponsesData>                 Responses;                                         // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FLegacyDialogMenuButtonVisibility      ButtonsVisibility;                                 // 0x00E0(0x0010)(NativeAccessSpecifierPrivate)
	class FText                                   Subtitle;                                          // 0x00F0(0x0018)(NativeAccessSpecifierPrivate)
	bool                                          bSubtitleVisibility;                               // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SpeakerName;                                       // 0x0110(0x0018)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetSubtitleVisibilityCVarSettings();
	void RegisterSendClickedBarterIcon();
	void RegisterSendClickedCloseIcon();
	void RegisterSendClickedPersuasionIcon();
	void RegisterSendClickedRechargingIcon();
	void RegisterSendClickedRepairingIcon();
	void RegisterSendClickedResponse(int32 ResponseIndex);
	void RegisterSendClickedSkip();
	void RegisterSendClickedSpellBarterIcon();
	void RegisterSendClickedTrainingIcon();

	struct FLegacyDialogMenuButtonVisibility GetButtonsVisibility() const;
	TArray<struct FResponsesData> GetResponses() const;
	class FText GetSpeakerName() const;
	class FText GetSubtitle() const;
	bool IsSubtitleVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDialogueMenuViewModel">();
	}
	static class UVDialogueMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDialogueMenuViewModel>();
	}
};
static_assert(alignof(UVDialogueMenuViewModel) == 0x000008, "Wrong alignment on UVDialogueMenuViewModel");
static_assert(sizeof(UVDialogueMenuViewModel) == 0x000130, "Wrong size on UVDialogueMenuViewModel");
static_assert(offsetof(UVDialogueMenuViewModel, Responses) == 0x0000D0, "Member 'UVDialogueMenuViewModel::Responses' has a wrong offset!");
static_assert(offsetof(UVDialogueMenuViewModel, ButtonsVisibility) == 0x0000E0, "Member 'UVDialogueMenuViewModel::ButtonsVisibility' has a wrong offset!");
static_assert(offsetof(UVDialogueMenuViewModel, Subtitle) == 0x0000F0, "Member 'UVDialogueMenuViewModel::Subtitle' has a wrong offset!");
static_assert(offsetof(UVDialogueMenuViewModel, bSubtitleVisibility) == 0x000108, "Member 'UVDialogueMenuViewModel::bSubtitleVisibility' has a wrong offset!");
static_assert(offsetof(UVDialogueMenuViewModel, SpeakerName) == 0x000110, "Member 'UVDialogueMenuViewModel::SpeakerName' has a wrong offset!");

// Class Altar.VDodgeCharacterAnimInstance
// 0x0060 (0x0400 - 0x03A0)
class UVDodgeCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	struct FDodgeAnimationData                    AnimSet;                                           // 0x03A0(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDodgeCharacterAnimInstance">();
	}
	static class UVDodgeCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDodgeCharacterAnimInstance>();
	}
};
static_assert(alignof(UVDodgeCharacterAnimInstance) == 0x000010, "Wrong alignment on UVDodgeCharacterAnimInstance");
static_assert(sizeof(UVDodgeCharacterAnimInstance) == 0x000400, "Wrong size on UVDodgeCharacterAnimInstance");
static_assert(offsetof(UVDodgeCharacterAnimInstance, AnimSet) == 0x0003A0, "Member 'UVDodgeCharacterAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VDoorNavLinkProxy
// 0x0050 (0x0338 - 0x02E8)
class AVDoorNavLinkProxy : public ANavLinkProxy
{
public:
	TMap<class AActor*, struct FTimerHandle>      ControllerTimerPairs;                              // 0x02E8(0x0050)(NativeAccessSpecifierPrivate)

public:
	void OnSmartNavLinkReached(const class AActor* MovingActor, const struct FVector& DestinationPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDoorNavLinkProxy">();
	}
	static class AVDoorNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVDoorNavLinkProxy>();
	}
};
static_assert(alignof(AVDoorNavLinkProxy) == 0x000008, "Wrong alignment on AVDoorNavLinkProxy");
static_assert(sizeof(AVDoorNavLinkProxy) == 0x000338, "Wrong size on AVDoorNavLinkProxy");
static_assert(offsetof(AVDoorNavLinkProxy, ControllerTimerPairs) == 0x0002E8, "Member 'AVDoorNavLinkProxy::ControllerTimerPairs' has a wrong offset!");

// Class Altar.VDoorTeleportMarker
// 0x0010 (0x02A8 - 0x0298)
class AVDoorTeleportMarker final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         FormRefID;                                         // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDoorTeleportMarker">();
	}
	static class AVDoorTeleportMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVDoorTeleportMarker>();
	}
};
static_assert(alignof(AVDoorTeleportMarker) == 0x000008, "Wrong alignment on AVDoorTeleportMarker");
static_assert(sizeof(AVDoorTeleportMarker) == 0x0002A8, "Wrong size on AVDoorTeleportMarker");
static_assert(offsetof(AVDoorTeleportMarker, Root) == 0x000298, "Member 'AVDoorTeleportMarker::Root' has a wrong offset!");
static_assert(offsetof(AVDoorTeleportMarker, FormRefID) == 0x0002A0, "Member 'AVDoorTeleportMarker::FormRefID' has a wrong offset!");

// Class Altar.VStandSneakMultiPowerAnimInstance
// 0x0070 (0x0440 - 0x03D0)
class UVStandSneakMultiPowerAnimInstance final : public UVLRPrepareAttackAnimInstance
{
public:
	struct FStandSneakMultiplePowerSingle         AnimSet;                                           // 0x03D0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStandSneakMultiPowerAnimInstance">();
	}
	static class UVStandSneakMultiPowerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStandSneakMultiPowerAnimInstance>();
	}
};
static_assert(alignof(UVStandSneakMultiPowerAnimInstance) == 0x000010, "Wrong alignment on UVStandSneakMultiPowerAnimInstance");
static_assert(sizeof(UVStandSneakMultiPowerAnimInstance) == 0x000440, "Wrong size on UVStandSneakMultiPowerAnimInstance");
static_assert(offsetof(UVStandSneakMultiPowerAnimInstance, AnimSet) == 0x0003D0, "Member 'UVStandSneakMultiPowerAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VDynamicNavAreaRebuilderComponent
// 0x0090 (0x0130 - 0x00A0)
class UVDynamicNavAreaRebuilderComponent final : public UActorComponent
{
public:
	bool                                          bDirtyNavAreaOnBeginPlay;                          // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDirtyNavAreaOnPhysicsStateChanged;                // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultPhysicsState;                              // 0x00A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePrimitivesBounds;                              // 0x00A3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAttachedChildPrimitivesBounds;                 // 0x00A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomBounds;                                  // 0x00A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CustomBoundsCenter;                                // 0x00A8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CustomBoundsExtents;                               // 0x00C0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVPhysicsControllerComponent*           OptionalPhysicsControllerComponent;                // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x50];                                      // 0x00E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DirtyNavArea(const class FName& DebugReason);
	void ForceDirtyNavArea(const class FName& DebugReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDynamicNavAreaRebuilderComponent">();
	}
	static class UVDynamicNavAreaRebuilderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDynamicNavAreaRebuilderComponent>();
	}
};
static_assert(alignof(UVDynamicNavAreaRebuilderComponent) == 0x000008, "Wrong alignment on UVDynamicNavAreaRebuilderComponent");
static_assert(sizeof(UVDynamicNavAreaRebuilderComponent) == 0x000130, "Wrong size on UVDynamicNavAreaRebuilderComponent");
static_assert(offsetof(UVDynamicNavAreaRebuilderComponent, bDirtyNavAreaOnBeginPlay) == 0x0000A0, "Member 'UVDynamicNavAreaRebuilderComponent::bDirtyNavAreaOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UVDynamicNavAreaRebuilderComponent, bDirtyNavAreaOnPhysicsStateChanged) == 0x0000A1, "Member 'UVDynamicNavAreaRebuilderComponent::bDirtyNavAreaOnPhysicsStateChanged' has a wrong offset!");
static_assert(offsetof(UVDynamicNavAreaRebuilderComponent, bDefaultPhysicsState) == 0x0000A2, "Member 'UVDynamicNavAreaRebuilderComponent::bDefaultPhysicsState' has a wrong offset!");
static_assert(offsetof(UVDynamicNavAreaRebuilderComponent, bUsePrimitivesBounds) == 0x0000A3, "Member 'UVDynamicNavAreaRebuilderComponent::bUsePrimitivesBounds' has a wrong offset!");
static_assert(offsetof(UVDynamicNavAreaRebuilderComponent, bUseAttachedChildPrimitivesBounds) == 0x0000A4, "Member 'UVDynamicNavAreaRebuilderComponent::bUseAttachedChildPrimitivesBounds' has a wrong offset!");
static_assert(offsetof(UVDynamicNavAreaRebuilderComponent, bUseCustomBounds) == 0x0000A5, "Member 'UVDynamicNavAreaRebuilderComponent::bUseCustomBounds' has a wrong offset!");
static_assert(offsetof(UVDynamicNavAreaRebuilderComponent, CustomBoundsCenter) == 0x0000A8, "Member 'UVDynamicNavAreaRebuilderComponent::CustomBoundsCenter' has a wrong offset!");
static_assert(offsetof(UVDynamicNavAreaRebuilderComponent, CustomBoundsExtents) == 0x0000C0, "Member 'UVDynamicNavAreaRebuilderComponent::CustomBoundsExtents' has a wrong offset!");
static_assert(offsetof(UVDynamicNavAreaRebuilderComponent, OptionalPhysicsControllerComponent) == 0x0000D8, "Member 'UVDynamicNavAreaRebuilderComponent::OptionalPhysicsControllerComponent' has a wrong offset!");

// Class Altar.VEditorMarkerComponent
// 0x0000 (0x0630 - 0x0630)
class UVEditorMarkerComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEditorMarkerComponent">();
	}
	static class UVEditorMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEditorMarkerComponent>();
	}
};
static_assert(alignof(UVEditorMarkerComponent) == 0x000010, "Wrong alignment on UVEditorMarkerComponent");
static_assert(sizeof(UVEditorMarkerComponent) == 0x000630, "Wrong size on UVEditorMarkerComponent");

// Class Altar.VEffectSettingsMenuViewModel
// 0x00B8 (0x0188 - 0x00D0)
class UVEffectSettingsMenuViewModel final : public UVViewModelBase
{
public:
	struct FLegacyEffectProperties                EffectProperties;                                  // 0x00D0(0x0020)(NativeAccessSpecifierPrivate)
	struct FLegacyEffectCost                      EffectCost;                                        // 0x00F0(0x000C)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bIsEnchantmentMenu;                                // 0x00FC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELegacyEffectEntryType                        FirstButtonType;                                   // 0x00FD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FirstButtonText;                                   // 0x0100(0x0018)(NativeAccessSpecifierPrivate)
	bool                                          bIsDeleteVisible;                                  // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRangeVisible;                                   // 0x0119(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMagnitudeVisible;                               // 0x011A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAreaVisible;                                    // 0x011B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDurationVisible;                                // 0x011C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLockLevelVisible;                               // 0x011D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11E[0x2];                                      // 0x011E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MagnitudeSelectedValue;                            // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLegacyScrollbarValueProperties        MagnitudeScrollbarProperties;                      // 0x0124(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	float                                         AreaSelectedValue;                                 // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLegacyScrollbarValueProperties        AreaScrollbarProperties;                           // 0x0138(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	float                                         DurationSelectedValue;                             // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLegacyScrollbarValueProperties        DurationScrollbarProperties;                       // 0x014C(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RangeText;                                         // 0x0160(0x0018)(NativeAccessSpecifierPrivate)
	EMordernLockLevel                             Locklevel;                                         // 0x0178(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_179[0xF];                                      // 0x0179(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendClickedAttribute();
	void RegisterSendClickedCancel();
	void RegisterSendClickedDelete();
	void RegisterSendClickedLockLevel();
	void RegisterSendClickedOk();
	void RegisterSendClickedRange();
	void RegisterSendClickedScrollbar(float NewValue, ELegacyEffectEntryType NewScrollbarType);
	void RegisterSendClickedSkill();
	void SetAreaScrollbarProperties(const struct FLegacyScrollbarValueProperties& NewScrollbarProperties);
	void SetAreaSelectedValue(float NewSelectedValue);
	void SetDurationScrollbarProperties(const struct FLegacyScrollbarValueProperties& NewScrollbarProperties);
	void SetDurationSelectedValue(float NewSelectedValue);
	void SetEffectCost(const struct FLegacyEffectCost& NewCost);
	void SetEffectProperties(const struct FLegacyEffectProperties& NewProperties);
	void SetFirstButtonText(const class FText& NewValue);
	void SetFirstButtonType(ELegacyEffectEntryType NewValue);
	void SetIsAreaVisible(bool bNewValue);
	void SetIsDeleteVisible(bool bNewValue);
	void SetIsDurationVisible(bool bNewValue);
	void SetIsEnchantmentMenu(bool bNewValue);
	void SetIsLockLevelVisible(bool bNewValue);
	void SetIsMagnitudeVisible(bool bNewValue);
	void SetIsRangeVisible(bool bNewValue);
	void SetLocklevel(const EMordernLockLevel& NewLockValue);
	void SetMagnitudeScrollbarProperties(const struct FLegacyScrollbarValueProperties& NewScrollbarProperties);
	void SetMagnitudeSelectedValue(float NewSelectedValue);
	void SetRangeText(const class FText& NewValue);

	const struct FLegacyScrollbarValueProperties GetAreaScrollbarProperties() const;
	float GetAreaSelectedValue() const;
	const struct FLegacyScrollbarValueProperties GetDurationScrollbarProperties() const;
	float GetDurationSelectedValue() const;
	const struct FLegacyEffectCost GetEffectCost() const;
	const struct FLegacyEffectProperties GetEffectProperties() const;
	const class FText GetFirstButtonText() const;
	ELegacyEffectEntryType GetFirstButtonType() const;
	bool GetIsAreaVisible() const;
	bool GetIsDeleteVisible() const;
	bool GetIsDurationVisible() const;
	bool GetIsEnchantmentMenu() const;
	bool GetIsLockLevelVisible() const;
	bool GetIsMagnitudeVisible() const;
	bool GetIsRangeVisible() const;
	const EMordernLockLevel GetLocklevel() const;
	const struct FLegacyScrollbarValueProperties GetMagnitudeScrollbarProperties() const;
	float GetMagnitudeSelectedValue() const;
	const class FText GetRangeText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEffectSettingsMenuViewModel">();
	}
	static class UVEffectSettingsMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEffectSettingsMenuViewModel>();
	}
};
static_assert(alignof(UVEffectSettingsMenuViewModel) == 0x000008, "Wrong alignment on UVEffectSettingsMenuViewModel");
static_assert(sizeof(UVEffectSettingsMenuViewModel) == 0x000188, "Wrong size on UVEffectSettingsMenuViewModel");
static_assert(offsetof(UVEffectSettingsMenuViewModel, EffectProperties) == 0x0000D0, "Member 'UVEffectSettingsMenuViewModel::EffectProperties' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, EffectCost) == 0x0000F0, "Member 'UVEffectSettingsMenuViewModel::EffectCost' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, bIsEnchantmentMenu) == 0x0000FC, "Member 'UVEffectSettingsMenuViewModel::bIsEnchantmentMenu' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, FirstButtonType) == 0x0000FD, "Member 'UVEffectSettingsMenuViewModel::FirstButtonType' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, FirstButtonText) == 0x000100, "Member 'UVEffectSettingsMenuViewModel::FirstButtonText' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, bIsDeleteVisible) == 0x000118, "Member 'UVEffectSettingsMenuViewModel::bIsDeleteVisible' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, bIsRangeVisible) == 0x000119, "Member 'UVEffectSettingsMenuViewModel::bIsRangeVisible' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, bIsMagnitudeVisible) == 0x00011A, "Member 'UVEffectSettingsMenuViewModel::bIsMagnitudeVisible' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, bIsAreaVisible) == 0x00011B, "Member 'UVEffectSettingsMenuViewModel::bIsAreaVisible' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, bIsDurationVisible) == 0x00011C, "Member 'UVEffectSettingsMenuViewModel::bIsDurationVisible' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, bIsLockLevelVisible) == 0x00011D, "Member 'UVEffectSettingsMenuViewModel::bIsLockLevelVisible' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, MagnitudeSelectedValue) == 0x000120, "Member 'UVEffectSettingsMenuViewModel::MagnitudeSelectedValue' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, MagnitudeScrollbarProperties) == 0x000124, "Member 'UVEffectSettingsMenuViewModel::MagnitudeScrollbarProperties' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, AreaSelectedValue) == 0x000134, "Member 'UVEffectSettingsMenuViewModel::AreaSelectedValue' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, AreaScrollbarProperties) == 0x000138, "Member 'UVEffectSettingsMenuViewModel::AreaScrollbarProperties' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, DurationSelectedValue) == 0x000148, "Member 'UVEffectSettingsMenuViewModel::DurationSelectedValue' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, DurationScrollbarProperties) == 0x00014C, "Member 'UVEffectSettingsMenuViewModel::DurationScrollbarProperties' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, RangeText) == 0x000160, "Member 'UVEffectSettingsMenuViewModel::RangeText' has a wrong offset!");
static_assert(offsetof(UVEffectSettingsMenuViewModel, Locklevel) == 0x000178, "Member 'UVEffectSettingsMenuViewModel::Locklevel' has a wrong offset!");

// Class Altar.VEnchantmentMenuViewModel
// 0x00B8 (0x0188 - 0x00D0)
class UVEnchantmentMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnSucessSoundTrigger;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEffectSettingsMenuOpen;                          // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEffectSettingsMenuClose;                         // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FSoulGemInfo                           SoulGemInfo;                                       // 0x0100(0x0028)(NativeAccessSpecifierPrivate)
	struct FItemToEnchantInfo                     ItemToEnchantInfo;                                 // 0x0128(0x0020)(NativeAccessSpecifierPrivate)
	TArray<struct FVModernEnchantmentItemProperties> ItemsList;                                      // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVModernEnchantmentItemProperties> CurrentPageItemsList;                           // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVModernEnchantmentItemProperties> EffectsList;                                    // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	EModernEnchantmentMenuPage                    CurrentPage;                                       // 0x0178(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOriginalInventoryMenuSortType                SortType;                                          // 0x0179(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17A[0x2];                                      // 0x017A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerGold;                                        // 0x017C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSortReversed;                                   // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendClickOnAddedEffectItem(int32 ItemIndex, bool bWantToDelete);
	void RegisterSendClickOnAvailableEffectItem(int32 ItemIndex, bool bWantToDelete);
	void RegisterSendClickOnCreateButton(const class FString& NewEnchantedItemName);
	void RegisterSendClickOnExitButton();
	void RegisterSendClickOnItem(int32 ItemIndex);
	void RegisterSendClickOnItemButton();
	void RegisterSendClickOnSoulGemButton();
	void SetCurrentPage(EModernEnchantmentMenuPage NewPage);
	void SetCurrentPageItemsList(const TArray<struct FVModernEnchantmentItemProperties>& NewItemsList);
	void SetEffectsList(const TArray<struct FVModernEnchantmentItemProperties>& NewEffectsList);
	void SetInventoryForPage(const EModernEnchantmentMenuPage Page);
	void SetIsSortReversed(bool bNewIsSortReversed);
	void SetItemsList(const TArray<struct FVModernEnchantmentItemProperties>& NewItemsList);
	void SetItemToEnchantInfo(const struct FItemToEnchantInfo& NewItemToEnchantInfo);
	void SetPlayerGold(int32 NewPlayerGold);
	void SetSortType(const EOriginalInventoryMenuSortType& NewSortType);
	void SetSoulGemInfo(const struct FSoulGemInfo& NewSoulGemInfo);

	const EModernEnchantmentMenuPage GetCurrentPage() const;
	const TArray<struct FVModernEnchantmentItemProperties> GetCurrentPageItemsList() const;
	const TArray<struct FVModernEnchantmentItemProperties> GetEffectsList() const;
	const TArray<struct FVModernEnchantmentItemProperties> GetItemsList() const;
	const struct FItemToEnchantInfo GetItemToEnchantInfo() const;
	int32 GetPlayerGold() const;
	EOriginalInventoryMenuSortType GetSortType() const;
	const struct FSoulGemInfo GetSoulGemInfo() const;
	bool IsItemTypeOnPage(const EModernEnchantmentMenuItemType ItemType, const EModernEnchantmentMenuPage Page) const;
	bool IsSortReversed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEnchantmentMenuViewModel">();
	}
	static class UVEnchantmentMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEnchantmentMenuViewModel>();
	}
};
static_assert(alignof(UVEnchantmentMenuViewModel) == 0x000008, "Wrong alignment on UVEnchantmentMenuViewModel");
static_assert(sizeof(UVEnchantmentMenuViewModel) == 0x000188, "Wrong size on UVEnchantmentMenuViewModel");
static_assert(offsetof(UVEnchantmentMenuViewModel, OnSucessSoundTrigger) == 0x0000D0, "Member 'UVEnchantmentMenuViewModel::OnSucessSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVEnchantmentMenuViewModel, OnEffectSettingsMenuOpen) == 0x0000E0, "Member 'UVEnchantmentMenuViewModel::OnEffectSettingsMenuOpen' has a wrong offset!");
static_assert(offsetof(UVEnchantmentMenuViewModel, OnEffectSettingsMenuClose) == 0x0000F0, "Member 'UVEnchantmentMenuViewModel::OnEffectSettingsMenuClose' has a wrong offset!");
static_assert(offsetof(UVEnchantmentMenuViewModel, SoulGemInfo) == 0x000100, "Member 'UVEnchantmentMenuViewModel::SoulGemInfo' has a wrong offset!");
static_assert(offsetof(UVEnchantmentMenuViewModel, ItemToEnchantInfo) == 0x000128, "Member 'UVEnchantmentMenuViewModel::ItemToEnchantInfo' has a wrong offset!");
static_assert(offsetof(UVEnchantmentMenuViewModel, ItemsList) == 0x000148, "Member 'UVEnchantmentMenuViewModel::ItemsList' has a wrong offset!");
static_assert(offsetof(UVEnchantmentMenuViewModel, CurrentPageItemsList) == 0x000158, "Member 'UVEnchantmentMenuViewModel::CurrentPageItemsList' has a wrong offset!");
static_assert(offsetof(UVEnchantmentMenuViewModel, EffectsList) == 0x000168, "Member 'UVEnchantmentMenuViewModel::EffectsList' has a wrong offset!");
static_assert(offsetof(UVEnchantmentMenuViewModel, CurrentPage) == 0x000178, "Member 'UVEnchantmentMenuViewModel::CurrentPage' has a wrong offset!");
static_assert(offsetof(UVEnchantmentMenuViewModel, SortType) == 0x000179, "Member 'UVEnchantmentMenuViewModel::SortType' has a wrong offset!");
static_assert(offsetof(UVEnchantmentMenuViewModel, PlayerGold) == 0x00017C, "Member 'UVEnchantmentMenuViewModel::PlayerGold' has a wrong offset!");
static_assert(offsetof(UVEnchantmentMenuViewModel, bIsSortReversed) == 0x000180, "Member 'UVEnchantmentMenuViewModel::bIsSortReversed' has a wrong offset!");

// Class Altar.VEnchantSaveData
// 0x0010 (0x0040 - 0x0030)
class UVEnchantSaveData final : public UVBaseAltarSaveData
{
public:
	uint32                                        SourceFormID;                                      // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEnchantSaveData">();
	}
	static class UVEnchantSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEnchantSaveData>();
	}
};
static_assert(alignof(UVEnchantSaveData) == 0x000008, "Wrong alignment on UVEnchantSaveData");
static_assert(sizeof(UVEnchantSaveData) == 0x000040, "Wrong size on UVEnchantSaveData");
static_assert(offsetof(UVEnchantSaveData, SourceFormID) == 0x000030, "Member 'UVEnchantSaveData::SourceFormID' has a wrong offset!");

// Class Altar.VEnhancedInAirCharacterAnimInstance
// 0x0060 (0x04C0 - 0x0460)
class UVEnhancedInAirCharacterAnimInstance : public UVLocomotionCharacterAnimInstance
{
public:
	struct FVEnhancedInAirAnimInstanceData        LayerData;                                         // 0x0460(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   LeftFootName;                                      // 0x04A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightFootName;                                     // 0x04A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovingJumpVelocityThreshold;                       // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLeftFootJump;                                   // 0x04B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B5[0xB];                                      // 0x04B5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetLandingAdditiveAlpha() const;
	bool IsInAir() const;
	bool IsJumping() const;
	bool IsLanding() const;
	bool IsLeftFootJump() const;
	bool IsSneaking() const;
	bool IsTryingToMove() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEnhancedInAirCharacterAnimInstance">();
	}
	static class UVEnhancedInAirCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEnhancedInAirCharacterAnimInstance>();
	}
};
static_assert(alignof(UVEnhancedInAirCharacterAnimInstance) == 0x000010, "Wrong alignment on UVEnhancedInAirCharacterAnimInstance");
static_assert(sizeof(UVEnhancedInAirCharacterAnimInstance) == 0x0004C0, "Wrong size on UVEnhancedInAirCharacterAnimInstance");
static_assert(offsetof(UVEnhancedInAirCharacterAnimInstance, LayerData) == 0x000460, "Member 'UVEnhancedInAirCharacterAnimInstance::LayerData' has a wrong offset!");
static_assert(offsetof(UVEnhancedInAirCharacterAnimInstance, LeftFootName) == 0x0004A0, "Member 'UVEnhancedInAirCharacterAnimInstance::LeftFootName' has a wrong offset!");
static_assert(offsetof(UVEnhancedInAirCharacterAnimInstance, RightFootName) == 0x0004A8, "Member 'UVEnhancedInAirCharacterAnimInstance::RightFootName' has a wrong offset!");
static_assert(offsetof(UVEnhancedInAirCharacterAnimInstance, MovingJumpVelocityThreshold) == 0x0004B0, "Member 'UVEnhancedInAirCharacterAnimInstance::MovingJumpVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UVEnhancedInAirCharacterAnimInstance, bIsLeftFootJump) == 0x0004B4, "Member 'UVEnhancedInAirCharacterAnimInstance::bIsLeftFootJump' has a wrong offset!");

// Class Altar.VEnhancedLocomotionCharacterAnimInstance
// 0x00F0 (0x0490 - 0x03A0)
class UVEnhancedLocomotionCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	class FName                                   PelvisRotationCurveName;                           // 0x03A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        PassiveForwardAngle;                               // 0x03A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        PassiveBackwardAngle;                              // 0x03B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            CharacterMoveComp;                                 // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionDirection;                               // 0x03C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionSpeed;                                   // 0x03C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionPlayRate;                                // 0x03C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CC[0xC];                                      // 0x03CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLocomotionAnimationData               AnimSet;                                           // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSprintingAnimationData                SprintSet;                                         // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                BlendValues;                                       // 0x03E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x90];                                     // 0x0400(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsSprinting() const;
	bool IsWeaponDrawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEnhancedLocomotionCharacterAnimInstance">();
	}
	static class UVEnhancedLocomotionCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEnhancedLocomotionCharacterAnimInstance>();
	}
};
static_assert(alignof(UVEnhancedLocomotionCharacterAnimInstance) == 0x000010, "Wrong alignment on UVEnhancedLocomotionCharacterAnimInstance");
static_assert(sizeof(UVEnhancedLocomotionCharacterAnimInstance) == 0x000490, "Wrong size on UVEnhancedLocomotionCharacterAnimInstance");
static_assert(offsetof(UVEnhancedLocomotionCharacterAnimInstance, PelvisRotationCurveName) == 0x0003A0, "Member 'UVEnhancedLocomotionCharacterAnimInstance::PelvisRotationCurveName' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionCharacterAnimInstance, PassiveForwardAngle) == 0x0003A8, "Member 'UVEnhancedLocomotionCharacterAnimInstance::PassiveForwardAngle' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionCharacterAnimInstance, PassiveBackwardAngle) == 0x0003B0, "Member 'UVEnhancedLocomotionCharacterAnimInstance::PassiveBackwardAngle' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionCharacterAnimInstance, CharacterMoveComp) == 0x0003B8, "Member 'UVEnhancedLocomotionCharacterAnimInstance::CharacterMoveComp' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionCharacterAnimInstance, LocomotionDirection) == 0x0003C0, "Member 'UVEnhancedLocomotionCharacterAnimInstance::LocomotionDirection' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionCharacterAnimInstance, LocomotionSpeed) == 0x0003C4, "Member 'UVEnhancedLocomotionCharacterAnimInstance::LocomotionSpeed' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionCharacterAnimInstance, LocomotionPlayRate) == 0x0003C8, "Member 'UVEnhancedLocomotionCharacterAnimInstance::LocomotionPlayRate' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionCharacterAnimInstance, AnimSet) == 0x0003D8, "Member 'UVEnhancedLocomotionCharacterAnimInstance::AnimSet' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionCharacterAnimInstance, SprintSet) == 0x0003E0, "Member 'UVEnhancedLocomotionCharacterAnimInstance::SprintSet' has a wrong offset!");
static_assert(offsetof(UVEnhancedLocomotionCharacterAnimInstance, BlendValues) == 0x0003E8, "Member 'UVEnhancedLocomotionCharacterAnimInstance::BlendValues' has a wrong offset!");

// Class Altar.VEquipUnequipMultiAnimInstance
// 0x0030 (0x03E0 - 0x03B0)
class UVEquipUnequipMultiAnimInstance final : public UVEquipUnequipCharacterAnimInstance
{
public:
	struct FEquipUnequipMultiLayerData            LayerData;                                         // 0x03A8(0x0020)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      EquipAnim;                                         // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      UnequipAnim;                                       // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEquipEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnUnEquipEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEquipUnequipMultiAnimInstance">();
	}
	static class UVEquipUnequipMultiAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEquipUnequipMultiAnimInstance>();
	}
};
static_assert(alignof(UVEquipUnequipMultiAnimInstance) == 0x000010, "Wrong alignment on UVEquipUnequipMultiAnimInstance");
static_assert(sizeof(UVEquipUnequipMultiAnimInstance) == 0x0003E0, "Wrong size on UVEquipUnequipMultiAnimInstance");
static_assert(offsetof(UVEquipUnequipMultiAnimInstance, LayerData) == 0x0003A8, "Member 'UVEquipUnequipMultiAnimInstance::LayerData' has a wrong offset!");
static_assert(offsetof(UVEquipUnequipMultiAnimInstance, EquipAnim) == 0x0003C8, "Member 'UVEquipUnequipMultiAnimInstance::EquipAnim' has a wrong offset!");
static_assert(offsetof(UVEquipUnequipMultiAnimInstance, UnequipAnim) == 0x0003D0, "Member 'UVEquipUnequipMultiAnimInstance::UnequipAnim' has a wrong offset!");

// Class Altar.VEquipUnequipSingleAnimInstance
// 0x0010 (0x03C0 - 0x03B0)
class UVEquipUnequipSingleAnimInstance final : public UVEquipUnequipCharacterAnimInstance
{
public:
	struct FEquipUnequipSingleLayerData           LayerData;                                         // 0x03A8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEquipEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnUnEquipEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEquipUnequipSingleAnimInstance">();
	}
	static class UVEquipUnequipSingleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEquipUnequipSingleAnimInstance>();
	}
};
static_assert(alignof(UVEquipUnequipSingleAnimInstance) == 0x000010, "Wrong alignment on UVEquipUnequipSingleAnimInstance");
static_assert(sizeof(UVEquipUnequipSingleAnimInstance) == 0x0003C0, "Wrong size on UVEquipUnequipSingleAnimInstance");
static_assert(offsetof(UVEquipUnequipSingleAnimInstance, LayerData) == 0x0003A8, "Member 'UVEquipUnequipSingleAnimInstance::LayerData' has a wrong offset!");

// Class Altar.VEquipUnequipSSwimSingle
// 0x0030 (0x03E0 - 0x03B0)
class UVEquipUnequipSSwimSingle final : public UVEquipUnequipCharacterAnimInstance
{
public:
	struct FEquipUnequipStandSwimSingleData       LayerData;                                         // 0x03A8(0x0020)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      EquipAnim;                                         // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      UnequipAnim;                                       // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEquipEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnUnEquipEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEquipUnequipSSwimSingle">();
	}
	static class UVEquipUnequipSSwimSingle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEquipUnequipSSwimSingle>();
	}
};
static_assert(alignof(UVEquipUnequipSSwimSingle) == 0x000010, "Wrong alignment on UVEquipUnequipSSwimSingle");
static_assert(sizeof(UVEquipUnequipSSwimSingle) == 0x0003E0, "Wrong size on UVEquipUnequipSSwimSingle");
static_assert(offsetof(UVEquipUnequipSSwimSingle, LayerData) == 0x0003A8, "Member 'UVEquipUnequipSSwimSingle::LayerData' has a wrong offset!");
static_assert(offsetof(UVEquipUnequipSSwimSingle, EquipAnim) == 0x0003C8, "Member 'UVEquipUnequipSSwimSingle::EquipAnim' has a wrong offset!");
static_assert(offsetof(UVEquipUnequipSSwimSingle, UnequipAnim) == 0x0003D0, "Member 'UVEquipUnequipSSwimSingle::UnequipAnim' has a wrong offset!");

// Class Altar.VEquipUnequipStandSneakSingle
// 0x0030 (0x03E0 - 0x03B0)
class UVEquipUnequipStandSneakSingle : public UVEquipUnequipCharacterAnimInstance
{
public:
	class UAnimSequenceBase*                      EquipAnim;                                         // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      UnequipAnim;                                       // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEquipUnequipStandSneakSingleLayerData LayerData;                                         // 0x03B8(0x0020)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEquipEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnUnEquipEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VEquipUnequipStandSneakSingle">();
	}
	static class UVEquipUnequipStandSneakSingle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVEquipUnequipStandSneakSingle>();
	}
};
static_assert(alignof(UVEquipUnequipStandSneakSingle) == 0x000010, "Wrong alignment on UVEquipUnequipStandSneakSingle");
static_assert(sizeof(UVEquipUnequipStandSneakSingle) == 0x0003E0, "Wrong size on UVEquipUnequipStandSneakSingle");
static_assert(offsetof(UVEquipUnequipStandSneakSingle, EquipAnim) == 0x0003A8, "Member 'UVEquipUnequipStandSneakSingle::EquipAnim' has a wrong offset!");
static_assert(offsetof(UVEquipUnequipStandSneakSingle, UnequipAnim) == 0x0003B0, "Member 'UVEquipUnequipStandSneakSingle::UnequipAnim' has a wrong offset!");
static_assert(offsetof(UVEquipUnequipStandSneakSingle, LayerData) == 0x0003B8, "Member 'UVEquipUnequipStandSneakSingle::LayerData' has a wrong offset!");

// Class Altar.VStaffAttackAnimInstance
// 0x0010 (0x03C0 - 0x03B0)
class UVStaffAttackAnimInstance final : public UVBaseStaffAttackAnimInstance
{
public:
	struct FStaffAttackData                       AnimSet;                                           // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStaffAttackAnimInstance">();
	}
	static class UVStaffAttackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStaffAttackAnimInstance>();
	}
};
static_assert(alignof(UVStaffAttackAnimInstance) == 0x000010, "Wrong alignment on UVStaffAttackAnimInstance");
static_assert(sizeof(UVStaffAttackAnimInstance) == 0x0003C0, "Wrong size on UVStaffAttackAnimInstance");
static_assert(offsetof(UVStaffAttackAnimInstance, AnimSet) == 0x0003B0, "Member 'UVStaffAttackAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VFacialCharacterAnimInstance
// 0x0060 (0x0400 - 0x03A0)
class UVFacialCharacterAnimInstance final : public UVLayerCharacterAnimInstance
{
public:
	bool                                          bShouldDisableIdleFacialPose;                      // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x8];                                      // 0x03A1(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsIdling;                                         // 0x03A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFleeing;                                        // 0x03AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldBlendFacialPose;                            // 0x03AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseAttackPose;                              // 0x03AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseHitReactionPose;                         // 0x03AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AE[0x2];                                      // 0x03AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendWeight;                                       // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpSpeed;                                       // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FacialBoneName;                                    // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TongueBoneName;                                    // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PassiveIdlePose;                                   // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CombatIdlePose;                                    // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FleePose;                                          // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttackPose;                                        // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HitReactionIdlePose;                               // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UVHitReactionAnimInstance>  HitReactionAnimInstanceClass;                      // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsUsingAttackPose() const;
	bool IsUsingHitPose() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFacialCharacterAnimInstance">();
	}
	static class UVFacialCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVFacialCharacterAnimInstance>();
	}
};
static_assert(alignof(UVFacialCharacterAnimInstance) == 0x000010, "Wrong alignment on UVFacialCharacterAnimInstance");
static_assert(sizeof(UVFacialCharacterAnimInstance) == 0x000400, "Wrong size on UVFacialCharacterAnimInstance");
static_assert(offsetof(UVFacialCharacterAnimInstance, bShouldDisableIdleFacialPose) == 0x0003A0, "Member 'UVFacialCharacterAnimInstance::bShouldDisableIdleFacialPose' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, bIsIdling) == 0x0003A9, "Member 'UVFacialCharacterAnimInstance::bIsIdling' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, bIsFleeing) == 0x0003AA, "Member 'UVFacialCharacterAnimInstance::bIsFleeing' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, bShouldBlendFacialPose) == 0x0003AB, "Member 'UVFacialCharacterAnimInstance::bShouldBlendFacialPose' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, bShouldUseAttackPose) == 0x0003AC, "Member 'UVFacialCharacterAnimInstance::bShouldUseAttackPose' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, bShouldUseHitReactionPose) == 0x0003AD, "Member 'UVFacialCharacterAnimInstance::bShouldUseHitReactionPose' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, BlendWeight) == 0x0003B0, "Member 'UVFacialCharacterAnimInstance::BlendWeight' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, InterpSpeed) == 0x0003B4, "Member 'UVFacialCharacterAnimInstance::InterpSpeed' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, FacialBoneName) == 0x0003B8, "Member 'UVFacialCharacterAnimInstance::FacialBoneName' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, TongueBoneName) == 0x0003C0, "Member 'UVFacialCharacterAnimInstance::TongueBoneName' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, PassiveIdlePose) == 0x0003C8, "Member 'UVFacialCharacterAnimInstance::PassiveIdlePose' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, CombatIdlePose) == 0x0003D0, "Member 'UVFacialCharacterAnimInstance::CombatIdlePose' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, FleePose) == 0x0003D8, "Member 'UVFacialCharacterAnimInstance::FleePose' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, AttackPose) == 0x0003E0, "Member 'UVFacialCharacterAnimInstance::AttackPose' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, HitReactionIdlePose) == 0x0003E8, "Member 'UVFacialCharacterAnimInstance::HitReactionIdlePose' has a wrong offset!");
static_assert(offsetof(UVFacialCharacterAnimInstance, HitReactionAnimInstanceClass) == 0x0003F0, "Member 'UVFacialCharacterAnimInstance::HitReactionAnimInstanceClass' has a wrong offset!");

// Class Altar.VFastTransitionCachedExtensionLevel
// 0x0010 (0x0038 - 0x0028)
class UVFastTransitionCachedExtensionLevel final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFastTransitionCachedExtensionLevel">();
	}
	static class UVFastTransitionCachedExtensionLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVFastTransitionCachedExtensionLevel>();
	}
};
static_assert(alignof(UVFastTransitionCachedExtensionLevel) == 0x000008, "Wrong alignment on UVFastTransitionCachedExtensionLevel");
static_assert(sizeof(UVFastTransitionCachedExtensionLevel) == 0x000038, "Wrong size on UVFastTransitionCachedExtensionLevel");

// Class Altar.VFastTransitionBase
// 0x0050 (0x0078 - 0x0028)
class UVFastTransitionBase : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFastTransitionBase">();
	}
	static class UVFastTransitionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVFastTransitionBase>();
	}
};
static_assert(alignof(UVFastTransitionBase) == 0x000008, "Wrong alignment on UVFastTransitionBase");
static_assert(sizeof(UVFastTransitionBase) == 0x000078, "Wrong size on UVFastTransitionBase");

// Class Altar.VWeapon_Melee
// 0x0010 (0x03A0 - 0x0390)
class AVWeapon_Melee : public AVWeapon
{
public:
	class UStaticMeshComponent*                   MainStaticMeshComponent;                           // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTwoHanded;                                      // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWeapon_Melee">();
	}
	static class AVWeapon_Melee* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWeapon_Melee>();
	}
};
static_assert(alignof(AVWeapon_Melee) == 0x000008, "Wrong alignment on AVWeapon_Melee");
static_assert(sizeof(AVWeapon_Melee) == 0x0003A0, "Wrong size on AVWeapon_Melee");
static_assert(offsetof(AVWeapon_Melee, MainStaticMeshComponent) == 0x000390, "Member 'AVWeapon_Melee::MainStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVWeapon_Melee, bIsTwoHanded) == 0x000398, "Member 'AVWeapon_Melee::bIsTwoHanded' has a wrong offset!");

// Class Altar.VWeapon_Blade
// 0x0000 (0x03A0 - 0x03A0)
class AVWeapon_Blade : public AVWeapon_Melee
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWeapon_Blade">();
	}
	static class AVWeapon_Blade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWeapon_Blade>();
	}
};
static_assert(alignof(AVWeapon_Blade) == 0x000008, "Wrong alignment on AVWeapon_Blade");
static_assert(sizeof(AVWeapon_Blade) == 0x0003A0, "Wrong size on AVWeapon_Blade");

// Class Altar.VFastTransition
// 0x0110 (0x0188 - 0x0078)
class UVFastTransition final : public UVFastTransitionBase
{
public:
	uint8                                         Pad_78[0x108];                                     // 0x0078(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	class UVLevelStreaming*                       InjectedAsParent;                                  // 0x0180(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnGoingToMainMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFastTransition">();
	}
	static class UVFastTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVFastTransition>();
	}
};
static_assert(alignof(UVFastTransition) == 0x000008, "Wrong alignment on UVFastTransition");
static_assert(sizeof(UVFastTransition) == 0x000188, "Wrong size on UVFastTransition");
static_assert(offsetof(UVFastTransition, InjectedAsParent) == 0x000180, "Member 'UVFastTransition::InjectedAsParent' has a wrong offset!");

// Class Altar.VFeetIKCharacterAnimInstance
// 0x0040 (0x03E0 - 0x03A0)
class UVFeetIKCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	class UCharacterMovementComponent*            CharacterMoveComp;                                 // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalSpeed;                                   // 0x03A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalSpeed;                                     // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLayerActive;                                    // 0x03B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LayerActivationLerpSpeed;                          // 0x03B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ControlRigAlpha;                                   // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMoving;                                         // 0x03BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BD[0x3];                                      // 0x03BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x03C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x03C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkableFloorZ;                                    // 0x03C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedRatio;                                        // 0x03CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSpeedRatio();

	bool IsInAir() const;
	bool IsSneaking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFeetIKCharacterAnimInstance">();
	}
	static class UVFeetIKCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVFeetIKCharacterAnimInstance>();
	}
};
static_assert(alignof(UVFeetIKCharacterAnimInstance) == 0x000010, "Wrong alignment on UVFeetIKCharacterAnimInstance");
static_assert(sizeof(UVFeetIKCharacterAnimInstance) == 0x0003E0, "Wrong size on UVFeetIKCharacterAnimInstance");
static_assert(offsetof(UVFeetIKCharacterAnimInstance, CharacterMoveComp) == 0x0003A0, "Member 'UVFeetIKCharacterAnimInstance::CharacterMoveComp' has a wrong offset!");
static_assert(offsetof(UVFeetIKCharacterAnimInstance, HorizontalSpeed) == 0x0003A8, "Member 'UVFeetIKCharacterAnimInstance::HorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UVFeetIKCharacterAnimInstance, VerticalSpeed) == 0x0003AC, "Member 'UVFeetIKCharacterAnimInstance::VerticalSpeed' has a wrong offset!");
static_assert(offsetof(UVFeetIKCharacterAnimInstance, bIsLayerActive) == 0x0003B0, "Member 'UVFeetIKCharacterAnimInstance::bIsLayerActive' has a wrong offset!");
static_assert(offsetof(UVFeetIKCharacterAnimInstance, LayerActivationLerpSpeed) == 0x0003B4, "Member 'UVFeetIKCharacterAnimInstance::LayerActivationLerpSpeed' has a wrong offset!");
static_assert(offsetof(UVFeetIKCharacterAnimInstance, ControlRigAlpha) == 0x0003B8, "Member 'UVFeetIKCharacterAnimInstance::ControlRigAlpha' has a wrong offset!");
static_assert(offsetof(UVFeetIKCharacterAnimInstance, bIsMoving) == 0x0003BC, "Member 'UVFeetIKCharacterAnimInstance::bIsMoving' has a wrong offset!");
static_assert(offsetof(UVFeetIKCharacterAnimInstance, Scale) == 0x0003C0, "Member 'UVFeetIKCharacterAnimInstance::Scale' has a wrong offset!");
static_assert(offsetof(UVFeetIKCharacterAnimInstance, Speed) == 0x0003C4, "Member 'UVFeetIKCharacterAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UVFeetIKCharacterAnimInstance, WalkableFloorZ) == 0x0003C8, "Member 'UVFeetIKCharacterAnimInstance::WalkableFloorZ' has a wrong offset!");
static_assert(offsetof(UVFeetIKCharacterAnimInstance, SpeedRatio) == 0x0003CC, "Member 'UVFeetIKCharacterAnimInstance::SpeedRatio' has a wrong offset!");

// Class Altar.VFooterViewModel
// 0x0050 (0x0120 - 0x00D0)
class UVFooterViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void(class UInputAction* TriggerInputAction)> OnHoldInputStart;         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UInputAction* TriggerInputAction)> OnHoldInputCancel;        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFooterUpdated;                                   // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FFooterInputActionDescription& NewInputActionDescription)> OnInputActionDescriptionUpdated; // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FFooterInputActionVisibility& NewInputActionVisibility)> OnInputActionVisibilityUpdated; // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnHoldCancel(class UInputAction* InputAction);
	void SetInputActionDescription(const struct FFooterInputActionDescription& NewExtraData);
	void SetInputActionVisibility(const struct FFooterInputActionVisibility& NewInputActionVisibility);
	void TriggerOnHoldInput(class UInputAction* InputAction);

	bool ThisIsForPluginCompliance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFooterViewModel">();
	}
	static class UVFooterViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVFooterViewModel>();
	}
};
static_assert(alignof(UVFooterViewModel) == 0x000008, "Wrong alignment on UVFooterViewModel");
static_assert(sizeof(UVFooterViewModel) == 0x000120, "Wrong size on UVFooterViewModel");
static_assert(offsetof(UVFooterViewModel, OnHoldInputStart) == 0x0000D0, "Member 'UVFooterViewModel::OnHoldInputStart' has a wrong offset!");
static_assert(offsetof(UVFooterViewModel, OnHoldInputCancel) == 0x0000E0, "Member 'UVFooterViewModel::OnHoldInputCancel' has a wrong offset!");
static_assert(offsetof(UVFooterViewModel, OnFooterUpdated) == 0x0000F0, "Member 'UVFooterViewModel::OnFooterUpdated' has a wrong offset!");
static_assert(offsetof(UVFooterViewModel, OnInputActionDescriptionUpdated) == 0x000100, "Member 'UVFooterViewModel::OnInputActionDescriptionUpdated' has a wrong offset!");
static_assert(offsetof(UVFooterViewModel, OnInputActionVisibilityUpdated) == 0x000110, "Member 'UVFooterViewModel::OnInputActionVisibilityUpdated' has a wrong offset!");

// Class Altar.VFootStepVFXBlueprint
// 0x0000 (0x02A0 - 0x02A0)
class AVFootStepVFXBlueprint : public AVVFXBlueprint
{
public:
	void OnStartPlay(EVLocomotionType LocomotionType, bool bDoesBeginInFirstPerson, const struct FVector& Velocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFootStepVFXBlueprint">();
	}
	static class AVFootStepVFXBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVFootStepVFXBlueprint>();
	}
};
static_assert(alignof(AVFootStepVFXBlueprint) == 0x000008, "Wrong alignment on AVFootStepVFXBlueprint");
static_assert(sizeof(AVFootStepVFXBlueprint) == 0x0002A0, "Wrong size on AVFootStepVFXBlueprint");

// Class Altar.VFormIDNavLinkCustomComponent
// 0x0050 (0x0230 - 0x01E0)
class UVFormIDNavLinkCustomComponent final : public UNavLinkCustomComponent
{
public:
	TSet<int32>                                   AllowedFormIDs;                                    // 0x01E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFormIDNavLinkCustomComponent">();
	}
	static class UVFormIDNavLinkCustomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVFormIDNavLinkCustomComponent>();
	}
};
static_assert(alignof(UVFormIDNavLinkCustomComponent) == 0x000008, "Wrong alignment on UVFormIDNavLinkCustomComponent");
static_assert(sizeof(UVFormIDNavLinkCustomComponent) == 0x000230, "Wrong size on UVFormIDNavLinkCustomComponent");
static_assert(offsetof(UVFormIDNavLinkCustomComponent, AllowedFormIDs) == 0x0001E0, "Member 'UVFormIDNavLinkCustomComponent::AllowedFormIDs' has a wrong offset!");

// Class Altar.ReactToFreezeInterface
// 0x0000 (0x0000 - 0x0000)
class IReactToFreezeInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReactToFreezeInterface">();
	}
	static class IReactToFreezeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IReactToFreezeInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IReactToFreezeInterface) == 0x000001, "Wrong alignment on IReactToFreezeInterface");
static_assert(sizeof(IReactToFreezeInterface) == 0x000001, "Wrong size on IReactToFreezeInterface");

// Class Altar.VFreezeInMenuSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class UVFreezeInMenuSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x78];                                      // 0x0030(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVFreezeLayer>                  FreezeStack;                                       // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Freeze(const class FName& FreezeName, bool bShouldFreezeOblivion);
	void RequestMode(EVFreezeSubsystemMode NewMode);
	void SetMode(EVFreezeSubsystemMode NewMode);
	void SpareActorFromFreeze(class AActor* ActorToAffect);
	void UnFreeze(const class FName& FreezeName, bool bShouldUnfreezeOblivion);

	class FName GetCurrentFreezeName() const;
	EVFreezeSubsystemMode GetMode() const;
	bool IsActorFrozen(const class AActor* Actor) const;
	bool IsFreezing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFreezeInMenuSubsystem">();
	}
	static class UVFreezeInMenuSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVFreezeInMenuSubsystem>();
	}
};
static_assert(alignof(UVFreezeInMenuSubsystem) == 0x000008, "Wrong alignment on UVFreezeInMenuSubsystem");
static_assert(sizeof(UVFreezeInMenuSubsystem) == 0x0000E0, "Wrong size on UVFreezeInMenuSubsystem");
static_assert(offsetof(UVFreezeInMenuSubsystem, FreezeStack) == 0x0000A8, "Member 'UVFreezeInMenuSubsystem::FreezeStack' has a wrong offset!");

// Class Altar.VGameplayTagOverlapComponent
// 0x0020 (0x00C0 - 0x00A0)
class UVGameplayTagOverlapComponent final : public UActorComponent
{
public:
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x00A0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void OnActorBeginOverlap(const class AActor* OverlappedActor, const class AActor* OtherActor);
	void OnActorEndOverlap(const class AActor* OverlappedActor, const class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VGameplayTagOverlapComponent">();
	}
	static class UVGameplayTagOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVGameplayTagOverlapComponent>();
	}
};
static_assert(alignof(UVGameplayTagOverlapComponent) == 0x000008, "Wrong alignment on UVGameplayTagOverlapComponent");
static_assert(sizeof(UVGameplayTagOverlapComponent) == 0x0000C0, "Wrong size on UVGameplayTagOverlapComponent");
static_assert(offsetof(UVGameplayTagOverlapComponent, GameplayTags) == 0x0000A0, "Member 'UVGameplayTagOverlapComponent::GameplayTags' has a wrong offset!");

// Class Altar.VGamertagViewModel
// 0x0000 (0x00D0 - 0x00D0)
class UVGamertagViewModel final : public UVViewModelBase
{
public:
	bool ThisIsForPluginCompliance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VGamertagViewModel">();
	}
	static class UVGamertagViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVGamertagViewModel>();
	}
};
static_assert(alignof(UVGamertagViewModel) == 0x000008, "Wrong alignment on UVGamertagViewModel");
static_assert(sizeof(UVGamertagViewModel) == 0x0000D0, "Wrong size on UVGamertagViewModel");

// Class Altar.VGenericMenuViewModel
// 0x0128 (0x01F8 - 0x00D0)
class UVGenericMenuViewModel final : public UVViewModelBase
{
public:
	class FText                                   ControllerText;                                    // 0x00D0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   MouseKeyboardText;                                 // 0x00E8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLegacyQuestAddedProperties            Properties;                                        // 0x0100(0x00A8)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x50];                                     // 0x01A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendClickedButton(int32 Value);
	void SetProperties(const struct FLegacyQuestAddedProperties& NewProperties);

	struct FLegacyQuestAddedProperties GetProperties() const;
	bool ThisIsForPluginCompliance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VGenericMenuViewModel">();
	}
	static class UVGenericMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVGenericMenuViewModel>();
	}
};
static_assert(alignof(UVGenericMenuViewModel) == 0x000008, "Wrong alignment on UVGenericMenuViewModel");
static_assert(sizeof(UVGenericMenuViewModel) == 0x0001F8, "Wrong size on UVGenericMenuViewModel");
static_assert(offsetof(UVGenericMenuViewModel, ControllerText) == 0x0000D0, "Member 'UVGenericMenuViewModel::ControllerText' has a wrong offset!");
static_assert(offsetof(UVGenericMenuViewModel, MouseKeyboardText) == 0x0000E8, "Member 'UVGenericMenuViewModel::MouseKeyboardText' has a wrong offset!");
static_assert(offsetof(UVGenericMenuViewModel, Properties) == 0x000100, "Member 'UVGenericMenuViewModel::Properties' has a wrong offset!");

// Class Altar.VGrabArmComponent
// 0x01F0 (0x0490 - 0x02A0)
class UVGrabArmComponent final : public USceneComponent
{
public:
	class USphereComponent*                       GrabAnchorComponent;                               // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsConstraintComponent*            GrabConstraintComponent;                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 ConstraintIndex)> OnGrabConstraintBroken;                    // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         BaseTargetArmLength;                               // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinArmLength;                                      // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxArmLength;                                      // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetArmLength;                                   // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketOffset;                                      // 0x02D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x02E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProbeSize;                                         // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ProbeChannel;                                      // 0x0304(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_305[0x3];                                      // 0x0305(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDoCollisionTest : 1;                              // 0x0308(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseOblivionPlayerCharacterPickLookAt : 1;         // 0x0308(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritPitch : 1;                                 // 0x0308(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritYaw : 1;                                   // 0x0308(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritRoll : 1;                                  // 0x0308(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PullSpeed;                                         // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushSpeed;                                         // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableGrabLag : 1;                                // 0x0314(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableGrabRotationLag : 1;                        // 0x0314(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseGrabLagSubstepping : 1;                        // 0x0314(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDebugLagMarkers : 1;                          // 0x0314(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrabLagSpeed;                                      // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrabRotationLagSpeed;                              // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrabLagMaxTimeStep;                                // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrabLagMaxDistance;                                // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bClampToMaxPhysicsDeltaTime : 1;                   // 0x0328(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_329[0x3];                                      // 0x0329(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinLinearDriveForce;                               // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearDriveForce;                               // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MinStrengthThreshold;                              // 0x0334(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxStrengthThreshold;                              // 0x0335(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_336[0x2];                                      // 0x0336(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearLimitLength;                                 // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstraintBreakingLengthThreshold;                 // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyHierarchyDepthFactor;                          // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticMeshPhysicBodyLinearDampingOverride;         // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticMeshPhysicBodyAngularDampingOverride;        // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesPropagateGrabArmYaw;                          // 0x034C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesPropagateGrabArmPitch;                        // 0x034D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E[0x2];                                      // 0x034E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MinDotProductToDisplayGrabbedActorName;            // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0xE0];                                     // 0x0358(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVGrabActionData                       CurrentGrabActionData;                             // 0x0438(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FVGrabOverridenSettings                OverridenSettingsToRestoreOnGrabEnd;               // 0x0480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FRotator GetTargetRotation() const;
	struct FVector GetUnfixedGrabAnchorPosition() const;
	bool IsCollisionFixApplied() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VGrabArmComponent">();
	}
	static class UVGrabArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVGrabArmComponent>();
	}
};
static_assert(alignof(UVGrabArmComponent) == 0x000010, "Wrong alignment on UVGrabArmComponent");
static_assert(sizeof(UVGrabArmComponent) == 0x000490, "Wrong size on UVGrabArmComponent");
static_assert(offsetof(UVGrabArmComponent, GrabAnchorComponent) == 0x0002A0, "Member 'UVGrabArmComponent::GrabAnchorComponent' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, GrabConstraintComponent) == 0x0002A8, "Member 'UVGrabArmComponent::GrabConstraintComponent' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, OnGrabConstraintBroken) == 0x0002B0, "Member 'UVGrabArmComponent::OnGrabConstraintBroken' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, BaseTargetArmLength) == 0x0002C0, "Member 'UVGrabArmComponent::BaseTargetArmLength' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, MinArmLength) == 0x0002C4, "Member 'UVGrabArmComponent::MinArmLength' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, MaxArmLength) == 0x0002C8, "Member 'UVGrabArmComponent::MaxArmLength' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, TargetArmLength) == 0x0002CC, "Member 'UVGrabArmComponent::TargetArmLength' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, SocketOffset) == 0x0002D0, "Member 'UVGrabArmComponent::SocketOffset' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, TargetOffset) == 0x0002E8, "Member 'UVGrabArmComponent::TargetOffset' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, ProbeSize) == 0x000300, "Member 'UVGrabArmComponent::ProbeSize' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, ProbeChannel) == 0x000304, "Member 'UVGrabArmComponent::ProbeChannel' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, PullSpeed) == 0x00030C, "Member 'UVGrabArmComponent::PullSpeed' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, PushSpeed) == 0x000310, "Member 'UVGrabArmComponent::PushSpeed' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, GrabLagSpeed) == 0x000318, "Member 'UVGrabArmComponent::GrabLagSpeed' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, GrabRotationLagSpeed) == 0x00031C, "Member 'UVGrabArmComponent::GrabRotationLagSpeed' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, GrabLagMaxTimeStep) == 0x000320, "Member 'UVGrabArmComponent::GrabLagMaxTimeStep' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, GrabLagMaxDistance) == 0x000324, "Member 'UVGrabArmComponent::GrabLagMaxDistance' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, MinLinearDriveForce) == 0x00032C, "Member 'UVGrabArmComponent::MinLinearDriveForce' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, MaxLinearDriveForce) == 0x000330, "Member 'UVGrabArmComponent::MaxLinearDriveForce' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, MinStrengthThreshold) == 0x000334, "Member 'UVGrabArmComponent::MinStrengthThreshold' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, MaxStrengthThreshold) == 0x000335, "Member 'UVGrabArmComponent::MaxStrengthThreshold' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, LinearLimitLength) == 0x000338, "Member 'UVGrabArmComponent::LinearLimitLength' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, ConstraintBreakingLengthThreshold) == 0x00033C, "Member 'UVGrabArmComponent::ConstraintBreakingLengthThreshold' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, BodyHierarchyDepthFactor) == 0x000340, "Member 'UVGrabArmComponent::BodyHierarchyDepthFactor' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, StaticMeshPhysicBodyLinearDampingOverride) == 0x000344, "Member 'UVGrabArmComponent::StaticMeshPhysicBodyLinearDampingOverride' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, StaticMeshPhysicBodyAngularDampingOverride) == 0x000348, "Member 'UVGrabArmComponent::StaticMeshPhysicBodyAngularDampingOverride' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, bDoesPropagateGrabArmYaw) == 0x00034C, "Member 'UVGrabArmComponent::bDoesPropagateGrabArmYaw' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, bDoesPropagateGrabArmPitch) == 0x00034D, "Member 'UVGrabArmComponent::bDoesPropagateGrabArmPitch' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, MinDotProductToDisplayGrabbedActorName) == 0x000350, "Member 'UVGrabArmComponent::MinDotProductToDisplayGrabbedActorName' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, CurrentGrabActionData) == 0x000438, "Member 'UVGrabArmComponent::CurrentGrabActionData' has a wrong offset!");
static_assert(offsetof(UVGrabArmComponent, OverridenSettingsToRestoreOnGrabEnd) == 0x000480, "Member 'UVGrabArmComponent::OverridenSettingsToRestoreOnGrabEnd' has a wrong offset!");

// Class Altar.VLocomotionHorseAnimInstance
// 0x0020 (0x0480 - 0x0460)
class UVLocomotionHorseAnimInstance : public UVLocomotionCharacterAnimInstance
{
public:
	float                                         LeanHorizontal;                                    // 0x0460(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGallopSpeed;                                    // 0x0464(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CanterSpeed;                                       // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GallopForwardSpeedAlpha;                           // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInGallop;                                       // 0x0470(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasRider;                                         // 0x0471(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRiderNPC;                                       // 0x0472(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_473[0x5];                                      // 0x0473(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AVPairedCreature*                       Horse;                                             // 0x0478(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsInTrot() const;
	bool IsMovingBackward() const;
	bool IsMovingForward() const;
	bool IsWalking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLocomotionHorseAnimInstance">();
	}
	static class UVLocomotionHorseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLocomotionHorseAnimInstance>();
	}
};
static_assert(alignof(UVLocomotionHorseAnimInstance) == 0x000010, "Wrong alignment on UVLocomotionHorseAnimInstance");
static_assert(sizeof(UVLocomotionHorseAnimInstance) == 0x000480, "Wrong size on UVLocomotionHorseAnimInstance");
static_assert(offsetof(UVLocomotionHorseAnimInstance, LeanHorizontal) == 0x000460, "Member 'UVLocomotionHorseAnimInstance::LeanHorizontal' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseAnimInstance, MaxGallopSpeed) == 0x000464, "Member 'UVLocomotionHorseAnimInstance::MaxGallopSpeed' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseAnimInstance, CanterSpeed) == 0x000468, "Member 'UVLocomotionHorseAnimInstance::CanterSpeed' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseAnimInstance, GallopForwardSpeedAlpha) == 0x00046C, "Member 'UVLocomotionHorseAnimInstance::GallopForwardSpeedAlpha' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseAnimInstance, bIsInGallop) == 0x000470, "Member 'UVLocomotionHorseAnimInstance::bIsInGallop' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseAnimInstance, bHasRider) == 0x000471, "Member 'UVLocomotionHorseAnimInstance::bHasRider' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseAnimInstance, bIsRiderNPC) == 0x000472, "Member 'UVLocomotionHorseAnimInstance::bIsRiderNPC' has a wrong offset!");
static_assert(offsetof(UVLocomotionHorseAnimInstance, Horse) == 0x000478, "Member 'UVLocomotionHorseAnimInstance::Horse' has a wrong offset!");

// Class Altar.VGroundLocomotionHorseAnimInstance
// 0x0210 (0x0690 - 0x0480)
class UVGroundLocomotionHorseAnimInstance : public UVLocomotionHorseAnimInstance
{
public:
	uint8                                         Pad_480[0x10];                                     // 0x0480(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInSpecialIdle;                                  // 0x0490(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0x3];                                      // 0x0491(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HalfFloorRaycastNum;                               // 0x0494(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyRadius;                                        // 0x0498(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleHalfHeight;                                 // 0x049C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RaycastLength;                                     // 0x04A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlopeNormalInterpSpeed;                            // 0x04A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVHorseLocomotionData                  AnimSet;                                           // 0x04A8(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      DefaultIdle;                                       // 0x04F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      CurrentSpecialIdle;                                // 0x0500(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimSequenceBase*>              SpecialIdleList;                                   // 0x0508(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         MinIdleTime;                                       // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxIdleTime;                                       // 0x051C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistance;                                       // 0x0520(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxAttempts;                                       // 0x0524(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowestHorseAnimationSpeed;                        // 0x0528(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastestHorseAnimationSpeed;                        // 0x052C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackwardHorseAnimationSpeed;                       // 0x0530(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_534[0x15C];                                    // 0x0534(0x015C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpecialIdleExit(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnUpdateIdleState(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void ProcessIdleTransitionLogic(float DeltaTime);
	void ProcessSpecialIdleTransitionLogic(float DeltaTime);

	bool CanPlaySpecialIdle() const;
	int32 GetCurrentSpecialIdleIndex() const;
	float GetLocomotionPlayRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VGroundLocomotionHorseAnimInstance">();
	}
	static class UVGroundLocomotionHorseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVGroundLocomotionHorseAnimInstance>();
	}
};
static_assert(alignof(UVGroundLocomotionHorseAnimInstance) == 0x000010, "Wrong alignment on UVGroundLocomotionHorseAnimInstance");
static_assert(sizeof(UVGroundLocomotionHorseAnimInstance) == 0x000690, "Wrong size on UVGroundLocomotionHorseAnimInstance");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, bIsInSpecialIdle) == 0x000490, "Member 'UVGroundLocomotionHorseAnimInstance::bIsInSpecialIdle' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, HalfFloorRaycastNum) == 0x000494, "Member 'UVGroundLocomotionHorseAnimInstance::HalfFloorRaycastNum' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, BodyRadius) == 0x000498, "Member 'UVGroundLocomotionHorseAnimInstance::BodyRadius' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, CapsuleHalfHeight) == 0x00049C, "Member 'UVGroundLocomotionHorseAnimInstance::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, RaycastLength) == 0x0004A0, "Member 'UVGroundLocomotionHorseAnimInstance::RaycastLength' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, SlopeNormalInterpSpeed) == 0x0004A4, "Member 'UVGroundLocomotionHorseAnimInstance::SlopeNormalInterpSpeed' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, AnimSet) == 0x0004A8, "Member 'UVGroundLocomotionHorseAnimInstance::AnimSet' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, DefaultIdle) == 0x0004F8, "Member 'UVGroundLocomotionHorseAnimInstance::DefaultIdle' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, CurrentSpecialIdle) == 0x000500, "Member 'UVGroundLocomotionHorseAnimInstance::CurrentSpecialIdle' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, SpecialIdleList) == 0x000508, "Member 'UVGroundLocomotionHorseAnimInstance::SpecialIdleList' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, MinIdleTime) == 0x000518, "Member 'UVGroundLocomotionHorseAnimInstance::MinIdleTime' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, MaxIdleTime) == 0x00051C, "Member 'UVGroundLocomotionHorseAnimInstance::MaxIdleTime' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, MaxDistance) == 0x000520, "Member 'UVGroundLocomotionHorseAnimInstance::MaxDistance' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, MaxAttempts) == 0x000524, "Member 'UVGroundLocomotionHorseAnimInstance::MaxAttempts' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, SlowestHorseAnimationSpeed) == 0x000528, "Member 'UVGroundLocomotionHorseAnimInstance::SlowestHorseAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, FastestHorseAnimationSpeed) == 0x00052C, "Member 'UVGroundLocomotionHorseAnimInstance::FastestHorseAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseAnimInstance, BackwardHorseAnimationSpeed) == 0x000530, "Member 'UVGroundLocomotionHorseAnimInstance::BackwardHorseAnimationSpeed' has a wrong offset!");

// Class Altar.VGroundLocomotionHorseRiderAnimInstance
// 0x0070 (0x0500 - 0x0490)
class UVGroundLocomotionHorseRiderAnimInstance : public UVLocomotionHorseRiderAnimInstance
{
public:
	bool                                          bCanLean;                                          // 0x0490(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVHorseRiderLocomotionStanding         GroundLayerData;                                   // 0x0498(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UVGroundLocomotionHorseAnimInstance*    HorseGroundLocoAnimInstance;                       // 0x04E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInSpecialIdle;                                  // 0x04F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanPlaySpecialIdle;                               // 0x04F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInDialogue;                                     // 0x04F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F3[0x1];                                      // 0x04F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAnimSequence>           CurrentSpecialIdle;                                // 0x04F4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FC[0x4];                                      // 0x04FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGroundLayerData(const struct FVHorseRiderLocomotionStanding& InGroundLayerData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VGroundLocomotionHorseRiderAnimInstance">();
	}
	static class UVGroundLocomotionHorseRiderAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVGroundLocomotionHorseRiderAnimInstance>();
	}
};
static_assert(alignof(UVGroundLocomotionHorseRiderAnimInstance) == 0x000010, "Wrong alignment on UVGroundLocomotionHorseRiderAnimInstance");
static_assert(sizeof(UVGroundLocomotionHorseRiderAnimInstance) == 0x000500, "Wrong size on UVGroundLocomotionHorseRiderAnimInstance");
static_assert(offsetof(UVGroundLocomotionHorseRiderAnimInstance, bCanLean) == 0x000490, "Member 'UVGroundLocomotionHorseRiderAnimInstance::bCanLean' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseRiderAnimInstance, GroundLayerData) == 0x000498, "Member 'UVGroundLocomotionHorseRiderAnimInstance::GroundLayerData' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseRiderAnimInstance, HorseGroundLocoAnimInstance) == 0x0004E8, "Member 'UVGroundLocomotionHorseRiderAnimInstance::HorseGroundLocoAnimInstance' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseRiderAnimInstance, bIsInSpecialIdle) == 0x0004F0, "Member 'UVGroundLocomotionHorseRiderAnimInstance::bIsInSpecialIdle' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseRiderAnimInstance, bCanPlaySpecialIdle) == 0x0004F1, "Member 'UVGroundLocomotionHorseRiderAnimInstance::bCanPlaySpecialIdle' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseRiderAnimInstance, bIsInDialogue) == 0x0004F2, "Member 'UVGroundLocomotionHorseRiderAnimInstance::bIsInDialogue' has a wrong offset!");
static_assert(offsetof(UVGroundLocomotionHorseRiderAnimInstance, CurrentSpecialIdle) == 0x0004F4, "Member 'UVGroundLocomotionHorseRiderAnimInstance::CurrentSpecialIdle' has a wrong offset!");

// Class Altar.VHelmetHeadMorphDataAsset
// 0x02D0 (0x0300 - 0x0030)
class UVHelmetHeadMorphDataAsset final : public UDataAsset
{
public:
	struct FVFaceMorphLimits                      DefaultLimits;                                     // 0x0030(0x0280)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, struct FVMorphLimitsRaceOverride> LimitsOverridePerRace;                     // 0x02B0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHelmetHeadMorphDataAsset">();
	}
	static class UVHelmetHeadMorphDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHelmetHeadMorphDataAsset>();
	}
};
static_assert(alignof(UVHelmetHeadMorphDataAsset) == 0x000008, "Wrong alignment on UVHelmetHeadMorphDataAsset");
static_assert(sizeof(UVHelmetHeadMorphDataAsset) == 0x000300, "Wrong size on UVHelmetHeadMorphDataAsset");
static_assert(offsetof(UVHelmetHeadMorphDataAsset, DefaultLimits) == 0x000030, "Member 'UVHelmetHeadMorphDataAsset::DefaultLimits' has a wrong offset!");
static_assert(offsetof(UVHelmetHeadMorphDataAsset, LimitsOverridePerRace) == 0x0002B0, "Member 'UVHelmetHeadMorphDataAsset::LimitsOverridePerRace' has a wrong offset!");

// Class Altar.VHelpMenuViewModel
// 0x0010 (0x00E0 - 0x00D0)
class UVHelpMenuViewModel final : public UVViewModelBase
{
public:
	int32                                         ViewMode;                                          // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             TutorialData;                                      // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void LoadHelpMenuViewModel();
	void SetViewMode(const int32 Value);
	void UnloadHelpMenuViewModel();

	class UDataTable* GetTutorialData() const;
	const int32 GetViewMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHelpMenuViewModel">();
	}
	static class UVHelpMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHelpMenuViewModel>();
	}
};
static_assert(alignof(UVHelpMenuViewModel) == 0x000008, "Wrong alignment on UVHelpMenuViewModel");
static_assert(sizeof(UVHelpMenuViewModel) == 0x0000E0, "Wrong size on UVHelpMenuViewModel");
static_assert(offsetof(UVHelpMenuViewModel, ViewMode) == 0x0000D0, "Member 'UVHelpMenuViewModel::ViewMode' has a wrong offset!");
static_assert(offsetof(UVHelpMenuViewModel, TutorialData) == 0x0000D8, "Member 'UVHelpMenuViewModel::TutorialData' has a wrong offset!");

// Class Altar.VHitReactionAnimInstance
// 0x0040 (0x03E0 - 0x03A0)
class UVHitReactionAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	EHitReactionState                             HitReactionState;                                  // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoredTags;                                       // 0x03A8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseDirectionSnapping;                             // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardDeadZone;                                   // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHitReactionAnimInstance">();
	}
	static class UVHitReactionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHitReactionAnimInstance>();
	}
};
static_assert(alignof(UVHitReactionAnimInstance) == 0x000010, "Wrong alignment on UVHitReactionAnimInstance");
static_assert(sizeof(UVHitReactionAnimInstance) == 0x0003E0, "Wrong size on UVHitReactionAnimInstance");
static_assert(offsetof(UVHitReactionAnimInstance, HitReactionState) == 0x0003A0, "Member 'UVHitReactionAnimInstance::HitReactionState' has a wrong offset!");
static_assert(offsetof(UVHitReactionAnimInstance, IgnoredTags) == 0x0003A8, "Member 'UVHitReactionAnimInstance::IgnoredTags' has a wrong offset!");
static_assert(offsetof(UVHitReactionAnimInstance, bUseDirectionSnapping) == 0x0003C8, "Member 'UVHitReactionAnimInstance::bUseDirectionSnapping' has a wrong offset!");
static_assert(offsetof(UVHitReactionAnimInstance, ForwardDeadZone) == 0x0003CC, "Member 'UVHitReactionAnimInstance::ForwardDeadZone' has a wrong offset!");

// Class Altar.VHitReactionKeyframeAnimInstance
// 0x0060 (0x0440 - 0x03E0)
class UVHitReactionKeyframeAnimInstance : public UVHitReactionAnimInstance
{
public:
	struct FHitReactionKeyframeData               AnimSet;                                           // 0x03E0(0x0030)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              Direction;                                         // 0x0410(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            CurrentBlendSpace;                                 // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentAlpha;                                      // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AlphaVariance;                                     // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ShouldPlayHitReaction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHitReactionKeyframeAnimInstance">();
	}
	static class UVHitReactionKeyframeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHitReactionKeyframeAnimInstance>();
	}
};
static_assert(alignof(UVHitReactionKeyframeAnimInstance) == 0x000010, "Wrong alignment on UVHitReactionKeyframeAnimInstance");
static_assert(sizeof(UVHitReactionKeyframeAnimInstance) == 0x000440, "Wrong size on UVHitReactionKeyframeAnimInstance");
static_assert(offsetof(UVHitReactionKeyframeAnimInstance, AnimSet) == 0x0003E0, "Member 'UVHitReactionKeyframeAnimInstance::AnimSet' has a wrong offset!");
static_assert(offsetof(UVHitReactionKeyframeAnimInstance, Direction) == 0x000410, "Member 'UVHitReactionKeyframeAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(UVHitReactionKeyframeAnimInstance, CurrentBlendSpace) == 0x000420, "Member 'UVHitReactionKeyframeAnimInstance::CurrentBlendSpace' has a wrong offset!");
static_assert(offsetof(UVHitReactionKeyframeAnimInstance, CurrentAlpha) == 0x000428, "Member 'UVHitReactionKeyframeAnimInstance::CurrentAlpha' has a wrong offset!");
static_assert(offsetof(UVHitReactionKeyframeAnimInstance, AlphaVariance) == 0x00042C, "Member 'UVHitReactionKeyframeAnimInstance::AlphaVariance' has a wrong offset!");

// Class Altar.VHitReactionProceduralAnimInstance
// 0x00A0 (0x0480 - 0x03E0)
class UVHitReactionProceduralAnimInstance final : public UVHitReactionAnimInstance
{
public:
	struct FHitReactionData                       LayerData;                                         // 0x03E0(0x0040)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  RestrictedStates;                                  // 0x0420(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FName                                   HitReactProfileName;                               // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpreadPhysicsBlend;                                // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReactionPhysicsBlend;                              // 0x044C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            RecoveryCurve;                                     // 0x0450(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x28];                                     // 0x0458(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitHitReaction(const class FName HitBoneName, const struct FVector& HitDirection, bool bIsArrow, bool bIsPowerAttack, bool bIsSpell);
	void OnHitReaction(const struct FVHitReactEvent& HitReactEvent);
	void OnPawnPhysicsSimulationStart();
	void OnPawnPhysicsSimulationStop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHitReactionProceduralAnimInstance">();
	}
	static class UVHitReactionProceduralAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHitReactionProceduralAnimInstance>();
	}
};
static_assert(alignof(UVHitReactionProceduralAnimInstance) == 0x000010, "Wrong alignment on UVHitReactionProceduralAnimInstance");
static_assert(sizeof(UVHitReactionProceduralAnimInstance) == 0x000480, "Wrong size on UVHitReactionProceduralAnimInstance");
static_assert(offsetof(UVHitReactionProceduralAnimInstance, LayerData) == 0x0003E0, "Member 'UVHitReactionProceduralAnimInstance::LayerData' has a wrong offset!");
static_assert(offsetof(UVHitReactionProceduralAnimInstance, RestrictedStates) == 0x000420, "Member 'UVHitReactionProceduralAnimInstance::RestrictedStates' has a wrong offset!");
static_assert(offsetof(UVHitReactionProceduralAnimInstance, HitReactProfileName) == 0x000440, "Member 'UVHitReactionProceduralAnimInstance::HitReactProfileName' has a wrong offset!");
static_assert(offsetof(UVHitReactionProceduralAnimInstance, SpreadPhysicsBlend) == 0x000448, "Member 'UVHitReactionProceduralAnimInstance::SpreadPhysicsBlend' has a wrong offset!");
static_assert(offsetof(UVHitReactionProceduralAnimInstance, ReactionPhysicsBlend) == 0x00044C, "Member 'UVHitReactionProceduralAnimInstance::ReactionPhysicsBlend' has a wrong offset!");
static_assert(offsetof(UVHitReactionProceduralAnimInstance, RecoveryCurve) == 0x000450, "Member 'UVHitReactionProceduralAnimInstance::RecoveryCurve' has a wrong offset!");

// Class Altar.VPairedPawnMovementComponent
// 0x0340 (0x1290 - 0x0F50)
#pragma pack(push, 0x1)
class alignas(0x10) UVPairedPawnMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_F48[0x8];                                      // 0x0F48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDoesSweepAllSecondaryColliders;                   // 0x0F50(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesDrawDebugSecondarySweepTraces;                // 0x0F51(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPawnGetPushedBySimulatingActor;                // 0x0F52(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F53[0x1];                                      // 0x0F53(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SimulatingActorPushFactor;                         // 0x0F54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumSimulatingActorPushVelocity;                // 0x0F58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesDrawSimulatingActorPush;                      // 0x0F5C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5D[0x3];                                      // 0x0F5D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CurrentGait;                                       // 0x0F60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HighestReachableGait;                              // 0x0F68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRunMult;                                       // 0x0F70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRunAthleticsMult;                              // 0x0F74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSwimRunAthleticsMult;                          // 0x0F78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSwimRunBase;                                   // 0x0F7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSwimWalkAthleticsMult;                         // 0x0F80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSwimWalkBase;                                  // 0x0F84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveWeightMax;                                     // 0x0F88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveWeightMin;                                     // 0x0F8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveWalkMax;                                       // 0x0F90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveWalkMin;                                       // 0x0F94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveEncumEffectNoWea;                              // 0x0F98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveEncumEffect;                                   // 0x0F9C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveNoWeaponMult;                                  // 0x0FA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSneakMult;                                     // 0x0FA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSneakRunMult;                                  // 0x0FA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveMaxFlySpeed;                                   // 0x0FAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveMinFlySpeed;                                   // 0x0FB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSprintBaseMult;                                // 0x0FB4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSprintAthleticsMult;                           // 0x0FB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FBC[0x4];                                      // 0x0FBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DirectionalSpeedCurve;                             // 0x0FC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartWalkDuration;                                 // 0x0FC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopWalkDuration;                                  // 0x0FCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartRunDuration;                                  // 0x0FD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopRunDuration;                                   // 0x0FD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartSprintDuration;                               // 0x0FD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopSprintDuration;                                // 0x0FDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsToRun;                                       // 0x0FE0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE1[0x3];                                      // 0x0FE1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunningThresholdRatio;                             // 0x0FE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSprintFatigueBaseCostPerSec;                   // 0x0FE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSprintFatigueRegenDelay;                       // 0x0FEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DirectionalAxis;                                   // 0x0FF0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalAxisLength;                             // 0x1000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOblivionLikeWalkingPhysics;                    // 0x1004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayOblivionLocoDebug;                         // 0x1005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1006[0x2];                                     // 0x1006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             NonLandscapeCollisionProfilesEligibleForAntiClimbing; // 0x1008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         SlopeAngleThresholdToUseDirectionalAntiClimbing;   // 0x1058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlopeAngleForFloorsNotEligibleForAntiClimbing;  // 0x105C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSlopeAntiClimbingActivationAngle;               // 0x1060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlopeAntiClimbingActivationAngle;               // 0x1064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlopeAngleBeforeSlide;                          // 0x1068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinJumpOffSlopeAngle;                              // 0x106C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinJumpOffSlopeVelocity;                           // 0x1070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAntiClimbingFactor;                             // 0x1074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAntiClimbingFactor;                             // 0x1078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_107C[0x4];                                     // 0x107C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             AntiClimbingFactorAgainstSlopeAngleCurve;          // 0x1080(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             NonLandscapeFloorAntiClimbingReducingFactorAgainstSlopeAngleCurve; // 0x10A8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocitySmoothingSpeed;                         // 0x10D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocitySmoothingSpeed;                         // 0x10D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             VelocitySmoothingAgainstSlopeAngleCurve;           // 0x10D8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapUpwardVelocityAtMaxSlopeAngle;                 // 0x1100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventJumpOnStiffSlopes;                         // 0x1101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1102[0x2];                                     // 0x1102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreventJumpMinSlopeAngle;                          // 0x1104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocomotionDebugEnabled;                         // 0x1108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccelerationEnabled;                              // 0x1109(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUseParentDeceleration;                       // 0x110A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110B[0x1];                                     // 0x110B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSwimmingDepth;                                  // 0x110C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOutOfWaterZFactor;                             // 0x1110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthToAllowJumpOutOfWater;                        // 0x1114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcrobaticWaterJumpZFactor;                         // 0x1118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddAboveWaterAcrobaticJumpDistanceAcceptance;     // 0x111C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111D[0x3];                                     // 0x111D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AcrobaticWaterJumpMaxDistanceAboveWaterPlane;      // 0x1120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWaterPlaneTestDistance;                         // 0x1124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnderneathWaterPlaneTestOffset;                    // 0x1128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlotationStopDepth;                                // 0x112C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlotationTriggerDepth;                             // 0x1130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceStabilisationSpeed;                         // 0x1134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterDecelerationSpeed;                            // 0x1138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterWalkJumpVerticalVelocityLimit;                // 0x113C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterWalkJumpHorizontalVelocityLimit;              // 0x1140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinWaterplaneDistanceToEnableWaterWalk;            // 0x1144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWaterplaneDistanceToEnableWaterWalk;            // 0x1148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampMinJumpOutOfWaterZForWaterWalk;              // 0x114C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114D[0x3];                                     // 0x114D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinJumpOutOfWaterZForWaterWalk;                    // 0x1150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSlideAgainstPawns;                             // 0x1154(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1155[0x13];                                    // 0x1155(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PawnInteractionForce;                              // 0x1168(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockNormalVelocity;                              // 0x1180(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1181[0xFF];                                    // 0x1181(0x00FF)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          WaterSplashEvent;                                  // 0x1280(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AcrobaticWaterJump();
	bool DoSpecialJump(float JumpHeightMultiplier, float HorizontalVelocityMultiplier);
	bool IsRunning();
	void OnHitFromSimulatingActor(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnPawnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPawnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnSprintFatigueRegenDelayFinished();
	void ResetFallingTimer();
	void ResetGlobalSpeedMultiplier();
	void ResetOffsetMovementInput();
	void ResetOverrideMaxSpeed();
	void SetAllowWaterWalking(bool bNewAllowWaterWalking);
	void SetGlobalSpeedMultiplier(float NewMultiplier);
	void SetIsMovementLocked(bool LockMovement);
	void SetOffsetMovementInput(const struct FVector& NewOverrideMoveInput);
	void SetOverrideMaxSpeed(float fNewOverrideMaxSpeed);
	void SetPreventSwimming(bool bNeverSwim);
	void SetUseControllerRotation(bool bUseControllerRotation);
	void StartSprint();
	void StopSprint();
	void SwimmingJumpOutOfWater();

	bool CanAcrobaticWaterJump() const;
	bool CanJumpOutOfWater() const;
	bool CanWaterWalk() const;
	float GetCurrentGaitMaxSpeed() const;
	float GetDistanceToUnderneathWaterPlane() const;
	float GetFallingTimer() const;
	float GetGlobalSpeedMultiplier() const;
	float GetImmersionDepth() const;
	bool GetIsSwimming() const;
	float GetMaxFlySpeed() const;
	float GetMaxGroundRunSpeed() const;
	float GetMaxGroundSprintSpeed() const;
	float GetMaxGroundWalkSpeed() const;
	float GetMaxSwimRunSpeed() const;
	float GetMaxSwimWalkSpeed() const;
	EVMoveDirection GetMovementDirection() const;
	bool IsAboveWater() const;
	bool IsInSprintRegenDelay() const;
	bool IsMovementLocked() const;
	bool IsSprinting() const;
	bool IsTouchingWater() const;
	bool IsWaterWalking() const;
	bool IsWaterWalkingAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPairedPawnMovementComponent">();
	}
	static class UVPairedPawnMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPairedPawnMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVPairedPawnMovementComponent) == 0x000010, "Wrong alignment on UVPairedPawnMovementComponent");
static_assert(sizeof(UVPairedPawnMovementComponent) == 0x001290, "Wrong size on UVPairedPawnMovementComponent");
static_assert(offsetof(UVPairedPawnMovementComponent, bDoesSweepAllSecondaryColliders) == 0x000F50, "Member 'UVPairedPawnMovementComponent::bDoesSweepAllSecondaryColliders' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bDoesDrawDebugSecondarySweepTraces) == 0x000F51, "Member 'UVPairedPawnMovementComponent::bDoesDrawDebugSecondarySweepTraces' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bCanPawnGetPushedBySimulatingActor) == 0x000F52, "Member 'UVPairedPawnMovementComponent::bCanPawnGetPushedBySimulatingActor' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, SimulatingActorPushFactor) == 0x000F54, "Member 'UVPairedPawnMovementComponent::SimulatingActorPushFactor' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MaximumSimulatingActorPushVelocity) == 0x000F58, "Member 'UVPairedPawnMovementComponent::MaximumSimulatingActorPushVelocity' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bDoesDrawSimulatingActorPush) == 0x000F5C, "Member 'UVPairedPawnMovementComponent::bDoesDrawSimulatingActorPush' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, CurrentGait) == 0x000F60, "Member 'UVPairedPawnMovementComponent::CurrentGait' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, HighestReachableGait) == 0x000F68, "Member 'UVPairedPawnMovementComponent::HighestReachableGait' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveRunMult) == 0x000F70, "Member 'UVPairedPawnMovementComponent::MoveRunMult' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveRunAthleticsMult) == 0x000F74, "Member 'UVPairedPawnMovementComponent::MoveRunAthleticsMult' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveSwimRunAthleticsMult) == 0x000F78, "Member 'UVPairedPawnMovementComponent::MoveSwimRunAthleticsMult' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveSwimRunBase) == 0x000F7C, "Member 'UVPairedPawnMovementComponent::MoveSwimRunBase' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveSwimWalkAthleticsMult) == 0x000F80, "Member 'UVPairedPawnMovementComponent::MoveSwimWalkAthleticsMult' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveSwimWalkBase) == 0x000F84, "Member 'UVPairedPawnMovementComponent::MoveSwimWalkBase' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveWeightMax) == 0x000F88, "Member 'UVPairedPawnMovementComponent::MoveWeightMax' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveWeightMin) == 0x000F8C, "Member 'UVPairedPawnMovementComponent::MoveWeightMin' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveWalkMax) == 0x000F90, "Member 'UVPairedPawnMovementComponent::MoveWalkMax' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveWalkMin) == 0x000F94, "Member 'UVPairedPawnMovementComponent::MoveWalkMin' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveEncumEffectNoWea) == 0x000F98, "Member 'UVPairedPawnMovementComponent::MoveEncumEffectNoWea' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveEncumEffect) == 0x000F9C, "Member 'UVPairedPawnMovementComponent::MoveEncumEffect' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveNoWeaponMult) == 0x000FA0, "Member 'UVPairedPawnMovementComponent::MoveNoWeaponMult' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveSneakMult) == 0x000FA4, "Member 'UVPairedPawnMovementComponent::MoveSneakMult' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveSneakRunMult) == 0x000FA8, "Member 'UVPairedPawnMovementComponent::MoveSneakRunMult' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveMaxFlySpeed) == 0x000FAC, "Member 'UVPairedPawnMovementComponent::MoveMaxFlySpeed' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveMinFlySpeed) == 0x000FB0, "Member 'UVPairedPawnMovementComponent::MoveMinFlySpeed' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveSprintBaseMult) == 0x000FB4, "Member 'UVPairedPawnMovementComponent::MoveSprintBaseMult' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveSprintAthleticsMult) == 0x000FB8, "Member 'UVPairedPawnMovementComponent::MoveSprintAthleticsMult' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, DirectionalSpeedCurve) == 0x000FC0, "Member 'UVPairedPawnMovementComponent::DirectionalSpeedCurve' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, StartWalkDuration) == 0x000FC8, "Member 'UVPairedPawnMovementComponent::StartWalkDuration' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, StopWalkDuration) == 0x000FCC, "Member 'UVPairedPawnMovementComponent::StopWalkDuration' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, StartRunDuration) == 0x000FD0, "Member 'UVPairedPawnMovementComponent::StartRunDuration' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, StopRunDuration) == 0x000FD4, "Member 'UVPairedPawnMovementComponent::StopRunDuration' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, StartSprintDuration) == 0x000FD8, "Member 'UVPairedPawnMovementComponent::StartSprintDuration' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, StopSprintDuration) == 0x000FDC, "Member 'UVPairedPawnMovementComponent::StopSprintDuration' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bWantsToRun) == 0x000FE0, "Member 'UVPairedPawnMovementComponent::bWantsToRun' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, RunningThresholdRatio) == 0x000FE4, "Member 'UVPairedPawnMovementComponent::RunningThresholdRatio' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveSprintFatigueBaseCostPerSec) == 0x000FE8, "Member 'UVPairedPawnMovementComponent::MoveSprintFatigueBaseCostPerSec' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MoveSprintFatigueRegenDelay) == 0x000FEC, "Member 'UVPairedPawnMovementComponent::MoveSprintFatigueRegenDelay' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, DirectionalAxis) == 0x000FF0, "Member 'UVPairedPawnMovementComponent::DirectionalAxis' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, DirectionalAxisLength) == 0x001000, "Member 'UVPairedPawnMovementComponent::DirectionalAxisLength' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bUseOblivionLikeWalkingPhysics) == 0x001004, "Member 'UVPairedPawnMovementComponent::bUseOblivionLikeWalkingPhysics' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bDisplayOblivionLocoDebug) == 0x001005, "Member 'UVPairedPawnMovementComponent::bDisplayOblivionLocoDebug' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, NonLandscapeCollisionProfilesEligibleForAntiClimbing) == 0x001008, "Member 'UVPairedPawnMovementComponent::NonLandscapeCollisionProfilesEligibleForAntiClimbing' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, SlopeAngleThresholdToUseDirectionalAntiClimbing) == 0x001058, "Member 'UVPairedPawnMovementComponent::SlopeAngleThresholdToUseDirectionalAntiClimbing' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MaxSlopeAngleForFloorsNotEligibleForAntiClimbing) == 0x00105C, "Member 'UVPairedPawnMovementComponent::MaxSlopeAngleForFloorsNotEligibleForAntiClimbing' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MinSlopeAntiClimbingActivationAngle) == 0x001060, "Member 'UVPairedPawnMovementComponent::MinSlopeAntiClimbingActivationAngle' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MaxSlopeAntiClimbingActivationAngle) == 0x001064, "Member 'UVPairedPawnMovementComponent::MaxSlopeAntiClimbingActivationAngle' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MaxSlopeAngleBeforeSlide) == 0x001068, "Member 'UVPairedPawnMovementComponent::MaxSlopeAngleBeforeSlide' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MinJumpOffSlopeAngle) == 0x00106C, "Member 'UVPairedPawnMovementComponent::MinJumpOffSlopeAngle' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MinJumpOffSlopeVelocity) == 0x001070, "Member 'UVPairedPawnMovementComponent::MinJumpOffSlopeVelocity' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MinAntiClimbingFactor) == 0x001074, "Member 'UVPairedPawnMovementComponent::MinAntiClimbingFactor' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MaxAntiClimbingFactor) == 0x001078, "Member 'UVPairedPawnMovementComponent::MaxAntiClimbingFactor' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, AntiClimbingFactorAgainstSlopeAngleCurve) == 0x001080, "Member 'UVPairedPawnMovementComponent::AntiClimbingFactorAgainstSlopeAngleCurve' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, NonLandscapeFloorAntiClimbingReducingFactorAgainstSlopeAngleCurve) == 0x0010A8, "Member 'UVPairedPawnMovementComponent::NonLandscapeFloorAntiClimbingReducingFactorAgainstSlopeAngleCurve' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MinVelocitySmoothingSpeed) == 0x0010D0, "Member 'UVPairedPawnMovementComponent::MinVelocitySmoothingSpeed' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MaxVelocitySmoothingSpeed) == 0x0010D4, "Member 'UVPairedPawnMovementComponent::MaxVelocitySmoothingSpeed' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, VelocitySmoothingAgainstSlopeAngleCurve) == 0x0010D8, "Member 'UVPairedPawnMovementComponent::VelocitySmoothingAgainstSlopeAngleCurve' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bCapUpwardVelocityAtMaxSlopeAngle) == 0x001100, "Member 'UVPairedPawnMovementComponent::bCapUpwardVelocityAtMaxSlopeAngle' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bPreventJumpOnStiffSlopes) == 0x001101, "Member 'UVPairedPawnMovementComponent::bPreventJumpOnStiffSlopes' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, PreventJumpMinSlopeAngle) == 0x001104, "Member 'UVPairedPawnMovementComponent::PreventJumpMinSlopeAngle' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bIsLocomotionDebugEnabled) == 0x001108, "Member 'UVPairedPawnMovementComponent::bIsLocomotionDebugEnabled' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bAccelerationEnabled) == 0x001109, "Member 'UVPairedPawnMovementComponent::bAccelerationEnabled' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bForceUseParentDeceleration) == 0x00110A, "Member 'UVPairedPawnMovementComponent::bForceUseParentDeceleration' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MinSwimmingDepth) == 0x00110C, "Member 'UVPairedPawnMovementComponent::MinSwimmingDepth' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, JumpOutOfWaterZFactor) == 0x001110, "Member 'UVPairedPawnMovementComponent::JumpOutOfWaterZFactor' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, DepthToAllowJumpOutOfWater) == 0x001114, "Member 'UVPairedPawnMovementComponent::DepthToAllowJumpOutOfWater' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, AcrobaticWaterJumpZFactor) == 0x001118, "Member 'UVPairedPawnMovementComponent::AcrobaticWaterJumpZFactor' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bAddAboveWaterAcrobaticJumpDistanceAcceptance) == 0x00111C, "Member 'UVPairedPawnMovementComponent::bAddAboveWaterAcrobaticJumpDistanceAcceptance' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, AcrobaticWaterJumpMaxDistanceAboveWaterPlane) == 0x001120, "Member 'UVPairedPawnMovementComponent::AcrobaticWaterJumpMaxDistanceAboveWaterPlane' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MaxWaterPlaneTestDistance) == 0x001124, "Member 'UVPairedPawnMovementComponent::MaxWaterPlaneTestDistance' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, UnderneathWaterPlaneTestOffset) == 0x001128, "Member 'UVPairedPawnMovementComponent::UnderneathWaterPlaneTestOffset' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, FlotationStopDepth) == 0x00112C, "Member 'UVPairedPawnMovementComponent::FlotationStopDepth' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, FlotationTriggerDepth) == 0x001130, "Member 'UVPairedPawnMovementComponent::FlotationTriggerDepth' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, SurfaceStabilisationSpeed) == 0x001134, "Member 'UVPairedPawnMovementComponent::SurfaceStabilisationSpeed' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, WaterDecelerationSpeed) == 0x001138, "Member 'UVPairedPawnMovementComponent::WaterDecelerationSpeed' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, WaterWalkJumpVerticalVelocityLimit) == 0x00113C, "Member 'UVPairedPawnMovementComponent::WaterWalkJumpVerticalVelocityLimit' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, WaterWalkJumpHorizontalVelocityLimit) == 0x001140, "Member 'UVPairedPawnMovementComponent::WaterWalkJumpHorizontalVelocityLimit' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MinWaterplaneDistanceToEnableWaterWalk) == 0x001144, "Member 'UVPairedPawnMovementComponent::MinWaterplaneDistanceToEnableWaterWalk' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MaxWaterplaneDistanceToEnableWaterWalk) == 0x001148, "Member 'UVPairedPawnMovementComponent::MaxWaterplaneDistanceToEnableWaterWalk' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bClampMinJumpOutOfWaterZForWaterWalk) == 0x00114C, "Member 'UVPairedPawnMovementComponent::bClampMinJumpOutOfWaterZForWaterWalk' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, MinJumpOutOfWaterZForWaterWalk) == 0x001150, "Member 'UVPairedPawnMovementComponent::MinJumpOutOfWaterZForWaterWalk' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bCanSlideAgainstPawns) == 0x001154, "Member 'UVPairedPawnMovementComponent::bCanSlideAgainstPawns' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, PawnInteractionForce) == 0x001168, "Member 'UVPairedPawnMovementComponent::PawnInteractionForce' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, bBlockNormalVelocity) == 0x001180, "Member 'UVPairedPawnMovementComponent::bBlockNormalVelocity' has a wrong offset!");
static_assert(offsetof(UVPairedPawnMovementComponent, WaterSplashEvent) == 0x001280, "Member 'UVPairedPawnMovementComponent::WaterSplashEvent' has a wrong offset!");

// Class Altar.VHorseMovementComponent
// 0x0040 (0x12D0 - 0x1290)
class UVHorseMovementComponent final : public UVPairedPawnMovementComponent
{
public:
	bool                                          bWantsToGallop;                                    // 0x1288(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1289[0x7];                                     // 0x1289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TurnMoveSpeedMultiplierCurve;                      // 0x1290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrotMultiplier;                                    // 0x1298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129C[0x4];                                     // 0x129C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AccelerationCurve;                                 // 0x12A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DecelerationCurve;                                 // 0x12A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12B0[0x20];                                    // 0x12B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetMaxGroundTrotSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHorseMovementComponent">();
	}
	static class UVHorseMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHorseMovementComponent>();
	}
};
static_assert(alignof(UVHorseMovementComponent) == 0x000010, "Wrong alignment on UVHorseMovementComponent");
static_assert(sizeof(UVHorseMovementComponent) == 0x0012D0, "Wrong size on UVHorseMovementComponent");
static_assert(offsetof(UVHorseMovementComponent, bWantsToGallop) == 0x001288, "Member 'UVHorseMovementComponent::bWantsToGallop' has a wrong offset!");
static_assert(offsetof(UVHorseMovementComponent, TurnMoveSpeedMultiplierCurve) == 0x001290, "Member 'UVHorseMovementComponent::TurnMoveSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UVHorseMovementComponent, TrotMultiplier) == 0x001298, "Member 'UVHorseMovementComponent::TrotMultiplier' has a wrong offset!");
static_assert(offsetof(UVHorseMovementComponent, AccelerationCurve) == 0x0012A0, "Member 'UVHorseMovementComponent::AccelerationCurve' has a wrong offset!");
static_assert(offsetof(UVHorseMovementComponent, DecelerationCurve) == 0x0012A8, "Member 'UVHorseMovementComponent::DecelerationCurve' has a wrong offset!");

// Class Altar.VTurnInPlaceCreatureAnimInstance
// 0x00F0 (0x0490 - 0x03A0)
class UVTurnInPlaceCreatureAnimInstance final : public UVLayerCharacterAnimInstance
{
public:
	struct FVTurnInPlaceCreature                  TurnSettings;                                      // 0x03A0(0x0038)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   BaseRootName;                                      // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            CharacterMoveComp;                                 // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBaseRootBone;                                  // 0x03E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CorrectedCurrentRotation;                          // 0x03F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         TurnPlayRate;                                      // 0x0408(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTurningInCombat;                                // 0x040C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldTurnLeftWithSmallBlend;                     // 0x040D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldTurnLeftWithBigBlend;                       // 0x040E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldTurnRightWithSmallBlend;                    // 0x040F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldTurnRightWithBigBlend;                      // 0x0410(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSmallBlends;                                   // 0x0411(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTurning;                                        // 0x0412(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_413[0x5];                                      // 0x0413(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVLocomotionTurn                       AnimSet;                                           // 0x0418(0x0020)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x58];                                     // 0x0438(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNotTurnUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnTurnEnd(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnTurnStart(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnTurnUpdate(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTurnInPlaceCreatureAnimInstance">();
	}
	static class UVTurnInPlaceCreatureAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVTurnInPlaceCreatureAnimInstance>();
	}
};
static_assert(alignof(UVTurnInPlaceCreatureAnimInstance) == 0x000010, "Wrong alignment on UVTurnInPlaceCreatureAnimInstance");
static_assert(sizeof(UVTurnInPlaceCreatureAnimInstance) == 0x000490, "Wrong size on UVTurnInPlaceCreatureAnimInstance");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, TurnSettings) == 0x0003A0, "Member 'UVTurnInPlaceCreatureAnimInstance::TurnSettings' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, BaseRootName) == 0x0003D8, "Member 'UVTurnInPlaceCreatureAnimInstance::BaseRootName' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, CharacterMoveComp) == 0x0003E0, "Member 'UVTurnInPlaceCreatureAnimInstance::CharacterMoveComp' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, bUseBaseRootBone) == 0x0003E8, "Member 'UVTurnInPlaceCreatureAnimInstance::bUseBaseRootBone' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, CorrectedCurrentRotation) == 0x0003F0, "Member 'UVTurnInPlaceCreatureAnimInstance::CorrectedCurrentRotation' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, TurnPlayRate) == 0x000408, "Member 'UVTurnInPlaceCreatureAnimInstance::TurnPlayRate' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, bIsTurningInCombat) == 0x00040C, "Member 'UVTurnInPlaceCreatureAnimInstance::bIsTurningInCombat' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, bShouldTurnLeftWithSmallBlend) == 0x00040D, "Member 'UVTurnInPlaceCreatureAnimInstance::bShouldTurnLeftWithSmallBlend' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, bShouldTurnLeftWithBigBlend) == 0x00040E, "Member 'UVTurnInPlaceCreatureAnimInstance::bShouldTurnLeftWithBigBlend' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, bShouldTurnRightWithSmallBlend) == 0x00040F, "Member 'UVTurnInPlaceCreatureAnimInstance::bShouldTurnRightWithSmallBlend' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, bShouldTurnRightWithBigBlend) == 0x000410, "Member 'UVTurnInPlaceCreatureAnimInstance::bShouldTurnRightWithBigBlend' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, bUseSmallBlends) == 0x000411, "Member 'UVTurnInPlaceCreatureAnimInstance::bUseSmallBlends' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, bIsTurning) == 0x000412, "Member 'UVTurnInPlaceCreatureAnimInstance::bIsTurning' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCreatureAnimInstance, AnimSet) == 0x000418, "Member 'UVTurnInPlaceCreatureAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VHUDBreathViewModel
// 0x0008 (0x00D8 - 0x00D0)
class UVHUDBreathViewModel final : public UVViewModelBase
{
public:
	float                                         BreathPercentage;                                  // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsBreathBarBlinking;                              // 0x00D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBreathPercentage(const float& NewBreathPercentage);

	const float GetBreathPercentage() const;
	bool GetIsBreathBarBlinking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHUDBreathViewModel">();
	}
	static class UVHUDBreathViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHUDBreathViewModel>();
	}
};
static_assert(alignof(UVHUDBreathViewModel) == 0x000008, "Wrong alignment on UVHUDBreathViewModel");
static_assert(sizeof(UVHUDBreathViewModel) == 0x0000D8, "Wrong size on UVHUDBreathViewModel");
static_assert(offsetof(UVHUDBreathViewModel, BreathPercentage) == 0x0000D0, "Member 'UVHUDBreathViewModel::BreathPercentage' has a wrong offset!");
static_assert(offsetof(UVHUDBreathViewModel, bIsBreathBarBlinking) == 0x0000D4, "Member 'UVHUDBreathViewModel::bIsBreathBarBlinking' has a wrong offset!");

// Class Altar.VHUDMainViewModel
// 0x0238 (0x0308 - 0x00D0)
class UVHUDMainViewModel final : public UVViewModelBase
{
public:
	float                                         HealthBarValue;                                    // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MagickaBarValue;                                   // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FatigueBarValue;                                   // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentMagickaValue;                               // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxMagickaValue;                                   // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CompassDirectionValue;                             // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ThirdPersonCompassOffset;                          // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLevelUpIconVisibility;                            // 0x00EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             WeaponIcon;                                        // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WeaponStatus;                                      // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SpellIcon;                                         // 0x0100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WeaponHealth;                                      // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WeaponAmmo;                                        // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   RegionText;                                        // 0x0110(0x0018)(NativeAccessSpecifierPrivate)
	bool                                          bIsRegionNewlyDiscovered;                          // 0x0128(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     EffectsIcons;                                      // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<double>                                EffectsTimeLeft;                                   // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bCanBeCast;                                        // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMenuMode;                                       // 0x0151(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_152[0x6];                                      // 0x0152(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCompassIconMarker>             CompassIconMarkers;                                // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHostileData>                   HostileData;                                       // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FLegacyMapMenuQuestProperties          ActiveQuest;                                       // 0x0178(0x0098)(NativeAccessSpecifierPrivate)
	bool                                          bIsOverencumbered;                                 // 0x0210(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsBrokenWeaponVisible;                            // 0x0211(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsWeaponChargeVisible;                            // 0x0212(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_213[0x1];                                      // 0x0213(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponChargeParams                    WeaponChargeParams;                                // 0x0214(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bIsHealthBarBlinking;                              // 0x021C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTrespassing;                                    // 0x021D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FModernApparelData                     ApparelData;                                       // 0x021E(0x0002)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FModernSkillProgression                SkillProgression;                                  // 0x0220(0x0028)(NativeAccessSpecifierPrivate)
	bool                                          bShouldDisplayBloodVignette;                       // 0x0248(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           DiscoveredAreas;                                   // 0x0250(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnMagickaBarBlinkTriggered;                        // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnFatigueBarBlinkTriggered;                        // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(EVHUDBloodDropScreenPosition ScreenPos, float EdgePos, float DamagePercent)> OnDirectionalBloodDropUpdated; // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x78];                                     // 0x0290(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckForNewArea(const class FText& AreaName);
	float ComputeCompassMarkerXPosition(const struct FCompassIconMarker& CompassIconMarker, float Heading, float Ratio);
	float ComputeRelativeMarkerXPosition(const struct FCompassIconMarker& CompassIconMarker, float Heading);
	void SetCompassIconMarkers(const TArray<struct FCompassIconMarker>& IconMarkers);
	void SetHostileData(const TArray<struct FHostileData>& InHostileData);
	void SetIsMenuMode(bool bNewValue);

	const struct FModernApparelData GetApparelData() const;
	bool GetBrokenWeaponVisibility() const;
	bool GetCanBeCast() const;
	float GetCompassDirectionValue() const;
	const TArray<struct FCompassIconMarker> GetCompassIconMarkers() const;
	float GetCurrentMagickaValue() const;
	const TArray<class UTexture2D*> GetEffectsIcons() const;
	const TArray<double> GetEffectsTimeLeft() const;
	float GetFatigueBarValue() const;
	float GetHealthBarValue() const;
	const TArray<struct FHostileData> GetHostileData() const;
	bool GetIsHealthBarBlinking() const;
	bool GetIsMenuMode() const;
	bool GetIsTrespassing() const;
	bool GetLevelUpIconVisibility() const;
	float GetMagickaBarValue() const;
	float GetMaxMagickaValue() const;
	bool GetNewlyDiscovered() const;
	bool GetOverencumberedVisibility() const;
	const class FText GetRegionText() const;
	bool GetShouldDisplayBloodVignette() const;
	const struct FModernSkillProgression GetSkillProgression() const;
	class UTexture2D* GetSpellIcon() const;
	float GetThirdPersonCompassOffset() const;
	float GetWeaponAmmo() const;
	const struct FWeaponChargeParams GetWeaponChargeParams() const;
	bool GetWeaponChargeVisibility() const;
	float GetWeaponHealth() const;
	class UTexture2D* GetWeaponIcon() const;
	int32 GetWeaponStatus() const;
	bool ThisIsForPluginCompliance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHUDMainViewModel">();
	}
	static class UVHUDMainViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHUDMainViewModel>();
	}
};
static_assert(alignof(UVHUDMainViewModel) == 0x000008, "Wrong alignment on UVHUDMainViewModel");
static_assert(sizeof(UVHUDMainViewModel) == 0x000308, "Wrong size on UVHUDMainViewModel");
static_assert(offsetof(UVHUDMainViewModel, HealthBarValue) == 0x0000D0, "Member 'UVHUDMainViewModel::HealthBarValue' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, MagickaBarValue) == 0x0000D4, "Member 'UVHUDMainViewModel::MagickaBarValue' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, FatigueBarValue) == 0x0000D8, "Member 'UVHUDMainViewModel::FatigueBarValue' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, CurrentMagickaValue) == 0x0000DC, "Member 'UVHUDMainViewModel::CurrentMagickaValue' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, MaxMagickaValue) == 0x0000E0, "Member 'UVHUDMainViewModel::MaxMagickaValue' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, CompassDirectionValue) == 0x0000E4, "Member 'UVHUDMainViewModel::CompassDirectionValue' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, ThirdPersonCompassOffset) == 0x0000E8, "Member 'UVHUDMainViewModel::ThirdPersonCompassOffset' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, bLevelUpIconVisibility) == 0x0000EC, "Member 'UVHUDMainViewModel::bLevelUpIconVisibility' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, WeaponIcon) == 0x0000F0, "Member 'UVHUDMainViewModel::WeaponIcon' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, WeaponStatus) == 0x0000F8, "Member 'UVHUDMainViewModel::WeaponStatus' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, SpellIcon) == 0x000100, "Member 'UVHUDMainViewModel::SpellIcon' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, WeaponHealth) == 0x000108, "Member 'UVHUDMainViewModel::WeaponHealth' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, WeaponAmmo) == 0x00010C, "Member 'UVHUDMainViewModel::WeaponAmmo' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, RegionText) == 0x000110, "Member 'UVHUDMainViewModel::RegionText' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, bIsRegionNewlyDiscovered) == 0x000128, "Member 'UVHUDMainViewModel::bIsRegionNewlyDiscovered' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, EffectsIcons) == 0x000130, "Member 'UVHUDMainViewModel::EffectsIcons' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, EffectsTimeLeft) == 0x000140, "Member 'UVHUDMainViewModel::EffectsTimeLeft' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, bCanBeCast) == 0x000150, "Member 'UVHUDMainViewModel::bCanBeCast' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, bIsMenuMode) == 0x000151, "Member 'UVHUDMainViewModel::bIsMenuMode' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, CompassIconMarkers) == 0x000158, "Member 'UVHUDMainViewModel::CompassIconMarkers' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, HostileData) == 0x000168, "Member 'UVHUDMainViewModel::HostileData' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, ActiveQuest) == 0x000178, "Member 'UVHUDMainViewModel::ActiveQuest' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, bIsOverencumbered) == 0x000210, "Member 'UVHUDMainViewModel::bIsOverencumbered' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, bIsBrokenWeaponVisible) == 0x000211, "Member 'UVHUDMainViewModel::bIsBrokenWeaponVisible' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, bIsWeaponChargeVisible) == 0x000212, "Member 'UVHUDMainViewModel::bIsWeaponChargeVisible' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, WeaponChargeParams) == 0x000214, "Member 'UVHUDMainViewModel::WeaponChargeParams' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, bIsHealthBarBlinking) == 0x00021C, "Member 'UVHUDMainViewModel::bIsHealthBarBlinking' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, bIsTrespassing) == 0x00021D, "Member 'UVHUDMainViewModel::bIsTrespassing' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, ApparelData) == 0x00021E, "Member 'UVHUDMainViewModel::ApparelData' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, SkillProgression) == 0x000220, "Member 'UVHUDMainViewModel::SkillProgression' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, bShouldDisplayBloodVignette) == 0x000248, "Member 'UVHUDMainViewModel::bShouldDisplayBloodVignette' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, DiscoveredAreas) == 0x000250, "Member 'UVHUDMainViewModel::DiscoveredAreas' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, OnMagickaBarBlinkTriggered) == 0x000260, "Member 'UVHUDMainViewModel::OnMagickaBarBlinkTriggered' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, OnFatigueBarBlinkTriggered) == 0x000270, "Member 'UVHUDMainViewModel::OnFatigueBarBlinkTriggered' has a wrong offset!");
static_assert(offsetof(UVHUDMainViewModel, OnDirectionalBloodDropUpdated) == 0x000280, "Member 'UVHUDMainViewModel::OnDirectionalBloodDropUpdated' has a wrong offset!");

// Class Altar.VHUDReticleViewModel
// 0x0060 (0x0130 - 0x00D0)
class UVHUDReticleViewModel final : public UVViewModelBase
{
public:
	ELegacyHudReticleIcon                         ReticleIcon;                                       // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStealing;                                       // 0x00D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NPCName;                                           // 0x00D8(0x0018)(NativeAccessSpecifierPrivate)
	struct FLegacyReticleEnemyHealthProperties    EnemyHealthProperties;                             // 0x00F0(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FLegacyReticleSneakingProperties       SneakingProperties;                                // 0x00F8(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	float                                         SneakDetectionLevel;                               // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FPairedOblivionHitEvent& HitEvent)> OnHitCrosshairTriggered; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(bool bIsDrawing)> OnAimingCrosshairTriggered;                      // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	EModernReticleWeaponBehavior                  ReticleWeaponBehavior;                             // 0x0128(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMenuMode;                                       // 0x0129(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12A[0x6];                                      // 0x012A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnemyHealthProperties(const struct FLegacyReticleEnemyHealthProperties& NewEnemyHealthProperties);
	void SetIsMenuMode(bool bNewValue);
	void SetIsStealing(bool bNewIsStealing);
	void SetNPCName(const class FText& NewNpcName);
	void SetReticleIcon(ELegacyHudReticleIcon NewReticleIcon);
	void SetReticleWeaponBehavior(EModernReticleWeaponBehavior newReticleWeaponBehavior);
	void SetSneakDetectionLevel(const float Detection);
	void SetSneakingProperties(const struct FLegacyReticleSneakingProperties& NewSneakingProperties);
	void SetWeaponTag(const struct FGameplayTag& NewWeaponTag);
	void TriggerHitCrosshairAnimation(const struct FPairedOblivionHitEvent& HitEvent);

	const struct FLegacyReticleEnemyHealthProperties GetEnemyHealthProperties() const;
	bool GetIsMenuMode() const;
	bool GetIsStealing() const;
	const class FText GetNPCName() const;
	ELegacyHudReticleIcon GetReticleIcon() const;
	const EModernReticleWeaponBehavior GetReticleWeaponBehavior() const;
	const float GetSneakDetectionLevel() const;
	const float GetSneakingLevel() const;
	const bool GetSneakingProperties() const;
	struct FGameplayTag GetWeaponTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHUDReticleViewModel">();
	}
	static class UVHUDReticleViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHUDReticleViewModel>();
	}
};
static_assert(alignof(UVHUDReticleViewModel) == 0x000008, "Wrong alignment on UVHUDReticleViewModel");
static_assert(sizeof(UVHUDReticleViewModel) == 0x000130, "Wrong size on UVHUDReticleViewModel");
static_assert(offsetof(UVHUDReticleViewModel, ReticleIcon) == 0x0000D0, "Member 'UVHUDReticleViewModel::ReticleIcon' has a wrong offset!");
static_assert(offsetof(UVHUDReticleViewModel, bIsStealing) == 0x0000D1, "Member 'UVHUDReticleViewModel::bIsStealing' has a wrong offset!");
static_assert(offsetof(UVHUDReticleViewModel, NPCName) == 0x0000D8, "Member 'UVHUDReticleViewModel::NPCName' has a wrong offset!");
static_assert(offsetof(UVHUDReticleViewModel, EnemyHealthProperties) == 0x0000F0, "Member 'UVHUDReticleViewModel::EnemyHealthProperties' has a wrong offset!");
static_assert(offsetof(UVHUDReticleViewModel, SneakingProperties) == 0x0000F8, "Member 'UVHUDReticleViewModel::SneakingProperties' has a wrong offset!");
static_assert(offsetof(UVHUDReticleViewModel, SneakDetectionLevel) == 0x000100, "Member 'UVHUDReticleViewModel::SneakDetectionLevel' has a wrong offset!");
static_assert(offsetof(UVHUDReticleViewModel, OnHitCrosshairTriggered) == 0x000108, "Member 'UVHUDReticleViewModel::OnHitCrosshairTriggered' has a wrong offset!");
static_assert(offsetof(UVHUDReticleViewModel, OnAimingCrosshairTriggered) == 0x000118, "Member 'UVHUDReticleViewModel::OnAimingCrosshairTriggered' has a wrong offset!");
static_assert(offsetof(UVHUDReticleViewModel, ReticleWeaponBehavior) == 0x000128, "Member 'UVHUDReticleViewModel::ReticleWeaponBehavior' has a wrong offset!");
static_assert(offsetof(UVHUDReticleViewModel, bIsMenuMode) == 0x000129, "Member 'UVHUDReticleViewModel::bIsMenuMode' has a wrong offset!");

// Class Altar.VHumanoidHeadCharacterAnimInstance
// 0x0020 (0x0380 - 0x0360)
class UVHumanoidHeadCharacterAnimInstance : public UVBaseCharacterAnimInstance
{
public:
	class FName                                   EyeBoneName_L;                                     // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EyeBoneName_R;                                     // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyesPitchRangeInDegree;                            // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyesHeadingRangeInDegree;                          // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmotionBlendSpeed;                                 // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EyeHeadingMultiplier;                              // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EyeHeadingBias;                                    // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetEmotionBlendValue() const;
	float GetEyeHeadingValue() const;
	float GetEyePitchValue() const;
	bool IsAngry() const;
	bool IsConscious() const;
	bool IsDisgusted() const;
	bool IsFearful() const;
	bool IsHappy() const;
	bool IsNeutral() const;
	bool IsSad() const;
	bool IsSurprised() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHumanoidHeadCharacterAnimInstance">();
	}
	static class UVHumanoidHeadCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHumanoidHeadCharacterAnimInstance>();
	}
};
static_assert(alignof(UVHumanoidHeadCharacterAnimInstance) == 0x000010, "Wrong alignment on UVHumanoidHeadCharacterAnimInstance");
static_assert(sizeof(UVHumanoidHeadCharacterAnimInstance) == 0x000380, "Wrong size on UVHumanoidHeadCharacterAnimInstance");
static_assert(offsetof(UVHumanoidHeadCharacterAnimInstance, EyeBoneName_L) == 0x000358, "Member 'UVHumanoidHeadCharacterAnimInstance::EyeBoneName_L' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadCharacterAnimInstance, EyeBoneName_R) == 0x000360, "Member 'UVHumanoidHeadCharacterAnimInstance::EyeBoneName_R' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadCharacterAnimInstance, EyesPitchRangeInDegree) == 0x000368, "Member 'UVHumanoidHeadCharacterAnimInstance::EyesPitchRangeInDegree' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadCharacterAnimInstance, EyesHeadingRangeInDegree) == 0x00036C, "Member 'UVHumanoidHeadCharacterAnimInstance::EyesHeadingRangeInDegree' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadCharacterAnimInstance, EmotionBlendSpeed) == 0x000370, "Member 'UVHumanoidHeadCharacterAnimInstance::EmotionBlendSpeed' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadCharacterAnimInstance, EyeHeadingMultiplier) == 0x000374, "Member 'UVHumanoidHeadCharacterAnimInstance::EyeHeadingMultiplier' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadCharacterAnimInstance, EyeHeadingBias) == 0x000378, "Member 'UVHumanoidHeadCharacterAnimInstance::EyeHeadingBias' has a wrong offset!");

// Class Altar.VHumanoidHeadComponent
// 0x00B0 (0x10B0 - 0x1000)
class UVHumanoidHeadComponent final : public USkeletalMeshComponentBudgeted
{
public:
	TMulticastInlineDelegate<void(class UVCharacterPhenotypeData* Phenotype)> OnHairComponentsInstantiated; // 0x0FF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class USkeletalMeshComponent* NewBodyMesh)> OnBodyMeshUpdated;     // 0x1008(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x1018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookingAtTarget;                                 // 0x1030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1031[0x3];                                     // 0x1031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentEyeHeading;                                 // 0x1034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentEyePitch;                                   // 0x1038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_103C[0x4];                                     // 0x103C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EVFacialHairType, struct FCharacterHairPieceBaseConstructResult> HairComponents;            // 0x1040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class USkeletalMeshComponent>  BodyMeshComponent;                                 // 0x1090(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldHideHair;                                   // 0x1098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldHideFacialHair;                             // 0x1099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109A[0x2];                                     // 0x109A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDialogueEmotion                       CurrentEmotion;                                    // 0x109C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10A4[0xC];                                     // 0x10A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InstantiateHairComponents(class UVCharacterPhenotypeData* Phenotype);
	void SetVisibilityOfFacialHair(EVFacialHairType FacialHair, bool bIsHairVisible);
	void ShouldHideHair(bool bInShouldHideHair, bool bInHideFacialHair);

	struct FDialogueEmotion GetEmotion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHumanoidHeadComponent">();
	}
	static class UVHumanoidHeadComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHumanoidHeadComponent>();
	}
};
static_assert(alignof(UVHumanoidHeadComponent) == 0x000010, "Wrong alignment on UVHumanoidHeadComponent");
static_assert(sizeof(UVHumanoidHeadComponent) == 0x0010B0, "Wrong size on UVHumanoidHeadComponent");
static_assert(offsetof(UVHumanoidHeadComponent, OnHairComponentsInstantiated) == 0x000FF8, "Member 'UVHumanoidHeadComponent::OnHairComponentsInstantiated' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadComponent, OnBodyMeshUpdated) == 0x001008, "Member 'UVHumanoidHeadComponent::OnBodyMeshUpdated' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadComponent, TargetLocation) == 0x001018, "Member 'UVHumanoidHeadComponent::TargetLocation' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadComponent, IsLookingAtTarget) == 0x001030, "Member 'UVHumanoidHeadComponent::IsLookingAtTarget' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadComponent, CurrentEyeHeading) == 0x001034, "Member 'UVHumanoidHeadComponent::CurrentEyeHeading' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadComponent, CurrentEyePitch) == 0x001038, "Member 'UVHumanoidHeadComponent::CurrentEyePitch' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadComponent, HairComponents) == 0x001040, "Member 'UVHumanoidHeadComponent::HairComponents' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadComponent, BodyMeshComponent) == 0x001090, "Member 'UVHumanoidHeadComponent::BodyMeshComponent' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadComponent, bShouldHideHair) == 0x001098, "Member 'UVHumanoidHeadComponent::bShouldHideHair' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadComponent, bShouldHideFacialHair) == 0x001099, "Member 'UVHumanoidHeadComponent::bShouldHideFacialHair' has a wrong offset!");
static_assert(offsetof(UVHumanoidHeadComponent, CurrentEmotion) == 0x00109C, "Member 'UVHumanoidHeadComponent::CurrentEmotion' has a wrong offset!");

// Class Altar.VHumanoidTailPhysicsAnimInstance
// 0x0020 (0x03C0 - 0x03A0)
class UVHumanoidTailPhysicsAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	bool                                          bCanSimulatePhysics;                               // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TailPhysicsAlpha;                                  // 0x03A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHumanoidTailPhysicsAnimInstance">();
	}
	static class UVHumanoidTailPhysicsAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVHumanoidTailPhysicsAnimInstance>();
	}
};
static_assert(alignof(UVHumanoidTailPhysicsAnimInstance) == 0x000010, "Wrong alignment on UVHumanoidTailPhysicsAnimInstance");
static_assert(sizeof(UVHumanoidTailPhysicsAnimInstance) == 0x0003C0, "Wrong size on UVHumanoidTailPhysicsAnimInstance");
static_assert(offsetof(UVHumanoidTailPhysicsAnimInstance, bCanSimulatePhysics) == 0x0003A0, "Member 'UVHumanoidTailPhysicsAnimInstance::bCanSimulatePhysics' has a wrong offset!");
static_assert(offsetof(UVHumanoidTailPhysicsAnimInstance, TailPhysicsAlpha) == 0x0003A4, "Member 'UVHumanoidTailPhysicsAnimInstance::TailPhysicsAlpha' has a wrong offset!");

// Class Altar.VInAirLocomotionHorseAnimInstance
// 0x0020 (0x04A0 - 0x0480)
class UVInAirLocomotionHorseAnimInstance : public UVLocomotionHorseAnimInstance
{
public:
	float                                         MaxCanterSpeedAlpha;                               // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInCanter;                                       // 0x0484(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanJump;                                          // 0x0485(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActingInPlace;                                  // 0x0486(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_487[0x1];                                      // 0x0487(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ApexSpeedTriggerOffset;                            // 0x0488(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpLoopUpSpeedRatio;                              // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStartJump();
	void OnStartJumpEnd();

	bool IsFalling() const;
	bool IsJumping() const;
	bool IsLanding() const;
	bool IsRearing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VInAirLocomotionHorseAnimInstance">();
	}
	static class UVInAirLocomotionHorseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVInAirLocomotionHorseAnimInstance>();
	}
};
static_assert(alignof(UVInAirLocomotionHorseAnimInstance) == 0x000010, "Wrong alignment on UVInAirLocomotionHorseAnimInstance");
static_assert(sizeof(UVInAirLocomotionHorseAnimInstance) == 0x0004A0, "Wrong size on UVInAirLocomotionHorseAnimInstance");
static_assert(offsetof(UVInAirLocomotionHorseAnimInstance, MaxCanterSpeedAlpha) == 0x000480, "Member 'UVInAirLocomotionHorseAnimInstance::MaxCanterSpeedAlpha' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseAnimInstance, bIsInCanter) == 0x000484, "Member 'UVInAirLocomotionHorseAnimInstance::bIsInCanter' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseAnimInstance, bCanJump) == 0x000485, "Member 'UVInAirLocomotionHorseAnimInstance::bCanJump' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseAnimInstance, bIsActingInPlace) == 0x000486, "Member 'UVInAirLocomotionHorseAnimInstance::bIsActingInPlace' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseAnimInstance, ApexSpeedTriggerOffset) == 0x000488, "Member 'UVInAirLocomotionHorseAnimInstance::ApexSpeedTriggerOffset' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseAnimInstance, JumpLoopUpSpeedRatio) == 0x00048C, "Member 'UVInAirLocomotionHorseAnimInstance::JumpLoopUpSpeedRatio' has a wrong offset!");

// Class Altar.VInAirLocomotionHorseRiderAnimInstance
// 0x0060 (0x04F0 - 0x0490)
class UVInAirLocomotionHorseRiderAnimInstance : public UVLocomotionHorseRiderAnimInstance
{
public:
	struct FVHorseRiderLocomotionJump             JumpLayerData;                                     // 0x0490(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsInCanter;                                       // 0x04D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActingInPlace;                                  // 0x04D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFalling;                                        // 0x04DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLanding;                                        // 0x04DB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsJumping;                                        // 0x04DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRearing;                                        // 0x04DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4DE[0x2];                                      // 0x04DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpLoopUpSpeedRatio;                              // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E4[0xC];                                      // 0x04E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetJumpLayerData(const struct FVHorseRiderLocomotionJump& InJumpLayerData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VInAirLocomotionHorseRiderAnimInstance">();
	}
	static class UVInAirLocomotionHorseRiderAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVInAirLocomotionHorseRiderAnimInstance>();
	}
};
static_assert(alignof(UVInAirLocomotionHorseRiderAnimInstance) == 0x000010, "Wrong alignment on UVInAirLocomotionHorseRiderAnimInstance");
static_assert(sizeof(UVInAirLocomotionHorseRiderAnimInstance) == 0x0004F0, "Wrong size on UVInAirLocomotionHorseRiderAnimInstance");
static_assert(offsetof(UVInAirLocomotionHorseRiderAnimInstance, JumpLayerData) == 0x000490, "Member 'UVInAirLocomotionHorseRiderAnimInstance::JumpLayerData' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseRiderAnimInstance, bIsInCanter) == 0x0004D8, "Member 'UVInAirLocomotionHorseRiderAnimInstance::bIsInCanter' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseRiderAnimInstance, bIsActingInPlace) == 0x0004D9, "Member 'UVInAirLocomotionHorseRiderAnimInstance::bIsActingInPlace' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseRiderAnimInstance, bIsFalling) == 0x0004DA, "Member 'UVInAirLocomotionHorseRiderAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseRiderAnimInstance, bIsLanding) == 0x0004DB, "Member 'UVInAirLocomotionHorseRiderAnimInstance::bIsLanding' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseRiderAnimInstance, bIsJumping) == 0x0004DC, "Member 'UVInAirLocomotionHorseRiderAnimInstance::bIsJumping' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseRiderAnimInstance, bIsRearing) == 0x0004DD, "Member 'UVInAirLocomotionHorseRiderAnimInstance::bIsRearing' has a wrong offset!");
static_assert(offsetof(UVInAirLocomotionHorseRiderAnimInstance, JumpLoopUpSpeedRatio) == 0x0004E0, "Member 'UVInAirLocomotionHorseRiderAnimInstance::JumpLoopUpSpeedRatio' has a wrong offset!");

// Class Altar.VInventoryCharacterAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UVInventoryCharacterAnimInstance : public UAnimInstance
{
public:
	class UVAnimationPairingComponent*            LinkedAnimationPairingComponent;                   // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTorchVisible;                                     // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShieldVisible;                                    // 0x0351(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterCombatIdles                         CombatPose;                                        // 0x0352(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_353[0xD];                                      // 0x0353(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEquippedWeaponChanged(int32 WeaponType, bool bHasShield, bool bHasTorch);
	void SetCombatPose();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VInventoryCharacterAnimInstance">();
	}
	static class UVInventoryCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVInventoryCharacterAnimInstance>();
	}
};
static_assert(alignof(UVInventoryCharacterAnimInstance) == 0x000010, "Wrong alignment on UVInventoryCharacterAnimInstance");
static_assert(sizeof(UVInventoryCharacterAnimInstance) == 0x000360, "Wrong size on UVInventoryCharacterAnimInstance");
static_assert(offsetof(UVInventoryCharacterAnimInstance, LinkedAnimationPairingComponent) == 0x000348, "Member 'UVInventoryCharacterAnimInstance::LinkedAnimationPairingComponent' has a wrong offset!");
static_assert(offsetof(UVInventoryCharacterAnimInstance, bTorchVisible) == 0x000350, "Member 'UVInventoryCharacterAnimInstance::bTorchVisible' has a wrong offset!");
static_assert(offsetof(UVInventoryCharacterAnimInstance, bShieldVisible) == 0x000351, "Member 'UVInventoryCharacterAnimInstance::bShieldVisible' has a wrong offset!");
static_assert(offsetof(UVInventoryCharacterAnimInstance, CombatPose) == 0x000352, "Member 'UVInventoryCharacterAnimInstance::CombatPose' has a wrong offset!");

// Class Altar.VOriginalInventoryMenuItem
// 0x0050 (0x0078 - 0x0028)
class UVOriginalInventoryMenuItem final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const struct FOriginalInventoryMenuItemProperties& Value);

	int32 GetInventoryIndex() const;
	const struct FOriginalInventoryMenuItemProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOriginalInventoryMenuItem">();
	}
	static class UVOriginalInventoryMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOriginalInventoryMenuItem>();
	}
};
static_assert(alignof(UVOriginalInventoryMenuItem) == 0x000008, "Wrong alignment on UVOriginalInventoryMenuItem");
static_assert(sizeof(UVOriginalInventoryMenuItem) == 0x000078, "Wrong size on UVOriginalInventoryMenuItem");

// Class Altar.VLegacyStatsMenuSkillItem
// 0x0090 (0x00B8 - 0x0028)
class UVLegacyStatsMenuSkillItem final : public UObject
{
public:
	uint8                                         Pad_28[0x90];                                      // 0x0028(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const struct FLegacyStatsMenuSkillItemProperties& Value);
	void UpdateProperties(const struct FLegacyStatsMenuSkillItemUpdatableProperties& Value);

	int32 GetIndex() const;
	const struct FLegacyStatsMenuSkillItemProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyStatsMenuSkillItem">();
	}
	static class UVLegacyStatsMenuSkillItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyStatsMenuSkillItem>();
	}
};
static_assert(alignof(UVLegacyStatsMenuSkillItem) == 0x000008, "Wrong alignment on UVLegacyStatsMenuSkillItem");
static_assert(sizeof(UVLegacyStatsMenuSkillItem) == 0x0000B8, "Wrong size on UVLegacyStatsMenuSkillItem");

// Class Altar.VInventoryPlayerCharacter
// 0x0010 (0x0FF0 - 0x0FE0)
class AVInventoryPlayerCharacter : public AVPairedCharacter
{
public:
	struct FLightingChannels                      LightingChannels;                                  // 0x0FE0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsInItemPreviewMode;                              // 0x0FE1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE2[0xE];                                      // 0x0FE2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceLOD0OnCharacter();
	void OnAppearanceRefresh(const class UVCharacterPhenotypeData* Preset);
	void OnAppearanceRefreshedEnded();
	void SetInventoryPlayerEquipment(EBipedModularBodySlot Slot, const class UTESForm* form);
	void SetLightChannelOnCharacter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VInventoryPlayerCharacter">();
	}
	static class AVInventoryPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVInventoryPlayerCharacter>();
	}
};
static_assert(alignof(AVInventoryPlayerCharacter) == 0x000010, "Wrong alignment on AVInventoryPlayerCharacter");
static_assert(sizeof(AVInventoryPlayerCharacter) == 0x000FF0, "Wrong size on AVInventoryPlayerCharacter");
static_assert(offsetof(AVInventoryPlayerCharacter, LightingChannels) == 0x000FE0, "Member 'AVInventoryPlayerCharacter::LightingChannels' has a wrong offset!");
static_assert(offsetof(AVInventoryPlayerCharacter, bIsInItemPreviewMode) == 0x000FE1, "Member 'AVInventoryPlayerCharacter::bIsInItemPreviewMode' has a wrong offset!");

// Class Altar.VItemDetailsViewModel
// 0x00A8 (0x0178 - 0x00D0)
class UVItemDetailsViewModel final : public UVViewModelBase
{
public:
	int32                                         WeaponCharge;                                      // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WeaponMaxCharge;                                   // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WeaponUse;                                         // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SoulgemCapacity;                                   // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SoulgemMaxCapacity;                                // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SoulgemLevel;                                      // 0x00E8(0x0018)(NativeAccessSpecifierPrivate)
	bool                                          bIsSoulgemUsable;                                  // 0x0100(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStoneUsable;                                    // 0x0101(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAlchemyToolUsable;                              // 0x0102(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRepairHammerUsable;                             // 0x0103(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOriginalInventoryMenuItemSkillInformations ItemSkillInformations;                        // 0x0108(0x0060)(NativeAccessSpecifierPrivate)
	bool                                          bIsLightArmor;                                     // 0x0168(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOriginalInventoryMenuArmorClothPart          ArmorPart;                                         // 0x0169(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOriginalInventoryMenuArmorClothPart          ClothPart;                                         // 0x016A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOriginalInventoryMenuPotionType              PotionType;                                        // 0x016B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOriginalInventoryMenuBookType                BookType;                                          // 0x016C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTESForm*                               HoveredObjectTESForm;                              // 0x0170(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetArmorPart(EOriginalInventoryMenuArmorClothPart NewArmorPart);
	void SetBookType(EOriginalInventoryMenuBookType NewBookType);
	void SetClothPart(EOriginalInventoryMenuArmorClothPart NewClothPart);
	void SetHoveredObjectTESForm(class UTESForm* NewForm);
	void SetIsAlchemyToolUsable(bool bNewIsUsable);
	void SetIsLightArmor(bool bNewIsLightArmor);
	void SetIsRepairHammerUsable(bool bNewIsUsable);
	void SetIsSoulgemUsable(bool bNewIsUsable);
	void SetIsStoneUsable(bool bNewIsUsable);
	void SetItemSkillInformations(const struct FOriginalInventoryMenuItemSkillInformations& NewSkillInformations);
	void SetPotionType(EOriginalInventoryMenuPotionType NewPotionType);
	void SetSoulgemCapacity(int32 NewSoulgemCapacity);
	void SetSoulgemLevel(const class FText& NewSoulgemLevel);
	void SetSoulgemMaxCapacity(int32 NewSoulgemMaxCapacity);
	void SetWeaponCharge(int32 NewWeaponCharge);
	void SetWeaponMaxCharge(int32 NewWeaponMaxCharge);
	void SetWeaponUse(int32 NewWeaponUse);

	EOriginalInventoryMenuArmorClothPart GetArmorPart() const;
	EOriginalInventoryMenuBookType GetBookType() const;
	EOriginalInventoryMenuArmorClothPart GetClothPart() const;
	const class UTESForm* GetHoveredObjectTESForm() const;
	class FText GetHoveredWeaponDescriptionText(const class FText& DescriptionTextFormat, const TMap<struct FGameplayTag, class FText>& WeaponSizeToTextMap, const TMap<struct FGameplayTag, class FText>& WeaponTypeToTextMap, const TMap<struct FGameplayTag, class FText>& WeaponSkillToTextMap) const;
	const bool GetIsAlchemyToolUsable() const;
	bool GetIsLightArmor() const;
	const bool GetIsRepairHammerUsable() const;
	const bool GetIsSoulgemUsable() const;
	const bool GetIsStoneUsable() const;
	const struct FOriginalInventoryMenuItemSkillInformations GetItemSkillInformations() const;
	EOriginalInventoryMenuPotionType GetPotionType() const;
	int32 GetSoulgemCapacity() const;
	const class FText GetSoulgemLevel() const;
	int32 GetSoulgemMaxCapacity() const;
	int32 GetWeaponCharge() const;
	int32 GetWeaponMaxCharge() const;
	int32 GetWeaponUse() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VItemDetailsViewModel">();
	}
	static class UVItemDetailsViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVItemDetailsViewModel>();
	}
};
static_assert(alignof(UVItemDetailsViewModel) == 0x000008, "Wrong alignment on UVItemDetailsViewModel");
static_assert(sizeof(UVItemDetailsViewModel) == 0x000178, "Wrong size on UVItemDetailsViewModel");
static_assert(offsetof(UVItemDetailsViewModel, WeaponCharge) == 0x0000D0, "Member 'UVItemDetailsViewModel::WeaponCharge' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, WeaponMaxCharge) == 0x0000D4, "Member 'UVItemDetailsViewModel::WeaponMaxCharge' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, WeaponUse) == 0x0000D8, "Member 'UVItemDetailsViewModel::WeaponUse' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, SoulgemCapacity) == 0x0000DC, "Member 'UVItemDetailsViewModel::SoulgemCapacity' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, SoulgemMaxCapacity) == 0x0000E0, "Member 'UVItemDetailsViewModel::SoulgemMaxCapacity' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, SoulgemLevel) == 0x0000E8, "Member 'UVItemDetailsViewModel::SoulgemLevel' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, bIsSoulgemUsable) == 0x000100, "Member 'UVItemDetailsViewModel::bIsSoulgemUsable' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, bIsStoneUsable) == 0x000101, "Member 'UVItemDetailsViewModel::bIsStoneUsable' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, bIsAlchemyToolUsable) == 0x000102, "Member 'UVItemDetailsViewModel::bIsAlchemyToolUsable' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, bIsRepairHammerUsable) == 0x000103, "Member 'UVItemDetailsViewModel::bIsRepairHammerUsable' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, ItemSkillInformations) == 0x000108, "Member 'UVItemDetailsViewModel::ItemSkillInformations' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, bIsLightArmor) == 0x000168, "Member 'UVItemDetailsViewModel::bIsLightArmor' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, ArmorPart) == 0x000169, "Member 'UVItemDetailsViewModel::ArmorPart' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, ClothPart) == 0x00016A, "Member 'UVItemDetailsViewModel::ClothPart' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, PotionType) == 0x00016B, "Member 'UVItemDetailsViewModel::PotionType' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, BookType) == 0x00016C, "Member 'UVItemDetailsViewModel::BookType' has a wrong offset!");
static_assert(offsetof(UVItemDetailsViewModel, HoveredObjectTESForm) == 0x000170, "Member 'UVItemDetailsViewModel::HoveredObjectTESForm' has a wrong offset!");

// Class Altar.VSleepWaitMenuViewModel
// 0x0048 (0x0118 - 0x00D0)
class UVSleepWaitMenuViewModel final : public UVViewModelBase
{
public:
	float                                         TimeToWait;                                        // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisible;                                          // 0x00D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSleep;                                          // 0x00D5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsWaitingInProgress;                              // 0x00D6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldFadeOut;                                    // 0x00D7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLegacyScrollbarValueProperties        ScrollbarProperties;                               // 0x00D8(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FLegacySleepWaitMenuGameInfo           SleepWaitGameInfo;                                 // 0x00E8(0x0030)(NativeAccessSpecifierPrivate)

public:
	void RegisterSendClickedOnCancel();
	void RegisterSendClickedOnWait();
	void RegisterSendTimeToWait(float NewTimeToWait);
	void SetIsWaitingInProgress(bool bNewIsWaitingInProgress);
	void SetScrollbarProperties(const struct FLegacyScrollbarValueProperties& NewScrollbarProperties);
	void SetShouldFadeOut(bool bInShouldFadeOut);
	void SetSleepWaitGameInfo(const struct FLegacySleepWaitMenuGameInfo& NewSleepWaitGameInfo);
	void SetTimeToWait(float NewTimeToWait);
	void SetVisibility(bool bNewVisibility);

	bool GetIsSleep() const;
	bool GetIsWaitingInProgress() const;
	struct FLegacyScrollbarValueProperties GetScrollbarProperties() const;
	bool GetShouldFadeOut() const;
	struct FLegacySleepWaitMenuGameInfo GetSleepWaitGameInfo() const;
	float GetTimeToWait() const;
	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSleepWaitMenuViewModel">();
	}
	static class UVSleepWaitMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSleepWaitMenuViewModel>();
	}
};
static_assert(alignof(UVSleepWaitMenuViewModel) == 0x000008, "Wrong alignment on UVSleepWaitMenuViewModel");
static_assert(sizeof(UVSleepWaitMenuViewModel) == 0x000118, "Wrong size on UVSleepWaitMenuViewModel");
static_assert(offsetof(UVSleepWaitMenuViewModel, TimeToWait) == 0x0000D0, "Member 'UVSleepWaitMenuViewModel::TimeToWait' has a wrong offset!");
static_assert(offsetof(UVSleepWaitMenuViewModel, bVisible) == 0x0000D4, "Member 'UVSleepWaitMenuViewModel::bVisible' has a wrong offset!");
static_assert(offsetof(UVSleepWaitMenuViewModel, bIsSleep) == 0x0000D5, "Member 'UVSleepWaitMenuViewModel::bIsSleep' has a wrong offset!");
static_assert(offsetof(UVSleepWaitMenuViewModel, bIsWaitingInProgress) == 0x0000D6, "Member 'UVSleepWaitMenuViewModel::bIsWaitingInProgress' has a wrong offset!");
static_assert(offsetof(UVSleepWaitMenuViewModel, bShouldFadeOut) == 0x0000D7, "Member 'UVSleepWaitMenuViewModel::bShouldFadeOut' has a wrong offset!");
static_assert(offsetof(UVSleepWaitMenuViewModel, ScrollbarProperties) == 0x0000D8, "Member 'UVSleepWaitMenuViewModel::ScrollbarProperties' has a wrong offset!");
static_assert(offsetof(UVSleepWaitMenuViewModel, SleepWaitGameInfo) == 0x0000E8, "Member 'UVSleepWaitMenuViewModel::SleepWaitGameInfo' has a wrong offset!");

// Class Altar.VOriginalInventoryMenuIngredientEffects
// 0x0028 (0x0050 - 0x0028)
class UVOriginalInventoryMenuIngredientEffects final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const struct FOriginalInventoryMenuIngredientEffects& Value);

	const struct FOriginalInventoryMenuIngredientEffects GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOriginalInventoryMenuIngredientEffects">();
	}
	static class UVOriginalInventoryMenuIngredientEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOriginalInventoryMenuIngredientEffects>();
	}
};
static_assert(alignof(UVOriginalInventoryMenuIngredientEffects) == 0x000008, "Wrong alignment on UVOriginalInventoryMenuIngredientEffects");
static_assert(sizeof(UVOriginalInventoryMenuIngredientEffects) == 0x000050, "Wrong size on UVOriginalInventoryMenuIngredientEffects");

// Class Altar.VItemEffectsViewModel
// 0x0030 (0x0100 - 0x00D0)
class UVItemEffectsViewModel final : public UVViewModelBase
{
public:
	TArray<struct FOriginalInventoryMenuItemEffects> ItemEffects;                                    // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FOriginalInventoryMenuIngredientEffects> IngredientEffects;                        // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FModernEffectItemData>          SigilstoneEffects;                                 // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void SetIngredientEffects(const TArray<struct FOriginalInventoryMenuIngredientEffects>& NewIngredientEffects);
	void SetItemEffects(const TArray<struct FOriginalInventoryMenuItemEffects>& NewItemEffects);
	void SetSigilstoneEffects(const TArray<struct FModernEffectItemData>& NewSigilstoneEffects);

	const TArray<struct FOriginalInventoryMenuIngredientEffects> GetIngredientEffects() const;
	const TArray<struct FOriginalInventoryMenuItemEffects> GetItemEffects() const;
	const TArray<struct FModernEffectItemData> GetSigilstoneEffects() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VItemEffectsViewModel">();
	}
	static class UVItemEffectsViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVItemEffectsViewModel>();
	}
};
static_assert(alignof(UVItemEffectsViewModel) == 0x000008, "Wrong alignment on UVItemEffectsViewModel");
static_assert(sizeof(UVItemEffectsViewModel) == 0x000100, "Wrong size on UVItemEffectsViewModel");
static_assert(offsetof(UVItemEffectsViewModel, ItemEffects) == 0x0000D0, "Member 'UVItemEffectsViewModel::ItemEffects' has a wrong offset!");
static_assert(offsetof(UVItemEffectsViewModel, IngredientEffects) == 0x0000E0, "Member 'UVItemEffectsViewModel::IngredientEffects' has a wrong offset!");
static_assert(offsetof(UVItemEffectsViewModel, SigilstoneEffects) == 0x0000F0, "Member 'UVItemEffectsViewModel::SigilstoneEffects' has a wrong offset!");

// Class Altar.VLegacyAddedEffectsList
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyAddedEffectsList final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyAddedEffectsList">();
	}
	static class UVLegacyAddedEffectsList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyAddedEffectsList>();
	}
};
static_assert(alignof(UVLegacyAddedEffectsList) == 0x000008, "Wrong alignment on UVLegacyAddedEffectsList");
static_assert(sizeof(UVLegacyAddedEffectsList) == 0x0004E8, "Wrong size on UVLegacyAddedEffectsList");

// Class Altar.VLegacyAlchemyMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyAlchemyMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyAlchemyMenu">();
	}
	static class UVLegacyAlchemyMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyAlchemyMenu>();
	}
};
static_assert(alignof(UVLegacyAlchemyMenu) == 0x000008, "Wrong alignment on UVLegacyAlchemyMenu");
static_assert(sizeof(UVLegacyAlchemyMenu) == 0x0004E8, "Wrong size on UVLegacyAlchemyMenu");

// Class Altar.VLegacyAudioMenu
// 0x0038 (0x0520 - 0x04E8)
class UVLegacyAudioMenu final : public UVAltarMenu
{
public:
	TMulticastInlineDelegate<void()>              OnDefaultClicked;                                  // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnReturnClicked;                                   // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FLegacyAudioSettings                   Settings;                                          // 0x0508(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEffectVolume(float Value);
	void SetFootVolume(float Value);
	void SetMasterVolume(float Value);
	void SetMusicVolume(float Value);
	void SetSettings(const struct FLegacyAudioSettings& Value);
	void SetVoiceVolume(float Value);
	void TriggerOnDefaultClicked();
	void TriggerOnReturnClicked();

	float GetEffectVolume() const;
	float GetFootVolume() const;
	float GetMasterVolume() const;
	float GetMusicVolume() const;
	const struct FLegacyAudioSettings GetSettings() const;
	float GetVoiceVolume() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyAudioMenu">();
	}
	static class UVLegacyAudioMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyAudioMenu>();
	}
};
static_assert(alignof(UVLegacyAudioMenu) == 0x000008, "Wrong alignment on UVLegacyAudioMenu");
static_assert(sizeof(UVLegacyAudioMenu) == 0x000520, "Wrong size on UVLegacyAudioMenu");
static_assert(offsetof(UVLegacyAudioMenu, OnDefaultClicked) == 0x0004E8, "Member 'UVLegacyAudioMenu::OnDefaultClicked' has a wrong offset!");
static_assert(offsetof(UVLegacyAudioMenu, OnReturnClicked) == 0x0004F8, "Member 'UVLegacyAudioMenu::OnReturnClicked' has a wrong offset!");
static_assert(offsetof(UVLegacyAudioMenu, Settings) == 0x000508, "Member 'UVLegacyAudioMenu::Settings' has a wrong offset!");

// Class Altar.VLegacyBookMenu
// 0x0048 (0x0530 - 0x04E8)
class UVLegacyBookMenu final : public UVAltarMenu
{
public:
	TSubclassOf<class UVLegacyMenuBookLine>       BookLineClass;                                     // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UVLegacyMenuBookLine*>           AllTextLines;                                      // 0x04F0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UPanelWidget*>                   PageList;                                          // 0x0500(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 NbLinesPerPage;                                    // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentDisplayedPageIndex;                         // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAScroll;                                        // 0x0524(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeTaken;                                       // 0x0525(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_526[0x2];                                      // 0x0526(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             BookImageDataTable;                                // 0x0528(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ComputeNbLinePerPages();
	void RemoveEmptyLinesAtTheEndOfTheList();
	void RemoveEmptyLinesBeforePageBreaks();
	void ResetContainers(bool bEmptyContainers);
	void SplitTextIntoTextLines(const TArray<struct FLegacyBookStylizedText>& Texts);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyBookMenu">();
	}
	static class UVLegacyBookMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyBookMenu>();
	}
};
static_assert(alignof(UVLegacyBookMenu) == 0x000008, "Wrong alignment on UVLegacyBookMenu");
static_assert(sizeof(UVLegacyBookMenu) == 0x000530, "Wrong size on UVLegacyBookMenu");
static_assert(offsetof(UVLegacyBookMenu, BookLineClass) == 0x0004E8, "Member 'UVLegacyBookMenu::BookLineClass' has a wrong offset!");
static_assert(offsetof(UVLegacyBookMenu, AllTextLines) == 0x0004F0, "Member 'UVLegacyBookMenu::AllTextLines' has a wrong offset!");
static_assert(offsetof(UVLegacyBookMenu, PageList) == 0x000500, "Member 'UVLegacyBookMenu::PageList' has a wrong offset!");
static_assert(offsetof(UVLegacyBookMenu, NbLinesPerPage) == 0x000510, "Member 'UVLegacyBookMenu::NbLinesPerPage' has a wrong offset!");
static_assert(offsetof(UVLegacyBookMenu, CurrentDisplayedPageIndex) == 0x000520, "Member 'UVLegacyBookMenu::CurrentDisplayedPageIndex' has a wrong offset!");
static_assert(offsetof(UVLegacyBookMenu, bIsAScroll) == 0x000524, "Member 'UVLegacyBookMenu::bIsAScroll' has a wrong offset!");
static_assert(offsetof(UVLegacyBookMenu, bCanBeTaken) == 0x000525, "Member 'UVLegacyBookMenu::bCanBeTaken' has a wrong offset!");
static_assert(offsetof(UVLegacyBookMenu, BookImageDataTable) == 0x000528, "Member 'UVLegacyBookMenu::BookImageDataTable' has a wrong offset!");

// Class Altar.VSettingsPageInterface
// 0x0000 (0x0000 - 0x0000)
class IVSettingsPageInterface final
{
public:
	bool DoesAllowNavigation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSettingsPageInterface">();
	}
	static class IVSettingsPageInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVSettingsPageInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IVSettingsPageInterface) == 0x000001, "Wrong alignment on IVSettingsPageInterface");
static_assert(sizeof(IVSettingsPageInterface) == 0x000001, "Wrong size on IVSettingsPageInterface");

// Class Altar.VLegacyClassMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyClassMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyClassMenu">();
	}
	static class UVLegacyClassMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyClassMenu>();
	}
};
static_assert(alignof(UVLegacyClassMenu) == 0x000008, "Wrong alignment on UVLegacyClassMenu");
static_assert(sizeof(UVLegacyClassMenu) == 0x0004E8, "Wrong size on UVLegacyClassMenu");

// Class Altar.VLegacyControlsMappingEntry
// 0x0048 (0x0318 - 0x02D0)
class UVLegacyControlsMappingEntry final : public UNavigationListviewEntry
{
public:
	class FText                                   Label;                                             // 0x02D0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	struct FKey                                   Mapping;                                           // 0x02E8(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFLegacyControlsDevice                        Device;                                            // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEntryEnabled;                                    // 0x0301(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_302[0x16];                                     // 0x0302(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CaptureInput();
	void OnIsEntryEnabledUpdated(const bool Value);
	void OnItemObjectSet(class UObject* ListItemObject);
	void OnLabelUpdated(const class FText& Value);
	void OnMappingUpdated(const struct FKey& Value);
	void SetDevice(const EFLegacyControlsDevice Value);
	void SetEntryEnabled(const bool Value);
	void SetLabel(const class FText& Value);
	void SetMapping(const struct FKey& Value);

	EFLegacyControlsDevice GetDevice() const;
	bool GetEntryEnabled() const;
	const class FText GetLabel() const;
	const struct FKey GetMapping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyControlsMappingEntry">();
	}
	static class UVLegacyControlsMappingEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyControlsMappingEntry>();
	}
};
static_assert(alignof(UVLegacyControlsMappingEntry) == 0x000008, "Wrong alignment on UVLegacyControlsMappingEntry");
static_assert(sizeof(UVLegacyControlsMappingEntry) == 0x000318, "Wrong size on UVLegacyControlsMappingEntry");
static_assert(offsetof(UVLegacyControlsMappingEntry, Label) == 0x0002D0, "Member 'UVLegacyControlsMappingEntry::Label' has a wrong offset!");
static_assert(offsetof(UVLegacyControlsMappingEntry, Mapping) == 0x0002E8, "Member 'UVLegacyControlsMappingEntry::Mapping' has a wrong offset!");
static_assert(offsetof(UVLegacyControlsMappingEntry, Device) == 0x000300, "Member 'UVLegacyControlsMappingEntry::Device' has a wrong offset!");
static_assert(offsetof(UVLegacyControlsMappingEntry, IsEntryEnabled) == 0x000301, "Member 'UVLegacyControlsMappingEntry::IsEntryEnabled' has a wrong offset!");

// Class Altar.VLegacyControlsInputMapping
// 0x0068 (0x0090 - 0x0028)
class UVLegacyControlsInputMapping final : public UObject
{
public:
	TMulticastInlineDelegate<void(const class FText& Action, const struct FKey& Mapping)> OnMappingUpdated; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMappingStarted;                                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMappingCancelled;                                // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x38];                                      // 0x0058(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Set(const struct FLegacyControlsInputMapping& Value, EFLegacyControlsDevice InDevice);
	void SetMapping(const struct FKey& Value);

	const class FText GetAction() const;
	EFLegacyControlsDevice GetDevice() const;
	const struct FKey GetMapping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyControlsInputMapping">();
	}
	static class UVLegacyControlsInputMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyControlsInputMapping>();
	}
};
static_assert(alignof(UVLegacyControlsInputMapping) == 0x000008, "Wrong alignment on UVLegacyControlsInputMapping");
static_assert(sizeof(UVLegacyControlsInputMapping) == 0x000090, "Wrong size on UVLegacyControlsInputMapping");
static_assert(offsetof(UVLegacyControlsInputMapping, OnMappingUpdated) == 0x000028, "Member 'UVLegacyControlsInputMapping::OnMappingUpdated' has a wrong offset!");
static_assert(offsetof(UVLegacyControlsInputMapping, OnMappingStarted) == 0x000038, "Member 'UVLegacyControlsInputMapping::OnMappingStarted' has a wrong offset!");
static_assert(offsetof(UVLegacyControlsInputMapping, OnMappingCancelled) == 0x000048, "Member 'UVLegacyControlsInputMapping::OnMappingCancelled' has a wrong offset!");

// Class Altar.VLegacyControlsMenu
// 0x0050 (0x0538 - 0x04E8)
class UVLegacyControlsMenu final : public UVAltarMenu
{
public:
	TMulticastInlineDelegate<void(const struct FLegacyControlsSettings& Settings)> OnDeviceSettingsUpdated; // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText Action, const struct FKey& Mapping)> OnDeviceMappingsUpdated; // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EFLegacyControlsDevice Device)> OnDeviceUpdated;                   // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FLegacyControlsSettings                Settings;                                          // 0x0518(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FLegacyControlsInputMapping>    DeviceMappings;                                    // 0x0520(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          IsJoystickDetected;                                // 0x0530(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_531[0x7];                                      // 0x0531(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeviceMappingsUpdatedInternal(const TArray<struct FLegacyControlsInputMapping>& Value);
	void OnIsJoystickDetectedUpdatedInternal(bool Value);
	void OnSettingsUpdatedInternal(const struct FLegacyControlsSettings& Value);
	void SetDeviceMapping(const struct FLegacyControlsInputMapping& Value);
	void SetDeviceMappings(const TArray<struct FLegacyControlsInputMapping>& Value);
	void SetInvertYInternal(bool Value);
	void SetIsJoystickDetected(bool Value);
	void SetMouseSensitivityInternal(float Value);
	void SetSettings(const struct FLegacyControlsSettings& Value);
	void SetSwapStickControlsInternal(bool Value);

	const TArray<struct FLegacyControlsInputMapping> GetDeviceMappings() const;
	bool GetIsJoystickDetected() const;
	const struct FLegacyControlsSettings GetSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyControlsMenu">();
	}
	static class UVLegacyControlsMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyControlsMenu>();
	}
};
static_assert(alignof(UVLegacyControlsMenu) == 0x000008, "Wrong alignment on UVLegacyControlsMenu");
static_assert(sizeof(UVLegacyControlsMenu) == 0x000538, "Wrong size on UVLegacyControlsMenu");
static_assert(offsetof(UVLegacyControlsMenu, OnDeviceSettingsUpdated) == 0x0004E8, "Member 'UVLegacyControlsMenu::OnDeviceSettingsUpdated' has a wrong offset!");
static_assert(offsetof(UVLegacyControlsMenu, OnDeviceMappingsUpdated) == 0x0004F8, "Member 'UVLegacyControlsMenu::OnDeviceMappingsUpdated' has a wrong offset!");
static_assert(offsetof(UVLegacyControlsMenu, OnDeviceUpdated) == 0x000508, "Member 'UVLegacyControlsMenu::OnDeviceUpdated' has a wrong offset!");
static_assert(offsetof(UVLegacyControlsMenu, Settings) == 0x000518, "Member 'UVLegacyControlsMenu::Settings' has a wrong offset!");
static_assert(offsetof(UVLegacyControlsMenu, DeviceMappings) == 0x000520, "Member 'UVLegacyControlsMenu::DeviceMappings' has a wrong offset!");
static_assert(offsetof(UVLegacyControlsMenu, IsJoystickDetected) == 0x000530, "Member 'UVLegacyControlsMenu::IsJoystickDetected' has a wrong offset!");

// Class Altar.VLegacyEditableText
// 0x0040 (0x0508 - 0x04C8)
class UVLegacyEditableText final : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(class FText TextToCommit)> OnTextCommited;                         // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x04D8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	class FText                                   HintText;                                          // 0x04F0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void CommitText();
	void SetHintText(const class FText& Value);
	void SetText(const class FText& Value);

	void ClearKeyboardFocus() const;
	void ClearUserFocus() const;
	const class FText GetHintText() const;
	const class FText GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyEditableText">();
	}
	static class UVLegacyEditableText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyEditableText>();
	}
};
static_assert(alignof(UVLegacyEditableText) == 0x000008, "Wrong alignment on UVLegacyEditableText");
static_assert(sizeof(UVLegacyEditableText) == 0x000508, "Wrong size on UVLegacyEditableText");
static_assert(offsetof(UVLegacyEditableText, OnTextCommited) == 0x0004C8, "Member 'UVLegacyEditableText::OnTextCommited' has a wrong offset!");
static_assert(offsetof(UVLegacyEditableText, Text) == 0x0004D8, "Member 'UVLegacyEditableText::Text' has a wrong offset!");
static_assert(offsetof(UVLegacyEditableText, HintText) == 0x0004F0, "Member 'UVLegacyEditableText::HintText' has a wrong offset!");

// Class Altar.VLegacyEffectSettingsMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyEffectSettingsMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyEffectSettingsMenu">();
	}
	static class UVLegacyEffectSettingsMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyEffectSettingsMenu>();
	}
};
static_assert(alignof(UVLegacyEffectSettingsMenu) == 0x000008, "Wrong alignment on UVLegacyEffectSettingsMenu");
static_assert(sizeof(UVLegacyEffectSettingsMenu) == 0x0004E8, "Wrong size on UVLegacyEffectSettingsMenu");

// Class Altar.VLegacyEnchantmentMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyEnchantmentMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyEnchantmentMenu">();
	}
	static class UVLegacyEnchantmentMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyEnchantmentMenu>();
	}
};
static_assert(alignof(UVLegacyEnchantmentMenu) == 0x000008, "Wrong alignment on UVLegacyEnchantmentMenu");
static_assert(sizeof(UVLegacyEnchantmentMenu) == 0x0004E8, "Wrong size on UVLegacyEnchantmentMenu");

// Class Altar.VLegacyHudBreath
// 0x0000 (0x04C8 - 0x04C8)
class UVLegacyHudBreath final : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyHudBreath">();
	}
	static class UVLegacyHudBreath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyHudBreath>();
	}
};
static_assert(alignof(UVLegacyHudBreath) == 0x000008, "Wrong alignment on UVLegacyHudBreath");
static_assert(sizeof(UVLegacyHudBreath) == 0x0004C8, "Wrong size on UVLegacyHudBreath");

// Class Altar.VLegacyHudCompass
// 0x0000 (0x1610 - 0x1610)
class UVLegacyHudCompass final : public UVAltarButton
{
public:
	float                                         Heading;                                           // 0x1608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          FrameVisible;                                      // 0x160C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160D[0x3];                                     // 0x160D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFrameVisibleUpdated(bool Value);
	void OnHeadingUpdated(float Value);
	void SetFrameVisible(bool Value);
	void SetHeading(float Value);

	bool GetFrameVisible() const;
	float GetHeading() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyHudCompass">();
	}
	static class UVLegacyHudCompass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyHudCompass>();
	}
};
static_assert(alignof(UVLegacyHudCompass) == 0x000010, "Wrong alignment on UVLegacyHudCompass");
static_assert(sizeof(UVLegacyHudCompass) == 0x001610, "Wrong size on UVLegacyHudCompass");
static_assert(offsetof(UVLegacyHudCompass, Heading) == 0x001608, "Member 'UVLegacyHudCompass::Heading' has a wrong offset!");
static_assert(offsetof(UVLegacyHudCompass, FrameVisible) == 0x00160C, "Member 'UVLegacyHudCompass::FrameVisible' has a wrong offset!");

// Class Altar.VLegacyHudInfo
// 0x0000 (0x04C8 - 0x04C8)
class UVLegacyHudInfo final : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyHudInfo">();
	}
	static class UVLegacyHudInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyHudInfo>();
	}
};
static_assert(alignof(UVLegacyHudInfo) == 0x000008, "Wrong alignment on UVLegacyHudInfo");
static_assert(sizeof(UVLegacyHudInfo) == 0x0004C8, "Wrong size on UVLegacyHudInfo");

// Class Altar.VLegacyHudMagicIcon
// 0x00E0 (0x16F0 - 0x1610)
class UVLegacyHudMagicIcon final : public UVAltarButton
{
public:
	uint8                                         Pad_1608[0x8];                                     // 0x1608(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            MagicBrush;                                        // 0x1610(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	bool                                          CanCast;                                           // 0x16E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16E1[0xF];                                     // 0x16E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCanCastUpdated(bool Value);
	void OnMagicBrushUpdated(const struct FSlateBrush& Value);
	void SetCanCast(bool Value);
	void SetMagicBrush(const struct FSlateBrush& Value);
	void SetMagicTexture(class UTexture2D* Value);

	bool GetCanCast() const;
	struct FSlateBrush GetMagicBrush() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyHudMagicIcon">();
	}
	static class UVLegacyHudMagicIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyHudMagicIcon>();
	}
};
static_assert(alignof(UVLegacyHudMagicIcon) == 0x000010, "Wrong alignment on UVLegacyHudMagicIcon");
static_assert(sizeof(UVLegacyHudMagicIcon) == 0x0016F0, "Wrong size on UVLegacyHudMagicIcon");
static_assert(offsetof(UVLegacyHudMagicIcon, MagicBrush) == 0x001610, "Member 'UVLegacyHudMagicIcon::MagicBrush' has a wrong offset!");
static_assert(offsetof(UVLegacyHudMagicIcon, CanCast) == 0x0016E0, "Member 'UVLegacyHudMagicIcon::CanCast' has a wrong offset!");

// Class Altar.VLegacyHudMain
// 0x0070 (0x0558 - 0x04E8)
class UVLegacyHudMain final : public UVAltarMenu
{
public:
	TMulticastInlineDelegate<void()>              OnStatusBarClicked;                                // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnWeaponIconClicked;                               // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMagicIconClicked;                                // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCompassClicked;                                  // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCodexClicked;                                    // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTabLeftClicked;                                  // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTabRightClicked;                                 // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void OnForcePlayerMenuPageUpdated(int32 Index_0);
	void OnHUDVisibilityChanged(EHUDVisibility Flag, bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyHudMain">();
	}
	static class UVLegacyHudMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyHudMain>();
	}
};
static_assert(alignof(UVLegacyHudMain) == 0x000008, "Wrong alignment on UVLegacyHudMain");
static_assert(sizeof(UVLegacyHudMain) == 0x000558, "Wrong size on UVLegacyHudMain");
static_assert(offsetof(UVLegacyHudMain, OnStatusBarClicked) == 0x0004E8, "Member 'UVLegacyHudMain::OnStatusBarClicked' has a wrong offset!");
static_assert(offsetof(UVLegacyHudMain, OnWeaponIconClicked) == 0x0004F8, "Member 'UVLegacyHudMain::OnWeaponIconClicked' has a wrong offset!");
static_assert(offsetof(UVLegacyHudMain, OnMagicIconClicked) == 0x000508, "Member 'UVLegacyHudMain::OnMagicIconClicked' has a wrong offset!");
static_assert(offsetof(UVLegacyHudMain, OnCompassClicked) == 0x000518, "Member 'UVLegacyHudMain::OnCompassClicked' has a wrong offset!");
static_assert(offsetof(UVLegacyHudMain, OnCodexClicked) == 0x000528, "Member 'UVLegacyHudMain::OnCodexClicked' has a wrong offset!");
static_assert(offsetof(UVLegacyHudMain, OnTabLeftClicked) == 0x000538, "Member 'UVLegacyHudMain::OnTabLeftClicked' has a wrong offset!");
static_assert(offsetof(UVLegacyHudMain, OnTabRightClicked) == 0x000548, "Member 'UVLegacyHudMain::OnTabRightClicked' has a wrong offset!");

// Class Altar.VLegacyHudPrimaryLayout
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyHudPrimaryLayout final : public UVAltarMenu
{
public:
	void OnHUDVisibilityChanged(EHUDVisibility Flag, bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyHudPrimaryLayout">();
	}
	static class UVLegacyHudPrimaryLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyHudPrimaryLayout>();
	}
};
static_assert(alignof(UVLegacyHudPrimaryLayout) == 0x000008, "Wrong alignment on UVLegacyHudPrimaryLayout");
static_assert(sizeof(UVLegacyHudPrimaryLayout) == 0x0004E8, "Wrong size on UVLegacyHudPrimaryLayout");

// Class Altar.VLegacyHudReticle
// 0x0000 (0x04C8 - 0x04C8)
class UVLegacyHudReticle final : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyHudReticle">();
	}
	static class UVLegacyHudReticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyHudReticle>();
	}
};
static_assert(alignof(UVLegacyHudReticle) == 0x000008, "Wrong alignment on UVLegacyHudReticle");
static_assert(sizeof(UVLegacyHudReticle) == 0x0004C8, "Wrong size on UVLegacyHudReticle");

// Class Altar.VLegacyHudStatusBars
// 0x0010 (0x1620 - 0x1610)
class UVLegacyHudStatusBars final : public UVAltarButton
{
public:
	float                                         HealthProgress;                                    // 0x1608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MagickaProgress;                                   // 0x160C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FatigueProgress;                                   // 0x1610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1614[0xC];                                     // 0x1614(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFatigueProgressUpdated(float Value);
	void OnHealthProgressUpdated(float Value);
	void OnMagickaProgressUpdated(float Value);
	void SetFatigueProgress(float Value);
	void SetHealthProgress(float Value);
	void SetMagickaProgress(float Value);

	float GetFatigueProgress() const;
	float GetHealthProgress() const;
	float GetMagickaProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyHudStatusBars">();
	}
	static class UVLegacyHudStatusBars* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyHudStatusBars>();
	}
};
static_assert(alignof(UVLegacyHudStatusBars) == 0x000010, "Wrong alignment on UVLegacyHudStatusBars");
static_assert(sizeof(UVLegacyHudStatusBars) == 0x001620, "Wrong size on UVLegacyHudStatusBars");
static_assert(offsetof(UVLegacyHudStatusBars, HealthProgress) == 0x001608, "Member 'UVLegacyHudStatusBars::HealthProgress' has a wrong offset!");
static_assert(offsetof(UVLegacyHudStatusBars, MagickaProgress) == 0x00160C, "Member 'UVLegacyHudStatusBars::MagickaProgress' has a wrong offset!");
static_assert(offsetof(UVLegacyHudStatusBars, FatigueProgress) == 0x001610, "Member 'UVLegacyHudStatusBars::FatigueProgress' has a wrong offset!");

// Class Altar.VLegacyHudSubtitle
// 0x0000 (0x04C8 - 0x04C8)
class UVLegacyHudSubtitle final : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyHudSubtitle">();
	}
	static class UVLegacyHudSubtitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyHudSubtitle>();
	}
};
static_assert(alignof(UVLegacyHudSubtitle) == 0x000008, "Wrong alignment on UVLegacyHudSubtitle");
static_assert(sizeof(UVLegacyHudSubtitle) == 0x0004C8, "Wrong size on UVLegacyHudSubtitle");

// Class Altar.VLegacyHudWeaponIcon
// 0x00F0 (0x1700 - 0x1610)
class UVLegacyHudWeaponIcon final : public UVAltarButton
{
public:
	float                                         Health;                                            // 0x1608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsAmmoVisible;                                     // 0x160C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160D[0x3];                                     // 0x160D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmmoCount;                                         // 0x1610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1614[0xC];                                     // 0x1614(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            WeaponBrush;                                       // 0x1620(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	int32                                         Status;                                            // 0x16F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16F4[0xC];                                     // 0x16F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAmmoCountUpdated(int32 Value);
	void OnHealthUpdated(float Value);
	void OnIsAmmoVisibleUpdated(bool Value);
	void OnStatusUpdated(int32 Value);
	void OnWeaponBrushUpdated(const struct FSlateBrush& Value);
	void SetAmmoCount(int32 Value);
	void SetHealth(float Value);
	void SetIsAmmoVisible(bool Value);
	void SetStatus(int32 Value);
	void SetStatusInternal(int32 Value);
	void SetWeaponBrush(const struct FSlateBrush& Value);
	void SetWeaponTexture(class UTexture2D* Value);

	int32 GetAmmoCount() const;
	float GetHealth() const;
	bool GetIsAmmoVisible() const;
	int32 GetStatus() const;
	int32 GetStatusInternal() const;
	struct FSlateBrush GetWeaponBrush() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyHudWeaponIcon">();
	}
	static class UVLegacyHudWeaponIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyHudWeaponIcon>();
	}
};
static_assert(alignof(UVLegacyHudWeaponIcon) == 0x000010, "Wrong alignment on UVLegacyHudWeaponIcon");
static_assert(sizeof(UVLegacyHudWeaponIcon) == 0x001700, "Wrong size on UVLegacyHudWeaponIcon");
static_assert(offsetof(UVLegacyHudWeaponIcon, Health) == 0x001608, "Member 'UVLegacyHudWeaponIcon::Health' has a wrong offset!");
static_assert(offsetof(UVLegacyHudWeaponIcon, IsAmmoVisible) == 0x00160C, "Member 'UVLegacyHudWeaponIcon::IsAmmoVisible' has a wrong offset!");
static_assert(offsetof(UVLegacyHudWeaponIcon, AmmoCount) == 0x001610, "Member 'UVLegacyHudWeaponIcon::AmmoCount' has a wrong offset!");
static_assert(offsetof(UVLegacyHudWeaponIcon, WeaponBrush) == 0x001620, "Member 'UVLegacyHudWeaponIcon::WeaponBrush' has a wrong offset!");
static_assert(offsetof(UVLegacyHudWeaponIcon, Status) == 0x0016F0, "Member 'UVLegacyHudWeaponIcon::Status' has a wrong offset!");

// Class Altar.VSaveLoadMenuViewModel
// 0x00F8 (0x01C8 - 0x00D0)
class UVSaveLoadMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnSaveSuccessful;                                  // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ESaveLoadMenuOpeningSource                    CachedOpeningSource;                               // 0x00E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FVSaveGameDetails> SavesMetaData;                                     // 0x00E8(0x0050)(NativeAccessSpecifierPrivate)
	bool                                          bIsSaveMenu;                                       // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ClickedItemIndex;                                  // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ClickedSaveSlotName;                               // 0x0140(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrentPlayerName;                                 // 0x0150(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsShiftPressed;                                    // 0x0160(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HoverItemIndex;                                    // 0x0164(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UTexture2D*>        ThumbnailMap;                                      // 0x0170(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bShouldAllowListViewItemClicks;                    // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBackOutMenu;                                   // 0x01C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMenuIsBusy;                                       // 0x01C2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C3[0x5];                                      // 0x01C3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTexture2D* FindOrAddGameThumbnailFromSlot(const class FString& SlotName);
	void RegisterSendClickedItem(int32 SaveIndex, const class FString& SaveSlotName, bool InIsShiftPressed);
	void RegisterSendClickedReturnButton();
	void RegisterSendClickedUploadItem(int32 SaveIndex, const class FString& SaveSlotName, const class FString& SaveContext);
	void SetCanBackOutMenu(bool bInNewValue);
	void SetMenuIsBusy(bool newMenuIsBusy);
	void SetSavesMetaData(const TMap<class FString, struct FVSaveGameDetails>& NewSavesMetaData);
	void SetShouldAllowListViewItemClicks(bool bInNewValue);
	void UpdateLoadingScreenDataFromSave(const class FString& SaveSlotName);

	bool CanBackOutMenu() const;
	class FString GetCurrentPlayerName() const;
	bool GetDisableAchievementFromSlot(const class FString& SlotName) const;
	class FString GetFullSaveNameFromSlot(const class FString& SlotName) const;
	class FText GetGameDetailsFromSlot(const class FString& SlotName) const;
	class FText GetModernSaveDateFromSlot(const class FString& SlotName) const;
	class FText GetModernSaveDayFromSlot(const class FString& SlotName) const;
	class FText GetModernSaveLevelFromSlot(const class FString& SlotName) const;
	class FText GetModernSaveLocationFromSlot(const class FString& SlotName) const;
	class FText GetModernSaveNameFromSlot(const class FString& SlotName) const;
	class FText GetModernSavePlayerNameFromSlot(const class FString& SlotName) const;
	class FText GetModernSaveTimeFromSlot(const class FString& SlotName, const bool InFormat) const;
	class FText GetModernSaveTypeFromSlot(const class FString& SlotName) const;
	const TMap<class FString, struct FVSaveGameDetails> GetSavesMetaData() const;
	class FText GetSaveTextFromSlot(const class FString& SlotName) const;
	bool IsSaveMenu() const;
	bool MenuIsBusy() const;
	bool MustShowUploadItemButton() const;
	bool ShouldAllowListViewItemClicks() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSaveLoadMenuViewModel">();
	}
	static class UVSaveLoadMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSaveLoadMenuViewModel>();
	}
};
static_assert(alignof(UVSaveLoadMenuViewModel) == 0x000008, "Wrong alignment on UVSaveLoadMenuViewModel");
static_assert(sizeof(UVSaveLoadMenuViewModel) == 0x0001C8, "Wrong size on UVSaveLoadMenuViewModel");
static_assert(offsetof(UVSaveLoadMenuViewModel, OnSaveSuccessful) == 0x0000D0, "Member 'UVSaveLoadMenuViewModel::OnSaveSuccessful' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, CachedOpeningSource) == 0x0000E0, "Member 'UVSaveLoadMenuViewModel::CachedOpeningSource' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, SavesMetaData) == 0x0000E8, "Member 'UVSaveLoadMenuViewModel::SavesMetaData' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, bIsSaveMenu) == 0x000138, "Member 'UVSaveLoadMenuViewModel::bIsSaveMenu' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, ClickedItemIndex) == 0x00013C, "Member 'UVSaveLoadMenuViewModel::ClickedItemIndex' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, ClickedSaveSlotName) == 0x000140, "Member 'UVSaveLoadMenuViewModel::ClickedSaveSlotName' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, CurrentPlayerName) == 0x000150, "Member 'UVSaveLoadMenuViewModel::CurrentPlayerName' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, IsShiftPressed) == 0x000160, "Member 'UVSaveLoadMenuViewModel::IsShiftPressed' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, HoverItemIndex) == 0x000164, "Member 'UVSaveLoadMenuViewModel::HoverItemIndex' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, ThumbnailMap) == 0x000170, "Member 'UVSaveLoadMenuViewModel::ThumbnailMap' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, bShouldAllowListViewItemClicks) == 0x0001C0, "Member 'UVSaveLoadMenuViewModel::bShouldAllowListViewItemClicks' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, bCanBackOutMenu) == 0x0001C1, "Member 'UVSaveLoadMenuViewModel::bCanBackOutMenu' has a wrong offset!");
static_assert(offsetof(UVSaveLoadMenuViewModel, bMenuIsBusy) == 0x0001C2, "Member 'UVSaveLoadMenuViewModel::bMenuIsBusy' has a wrong offset!");

// Class Altar.VLegacyImageTile
// 0x00F0 (0x03B0 - 0x02C0)
class UVLegacyImageTile : public UUserWidget
{
public:
	bool                                          StretchImage;                                      // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Crop;                                              // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x02E0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void OnBrushUpdated(const struct FSlateBrush& Value);
	void OnCropUpdated(const struct FVector2D& Value);
	void OnStretchImageUpdated(bool Value);
	void OnSynchronizeProperties();
	void SetBrush(const struct FSlateBrush& Value);
	void SetCrop(const struct FVector2D& Value);
	void SetStretchImage(bool Value);

	const struct FSlateBrush GetBrush() const;
	struct FVector2D GetCrop() const;
	bool GetStretchImage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyImageTile">();
	}
	static class UVLegacyImageTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyImageTile>();
	}
};
static_assert(alignof(UVLegacyImageTile) == 0x000010, "Wrong alignment on UVLegacyImageTile");
static_assert(sizeof(UVLegacyImageTile) == 0x0003B0, "Wrong size on UVLegacyImageTile");
static_assert(offsetof(UVLegacyImageTile, StretchImage) == 0x0002C0, "Member 'UVLegacyImageTile::StretchImage' has a wrong offset!");
static_assert(offsetof(UVLegacyImageTile, Crop) == 0x0002C8, "Member 'UVLegacyImageTile::Crop' has a wrong offset!");
static_assert(offsetof(UVLegacyImageTile, Brush) == 0x0002E0, "Member 'UVLegacyImageTile::Brush' has a wrong offset!");

// Class Altar.VLegacyLevelUpMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyLevelUpMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyLevelUpMenu">();
	}
	static class UVLegacyLevelUpMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyLevelUpMenu>();
	}
};
static_assert(alignof(UVLegacyLevelUpMenu) == 0x000008, "Wrong alignment on UVLegacyLevelUpMenu");
static_assert(sizeof(UVLegacyLevelUpMenu) == 0x0004E8, "Wrong size on UVLegacyLevelUpMenu");

// Class Altar.VTESObjectRefComponent
// 0x0078 (0x0118 - 0x00A0)
class UVTESObjectRefComponent final : public UActorComponent
{
public:
	uint32                                        FormIDInstance;                                    // 0x00A0(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x00A4(0x0010)(Edit, ZeroConstructor, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CellName;                                          // 0x00B8(0x0010)(Edit, ZeroConstructor, EditConst, DuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CellNameAtRuntime;                                 // 0x00C8(0x0010)(Edit, ZeroConstructor, EditConst, DuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESForm*                               TESForm;                                           // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPaired;                                         // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnInitializedAndPaired;                            // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnUnpaired;                                        // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EVBossCategory                                BossTag;                                           // 0x0110(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EVBossCategory GetBossTag() const;
	class FString GetHexFormRefID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTESObjectRefComponent">();
	}
	static class UVTESObjectRefComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVTESObjectRefComponent>();
	}
};
static_assert(alignof(UVTESObjectRefComponent) == 0x000008, "Wrong alignment on UVTESObjectRefComponent");
static_assert(sizeof(UVTESObjectRefComponent) == 0x000118, "Wrong size on UVTESObjectRefComponent");
static_assert(offsetof(UVTESObjectRefComponent, FormIDInstance) == 0x0000A0, "Member 'UVTESObjectRefComponent::FormIDInstance' has a wrong offset!");
static_assert(offsetof(UVTESObjectRefComponent, Guid) == 0x0000A4, "Member 'UVTESObjectRefComponent::Guid' has a wrong offset!");
static_assert(offsetof(UVTESObjectRefComponent, CellName) == 0x0000B8, "Member 'UVTESObjectRefComponent::CellName' has a wrong offset!");
static_assert(offsetof(UVTESObjectRefComponent, CellNameAtRuntime) == 0x0000C8, "Member 'UVTESObjectRefComponent::CellNameAtRuntime' has a wrong offset!");
static_assert(offsetof(UVTESObjectRefComponent, TESForm) == 0x0000D8, "Member 'UVTESObjectRefComponent::TESForm' has a wrong offset!");
static_assert(offsetof(UVTESObjectRefComponent, bIsPaired) == 0x0000E0, "Member 'UVTESObjectRefComponent::bIsPaired' has a wrong offset!");
static_assert(offsetof(UVTESObjectRefComponent, OnInitializedAndPaired) == 0x0000E8, "Member 'UVTESObjectRefComponent::OnInitializedAndPaired' has a wrong offset!");
static_assert(offsetof(UVTESObjectRefComponent, OnUnpaired) == 0x0000F8, "Member 'UVTESObjectRefComponent::OnUnpaired' has a wrong offset!");
static_assert(offsetof(UVTESObjectRefComponent, BossTag) == 0x000110, "Member 'UVTESObjectRefComponent::BossTag' has a wrong offset!");

// Class Altar.VLegacyListViewEntryBase
// 0x0008 (0x02F0 - 0x02E8)
class UVLegacyListViewEntryBase final : public UCommonUserWidget
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnItemObjectSet(class UObject* ListItemObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyListViewEntryBase">();
	}
	static class UVLegacyListViewEntryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyListViewEntryBase>();
	}
};
static_assert(alignof(UVLegacyListViewEntryBase) == 0x000008, "Wrong alignment on UVLegacyListViewEntryBase");
static_assert(sizeof(UVLegacyListViewEntryBase) == 0x0002F0, "Wrong size on UVLegacyListViewEntryBase");

// Class Altar.VLegacyLoadingMenu
// 0x0028 (0x0510 - 0x04E8)
class UVLegacyLoadingMenu final : public UVAltarMenu
{
public:
	float                                         LoadingProgress;                                   // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyLoadingMenuGameInfo             LoadingScreen;                                     // 0x04F0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void OnLoadingProgressUpdated(const float Value);
	void OnLoadingScreenUpdated(const struct FLegacyLoadingMenuGameInfo& Value);
	void SetLoadingProgress(const float Value);
	void SetLoadingScreen(const struct FLegacyLoadingMenuGameInfo& Value);

	const float GetLoadingProgress() const;
	const struct FLegacyLoadingMenuGameInfo GetLoadingScreen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyLoadingMenu">();
	}
	static class UVLegacyLoadingMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyLoadingMenu>();
	}
};
static_assert(alignof(UVLegacyLoadingMenu) == 0x000008, "Wrong alignment on UVLegacyLoadingMenu");
static_assert(sizeof(UVLegacyLoadingMenu) == 0x000510, "Wrong size on UVLegacyLoadingMenu");
static_assert(offsetof(UVLegacyLoadingMenu, LoadingProgress) == 0x0004E8, "Member 'UVLegacyLoadingMenu::LoadingProgress' has a wrong offset!");
static_assert(offsetof(UVLegacyLoadingMenu, LoadingScreen) == 0x0004F0, "Member 'UVLegacyLoadingMenu::LoadingScreen' has a wrong offset!");

// Class Altar.VLegacyLockpickingMenuTumbler
// 0x0020 (0x04E8 - 0x04C8)
class UVLegacyLockpickingMenuTumbler final : public UVAltarWidget
{
public:
	struct FLegacyLockpickMenuTumblerProperties   Properties;                                        // 0x04C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          IsSolved;                                          // 0x04D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsTumbling;                                        // 0x04D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4DA[0xE];                                      // 0x04DA(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AttemptSolve();
	float GetNextAnimationTime(const float DeltaTime);
	void PlayInitialMovementEffects();
	void PlayIsSolvedEffects();
	void PlayOnFallEffects();
	void SetInitialMovement(const struct FLegacyLockpickMenuTumblerProperties& Value);
	void SetIsSolved(const bool Value);
	void SetIsTumbling(const bool Value);
	void UpdateAnimation(const float DeltaTime);

	const struct FLegacyLockpickMenuTumblerProperties GetInitialMovement() const;
	bool GetIsSolved() const;
	bool GetIsTumbling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyLockpickingMenuTumbler">();
	}
	static class UVLegacyLockpickingMenuTumbler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyLockpickingMenuTumbler>();
	}
};
static_assert(alignof(UVLegacyLockpickingMenuTumbler) == 0x000008, "Wrong alignment on UVLegacyLockpickingMenuTumbler");
static_assert(sizeof(UVLegacyLockpickingMenuTumbler) == 0x0004E8, "Wrong size on UVLegacyLockpickingMenuTumbler");
static_assert(offsetof(UVLegacyLockpickingMenuTumbler, Properties) == 0x0004C8, "Member 'UVLegacyLockpickingMenuTumbler::Properties' has a wrong offset!");
static_assert(offsetof(UVLegacyLockpickingMenuTumbler, IsSolved) == 0x0004D8, "Member 'UVLegacyLockpickingMenuTumbler::IsSolved' has a wrong offset!");
static_assert(offsetof(UVLegacyLockpickingMenuTumbler, IsTumbling) == 0x0004D9, "Member 'UVLegacyLockpickingMenuTumbler::IsTumbling' has a wrong offset!");

// Class Altar.VLegacyLockpickMenu
// 0x0010 (0x04F8 - 0x04E8)
class UVLegacyLockpickMenu final : public UVAltarMenu
{
public:
	class UCurveTable*                            DifficultyCurveTable;                              // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckMenuFocus(const struct FGameplayTag& TopMostLayer, class UCommonActivatableWidget* TopMostWidget);
	void InitialiseTumblerMovement(int32 TumblerIndex, const struct FLegacyLockpickMenuTumblerDefaultProperties& TumblerDefaultProperties, const struct FLegacyLockpickMenuProperties& MenuProperties);
	void OnMenuFocusChanged(bool IsFocussed);
	void OnTumberMovementInitialised(int32 TumblerIndex, const struct FLegacyLockpickMenuTumblerProperties& TumbleProperties);
	void SetDifficultyCurve(ELegacyLockpickMenuDifficulty Difficulty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyLockpickMenu">();
	}
	static class UVLegacyLockpickMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyLockpickMenu>();
	}
};
static_assert(alignof(UVLegacyLockpickMenu) == 0x000008, "Wrong alignment on UVLegacyLockpickMenu");
static_assert(sizeof(UVLegacyLockpickMenu) == 0x0004F8, "Wrong size on UVLegacyLockpickMenu");
static_assert(offsetof(UVLegacyLockpickMenu, DifficultyCurveTable) == 0x0004E8, "Member 'UVLegacyLockpickMenu::DifficultyCurveTable' has a wrong offset!");

// Class Altar.VLegacyLockpickMenuPick
// 0x0050 (0x0518 - 0x04C8)
class UVLegacyLockpickMenuPick final : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(int32 TumblerIndex)> OnTumble;                                     // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 TumblerIndex)> OnSolve;                                      // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	int32                                         ActiveTumbler;                                     // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 TumblerPositions;                                  // 0x04F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          IsBroken;                                          // 0x0500(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsMovementDisabled;                                // 0x0501(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELegacyLockpickMenuHandleType                 HandleType;                                        // 0x0502(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_503[0x1];                                      // 0x0503(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeadZone;                                          // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x10];                                     // 0x0508(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ELegacyLockpickMenuPickMovement GetMovementActionFromMouseMovement();
	void MovePick(const ELegacyLockpickMenuPickMovement Action);
	void OnActiveTumblerUpdated(const int32 Value);
	void OnHandleTypeUpdated(const ELegacyLockpickMenuHandleType Value);
	void OnIsBrokenUpdated(const bool Value);
	void OnTumbleAction();
	void SetActiveTumbler(const int32 Value);
	void SetDeadZone(const float Value);
	void SetHandleType(const ELegacyLockpickMenuHandleType Value);
	void SetIsBroken(const bool Value);
	void SetIsMovementDisabled(const bool Value);
	void SetTumblerPositions(const TArray<float>& Value);

	bool CanPickMove() const;
	int32 GetActiveTumbler() const;
	float GetActiveTumblerPosition() const;
	float GetDeadZone() const;
	ELegacyLockpickMenuHandleType GetHandleType() const;
	bool GetIsBroken() const;
	bool GetIsMovementDisabled() const;
	float GetPreviousTumblerPosition() const;
	const TArray<float> GetTumblerPositions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyLockpickMenuPick">();
	}
	static class UVLegacyLockpickMenuPick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyLockpickMenuPick>();
	}
};
static_assert(alignof(UVLegacyLockpickMenuPick) == 0x000008, "Wrong alignment on UVLegacyLockpickMenuPick");
static_assert(sizeof(UVLegacyLockpickMenuPick) == 0x000518, "Wrong size on UVLegacyLockpickMenuPick");
static_assert(offsetof(UVLegacyLockpickMenuPick, OnTumble) == 0x0004C8, "Member 'UVLegacyLockpickMenuPick::OnTumble' has a wrong offset!");
static_assert(offsetof(UVLegacyLockpickMenuPick, OnSolve) == 0x0004D8, "Member 'UVLegacyLockpickMenuPick::OnSolve' has a wrong offset!");
static_assert(offsetof(UVLegacyLockpickMenuPick, ActiveTumbler) == 0x0004E8, "Member 'UVLegacyLockpickMenuPick::ActiveTumbler' has a wrong offset!");
static_assert(offsetof(UVLegacyLockpickMenuPick, TumblerPositions) == 0x0004F0, "Member 'UVLegacyLockpickMenuPick::TumblerPositions' has a wrong offset!");
static_assert(offsetof(UVLegacyLockpickMenuPick, IsBroken) == 0x000500, "Member 'UVLegacyLockpickMenuPick::IsBroken' has a wrong offset!");
static_assert(offsetof(UVLegacyLockpickMenuPick, IsMovementDisabled) == 0x000501, "Member 'UVLegacyLockpickMenuPick::IsMovementDisabled' has a wrong offset!");
static_assert(offsetof(UVLegacyLockpickMenuPick, HandleType) == 0x000502, "Member 'UVLegacyLockpickMenuPick::HandleType' has a wrong offset!");
static_assert(offsetof(UVLegacyLockpickMenuPick, DeadZone) == 0x000504, "Member 'UVLegacyLockpickMenuPick::DeadZone' has a wrong offset!");

// Class Altar.VLegacyMagicMenu
// 0x0000 (0x04F0 - 0x04F0)
class UVLegacyMagicMenu : public UVLegacyPlayerSubMenuBase
{
public:
	void MoveToNextPage(bool bRight);

	class UVLegacyMagicPopupMenu* GetMagicPopup() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMagicMenu">();
	}
	static class UVLegacyMagicMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMagicMenu>();
	}
};
static_assert(alignof(UVLegacyMagicMenu) == 0x000008, "Wrong alignment on UVLegacyMagicMenu");
static_assert(sizeof(UVLegacyMagicMenu) == 0x0004F0, "Wrong size on UVLegacyMagicMenu");

// Class Altar.VLegacyMagicPopupMenu
// 0x0000 (0x04C8 - 0x04C8)
class UVLegacyMagicPopupMenu final : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMagicPopupMenu">();
	}
	static class UVLegacyMagicPopupMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMagicPopupMenu>();
	}
};
static_assert(alignof(UVLegacyMagicPopupMenu) == 0x000008, "Wrong alignment on UVLegacyMagicPopupMenu");
static_assert(sizeof(UVLegacyMagicPopupMenu) == 0x0004C8, "Wrong size on UVLegacyMagicPopupMenu");

// Class Altar.VLegacyMapMenu
// 0x0020 (0x0510 - 0x04F0)
class UVLegacyMapMenu : public UVLegacyPlayerSubMenuBase
{
public:
	struct FLegacyMenuActionBinding               ClickIconData;                                     // 0x04F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_508[0x8];                                      // 0x0508(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MoveToNextPage(const bool bRight);
	void OnClickedIcon();

	class UVLegacyMapMenuMapPage* GetLocalMapPage() const;
	class UVLegacyMapMenuQuestsPage* GetQuestsPage() const;
	class UVLegacyMapMenuMapPage* GetWorldMapPage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMapMenu">();
	}
	static class UVLegacyMapMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMapMenu>();
	}
};
static_assert(alignof(UVLegacyMapMenu) == 0x000008, "Wrong alignment on UVLegacyMapMenu");
static_assert(sizeof(UVLegacyMapMenu) == 0x000510, "Wrong size on UVLegacyMapMenu");
static_assert(offsetof(UVLegacyMapMenu, ClickIconData) == 0x0004F0, "Member 'UVLegacyMapMenu::ClickIconData' has a wrong offset!");

// Class Altar.VLegacyStatsMenuMiscItem
// 0x0020 (0x0048 - 0x0028)
class UVLegacyStatsMenuMiscItem final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetItem(const struct FLegacyStatsMenuMiscItemProperties& Value);

	const struct FLegacyStatsMenuMiscItemProperties GetItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyStatsMenuMiscItem">();
	}
	static class UVLegacyStatsMenuMiscItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyStatsMenuMiscItem>();
	}
};
static_assert(alignof(UVLegacyStatsMenuMiscItem) == 0x000008, "Wrong alignment on UVLegacyStatsMenuMiscItem");
static_assert(sizeof(UVLegacyStatsMenuMiscItem) == 0x000048, "Wrong size on UVLegacyStatsMenuMiscItem");

// Class Altar.VLegacyMapMenuMapPage
// 0x0000 (0x04C8 - 0x04C8)
class UVLegacyMapMenuMapPage : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMapMenuMapPage">();
	}
	static class UVLegacyMapMenuMapPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMapMenuMapPage>();
	}
};
static_assert(alignof(UVLegacyMapMenuMapPage) == 0x000008, "Wrong alignment on UVLegacyMapMenuMapPage");
static_assert(sizeof(UVLegacyMapMenuMapPage) == 0x0004C8, "Wrong size on UVLegacyMapMenuMapPage");

// Class Altar.VLegacyMapMenuQuestsPage
// 0x0000 (0x04C8 - 0x04C8)
class UVLegacyMapMenuQuestsPage : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMapMenuQuestsPage">();
	}
	static class UVLegacyMapMenuQuestsPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMapMenuQuestsPage>();
	}
};
static_assert(alignof(UVLegacyMapMenuQuestsPage) == 0x000008, "Wrong alignment on UVLegacyMapMenuQuestsPage");
static_assert(sizeof(UVLegacyMapMenuQuestsPage) == 0x0004C8, "Wrong size on UVLegacyMapMenuQuestsPage");

// Class Altar.VLegacyNegotiateMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyNegotiateMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyNegotiateMenu">();
	}
	static class UVLegacyNegotiateMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyNegotiateMenu>();
	}
};
static_assert(alignof(UVLegacyNegotiateMenu) == 0x000008, "Wrong alignment on UVLegacyNegotiateMenu");
static_assert(sizeof(UVLegacyNegotiateMenu) == 0x0004E8, "Wrong size on UVLegacyNegotiateMenu");

// Class Altar.VLegacyPageTab
// 0x00F8 (0x05C0 - 0x04C8)
class UVLegacyPageTab : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void()>              OnTabClickedCallback;                              // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            IconBrush;                                         // 0x04E0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	bool                                          IsSelected;                                        // 0x05B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B1[0xF];                                      // 0x05B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIconUpdated();
	void OnIsSelectedUpdated();
	void SetIconBrush(const struct FSlateBrush& Value);
	void SetIsSelected(const bool Value);
	void TriggerTabClicked();

	const struct FSlateBrush GetIconBrush() const;
	bool GetIsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyPageTab">();
	}
	static class UVLegacyPageTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyPageTab>();
	}
};
static_assert(alignof(UVLegacyPageTab) == 0x000010, "Wrong alignment on UVLegacyPageTab");
static_assert(sizeof(UVLegacyPageTab) == 0x0005C0, "Wrong size on UVLegacyPageTab");
static_assert(offsetof(UVLegacyPageTab, OnTabClickedCallback) == 0x0004C8, "Member 'UVLegacyPageTab::OnTabClickedCallback' has a wrong offset!");
static_assert(offsetof(UVLegacyPageTab, IconBrush) == 0x0004E0, "Member 'UVLegacyPageTab::IconBrush' has a wrong offset!");
static_assert(offsetof(UVLegacyPageTab, IsSelected) == 0x0005B0, "Member 'UVLegacyPageTab::IsSelected' has a wrong offset!");

// Class Altar.VLegacyPauseMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyPauseMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyPauseMenu">();
	}
	static class UVLegacyPauseMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyPauseMenu>();
	}
};
static_assert(alignof(UVLegacyPauseMenu) == 0x000008, "Wrong alignment on UVLegacyPauseMenu");
static_assert(sizeof(UVLegacyPauseMenu) == 0x0004E8, "Wrong size on UVLegacyPauseMenu");

// Class Altar.VLegacyPlayerMenu
// 0x0020 (0x0508 - 0x04E8)
class UVLegacyPlayerMenu : public UVAltarMenu
{
public:
	struct FLegacyMenuActionBinding               CloseMenuData;                                     // 0x04E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseMenu();
	void MoveToNextMenuPage(const bool bLeft);
	void OnDisplayPlayerInInventory(bool bValue);

	const class UCommonActivatableWidget* GetCodex() const;
	const class UVLegacyHudMain* GetHudMain() const;
	const class UVInventoryMenu* GetInventoryMenu() const;
	const class UVLegacyMagicMenu* GetMagicMenu() const;
	const class UVLegacyMapMenu* GetMapMenu() const;
	const class UCommonActivatableWidget* GetMenuFromEnum(ELegacyPlayerMenuPage Page) const;
	const class UVLegacySettingsMenu* GetSettings() const;
	const class UVLegacyStatsMenu* GetStatsMenu() const;
	const class UVPlayerMenuViewModel* GetViewModelRef() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyPlayerMenu">();
	}
	static class UVLegacyPlayerMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyPlayerMenu>();
	}
};
static_assert(alignof(UVLegacyPlayerMenu) == 0x000008, "Wrong alignment on UVLegacyPlayerMenu");
static_assert(sizeof(UVLegacyPlayerMenu) == 0x000508, "Wrong size on UVLegacyPlayerMenu");
static_assert(offsetof(UVLegacyPlayerMenu, CloseMenuData) == 0x0004E8, "Member 'UVLegacyPlayerMenu::CloseMenuData' has a wrong offset!");

// Class Altar.VLegacyQuantityMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyQuantityMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyQuantityMenu">();
	}
	static class UVLegacyQuantityMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyQuantityMenu>();
	}
};
static_assert(alignof(UVLegacyQuantityMenu) == 0x000008, "Wrong alignment on UVLegacyQuantityMenu");
static_assert(sizeof(UVLegacyQuantityMenu) == 0x0004E8, "Wrong size on UVLegacyQuantityMenu");

// Class Altar.VLegacyQuestAddedMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyQuestAddedMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyQuestAddedMenu">();
	}
	static class UVLegacyQuestAddedMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyQuestAddedMenu>();
	}
};
static_assert(alignof(UVLegacyQuestAddedMenu) == 0x000008, "Wrong alignment on UVLegacyQuestAddedMenu");
static_assert(sizeof(UVLegacyQuestAddedMenu) == 0x0004E8, "Wrong size on UVLegacyQuestAddedMenu");

// Class Altar.VLegacyRaceSexMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyRaceSexMenu final : public UVAltarMenu
{
public:
	void PostFadeAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyRaceSexMenu">();
	}
	static class UVLegacyRaceSexMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyRaceSexMenu>();
	}
};
static_assert(alignof(UVLegacyRaceSexMenu) == 0x000008, "Wrong alignment on UVLegacyRaceSexMenu");
static_assert(sizeof(UVLegacyRaceSexMenu) == 0x0004E8, "Wrong size on UVLegacyRaceSexMenu");

// Class Altar.VLegacyRechargeMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyRechargeMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyRechargeMenu">();
	}
	static class UVLegacyRechargeMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyRechargeMenu>();
	}
};
static_assert(alignof(UVLegacyRechargeMenu) == 0x000008, "Wrong alignment on UVLegacyRechargeMenu");
static_assert(sizeof(UVLegacyRechargeMenu) == 0x0004E8, "Wrong size on UVLegacyRechargeMenu");

// Class Altar.VLegacyRepairMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyRepairMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyRepairMenu">();
	}
	static class UVLegacyRepairMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyRepairMenu>();
	}
};
static_assert(alignof(UVLegacyRepairMenu) == 0x000008, "Wrong alignment on UVLegacyRepairMenu");
static_assert(sizeof(UVLegacyRepairMenu) == 0x0004E8, "Wrong size on UVLegacyRepairMenu");

// Class Altar.VLegacyScrollbar
// 0x0050 (0x0518 - 0x04C8)
class UVLegacyScrollbar final : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(float Value)>   OnScrollbarValueChanged;                           // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Value)>   OnValueSubmitted;                                  // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SliderLength;                                      // 0x04EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLegacyScrollbarValueProperties        ValueProperties;                                   // 0x04F0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FLegacyScrollbarTextProperties         TextProperties;                                    // 0x0500(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          FocusBackgroundEnabled;                            // 0x0514(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_515[0x3];                                      // 0x0515(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMarkerPositionUpdated();
	void OnValueUpdated(float Value);
	void SetFocusBackgroundEnabled(const bool Value);
	void SetSliderLength(float Value);
	void SetTextProperties(const struct FLegacyScrollbarTextProperties& Value);
	void SetValue(float Value);
	void SetValueProperties(const struct FLegacyScrollbarValueProperties& Value);
	void UpdateValueFromSlider(float Value);

	bool GetFocusBackgroundEnabled() const;
	float GetSliderLength() const;
	const struct FLegacyScrollbarTextProperties GetTextProperties() const;
	float GetValue() const;
	float GetValueAsPercentage() const;
	const struct FLegacyScrollbarValueProperties GetValueProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyScrollbar">();
	}
	static class UVLegacyScrollbar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyScrollbar>();
	}
};
static_assert(alignof(UVLegacyScrollbar) == 0x000008, "Wrong alignment on UVLegacyScrollbar");
static_assert(sizeof(UVLegacyScrollbar) == 0x000518, "Wrong size on UVLegacyScrollbar");
static_assert(offsetof(UVLegacyScrollbar, OnScrollbarValueChanged) == 0x0004C8, "Member 'UVLegacyScrollbar::OnScrollbarValueChanged' has a wrong offset!");
static_assert(offsetof(UVLegacyScrollbar, OnValueSubmitted) == 0x0004D8, "Member 'UVLegacyScrollbar::OnValueSubmitted' has a wrong offset!");
static_assert(offsetof(UVLegacyScrollbar, CurrentValue) == 0x0004E8, "Member 'UVLegacyScrollbar::CurrentValue' has a wrong offset!");
static_assert(offsetof(UVLegacyScrollbar, SliderLength) == 0x0004EC, "Member 'UVLegacyScrollbar::SliderLength' has a wrong offset!");
static_assert(offsetof(UVLegacyScrollbar, ValueProperties) == 0x0004F0, "Member 'UVLegacyScrollbar::ValueProperties' has a wrong offset!");
static_assert(offsetof(UVLegacyScrollbar, TextProperties) == 0x000500, "Member 'UVLegacyScrollbar::TextProperties' has a wrong offset!");
static_assert(offsetof(UVLegacyScrollbar, FocusBackgroundEnabled) == 0x000514, "Member 'UVLegacyScrollbar::FocusBackgroundEnabled' has a wrong offset!");

// Class Altar.VLegacySettingsMenu
// 0x0000 (0x04F0 - 0x04F0)
class UVLegacySettingsMenu : public UVLegacyPlayerSubMenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacySettingsMenu">();
	}
	static class UVLegacySettingsMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacySettingsMenu>();
	}
};
static_assert(alignof(UVLegacySettingsMenu) == 0x000008, "Wrong alignment on UVLegacySettingsMenu");
static_assert(sizeof(UVLegacySettingsMenu) == 0x0004F0, "Wrong size on UVLegacySettingsMenu");

// Class Altar.VLegacySigilStoneMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacySigilStoneMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacySigilStoneMenu">();
	}
	static class UVLegacySigilStoneMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacySigilStoneMenu>();
	}
};
static_assert(alignof(UVLegacySigilStoneMenu) == 0x000008, "Wrong alignment on UVLegacySigilStoneMenu");
static_assert(sizeof(UVLegacySigilStoneMenu) == 0x0004E8, "Wrong size on UVLegacySigilStoneMenu");

// Class Altar.VLegacySleepWaitMenu
// 0x0028 (0x0510 - 0x04E8)
class UVLegacySleepWaitMenu final : public UVAltarMenu
{
public:
	struct FVector2D                              FadeEffectAlpha;                                   // 0x04E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeEffectDuration;                                // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FadeColor;                                         // 0x04FC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldFadeAudio;                                   // 0x050C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFadeIn;                                         // 0x050D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50E[0x2];                                      // 0x050E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInstantFadeIn();
	void StartCameraFade(bool bInFadeIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacySleepWaitMenu">();
	}
	static class UVLegacySleepWaitMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacySleepWaitMenu>();
	}
};
static_assert(alignof(UVLegacySleepWaitMenu) == 0x000008, "Wrong alignment on UVLegacySleepWaitMenu");
static_assert(sizeof(UVLegacySleepWaitMenu) == 0x000510, "Wrong size on UVLegacySleepWaitMenu");
static_assert(offsetof(UVLegacySleepWaitMenu, FadeEffectAlpha) == 0x0004E8, "Member 'UVLegacySleepWaitMenu::FadeEffectAlpha' has a wrong offset!");
static_assert(offsetof(UVLegacySleepWaitMenu, FadeEffectDuration) == 0x0004F8, "Member 'UVLegacySleepWaitMenu::FadeEffectDuration' has a wrong offset!");
static_assert(offsetof(UVLegacySleepWaitMenu, FadeColor) == 0x0004FC, "Member 'UVLegacySleepWaitMenu::FadeColor' has a wrong offset!");
static_assert(offsetof(UVLegacySleepWaitMenu, ShouldFadeAudio) == 0x00050C, "Member 'UVLegacySleepWaitMenu::ShouldFadeAudio' has a wrong offset!");
static_assert(offsetof(UVLegacySleepWaitMenu, bIsFadeIn) == 0x00050D, "Member 'UVLegacySleepWaitMenu::bIsFadeIn' has a wrong offset!");

// Class Altar.VLegacySpellMakingMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacySpellMakingMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacySpellMakingMenu">();
	}
	static class UVLegacySpellMakingMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacySpellMakingMenu>();
	}
};
static_assert(alignof(UVLegacySpellMakingMenu) == 0x000008, "Wrong alignment on UVLegacySpellMakingMenu");
static_assert(sizeof(UVLegacySpellMakingMenu) == 0x0004E8, "Wrong size on UVLegacySpellMakingMenu");

// Class Altar.VLegacySpellPurchaseMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacySpellPurchaseMenu final : public UVAltarMenu
{
public:
	void OnPlayerMoneyUpdated(const int32 Value);
	void OnSpellsUpdated(const TArray<struct FLegacySpellPurchaseMenuItemProperties>& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacySpellPurchaseMenu">();
	}
	static class UVLegacySpellPurchaseMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacySpellPurchaseMenu>();
	}
};
static_assert(alignof(UVLegacySpellPurchaseMenu) == 0x000008, "Wrong alignment on UVLegacySpellPurchaseMenu");
static_assert(sizeof(UVLegacySpellPurchaseMenu) == 0x0004E8, "Wrong size on UVLegacySpellPurchaseMenu");

// Class Altar.VLegacyStatsMenuItemPage
// 0x0000 (0x04C8 - 0x04C8)
class UVLegacyStatsMenuItemPage : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyStatsMenuItemPage">();
	}
	static class UVLegacyStatsMenuItemPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyStatsMenuItemPage>();
	}
};
static_assert(alignof(UVLegacyStatsMenuItemPage) == 0x000008, "Wrong alignment on UVLegacyStatsMenuItemPage");
static_assert(sizeof(UVLegacyStatsMenuItemPage) == 0x0004C8, "Wrong size on UVLegacyStatsMenuItemPage");

// Class Altar.VLegacyStatsMenuPage1
// 0x0020 (0x04E8 - 0x04C8)
class UVLegacyStatsMenuPage1 : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(const ELegacyStatsMenuPage1Items AttributeIndex)> OnItemFocussed;  // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnItemUnfocussed;                                  // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyStatsMenuPage1">();
	}
	static class UVLegacyStatsMenuPage1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyStatsMenuPage1>();
	}
};
static_assert(alignof(UVLegacyStatsMenuPage1) == 0x000008, "Wrong alignment on UVLegacyStatsMenuPage1");
static_assert(sizeof(UVLegacyStatsMenuPage1) == 0x0004E8, "Wrong size on UVLegacyStatsMenuPage1");
static_assert(offsetof(UVLegacyStatsMenuPage1, OnItemFocussed) == 0x0004C8, "Member 'UVLegacyStatsMenuPage1::OnItemFocussed' has a wrong offset!");
static_assert(offsetof(UVLegacyStatsMenuPage1, OnItemUnfocussed) == 0x0004D8, "Member 'UVLegacyStatsMenuPage1::OnItemUnfocussed' has a wrong offset!");

// Class Altar.VLegacyStatsMenuPage2
// 0x0020 (0x04E8 - 0x04C8)
class UVLegacyStatsMenuPage2 : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(const ELegacyStatsMenuPage2Items AttributeIndex)> OnItemFocussed;  // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnItemUnfocussed;                                  // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyStatsMenuPage2">();
	}
	static class UVLegacyStatsMenuPage2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyStatsMenuPage2>();
	}
};
static_assert(alignof(UVLegacyStatsMenuPage2) == 0x000008, "Wrong alignment on UVLegacyStatsMenuPage2");
static_assert(sizeof(UVLegacyStatsMenuPage2) == 0x0004E8, "Wrong size on UVLegacyStatsMenuPage2");
static_assert(offsetof(UVLegacyStatsMenuPage2, OnItemFocussed) == 0x0004C8, "Member 'UVLegacyStatsMenuPage2::OnItemFocussed' has a wrong offset!");
static_assert(offsetof(UVLegacyStatsMenuPage2, OnItemUnfocussed) == 0x0004D8, "Member 'UVLegacyStatsMenuPage2::OnItemUnfocussed' has a wrong offset!");

// Class Altar.VLegacyStatsMenuPage4
// 0x0000 (0x04C8 - 0x04C8)
class UVLegacyStatsMenuPage4 : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyStatsMenuPage4">();
	}
	static class UVLegacyStatsMenuPage4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyStatsMenuPage4>();
	}
};
static_assert(alignof(UVLegacyStatsMenuPage4) == 0x000008, "Wrong alignment on UVLegacyStatsMenuPage4");
static_assert(sizeof(UVLegacyStatsMenuPage4) == 0x0004C8, "Wrong size on UVLegacyStatsMenuPage4");

// Class Altar.VLegacyStatsMenuPage5
// 0x0000 (0x04C8 - 0x04C8)
class UVLegacyStatsMenuPage5 : public UVAltarWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyStatsMenuPage5">();
	}
	static class UVLegacyStatsMenuPage5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyStatsMenuPage5>();
	}
};
static_assert(alignof(UVLegacyStatsMenuPage5) == 0x000008, "Wrong alignment on UVLegacyStatsMenuPage5");
static_assert(sizeof(UVLegacyStatsMenuPage5) == 0x0004C8, "Wrong size on UVLegacyStatsMenuPage5");

// Class Altar.VLegacyTextEditMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVLegacyTextEditMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyTextEditMenu">();
	}
	static class UVLegacyTextEditMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyTextEditMenu>();
	}
};
static_assert(alignof(UVLegacyTextEditMenu) == 0x000008, "Wrong alignment on UVLegacyTextEditMenu");
static_assert(sizeof(UVLegacyTextEditMenu) == 0x0004E8, "Wrong size on UVLegacyTextEditMenu");

// Class Altar.VShieldHandPoseCharacterAnimInstance
// 0x0020 (0x03C0 - 0x03A0)
class UVShieldHandPoseCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	struct FShieldHandPoseSetup                   HandPoseSetup;                                     // 0x03A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupShieldHandPoseLayer(const struct FShieldHandPoseSetup& InHandPoseSetup);

	bool IsShieldHandPoseActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VShieldHandPoseCharacterAnimInstance">();
	}
	static class UVShieldHandPoseCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVShieldHandPoseCharacterAnimInstance>();
	}
};
static_assert(alignof(UVShieldHandPoseCharacterAnimInstance) == 0x000010, "Wrong alignment on UVShieldHandPoseCharacterAnimInstance");
static_assert(sizeof(UVShieldHandPoseCharacterAnimInstance) == 0x0003C0, "Wrong size on UVShieldHandPoseCharacterAnimInstance");
static_assert(offsetof(UVShieldHandPoseCharacterAnimInstance, HandPoseSetup) == 0x0003A0, "Member 'UVShieldHandPoseCharacterAnimInstance::HandPoseSetup' has a wrong offset!");

// Class Altar.VLegacyValueSwitcher
// 0x0018 (0x04E0 - 0x04C8)
class UVLegacyValueSwitcher : public UVAltarWidget
{
public:
	TArray<class FText>                           Options;                                           // 0x04C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         SelectedIndex;                                     // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4DC[0x4];                                      // 0x04DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class FText> GetOptions();
	const int32 GetSelectedIndex();
	const class FText GetSelectedValue();
	void OnSelectedValueUpdated();
	void SetOptions(const TArray<class FText>& Value);
	void SetSelectedIndex(const int32 Value);
	void SwitchToNextOption();
	void SwitchToPreviousOption();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyValueSwitcher">();
	}
	static class UVLegacyValueSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyValueSwitcher>();
	}
};
static_assert(alignof(UVLegacyValueSwitcher) == 0x000008, "Wrong alignment on UVLegacyValueSwitcher");
static_assert(sizeof(UVLegacyValueSwitcher) == 0x0004E0, "Wrong size on UVLegacyValueSwitcher");
static_assert(offsetof(UVLegacyValueSwitcher, Options) == 0x0004C8, "Member 'UVLegacyValueSwitcher::Options' has a wrong offset!");
static_assert(offsetof(UVLegacyValueSwitcher, SelectedIndex) == 0x0004D8, "Member 'UVLegacyValueSwitcher::SelectedIndex' has a wrong offset!");

// Class Altar.VLegacyVideoMenu
// 0x0120 (0x0608 - 0x04E8)
class UVLegacyVideoMenu final : public UVAltarMenu
{
public:
	struct FLegacyVideoSettings                   Settings;                                          // 0x04E8(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	struct FLegacyVideoTextSettingValues          SettingOptions;                                    // 0x0588(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void OnSettingOptionsUpdated(const struct FLegacyVideoTextSettingValues& Value);
	void OnSettingsUpdated(const struct FLegacyVideoSettings& Value);
	void SetFloatSetting(const EFLegacyVideoSettingsEnum SettingName, float Value);
	void SetSettingOptions(const struct FLegacyVideoTextSettingValues& Value);
	void SetSettings(const struct FLegacyVideoSettings& Value);
	void SetUintSetting(const EFLegacyVideoSettingsEnum SettingName, uint8 Value);

	float GetFloatSetting(const EFLegacyVideoSettingsEnum SettingName) const;
	const struct FLegacyVideoTextSettingValues GetSettingOptions() const;
	const TArray<class FText> GetSettingOptionsFromType(const ELegacyVideoMenuOptionType OptionType) const;
	const struct FLegacyVideoSettings GetSettings() const;
	uint8 GetUintSetting(const EFLegacyVideoSettingsEnum SettingName) const;
	bool IsResolutionWidescreen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyVideoMenu">();
	}
	static class UVLegacyVideoMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyVideoMenu>();
	}
};
static_assert(alignof(UVLegacyVideoMenu) == 0x000008, "Wrong alignment on UVLegacyVideoMenu");
static_assert(sizeof(UVLegacyVideoMenu) == 0x000608, "Wrong size on UVLegacyVideoMenu");
static_assert(offsetof(UVLegacyVideoMenu, Settings) == 0x0004E8, "Member 'UVLegacyVideoMenu::Settings' has a wrong offset!");
static_assert(offsetof(UVLegacyVideoMenu, SettingOptions) == 0x000588, "Member 'UVLegacyVideoMenu::SettingOptions' has a wrong offset!");

// Class Altar.VLegacyVideoWidgetBase
// 0x0050 (0x0518 - 0x04C8)
class UVLegacyVideoWidgetBase final : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(EFLegacyVideoSettingsEnum Setting, uint8 Value)> OnUintUpdated;    // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EFLegacyVideoSettingsEnum Setting, float Value)> OnFloatUpdated;   // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FText                                   Label;                                             // 0x04E8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	EFLegacyVideoSettingsEnum                     SettingName;                                       // 0x0500(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_501[0x7];                                      // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           Options;                                           // 0x0508(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	const TArray<class FText> GetOptions();
	EFLegacyVideoSettingsEnum GetSettingName();
	void OnFloatValueUpdatedInternal(const float Value);
	void OnLabelUpdatedInternal(const class FText& Value);
	void OnOptionsUpdatedInternal(const TArray<class FText>& Value);
	void OnUintValueUpdatedInternal(const uint8 Value);
	void SetFloatValue(const float Value);
	void SetLabel(const class FText& Value);
	void SetOptions(const TArray<class FText>& Value);
	void SetSettingName(const EFLegacyVideoSettingsEnum Value);
	void SetUintValue(const uint8 Value);
	void TriggerOnFloatUpdated(EFLegacyVideoSettingsEnum Setting, float Value);
	void TriggerOnUintUpdated(EFLegacyVideoSettingsEnum Setting, uint8 Value);

	const class FText GetLabel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyVideoWidgetBase">();
	}
	static class UVLegacyVideoWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyVideoWidgetBase>();
	}
};
static_assert(alignof(UVLegacyVideoWidgetBase) == 0x000008, "Wrong alignment on UVLegacyVideoWidgetBase");
static_assert(sizeof(UVLegacyVideoWidgetBase) == 0x000518, "Wrong size on UVLegacyVideoWidgetBase");
static_assert(offsetof(UVLegacyVideoWidgetBase, OnUintUpdated) == 0x0004C8, "Member 'UVLegacyVideoWidgetBase::OnUintUpdated' has a wrong offset!");
static_assert(offsetof(UVLegacyVideoWidgetBase, OnFloatUpdated) == 0x0004D8, "Member 'UVLegacyVideoWidgetBase::OnFloatUpdated' has a wrong offset!");
static_assert(offsetof(UVLegacyVideoWidgetBase, Label) == 0x0004E8, "Member 'UVLegacyVideoWidgetBase::Label' has a wrong offset!");
static_assert(offsetof(UVLegacyVideoWidgetBase, SettingName) == 0x000500, "Member 'UVLegacyVideoWidgetBase::SettingName' has a wrong offset!");
static_assert(offsetof(UVLegacyVideoWidgetBase, Options) == 0x000508, "Member 'UVLegacyVideoWidgetBase::Options' has a wrong offset!");

// Class Altar.VLegacyXControlsMenu
// 0x0020 (0x0508 - 0x04E8)
class UVLegacyXControlsMenu final : public UVAltarMenu
{
public:
	struct FLegacyXControllerSettings             Settings;                                          // 0x04E8(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLegacyControlsInputMapping>    ControllerMappings;                                // 0x04F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnControllerMappingsUpdated(const TArray<struct FLegacyControlsInputMapping>& Value);
	void OnSettingsUpdated(const struct FLegacyXControllerSettings& Value);
	void SetControllerMappings(const TArray<struct FLegacyControlsInputMapping>& Value);
	void SetHorizontalSensitivity(const float Value);
	void SetInvertY(const bool Value);
	void SetMapping(const struct FLegacyControlsInputMapping& Value);
	void SetSettings(const struct FLegacyXControllerSettings& Value);
	void SetVerticalSensitivity(const float Value);
	void SetVibration(const bool Value);

	const TArray<struct FLegacyControlsInputMapping> GetControllerMappings() const;
	const struct FLegacyXControllerSettings GetSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyXControlsMenu">();
	}
	static class UVLegacyXControlsMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyXControlsMenu>();
	}
};
static_assert(alignof(UVLegacyXControlsMenu) == 0x000008, "Wrong alignment on UVLegacyXControlsMenu");
static_assert(sizeof(UVLegacyXControlsMenu) == 0x000508, "Wrong size on UVLegacyXControlsMenu");
static_assert(offsetof(UVLegacyXControlsMenu, Settings) == 0x0004E8, "Member 'UVLegacyXControlsMenu::Settings' has a wrong offset!");
static_assert(offsetof(UVLegacyXControlsMenu, ControllerMappings) == 0x0004F8, "Member 'UVLegacyXControlsMenu::ControllerMappings' has a wrong offset!");

// Class Altar.VInitializedPrePlacedActor
// 0x0020 (0x0048 - 0x0028)
class UVInitializedPrePlacedActor final : public UObject
{
public:
	class AVActor*                                Actor;                                             // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VInitializedPrePlacedActor">();
	}
	static class UVInitializedPrePlacedActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVInitializedPrePlacedActor>();
	}
};
static_assert(alignof(UVInitializedPrePlacedActor) == 0x000008, "Wrong alignment on UVInitializedPrePlacedActor");
static_assert(sizeof(UVInitializedPrePlacedActor) == 0x000048, "Wrong size on UVInitializedPrePlacedActor");
static_assert(offsetof(UVInitializedPrePlacedActor, Actor) == 0x000028, "Member 'UVInitializedPrePlacedActor::Actor' has a wrong offset!");

// Class Altar.VLevelSelectDoor
// 0x0048 (0x02E0 - 0x0298)
class AVLevelSelectDoor : public AActor
{
public:
	class FText                                   DoorText;                                          // 0x0298(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartupCommand;                                    // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDebugGamemode;                                 // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   MainStaticMesh;                                    // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          BoxComponent;                                      // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLevelSelectDoor">();
	}
	static class AVLevelSelectDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVLevelSelectDoor>();
	}
};
static_assert(alignof(AVLevelSelectDoor) == 0x000008, "Wrong alignment on AVLevelSelectDoor");
static_assert(sizeof(AVLevelSelectDoor) == 0x0002E0, "Wrong size on AVLevelSelectDoor");
static_assert(offsetof(AVLevelSelectDoor, DoorText) == 0x000298, "Member 'AVLevelSelectDoor::DoorText' has a wrong offset!");
static_assert(offsetof(AVLevelSelectDoor, LevelName) == 0x0002B0, "Member 'AVLevelSelectDoor::LevelName' has a wrong offset!");
static_assert(offsetof(AVLevelSelectDoor, StartupCommand) == 0x0002B8, "Member 'AVLevelSelectDoor::StartupCommand' has a wrong offset!");
static_assert(offsetof(AVLevelSelectDoor, bUseDebugGamemode) == 0x0002C8, "Member 'AVLevelSelectDoor::bUseDebugGamemode' has a wrong offset!");
static_assert(offsetof(AVLevelSelectDoor, MainStaticMesh) == 0x0002D0, "Member 'AVLevelSelectDoor::MainStaticMesh' has a wrong offset!");
static_assert(offsetof(AVLevelSelectDoor, BoxComponent) == 0x0002D8, "Member 'AVLevelSelectDoor::BoxComponent' has a wrong offset!");

// Class Altar.VLevelSelectSettings
// 0x0008 (0x0030 - 0x0028)
class UVLevelSelectSettings final : public UObject
{
public:
	TSubclassOf<class AVLevelSelectDoor>          DoorActor;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLevelSelectSettings">();
	}
	static class UVLevelSelectSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLevelSelectSettings>();
	}
};
static_assert(alignof(UVLevelSelectSettings) == 0x000008, "Wrong alignment on UVLevelSelectSettings");
static_assert(sizeof(UVLevelSelectSettings) == 0x000030, "Wrong size on UVLevelSelectSettings");
static_assert(offsetof(UVLevelSelectSettings, DoorActor) == 0x000028, "Member 'UVLevelSelectSettings::DoorActor' has a wrong offset!");

// Class Altar.VLevelStreaming
// 0x00C0 (0x0260 - 0x01A0)
class UVLevelStreaming final : public ULevelStreamingDynamic
{
public:
	uint8                                         Pad_1A0[0x20];                                     // 0x01A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, class AActor*>                   PawnActors;                                        // 0x01C0(0x0050)(NativeAccessSpecifierPublic)
	struct FBox                                   LevelBounds;                                       // 0x0210(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ZKillDistUnderLevel;                               // 0x0248(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ContainedActors;                                   // 0x0250(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnInteriorLevelHidden();
	void OnInteriorLevelLoaded();
	void OnInteriorLevelShown();
	void OnInteriorLevelUnloaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLevelStreaming">();
	}
	static class UVLevelStreaming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLevelStreaming>();
	}
};
static_assert(alignof(UVLevelStreaming) == 0x000010, "Wrong alignment on UVLevelStreaming");
static_assert(sizeof(UVLevelStreaming) == 0x000260, "Wrong size on UVLevelStreaming");
static_assert(offsetof(UVLevelStreaming, PawnActors) == 0x0001C0, "Member 'UVLevelStreaming::PawnActors' has a wrong offset!");
static_assert(offsetof(UVLevelStreaming, LevelBounds) == 0x000210, "Member 'UVLevelStreaming::LevelBounds' has a wrong offset!");
static_assert(offsetof(UVLevelStreaming, ZKillDistUnderLevel) == 0x000248, "Member 'UVLevelStreaming::ZKillDistUnderLevel' has a wrong offset!");
static_assert(offsetof(UVLevelStreaming, ContainedActors) == 0x000250, "Member 'UVLevelStreaming::ContainedActors' has a wrong offset!");

// Class Altar.VLevelUpMenuViewModel
// 0x0078 (0x0148 - 0x00D0)
class UVLevelUpMenuViewModel final : public UVViewModelBase
{
public:
	struct FLevelUpMenuInitializationData         InitializationData;                                // 0x00D0(0x0038)(NativeAccessSpecifierPrivate)
	struct FLevelUpMenuState                      CurrentState;                                      // 0x0108(0x0018)(NativeAccessSpecifierPrivate)
	int32                                         CurrentPointsNb;                                   // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ModifiedAttributesIndexArray;                      // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 BonusesArray;                                      // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void RegisterSendClickedDoneHandler();
	void RegisterSendModifiedAttributesAndClickedDoneHandler();
	void RegisterSendSelectAttributeHandler(const EVAttribute SelectedAttribute);
	void SetBonusesArray(const TArray<int32>& NewBonusesArray);
	void SetCurrentPointsNb(const int32& NewPointsNb);
	void SetModifiedAttributesIndexArray(const TArray<int32>& NewModifiedAttributesIndexArray);
	void UpdateCurrentPointsNb(const bool IsPlus, const int32 BonusCost);

	const TArray<int32> GetBonusesArray() const;
	const int32 GetCurrentPointsNb() const;
	const struct FLevelUpMenuState GetCurrentState() const;
	const struct FLevelUpMenuInitializationData GetInitializationData() const;
	const TArray<int32> GetModifiedAttributesIndexArray() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLevelUpMenuViewModel">();
	}
	static class UVLevelUpMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLevelUpMenuViewModel>();
	}
};
static_assert(alignof(UVLevelUpMenuViewModel) == 0x000008, "Wrong alignment on UVLevelUpMenuViewModel");
static_assert(sizeof(UVLevelUpMenuViewModel) == 0x000148, "Wrong size on UVLevelUpMenuViewModel");
static_assert(offsetof(UVLevelUpMenuViewModel, InitializationData) == 0x0000D0, "Member 'UVLevelUpMenuViewModel::InitializationData' has a wrong offset!");
static_assert(offsetof(UVLevelUpMenuViewModel, CurrentState) == 0x000108, "Member 'UVLevelUpMenuViewModel::CurrentState' has a wrong offset!");
static_assert(offsetof(UVLevelUpMenuViewModel, CurrentPointsNb) == 0x000120, "Member 'UVLevelUpMenuViewModel::CurrentPointsNb' has a wrong offset!");
static_assert(offsetof(UVLevelUpMenuViewModel, ModifiedAttributesIndexArray) == 0x000128, "Member 'UVLevelUpMenuViewModel::ModifiedAttributesIndexArray' has a wrong offset!");
static_assert(offsetof(UVLevelUpMenuViewModel, BonusesArray) == 0x000138, "Member 'UVLevelUpMenuViewModel::BonusesArray' has a wrong offset!");

// Class Altar.VLevelUpSecondaryAttributeWidget
// 0x0000 (0x04C8 - 0x04C8)
class UVLevelUpSecondaryAttributeWidget final : public UVAltarWidget
{
public:
	void OnDecrementBonus();
	void OnIncrementBonus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLevelUpSecondaryAttributeWidget">();
	}
	static class UVLevelUpSecondaryAttributeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLevelUpSecondaryAttributeWidget>();
	}
};
static_assert(alignof(UVLevelUpSecondaryAttributeWidget) == 0x000008, "Wrong alignment on UVLevelUpSecondaryAttributeWidget");
static_assert(sizeof(UVLevelUpSecondaryAttributeWidget) == 0x0004C8, "Wrong size on UVLevelUpSecondaryAttributeWidget");

// Class Altar.VLoadingScreenViewModel
// 0x0058 (0x0128 - 0x00D0)
class UVLoadingScreenViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void(const struct FLoadScreenPlayerData& UpdatedPlayerData)> OnPlayerDataUpdated; // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<struct FHintData>& NewHintsArray)> OnHintsArrayUpdated; // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FHintData>                      Hints;                                             // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	ELoadingScreenType                            LoadingScreenType;                                 // 0x0100(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoadScreenPlayerData                  PlayerData;                                        // 0x0108(0x0020)(NativeAccessSpecifierPrivate)

public:
	void SetHints(const TArray<struct FHintData>& NewHints);
	void SetLoadingScreenType(ELoadingScreenType NewLoadingScreenType);
	void SetPlayerData(const struct FLoadScreenPlayerData& NewPlayerData);

	const TArray<struct FHintData> GetHints() const;
	ELoadingScreenType GetLoadingScreenType() const;
	const struct FLoadScreenPlayerData GetPlayerData() const;
	bool ThisIsForPluginCompliance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLoadingScreenViewModel">();
	}
	static class UVLoadingScreenViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLoadingScreenViewModel>();
	}
};
static_assert(alignof(UVLoadingScreenViewModel) == 0x000008, "Wrong alignment on UVLoadingScreenViewModel");
static_assert(sizeof(UVLoadingScreenViewModel) == 0x000128, "Wrong size on UVLoadingScreenViewModel");
static_assert(offsetof(UVLoadingScreenViewModel, OnPlayerDataUpdated) == 0x0000D0, "Member 'UVLoadingScreenViewModel::OnPlayerDataUpdated' has a wrong offset!");
static_assert(offsetof(UVLoadingScreenViewModel, OnHintsArrayUpdated) == 0x0000E0, "Member 'UVLoadingScreenViewModel::OnHintsArrayUpdated' has a wrong offset!");
static_assert(offsetof(UVLoadingScreenViewModel, Hints) == 0x0000F0, "Member 'UVLoadingScreenViewModel::Hints' has a wrong offset!");
static_assert(offsetof(UVLoadingScreenViewModel, LoadingScreenType) == 0x000100, "Member 'UVLoadingScreenViewModel::LoadingScreenType' has a wrong offset!");
static_assert(offsetof(UVLoadingScreenViewModel, PlayerData) == 0x000108, "Member 'UVLoadingScreenViewModel::PlayerData' has a wrong offset!");

// Class Altar.VLocalizationSettings
// 0x0010 (0x0038 - 0x0028)
class UVLocalizationSettings final : public UObject
{
public:
	TArray<struct FVLocalizationStringTable>      LocalizationTables;                                // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLocalizationSettings">();
	}
	static class UVLocalizationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLocalizationSettings>();
	}
};
static_assert(alignof(UVLocalizationSettings) == 0x000008, "Wrong alignment on UVLocalizationSettings");
static_assert(sizeof(UVLocalizationSettings) == 0x000038, "Wrong size on UVLocalizationSettings");
static_assert(offsetof(UVLocalizationSettings, LocalizationTables) == 0x000028, "Member 'UVLocalizationSettings::LocalizationTables' has a wrong offset!");

// Class Altar.VLockpickMenuViewModel
// 0x0030 (0x0100 - 0x00D0)
class UVLockpickMenuViewModel final : public UVViewModelBase
{
public:
	EAttemptSuccess                               HasAutoAttemptWorked;                              // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyLockpickMenuProperties          MenuProperties;                                    // 0x00D4(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FLegacyLockpickMenuTumblerDefaultProperties TumblerDefaultProperties;                     // 0x00E4(0x001C)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	void RegisterSendBrokeAPick();
	void RegisterSendClickedAutoAttempt();
	void RegisterSendClickedClose();
	void RegisterSendComplete();
	void RegisterSendTumblerPicked();
	void SetHasAutoAttemptWorked(EAttemptSuccess NewValue);
	void SetMenuProperties(const struct FLegacyLockpickMenuProperties& NewProperties);
	void SetTumblerDefaultProperties(const struct FLegacyLockpickMenuTumblerDefaultProperties& NewTumblerDefaultProperties);

	EAttemptSuccess GetHasAutoAttemptWorked() const;
	const struct FLegacyLockpickMenuProperties GetMenuProperties() const;
	const struct FLegacyLockpickMenuTumblerDefaultProperties GetTumblerDefaultProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLockpickMenuViewModel">();
	}
	static class UVLockpickMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLockpickMenuViewModel>();
	}
};
static_assert(alignof(UVLockpickMenuViewModel) == 0x000008, "Wrong alignment on UVLockpickMenuViewModel");
static_assert(sizeof(UVLockpickMenuViewModel) == 0x000100, "Wrong size on UVLockpickMenuViewModel");
static_assert(offsetof(UVLockpickMenuViewModel, HasAutoAttemptWorked) == 0x0000D0, "Member 'UVLockpickMenuViewModel::HasAutoAttemptWorked' has a wrong offset!");
static_assert(offsetof(UVLockpickMenuViewModel, MenuProperties) == 0x0000D4, "Member 'UVLockpickMenuViewModel::MenuProperties' has a wrong offset!");
static_assert(offsetof(UVLockpickMenuViewModel, TumblerDefaultProperties) == 0x0000E4, "Member 'UVLockpickMenuViewModel::TumblerDefaultProperties' has a wrong offset!");

// Class Altar.VLocomotionStandTurnAnimInstance
// 0x0030 (0x0490 - 0x0460)
class UVLocomotionStandTurnAnimInstance final : public UVLocomotionCharacterAnimInstance
{
public:
	TSubclassOf<class UAnimInstance>              TurnInPlaceLayer;                                  // 0x0460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVLocomotionTurn                       AnimSet;                                           // 0x0468(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanTurn() const;
	bool IsTurning() const;
	bool IsTurningLeft() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLocomotionStandTurnAnimInstance">();
	}
	static class UVLocomotionStandTurnAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLocomotionStandTurnAnimInstance>();
	}
};
static_assert(alignof(UVLocomotionStandTurnAnimInstance) == 0x000010, "Wrong alignment on UVLocomotionStandTurnAnimInstance");
static_assert(sizeof(UVLocomotionStandTurnAnimInstance) == 0x000490, "Wrong size on UVLocomotionStandTurnAnimInstance");
static_assert(offsetof(UVLocomotionStandTurnAnimInstance, TurnInPlaceLayer) == 0x000460, "Member 'UVLocomotionStandTurnAnimInstance::TurnInPlaceLayer' has a wrong offset!");
static_assert(offsetof(UVLocomotionStandTurnAnimInstance, AnimSet) == 0x000468, "Member 'UVLocomotionStandTurnAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VSenescenceLevel
// 0x0098 (0x00C8 - 0x0030)
class UVSenescenceLevel final : public UDataAsset
{
public:
	class UMaterialInterface*                     OverrideMaterial;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVSenescenceTexture                    HealthyTexture;                                    // 0x0038(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVSenescenceTexture                    SickTexture;                                       // 0x0078(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FVSenescenceTexture>            VampireTexture;                                    // 0x00B8(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSenescenceLevel">();
	}
	static class UVSenescenceLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSenescenceLevel>();
	}
};
static_assert(alignof(UVSenescenceLevel) == 0x000008, "Wrong alignment on UVSenescenceLevel");
static_assert(sizeof(UVSenescenceLevel) == 0x0000C8, "Wrong size on UVSenescenceLevel");
static_assert(offsetof(UVSenescenceLevel, OverrideMaterial) == 0x000030, "Member 'UVSenescenceLevel::OverrideMaterial' has a wrong offset!");
static_assert(offsetof(UVSenescenceLevel, HealthyTexture) == 0x000038, "Member 'UVSenescenceLevel::HealthyTexture' has a wrong offset!");
static_assert(offsetof(UVSenescenceLevel, SickTexture) == 0x000078, "Member 'UVSenescenceLevel::SickTexture' has a wrong offset!");
static_assert(offsetof(UVSenescenceLevel, VampireTexture) == 0x0000B8, "Member 'UVSenescenceLevel::VampireTexture' has a wrong offset!");

// Class Altar.VWaterSoundFollower
// 0x0050 (0x02E8 - 0x0298)
class AVWaterSoundFollower final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StartWaterEvent;                                   // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          StopWaterEvent;                                    // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x30];                                     // 0x02B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAltarAkComponent*                     AkAudioComponent;                                  // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnLoadFinished();
	void OnLoadStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWaterSoundFollower">();
	}
	static class AVWaterSoundFollower* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWaterSoundFollower>();
	}
};
static_assert(alignof(AVWaterSoundFollower) == 0x000008, "Wrong alignment on AVWaterSoundFollower");
static_assert(sizeof(AVWaterSoundFollower) == 0x0002E8, "Wrong size on AVWaterSoundFollower");
static_assert(offsetof(AVWaterSoundFollower, StartWaterEvent) == 0x0002A0, "Member 'AVWaterSoundFollower::StartWaterEvent' has a wrong offset!");
static_assert(offsetof(AVWaterSoundFollower, StopWaterEvent) == 0x0002A8, "Member 'AVWaterSoundFollower::StopWaterEvent' has a wrong offset!");
static_assert(offsetof(AVWaterSoundFollower, AkAudioComponent) == 0x0002E0, "Member 'AVWaterSoundFollower::AkAudioComponent' has a wrong offset!");

// Class Altar.VLookAtAnimInstance
// 0x0010 (0x03B0 - 0x03A0)
class UVLookAtAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	class FName                                   CommandEffectName;                                 // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanLookAt;                                        // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsSitting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLookAtAnimInstance">();
	}
	static class UVLookAtAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLookAtAnimInstance>();
	}
};
static_assert(alignof(UVLookAtAnimInstance) == 0x000010, "Wrong alignment on UVLookAtAnimInstance");
static_assert(sizeof(UVLookAtAnimInstance) == 0x0003B0, "Wrong size on UVLookAtAnimInstance");
static_assert(offsetof(UVLookAtAnimInstance, CommandEffectName) == 0x0003A0, "Member 'UVLookAtAnimInstance::CommandEffectName' has a wrong offset!");
static_assert(offsetof(UVLookAtAnimInstance, bCanLookAt) == 0x0003A8, "Member 'UVLookAtAnimInstance::bCanLookAt' has a wrong offset!");

// Class Altar.VMagicMenuViewModel
// 0x00F8 (0x01C8 - 0x00D0)
class UVMagicMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnSpellEquipSoundTrigger;                          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<struct FLegacyMagicMenuItemProperties> Inventory;                                         // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FLegacyMagicMenuItemProperties> CurrentPageInventory;                              // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FLegacyMagicMenuItemProperties> FavoritesItems;                                    // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         SpellEffectiveness;                                // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModernSpellEffectivenessProperties    SpellEfectivenessExplanation;                      // 0x0118(0x0048)(NativeAccessSpecifierPrivate)
	ELegacyMagicMenuPage                          CurrentPage;                                       // 0x0160(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELegacyMagicMenuSortType                      SortType;                                          // 0x0161(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSortReversed;                                   // 0x0162(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_163[0x5];                                      // 0x0163(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyMagicMenuItemProperties         CurrentSpellEquiped;                               // 0x0168(0x0060)(NativeAccessSpecifierPrivate)

public:
	void RegisterSendClickOnItemHandler(int32 InButtonIndex);
	void RegisterSendItemHoverHandler(int32 ItemIndex);
	void ReplaceCurrentPageInventory(const TArray<struct FLegacyMagicMenuItemProperties>& NewItems);
	void SetCurrentPage(ELegacyMagicMenuPage NewPage);
	void SetCurrentSpellEquiped(const struct FLegacyMagicMenuItemProperties& InSpellEquiped);
	void SetInventory(const TArray<struct FLegacyMagicMenuItemProperties>& NewItems);
	void SetInventoryForPage(const ELegacyMagicMenuPage Page);
	void SetIsSortReversed(bool bNewIsSortReversed);
	void SetSortType(ELegacyMagicMenuSortType NewSortType);
	void SetSpellEfectivenessExplanation(const struct FModernSpellEffectivenessProperties& NewSpellEffectivenessExplanation);
	void SetSpellEffectiveness(float NewSpellEffectiveness);
	void ToggleFavoriteItem(const struct FLegacyMagicMenuItemProperties& InItem);

	ELegacyMagicMenuPage GetCurrentPage() const;
	const TArray<struct FLegacyMagicMenuItemProperties> GetCurrentPageInventory() const;
	const struct FLegacyMagicMenuItemProperties GetCurrentSpellEquiped() const;
	const TArray<struct FLegacyMagicMenuItemProperties> GetFavoritesItems() const;
	const TArray<struct FLegacyMagicMenuItemProperties> GetInventory() const;
	ELegacyMagicMenuSortType GetSortType() const;
	struct FModernSpellEffectivenessProperties GetSpellEfectivenessExplanation() const;
	float GetSpellEffectiveness() const;
	bool IsItemTypeOnPage(const ELegacyMagicMenuItemType Item, const ELegacyMagicMenuPage Page) const;
	bool IsSortReversed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMagicMenuViewModel">();
	}
	static class UVMagicMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMagicMenuViewModel>();
	}
};
static_assert(alignof(UVMagicMenuViewModel) == 0x000008, "Wrong alignment on UVMagicMenuViewModel");
static_assert(sizeof(UVMagicMenuViewModel) == 0x0001C8, "Wrong size on UVMagicMenuViewModel");
static_assert(offsetof(UVMagicMenuViewModel, OnSpellEquipSoundTrigger) == 0x0000D0, "Member 'UVMagicMenuViewModel::OnSpellEquipSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVMagicMenuViewModel, Inventory) == 0x0000E0, "Member 'UVMagicMenuViewModel::Inventory' has a wrong offset!");
static_assert(offsetof(UVMagicMenuViewModel, CurrentPageInventory) == 0x0000F0, "Member 'UVMagicMenuViewModel::CurrentPageInventory' has a wrong offset!");
static_assert(offsetof(UVMagicMenuViewModel, FavoritesItems) == 0x000100, "Member 'UVMagicMenuViewModel::FavoritesItems' has a wrong offset!");
static_assert(offsetof(UVMagicMenuViewModel, SpellEffectiveness) == 0x000110, "Member 'UVMagicMenuViewModel::SpellEffectiveness' has a wrong offset!");
static_assert(offsetof(UVMagicMenuViewModel, SpellEfectivenessExplanation) == 0x000118, "Member 'UVMagicMenuViewModel::SpellEfectivenessExplanation' has a wrong offset!");
static_assert(offsetof(UVMagicMenuViewModel, CurrentPage) == 0x000160, "Member 'UVMagicMenuViewModel::CurrentPage' has a wrong offset!");
static_assert(offsetof(UVMagicMenuViewModel, SortType) == 0x000161, "Member 'UVMagicMenuViewModel::SortType' has a wrong offset!");
static_assert(offsetof(UVMagicMenuViewModel, bIsSortReversed) == 0x000162, "Member 'UVMagicMenuViewModel::bIsSortReversed' has a wrong offset!");
static_assert(offsetof(UVMagicMenuViewModel, CurrentSpellEquiped) == 0x000168, "Member 'UVMagicMenuViewModel::CurrentSpellEquiped' has a wrong offset!");

// Class Altar.VMagicPopupMenuViewModel
// 0x0030 (0x0100 - 0x00D0)
class UVMagicPopupMenuViewModel final : public UVViewModelBase
{
public:
	TArray<struct FLegacyMagicPopupEffectProperties> Effects;                                        // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FText                                   Requires;                                          // 0x00E0(0x0018)(NativeAccessSpecifierPrivate)
	bool                                          bIsDisplayed;                                      // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetYOffset;                                     // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetEffects(const TArray<struct FLegacyMagicPopupEffectProperties>& NewEffectsProperties);
	void SetIsDisplayed(bool bNewValue);
	void SetRequires(const class FText& NewRequiresText);
	void SetTargetYOffset(float NewValue);

	const TArray<struct FLegacyMagicPopupEffectProperties> GetEffects() const;
	bool GetIsDisplayed() const;
	const class FText GetRequires() const;
	float GetTargetYOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMagicPopupMenuViewModel">();
	}
	static class UVMagicPopupMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMagicPopupMenuViewModel>();
	}
};
static_assert(alignof(UVMagicPopupMenuViewModel) == 0x000008, "Wrong alignment on UVMagicPopupMenuViewModel");
static_assert(sizeof(UVMagicPopupMenuViewModel) == 0x000100, "Wrong size on UVMagicPopupMenuViewModel");
static_assert(offsetof(UVMagicPopupMenuViewModel, Effects) == 0x0000D0, "Member 'UVMagicPopupMenuViewModel::Effects' has a wrong offset!");
static_assert(offsetof(UVMagicPopupMenuViewModel, Requires) == 0x0000E0, "Member 'UVMagicPopupMenuViewModel::Requires' has a wrong offset!");
static_assert(offsetof(UVMagicPopupMenuViewModel, bIsDisplayed) == 0x0000F8, "Member 'UVMagicPopupMenuViewModel::bIsDisplayed' has a wrong offset!");
static_assert(offsetof(UVMagicPopupMenuViewModel, TargetYOffset) == 0x0000FC, "Member 'UVMagicPopupMenuViewModel::TargetYOffset' has a wrong offset!");

// Class Altar.VMainCharacterAnimInstance
// 0x0480 (0x07E0 - 0x0360)
class UVMainCharacterAnimInstance : public UVBaseCharacterAnimInstance
{
public:
	uint8                                         Pad_358[0x20];                                     // 0x0358(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanSwim;                                          // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterPropertyLinkTable>    PropertyLinkTable;                                 // 0x0380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCharacterPropertyLinkTable>    DynamicPropertyLinkTable;                          // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FCharacterLayerLinkTable> AttackingLayerLinkTable;              // 0x03A0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCharacterPropertyLinkTable>    LocomotionLinkTable;                               // 0x03F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterPropertyLinkTable            EquipUnequipLink;                                  // 0x0400(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AttackingTags;                                     // 0x0418(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  EquipUnequipTags;                                  // 0x0438(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlockingTags;                                      // 0x0458(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SlowestMovingTag;                                  // 0x0478(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FastestMovingTag;                                  // 0x0480(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStaggered;                                      // 0x0488(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDodgingRequest;                                   // 0x0489(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanExitBlock;                                     // 0x048A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanExitAttack;                                    // 0x048B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttackingRequest;                                 // 0x048C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEquipUnequipRequest;                              // 0x048D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCastingRequest;                                   // 0x048E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRecoilingRequest;                                 // 0x048F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUsingFullBody;                                  // 0x0490(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWeaponDrawn;                                    // 0x0491(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_492[0x6];                                      // 0x0492(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              SpecialAndDynamicIdleAnimLayerClass;               // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              TorchAnimLayerClass;                               // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              ShieldHandPoseAnimLayerClass;                      // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              ConversationIdleAnimLayerClass;                    // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              SpellCastAnimLayerClass;                           // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              BlockAnimLayerClass;                               // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              RecoilAnimLayerClass;                              // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              StaggerAnimLayerClass;                             // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              DodgeAnimLayerClass;                               // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              GetUpAnimLayerClass;                               // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              InAirAnimLayerClass;                               // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              HorseRiderGroundAnimLayerClass;                    // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              HorseRiderInAirAnimLayerClass;                     // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              HorseRiderSwimAnimLayerClass;                      // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpecialIdleUpperBodyBoneName;                      // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpecialIdleUpperBodyBlendDepth;                    // 0x0510(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVSpecialIdleAndDockData               SpecialIdleAndDockData;                            // 0x0518(0x0040)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTorchAnimationData                    TorchAnimSet;                                      // 0x0558(0x0040)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FShieldHandPoseSetup                   ShieldHandPoseSetup;                               // 0x0598(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FConversationIdleData                  ConversationAnimSet;                               // 0x05B0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FCharacterPropertyLinkTable            SpellCastLayerPropertyLinkTable;                   // 0x05D0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterPropertyLinkTable            BlockLayerPropertyLinkTable;                       // 0x05E8(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterPropertyLinkTable            RecoilLayerPropertyLinkTable;                      // 0x0600(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterPropertyLinkTable            StaggerLayerPropertyLinkTable;                     // 0x0618(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterPropertyLinkTable            DodgeLayerPropertyLinkTable;                       // 0x0630(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterPropertyLinkTable            GetUpLayerPropertyLinkTable;                       // 0x0648(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterPropertyLinkTable            InAirLayerPropertyLinkTable;                       // 0x0660(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVHorseRiderLocomotionStanding         HorseRiderGroundData;                              // 0x0678(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVHorseRiderLocomotionSwim             HorseRiderSwimData;                                // 0x06C8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVHorseRiderLocomotionJump             HorseRiderJumpData;                                // 0x06E0(0x0048)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_728[0xB8];                                     // 0x0728(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DockingTransitionUpdated(bool bIsUndockingTransition);
	void LinkDynamicAnimLayersRequest();
	void OnCombatStateComplete(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCombatStateExit(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCombatStateFullyBlendedIn(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void SetLocomotionLinkTable(const TArray<struct FCharacterPropertyLinkTable>& InLocomotionLinkTable);
	void SetPropertyLinkTable(const TArray<struct FCharacterPropertyLinkTable>& InPropertyLinkTable);
	void SpecialIdleAnimationStart(class UAnimSequenceBase* AnimationAsset);
	void StateMachineActionRequest(class UVPawnAnimatedAction* Action);
	class UAnimInstance* TryToLinkLayer(const TSubclassOf<class UAnimInstance> AnimLayerClass);
	class UAnimInstance* TryToLinkLayerAndUpdateLinkTable(const TSubclassOf<class UAnimInstance> AnimLayerClass, struct FCharacterPropertyLinkTable* InPropertyLinkTable);
	void UpdateLocomotionLinkTable();
	void UpdateLocomotionLinkTableStateNode(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

	bool HasActionRequest(const struct FGameplayTag& ActionTag) const;
	bool HasActionRequestWithIndex(const struct FGameplayTag& ActionTag, int32 AnimIndex) const;
	bool HasAnyActionRequest(const struct FGameplayTagContainer& TagContainer) const;
	bool IsAttacking() const;
	bool IsBlocking() const;
	bool IsDodging() const;
	bool IsGrabbing() const;
	bool IsInAir() const;
	bool IsMoving() const;
	bool IsOnHorse() const;
	bool IsRecoiling() const;
	bool IsResurrecting() const;
	bool IsRunning() const;
	bool IsSneaking() const;
	bool IsStaggered() const;
	bool IsStanding() const;
	bool IsSwimming() const;
	bool IsWeaponDrawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMainCharacterAnimInstance">();
	}
	static class UVMainCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMainCharacterAnimInstance>();
	}
};
static_assert(alignof(UVMainCharacterAnimInstance) == 0x000010, "Wrong alignment on UVMainCharacterAnimInstance");
static_assert(sizeof(UVMainCharacterAnimInstance) == 0x0007E0, "Wrong size on UVMainCharacterAnimInstance");
static_assert(offsetof(UVMainCharacterAnimInstance, bCanSwim) == 0x000378, "Member 'UVMainCharacterAnimInstance::bCanSwim' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, PropertyLinkTable) == 0x000380, "Member 'UVMainCharacterAnimInstance::PropertyLinkTable' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, DynamicPropertyLinkTable) == 0x000390, "Member 'UVMainCharacterAnimInstance::DynamicPropertyLinkTable' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, AttackingLayerLinkTable) == 0x0003A0, "Member 'UVMainCharacterAnimInstance::AttackingLayerLinkTable' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, LocomotionLinkTable) == 0x0003F0, "Member 'UVMainCharacterAnimInstance::LocomotionLinkTable' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, EquipUnequipLink) == 0x000400, "Member 'UVMainCharacterAnimInstance::EquipUnequipLink' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, AttackingTags) == 0x000418, "Member 'UVMainCharacterAnimInstance::AttackingTags' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, EquipUnequipTags) == 0x000438, "Member 'UVMainCharacterAnimInstance::EquipUnequipTags' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, BlockingTags) == 0x000458, "Member 'UVMainCharacterAnimInstance::BlockingTags' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, SlowestMovingTag) == 0x000478, "Member 'UVMainCharacterAnimInstance::SlowestMovingTag' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, FastestMovingTag) == 0x000480, "Member 'UVMainCharacterAnimInstance::FastestMovingTag' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, bIsStaggered) == 0x000488, "Member 'UVMainCharacterAnimInstance::bIsStaggered' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, bDodgingRequest) == 0x000489, "Member 'UVMainCharacterAnimInstance::bDodgingRequest' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, bCanExitBlock) == 0x00048A, "Member 'UVMainCharacterAnimInstance::bCanExitBlock' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, bCanExitAttack) == 0x00048B, "Member 'UVMainCharacterAnimInstance::bCanExitAttack' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, bAttackingRequest) == 0x00048C, "Member 'UVMainCharacterAnimInstance::bAttackingRequest' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, bEquipUnequipRequest) == 0x00048D, "Member 'UVMainCharacterAnimInstance::bEquipUnequipRequest' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, bCastingRequest) == 0x00048E, "Member 'UVMainCharacterAnimInstance::bCastingRequest' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, bRecoilingRequest) == 0x00048F, "Member 'UVMainCharacterAnimInstance::bRecoilingRequest' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, bIsUsingFullBody) == 0x000490, "Member 'UVMainCharacterAnimInstance::bIsUsingFullBody' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, bIsWeaponDrawn) == 0x000491, "Member 'UVMainCharacterAnimInstance::bIsWeaponDrawn' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, SpecialAndDynamicIdleAnimLayerClass) == 0x000498, "Member 'UVMainCharacterAnimInstance::SpecialAndDynamicIdleAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, TorchAnimLayerClass) == 0x0004A0, "Member 'UVMainCharacterAnimInstance::TorchAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, ShieldHandPoseAnimLayerClass) == 0x0004A8, "Member 'UVMainCharacterAnimInstance::ShieldHandPoseAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, ConversationIdleAnimLayerClass) == 0x0004B0, "Member 'UVMainCharacterAnimInstance::ConversationIdleAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, SpellCastAnimLayerClass) == 0x0004B8, "Member 'UVMainCharacterAnimInstance::SpellCastAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, BlockAnimLayerClass) == 0x0004C0, "Member 'UVMainCharacterAnimInstance::BlockAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, RecoilAnimLayerClass) == 0x0004C8, "Member 'UVMainCharacterAnimInstance::RecoilAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, StaggerAnimLayerClass) == 0x0004D0, "Member 'UVMainCharacterAnimInstance::StaggerAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, DodgeAnimLayerClass) == 0x0004D8, "Member 'UVMainCharacterAnimInstance::DodgeAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, GetUpAnimLayerClass) == 0x0004E0, "Member 'UVMainCharacterAnimInstance::GetUpAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, InAirAnimLayerClass) == 0x0004E8, "Member 'UVMainCharacterAnimInstance::InAirAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, HorseRiderGroundAnimLayerClass) == 0x0004F0, "Member 'UVMainCharacterAnimInstance::HorseRiderGroundAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, HorseRiderInAirAnimLayerClass) == 0x0004F8, "Member 'UVMainCharacterAnimInstance::HorseRiderInAirAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, HorseRiderSwimAnimLayerClass) == 0x000500, "Member 'UVMainCharacterAnimInstance::HorseRiderSwimAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, SpecialIdleUpperBodyBoneName) == 0x000508, "Member 'UVMainCharacterAnimInstance::SpecialIdleUpperBodyBoneName' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, SpecialIdleUpperBodyBlendDepth) == 0x000510, "Member 'UVMainCharacterAnimInstance::SpecialIdleUpperBodyBlendDepth' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, SpecialIdleAndDockData) == 0x000518, "Member 'UVMainCharacterAnimInstance::SpecialIdleAndDockData' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, TorchAnimSet) == 0x000558, "Member 'UVMainCharacterAnimInstance::TorchAnimSet' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, ShieldHandPoseSetup) == 0x000598, "Member 'UVMainCharacterAnimInstance::ShieldHandPoseSetup' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, ConversationAnimSet) == 0x0005B0, "Member 'UVMainCharacterAnimInstance::ConversationAnimSet' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, SpellCastLayerPropertyLinkTable) == 0x0005D0, "Member 'UVMainCharacterAnimInstance::SpellCastLayerPropertyLinkTable' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, BlockLayerPropertyLinkTable) == 0x0005E8, "Member 'UVMainCharacterAnimInstance::BlockLayerPropertyLinkTable' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, RecoilLayerPropertyLinkTable) == 0x000600, "Member 'UVMainCharacterAnimInstance::RecoilLayerPropertyLinkTable' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, StaggerLayerPropertyLinkTable) == 0x000618, "Member 'UVMainCharacterAnimInstance::StaggerLayerPropertyLinkTable' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, DodgeLayerPropertyLinkTable) == 0x000630, "Member 'UVMainCharacterAnimInstance::DodgeLayerPropertyLinkTable' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, GetUpLayerPropertyLinkTable) == 0x000648, "Member 'UVMainCharacterAnimInstance::GetUpLayerPropertyLinkTable' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, InAirLayerPropertyLinkTable) == 0x000660, "Member 'UVMainCharacterAnimInstance::InAirLayerPropertyLinkTable' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, HorseRiderGroundData) == 0x000678, "Member 'UVMainCharacterAnimInstance::HorseRiderGroundData' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, HorseRiderSwimData) == 0x0006C8, "Member 'UVMainCharacterAnimInstance::HorseRiderSwimData' has a wrong offset!");
static_assert(offsetof(UVMainCharacterAnimInstance, HorseRiderJumpData) == 0x0006E0, "Member 'UVMainCharacterAnimInstance::HorseRiderJumpData' has a wrong offset!");

// Class Altar.VMainMenuViewModel
// 0x00D0 (0x01A0 - 0x00D0)
class UVMainMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnConfirmNewGameMessageMenu;                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCancelNewGameMessageMenu;                        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnConfirmLoadGameMessageMenu;                      // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSettingsMenuOpen;                                // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSettingsMenuClose;                               // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSaveLoadMenuOpen;                                // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSaveLoadMenuClose;                               // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          ContinueVisibility;                                // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   VersionText;                                       // 0x0148(0x0018)(NativeAccessSpecifierPrivate)
	EFLegacyMainMenuButtonVisibility              ButtonsVisibility;                                 // 0x0160(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMoviePlaying;                                   // 0x0161(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_162[0x6];                                      // 0x0162(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GamertagText;                                      // 0x0168(0x0018)(NativeAccessSpecifierPrivate)
	bool                                          bDoesNeedOnboarding;                               // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ACameraActor>            InitialActorViewTarget;                            // 0x0184(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULevelStreamingDynamic*>         LevelsLoaded;                                      // 0x0190(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	bool IsBackgroundLoaded();
	void LoadInstanceOfLevels(class UWorld* CurrentWorld);
	void OnPostSeamlessTravel();
	void PrepareLoadingScreenContextOnNewGame();
	void RegisterSendClickedContinue();
	void RegisterSendClickedExitGame();
	void RegisterSendClickedLoadGame();
	void RegisterSendClickedNewGame();
	void RegisterSendClickedSettings();
	void RegisterSendConfirmNewGame();
	void RegisterToLevelChangeData();
	void RequiresHideHUD();
	void SendCloseMainMenu();
	void SetButtonsVisibility(EFLegacyMainMenuButtonVisibility NewButtonsVisibility);
	void SetContinueVisibility(bool bVisibility);
	void SetIsMoviePlaying(bool bNewIsMoviePlaying);
	void SetVersionText(const class FText& NewText);
	void UnloadInstanceLevels(class UWorld* CurrentWorld);
	void UnRegisterToLevelChangeData();
	void UpdateContinueVisibility();
	void ValidateOnboarding();

	class FText GetBuildInfo() const;
	const EFLegacyMainMenuButtonVisibility GetButtonsVisibility() const;
	bool GetContinueVisibility() const;
	bool GetDoesNeedOnboarding() const;
	bool GetIsMoviePlaying() const;
	const class FText GetVersionText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMainMenuViewModel">();
	}
	static class UVMainMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMainMenuViewModel>();
	}
};
static_assert(alignof(UVMainMenuViewModel) == 0x000008, "Wrong alignment on UVMainMenuViewModel");
static_assert(sizeof(UVMainMenuViewModel) == 0x0001A0, "Wrong size on UVMainMenuViewModel");
static_assert(offsetof(UVMainMenuViewModel, OnConfirmNewGameMessageMenu) == 0x0000D0, "Member 'UVMainMenuViewModel::OnConfirmNewGameMessageMenu' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, OnCancelNewGameMessageMenu) == 0x0000E0, "Member 'UVMainMenuViewModel::OnCancelNewGameMessageMenu' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, OnConfirmLoadGameMessageMenu) == 0x0000F0, "Member 'UVMainMenuViewModel::OnConfirmLoadGameMessageMenu' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, OnSettingsMenuOpen) == 0x000100, "Member 'UVMainMenuViewModel::OnSettingsMenuOpen' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, OnSettingsMenuClose) == 0x000110, "Member 'UVMainMenuViewModel::OnSettingsMenuClose' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, OnSaveLoadMenuOpen) == 0x000120, "Member 'UVMainMenuViewModel::OnSaveLoadMenuOpen' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, OnSaveLoadMenuClose) == 0x000130, "Member 'UVMainMenuViewModel::OnSaveLoadMenuClose' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, ContinueVisibility) == 0x000140, "Member 'UVMainMenuViewModel::ContinueVisibility' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, VersionText) == 0x000148, "Member 'UVMainMenuViewModel::VersionText' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, ButtonsVisibility) == 0x000160, "Member 'UVMainMenuViewModel::ButtonsVisibility' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, bIsMoviePlaying) == 0x000161, "Member 'UVMainMenuViewModel::bIsMoviePlaying' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, GamertagText) == 0x000168, "Member 'UVMainMenuViewModel::GamertagText' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, bDoesNeedOnboarding) == 0x000180, "Member 'UVMainMenuViewModel::bDoesNeedOnboarding' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, InitialActorViewTarget) == 0x000184, "Member 'UVMainMenuViewModel::InitialActorViewTarget' has a wrong offset!");
static_assert(offsetof(UVMainMenuViewModel, LevelsLoaded) == 0x000190, "Member 'UVMainMenuViewModel::LevelsLoaded' has a wrong offset!");

// Class Altar.VLegacyMapMenuQuestCarouselItem
// 0x0068 (0x0090 - 0x0028)
class UVLegacyMapMenuQuestCarouselItem final : public UObject
{
public:
	class FText                                   Date;                                              // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ControllerText;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   KeyboardText;                                      // 0x0070(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsDecorator;                                      // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftDecorator;                                  // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVLegacyMapMenuQuestCarouselItem* CreateQuestCarouselItem(const class FText& NewDate, const class FText& NewBody);
	static class UVLegacyMapMenuQuestCarouselItem* CreateQuestCarouselItemFromQuest(const struct FLegacyMapMenuQuestProperties& Quest);
	static class UVLegacyMapMenuQuestCarouselItem* CreateQuestCarouselItemLeftDecorator();
	static class UVLegacyMapMenuQuestCarouselItem* CreateQuestCarouselItemRightDecorator();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyMapMenuQuestCarouselItem">();
	}
	static class UVLegacyMapMenuQuestCarouselItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyMapMenuQuestCarouselItem>();
	}
};
static_assert(alignof(UVLegacyMapMenuQuestCarouselItem) == 0x000008, "Wrong alignment on UVLegacyMapMenuQuestCarouselItem");
static_assert(sizeof(UVLegacyMapMenuQuestCarouselItem) == 0x000090, "Wrong size on UVLegacyMapMenuQuestCarouselItem");
static_assert(offsetof(UVLegacyMapMenuQuestCarouselItem, Date) == 0x000028, "Member 'UVLegacyMapMenuQuestCarouselItem::Date' has a wrong offset!");
static_assert(offsetof(UVLegacyMapMenuQuestCarouselItem, Body) == 0x000040, "Member 'UVLegacyMapMenuQuestCarouselItem::Body' has a wrong offset!");
static_assert(offsetof(UVLegacyMapMenuQuestCarouselItem, ControllerText) == 0x000058, "Member 'UVLegacyMapMenuQuestCarouselItem::ControllerText' has a wrong offset!");
static_assert(offsetof(UVLegacyMapMenuQuestCarouselItem, KeyboardText) == 0x000070, "Member 'UVLegacyMapMenuQuestCarouselItem::KeyboardText' has a wrong offset!");
static_assert(offsetof(UVLegacyMapMenuQuestCarouselItem, bIsDecorator) == 0x000088, "Member 'UVLegacyMapMenuQuestCarouselItem::bIsDecorator' has a wrong offset!");
static_assert(offsetof(UVLegacyMapMenuQuestCarouselItem, bIsLeftDecorator) == 0x000089, "Member 'UVLegacyMapMenuQuestCarouselItem::bIsLeftDecorator' has a wrong offset!");

// Class Altar.VStatsMenuViewModel
// 0x0168 (0x0238 - 0x00D0)
class UVStatsMenuViewModel final : public UVViewModelBase
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyStatsMenuPlayerInfo             PlayerInfo;                                        // 0x00D8(0x0070)(NativeAccessSpecifierPrivate)
	ELegacyStatsMenuPage                          CurrentPage;                                       // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyStatsMenuPopupContent           PopupContent;                                      // 0x0150(0x0028)(NativeAccessSpecifierPrivate)
	TArray<struct FLegacyStatsMenuMiscItemProperties> MiscItems;                                     // 0x0178(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FLegacyStatsMenuFactionProperties> Factions;                                       // 0x0188(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FLegacyStatsMenuLevelProgression       LevelProgression;                                  // 0x0198(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FLegacyStatsMenuSkillItemUpdatableProperties SkillItemUpdatableProperties;                // 0x01A0(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FLegacyStatsMenuSkillItemProperties> SkillItemProperties;                          // 0x01B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<ELegacyStatsMenuPage2Items, struct FLegacyStatsMenuSecondaryAttribute> SecondaryAttributes; // 0x01C0(0x0050)(NativeAccessSpecifierPrivate)
	struct FLegacyStatsMenuPrimaryAttributeValues Fatigue;                                           // 0x0210(0x000C)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FLegacyStatsMenuPrimaryAttributeValues Magicka;                                           // 0x021C(0x000C)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FLegacyStatsMenuPrimaryAttributeValues Health;                                            // 0x0228(0x000C)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          AreDetailsDisplayed;                               // 0x0234(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendHoverOnItemHandler(ELegacyStatsMenuPage Page, int32 ItemIndex);
	void ResetHoverData();
	void SetAreDetailsDisplayed(bool NewAreDetailsDisplayed);
	void SetCurrentPage(const ELegacyStatsMenuPage& NewCurrentPage);
	void SetFactions(const TArray<struct FLegacyStatsMenuFactionProperties>& NewFactions);
	void SetFatigue(const struct FLegacyStatsMenuPrimaryAttributeValues& NewFatigue);
	void SetHealth(const struct FLegacyStatsMenuPrimaryAttributeValues& NewHealth);
	void SetLevelProgression(const struct FLegacyStatsMenuLevelProgression& NewLevelProgression);
	void SetMagicka(const struct FLegacyStatsMenuPrimaryAttributeValues& NewMagicka);
	void SetMiscItems(const TArray<struct FLegacyStatsMenuMiscItemProperties>& NewMiscItems);
	void SetPlayerInfo(const struct FLegacyStatsMenuPlayerInfo& NewPlayerInfo);
	void SetPopupContent(const struct FLegacyStatsMenuPopupContent& NewPopUpContent);
	void SetSecondaryAttribute(const ELegacyStatsMenuPage2Items Item, const struct FLegacyStatsMenuSecondaryAttribute& NewValue);
	void SetSecondaryAttributes(const TMap<ELegacyStatsMenuPage2Items, struct FLegacyStatsMenuSecondaryAttribute>& NewAttributes);
	void SetSkillItemProperties(const TArray<struct FLegacyStatsMenuSkillItemProperties>& NewSkillItemProperties);
	void SetSkillItemUpdatableProperties(const struct FLegacyStatsMenuSkillItemUpdatableProperties& NewSkillItemUpdatableProperties);
	void UpdateOneSkillItemProperties(const int32 Index_0, const struct FLegacyStatsMenuSkillItemUpdatableProperties& NewSkillItemProperties);

	bool GetAreDetailsDisplayed() const;
	ELegacyStatsMenuPage GetCurrentPage() const;
	const TArray<struct FLegacyStatsMenuFactionProperties> GetFactions() const;
	const struct FLegacyStatsMenuPrimaryAttributeValues GetFatigue() const;
	const struct FLegacyStatsMenuPrimaryAttributeValues GetHealth() const;
	const struct FLegacyStatsMenuLevelProgression GetLevelProgression() const;
	const struct FLegacyStatsMenuPrimaryAttributeValues GetMagicka() const;
	const TArray<struct FLegacyStatsMenuMiscItemProperties> GetMiscItems() const;
	const struct FLegacyStatsMenuPlayerInfo GetPlayerInfo() const;
	const struct FLegacyStatsMenuPopupContent GetPopUpContent() const;
	const TMap<ELegacyStatsMenuPage2Items, struct FLegacyStatsMenuSecondaryAttribute> GetSecondaryAttributes() const;
	const TArray<struct FLegacyStatsMenuSkillItemProperties> GetSkillItemProperties() const;
	const struct FLegacyStatsMenuSkillItemUpdatableProperties GetSkillItemUpdatableProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStatsMenuViewModel">();
	}
	static class UVStatsMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStatsMenuViewModel>();
	}
};
static_assert(alignof(UVStatsMenuViewModel) == 0x000008, "Wrong alignment on UVStatsMenuViewModel");
static_assert(sizeof(UVStatsMenuViewModel) == 0x000238, "Wrong size on UVStatsMenuViewModel");
static_assert(offsetof(UVStatsMenuViewModel, PlayerInfo) == 0x0000D8, "Member 'UVStatsMenuViewModel::PlayerInfo' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, CurrentPage) == 0x000148, "Member 'UVStatsMenuViewModel::CurrentPage' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, PopupContent) == 0x000150, "Member 'UVStatsMenuViewModel::PopupContent' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, MiscItems) == 0x000178, "Member 'UVStatsMenuViewModel::MiscItems' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, Factions) == 0x000188, "Member 'UVStatsMenuViewModel::Factions' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, LevelProgression) == 0x000198, "Member 'UVStatsMenuViewModel::LevelProgression' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, SkillItemUpdatableProperties) == 0x0001A0, "Member 'UVStatsMenuViewModel::SkillItemUpdatableProperties' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, SkillItemProperties) == 0x0001B0, "Member 'UVStatsMenuViewModel::SkillItemProperties' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, SecondaryAttributes) == 0x0001C0, "Member 'UVStatsMenuViewModel::SecondaryAttributes' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, Fatigue) == 0x000210, "Member 'UVStatsMenuViewModel::Fatigue' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, Magicka) == 0x00021C, "Member 'UVStatsMenuViewModel::Magicka' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, Health) == 0x000228, "Member 'UVStatsMenuViewModel::Health' has a wrong offset!");
static_assert(offsetof(UVStatsMenuViewModel, AreDetailsDisplayed) == 0x000234, "Member 'UVStatsMenuViewModel::AreDetailsDisplayed' has a wrong offset!");

// Class Altar.VMapMenuViewModel
// 0x0160 (0x0230 - 0x00D0)
class UVMapMenuViewModel final : public UVViewModelBase
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ELegacyMapMenuPage                            CurrentPage;                                       // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyMapMenuTitleProperties          TitleProperties;                                   // 0x00E0(0x0030)(NativeAccessSpecifierPrivate)
	TArray<struct FLegacyMapMenuQuestProperties>  Quests;                                            // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FLegacyMapMenuQuestProperties>  QuestHistory;                                      // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FLegacyMapMenuQuestProperties          ActiveQuestData;                                   // 0x0130(0x0098)(NativeAccessSpecifierPrivate)
	class UVMapPageViewModel*                     LocalMapMenuViewModel;                             // 0x01C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVMapPageViewModel*                     WorldMapMenuViewModel;                             // 0x01D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FInputText>        IconSelectionMap;                                  // 0x01E0(0x0050)(NativeAccessSpecifierPrivate)

public:
	void DelayFastTravelRequestUntilFadeEnd(EVFadeTransitionType InFadeTransitionType);
	void HideMap();
	void RegisterSendClickedBack();
	void RegisterSendClickedCurrentQuestHistory(int32 Value);
	void RegisterSendClickedDetailedQuest(int32 Value);
	void RegisterSendClickedMap();
	void RegisterSendClickedQuest(int32 Value);
	void RegisterSendClickedQuestCompleted(int32 Value);
	void RegisterSendCurrentPageUpdatedHandler(const ELegacyMapMenuPage NewPage);
	void SetActiveQuestData(const struct FLegacyMapMenuQuestProperties& NewActiveQuestData);
	void SetCurrentPage(const ELegacyMapMenuPage NewPage);
	void SetQuestHistory(const TArray<struct FLegacyMapMenuQuestProperties>& NewQuestHistory);
	void SetQuests(const TArray<struct FLegacyMapMenuQuestProperties>& NewQuests);
	void SetTitleProperties(const struct FLegacyMapMenuTitleProperties& NewTitleProperties);

	const struct FLegacyMapMenuQuestProperties GetActiveQuestData() const;
	ELegacyMapMenuPage GetCurrentPage() const;
	class UVMapPageViewModel* GetLocalMapMenuViewModel() const;
	const TArray<struct FLegacyMapMenuQuestProperties> GetQuestHistory() const;
	const TArray<struct FLegacyMapMenuQuestProperties> GetQuests() const;
	const struct FLegacyMapMenuTitleProperties GetTitleProperties() const;
	class UVMapPageViewModel* GetWorldMapMenuViewModel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMapMenuViewModel">();
	}
	static class UVMapMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMapMenuViewModel>();
	}
};
static_assert(alignof(UVMapMenuViewModel) == 0x000008, "Wrong alignment on UVMapMenuViewModel");
static_assert(sizeof(UVMapMenuViewModel) == 0x000230, "Wrong size on UVMapMenuViewModel");
static_assert(offsetof(UVMapMenuViewModel, CurrentPage) == 0x0000D8, "Member 'UVMapMenuViewModel::CurrentPage' has a wrong offset!");
static_assert(offsetof(UVMapMenuViewModel, TitleProperties) == 0x0000E0, "Member 'UVMapMenuViewModel::TitleProperties' has a wrong offset!");
static_assert(offsetof(UVMapMenuViewModel, Quests) == 0x000110, "Member 'UVMapMenuViewModel::Quests' has a wrong offset!");
static_assert(offsetof(UVMapMenuViewModel, QuestHistory) == 0x000120, "Member 'UVMapMenuViewModel::QuestHistory' has a wrong offset!");
static_assert(offsetof(UVMapMenuViewModel, ActiveQuestData) == 0x000130, "Member 'UVMapMenuViewModel::ActiveQuestData' has a wrong offset!");
static_assert(offsetof(UVMapMenuViewModel, LocalMapMenuViewModel) == 0x0001C8, "Member 'UVMapMenuViewModel::LocalMapMenuViewModel' has a wrong offset!");
static_assert(offsetof(UVMapMenuViewModel, WorldMapMenuViewModel) == 0x0001D0, "Member 'UVMapMenuViewModel::WorldMapMenuViewModel' has a wrong offset!");
static_assert(offsetof(UVMapMenuViewModel, IconSelectionMap) == 0x0001E0, "Member 'UVMapMenuViewModel::IconSelectionMap' has a wrong offset!");

// Class Altar.VMapPageViewModel
// 0x0098 (0x0168 - 0x00D0)
class UVMapPageViewModel final : public UVViewModelBase
{
public:
	TArray<float>                                 FogDatas;                                          // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLegacyMapMenuWorldMapProperties       WorldMapProperties;                                // 0x00E0(0x0020)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FLegacyMapMenuLocalMapProperties       LocalMapProperties;                                // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FLegacyMapMenuIconProperties>   MapIcons;                                          // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FVector2D                              MapPosition;                                       // 0x0138(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              PlayerMarkerPosition;                              // 0x0148(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Zoom;                                              // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinZoomValue;                                      // 0x015C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxZoomValue;                                      // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasTriedFastTravel;                               // 0x0164(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLockingUpdatesDuringDelayedFastTravel;            // 0x0165(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_166[0x2];                                      // 0x0166(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CenterMapOnPlayer();
	void ForceSetMapPosition(const struct FVector2D& NewMapPosition);
	void RegisterSendCreatePlayerMarkerHandler(bool IsWorldMap, const struct FVector2D& MarkerPos, const struct FVector2D& OblivionWorldMarkerPos);
	void RegisterSendShowSleepWaitMenu();
	void RegisterSendWorldMapIconClickedHandlerAddress(const class FString& Address);
	void RegisterSendWorldMapIconClickedHandlerName(const class FName& Key);
	void SetHasTriedFastTravel(bool bNewValue);
	void SetLocalMapProperties(const struct FLegacyMapMenuLocalMapProperties& NewMapProperties);
	void SetLockingUpdatesDuringDelayedFastTravel(bool InLockMapUpdates);
	void SetMapIcons(const TArray<struct FLegacyMapMenuIconProperties>& NewIcons);
	void SetMapPosition(const struct FVector2D& NewMapPosition);
	void SetMaxZoomValue(float NewMaxZoomValue);
	void SetMinZoomValue(float NewMinZoomValue);
	void SetPlayerMarkerPosition(const struct FVector2D& NewMapPosition);
	void SetRenderTargetTextureFog(class UTextureRenderTarget2D* RenderTarget);
	void SetWorldMapProperties(const struct FLegacyMapMenuWorldMapProperties& NewMapProperties);
	void SetZoom(float NewZoom);

	bool GetHasTriedFastTravel() const;
	const struct FLegacyMapMenuLocalMapProperties GetLocalMapProperties() const;
	bool GetLockingUpdatesDuringDelayedFastTravel() const;
	const TArray<struct FLegacyMapMenuIconProperties> GetMapIcons() const;
	const struct FVector2D GetMapPosition() const;
	float GetMaxZoomValue() const;
	float GetMinZoomValue() const;
	const struct FVector2D GetPlayerMarkerPosition() const;
	const struct FLegacyMapMenuWorldMapProperties GetWorldMapProperties() const;
	float GetZoom() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMapPageViewModel">();
	}
	static class UVMapPageViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMapPageViewModel>();
	}
};
static_assert(alignof(UVMapPageViewModel) == 0x000008, "Wrong alignment on UVMapPageViewModel");
static_assert(sizeof(UVMapPageViewModel) == 0x000168, "Wrong size on UVMapPageViewModel");
static_assert(offsetof(UVMapPageViewModel, FogDatas) == 0x0000D0, "Member 'UVMapPageViewModel::FogDatas' has a wrong offset!");
static_assert(offsetof(UVMapPageViewModel, WorldMapProperties) == 0x0000E0, "Member 'UVMapPageViewModel::WorldMapProperties' has a wrong offset!");
static_assert(offsetof(UVMapPageViewModel, LocalMapProperties) == 0x000100, "Member 'UVMapPageViewModel::LocalMapProperties' has a wrong offset!");
static_assert(offsetof(UVMapPageViewModel, MapIcons) == 0x000128, "Member 'UVMapPageViewModel::MapIcons' has a wrong offset!");
static_assert(offsetof(UVMapPageViewModel, MapPosition) == 0x000138, "Member 'UVMapPageViewModel::MapPosition' has a wrong offset!");
static_assert(offsetof(UVMapPageViewModel, PlayerMarkerPosition) == 0x000148, "Member 'UVMapPageViewModel::PlayerMarkerPosition' has a wrong offset!");
static_assert(offsetof(UVMapPageViewModel, Zoom) == 0x000158, "Member 'UVMapPageViewModel::Zoom' has a wrong offset!");
static_assert(offsetof(UVMapPageViewModel, MinZoomValue) == 0x00015C, "Member 'UVMapPageViewModel::MinZoomValue' has a wrong offset!");
static_assert(offsetof(UVMapPageViewModel, MaxZoomValue) == 0x000160, "Member 'UVMapPageViewModel::MaxZoomValue' has a wrong offset!");
static_assert(offsetof(UVMapPageViewModel, bHasTriedFastTravel) == 0x000164, "Member 'UVMapPageViewModel::bHasTriedFastTravel' has a wrong offset!");
static_assert(offsetof(UVMapPageViewModel, bLockingUpdatesDuringDelayedFastTravel) == 0x000165, "Member 'UVMapPageViewModel::bLockingUpdatesDuringDelayedFastTravel' has a wrong offset!");

// Class Altar.VMeleeAttackMultiAnimInstance
// 0x0030 (0x0400 - 0x03D0)
class UVMeleeAttackMultiAnimInstance final : public UVLRPrepareAttackAnimInstance
{
public:
	struct FMeleeAttackMultiple                   AnimSet;                                           // 0x03D0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMeleeAttackMultiAnimInstance">();
	}
	static class UVMeleeAttackMultiAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMeleeAttackMultiAnimInstance>();
	}
};
static_assert(alignof(UVMeleeAttackMultiAnimInstance) == 0x000010, "Wrong alignment on UVMeleeAttackMultiAnimInstance");
static_assert(sizeof(UVMeleeAttackMultiAnimInstance) == 0x000400, "Wrong size on UVMeleeAttackMultiAnimInstance");
static_assert(offsetof(UVMeleeAttackMultiAnimInstance, AnimSet) == 0x0003D0, "Member 'UVMeleeAttackMultiAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VMeleeMultiPowerMultiAnimInstance
// 0x0070 (0x0440 - 0x03D0)
class UVMeleeMultiPowerMultiAnimInstance final : public UVLRPrepareAttackAnimInstance
{
public:
	struct FMeleeAttackMultiplePowerMultiple      AnimSet;                                           // 0x03D0(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMeleeMultiPowerMultiAnimInstance">();
	}
	static class UVMeleeMultiPowerMultiAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMeleeMultiPowerMultiAnimInstance>();
	}
};
static_assert(alignof(UVMeleeMultiPowerMultiAnimInstance) == 0x000010, "Wrong alignment on UVMeleeMultiPowerMultiAnimInstance");
static_assert(sizeof(UVMeleeMultiPowerMultiAnimInstance) == 0x000440, "Wrong size on UVMeleeMultiPowerMultiAnimInstance");
static_assert(offsetof(UVMeleeMultiPowerMultiAnimInstance, AnimSet) == 0x0003D0, "Member 'UVMeleeMultiPowerMultiAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VMeleeMultiPowerSingleAnimInstance
// 0x0050 (0x0420 - 0x03D0)
class UVMeleeMultiPowerSingleAnimInstance final : public UVLRPrepareAttackAnimInstance
{
public:
	struct FMeleeAttackMultiplePowerSingle        AnimSet;                                           // 0x03D0(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMeleeMultiPowerSingleAnimInstance">();
	}
	static class UVMeleeMultiPowerSingleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMeleeMultiPowerSingleAnimInstance>();
	}
};
static_assert(alignof(UVMeleeMultiPowerSingleAnimInstance) == 0x000010, "Wrong alignment on UVMeleeMultiPowerSingleAnimInstance");
static_assert(sizeof(UVMeleeMultiPowerSingleAnimInstance) == 0x000420, "Wrong size on UVMeleeMultiPowerSingleAnimInstance");
static_assert(offsetof(UVMeleeMultiPowerSingleAnimInstance, AnimSet) == 0x0003D0, "Member 'UVMeleeMultiPowerSingleAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VMergedSkeletalMeshTask
// 0x0028 (0x0050 - 0x0028)
class UVMergedSkeletalMeshTask final : public UObject
{
public:
	TArray<class USkeletalMesh*>                  SkeletalMeshes;                                    // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkelMeshMergeSectionMapping>   SectionMappings;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMergedSkeletalMeshTask">();
	}
	static class UVMergedSkeletalMeshTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMergedSkeletalMeshTask>();
	}
};
static_assert(alignof(UVMergedSkeletalMeshTask) == 0x000008, "Wrong alignment on UVMergedSkeletalMeshTask");
static_assert(sizeof(UVMergedSkeletalMeshTask) == 0x000050, "Wrong size on UVMergedSkeletalMeshTask");
static_assert(offsetof(UVMergedSkeletalMeshTask, SkeletalMeshes) == 0x000028, "Member 'UVMergedSkeletalMeshTask::SkeletalMeshes' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshTask, SectionMappings) == 0x000038, "Member 'UVMergedSkeletalMeshTask::SectionMappings' has a wrong offset!");

// Class Altar.VMergedSkeletalMeshCache
// 0x0068 (0x0090 - 0x0028)
class UVMergedSkeletalMeshCache final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          MergedMesh;                                        // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVMergedSkeletalMeshTask*               Task;                                              // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UVMergedSkeletalMeshBuffer*>       WaitingBuffers;                                    // 0x0040(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMergedSkeletalMeshCache">();
	}
	static class UVMergedSkeletalMeshCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMergedSkeletalMeshCache>();
	}
};
static_assert(alignof(UVMergedSkeletalMeshCache) == 0x000008, "Wrong alignment on UVMergedSkeletalMeshCache");
static_assert(sizeof(UVMergedSkeletalMeshCache) == 0x000090, "Wrong size on UVMergedSkeletalMeshCache");
static_assert(offsetof(UVMergedSkeletalMeshCache, MergedMesh) == 0x000030, "Member 'UVMergedSkeletalMeshCache::MergedMesh' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshCache, Task) == 0x000038, "Member 'UVMergedSkeletalMeshCache::Task' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshCache, WaitingBuffers) == 0x000040, "Member 'UVMergedSkeletalMeshCache::WaitingBuffers' has a wrong offset!");

// Class Altar.VMergedSkeletalMeshQuery
// 0x0018 (0x0040 - 0x0028)
class UVMergedSkeletalMeshQuery final : public UObject
{
public:
	class UVMergedSkeletalMeshComponent*          Component;                                         // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MasterPoseComponent;                               // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVMergedSkeletalMeshCache*              Cache;                                             // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMergedSkeletalMeshQuery">();
	}
	static class UVMergedSkeletalMeshQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMergedSkeletalMeshQuery>();
	}
};
static_assert(alignof(UVMergedSkeletalMeshQuery) == 0x000008, "Wrong alignment on UVMergedSkeletalMeshQuery");
static_assert(sizeof(UVMergedSkeletalMeshQuery) == 0x000040, "Wrong size on UVMergedSkeletalMeshQuery");
static_assert(offsetof(UVMergedSkeletalMeshQuery, Component) == 0x000028, "Member 'UVMergedSkeletalMeshQuery::Component' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshQuery, MasterPoseComponent) == 0x000030, "Member 'UVMergedSkeletalMeshQuery::MasterPoseComponent' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshQuery, Cache) == 0x000038, "Member 'UVMergedSkeletalMeshQuery::Cache' has a wrong offset!");

// Class Altar.VMergedSkeletalMeshSubsystem
// 0x0118 (0x0148 - 0x0030)
class UVMergedSkeletalMeshSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<class UVMergedSkeletalMeshComponent*, class UVMergedSkeletalMeshBuffer*> ComponentToBuffer; // 0x0030(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, TWeakObjectPtr<class UVMergedSkeletalMeshCache>> CacheLookup;                  // 0x0080(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UVMergedSkeletalMeshBuffer*>     BufferQueue;                                       // 0x00D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSet<class UVMergedSkeletalMeshCache*>        CachesWithRunningTask;                             // 0x00E8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class UVMergedSkeletalMeshBuffer*>     DestroyedBuffersQueue;                             // 0x0138(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMergedSkeletalMeshSubsystem">();
	}
	static class UVMergedSkeletalMeshSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMergedSkeletalMeshSubsystem>();
	}
};
static_assert(alignof(UVMergedSkeletalMeshSubsystem) == 0x000008, "Wrong alignment on UVMergedSkeletalMeshSubsystem");
static_assert(sizeof(UVMergedSkeletalMeshSubsystem) == 0x000148, "Wrong size on UVMergedSkeletalMeshSubsystem");
static_assert(offsetof(UVMergedSkeletalMeshSubsystem, ComponentToBuffer) == 0x000030, "Member 'UVMergedSkeletalMeshSubsystem::ComponentToBuffer' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshSubsystem, CacheLookup) == 0x000080, "Member 'UVMergedSkeletalMeshSubsystem::CacheLookup' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshSubsystem, BufferQueue) == 0x0000D8, "Member 'UVMergedSkeletalMeshSubsystem::BufferQueue' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshSubsystem, CachesWithRunningTask) == 0x0000E8, "Member 'UVMergedSkeletalMeshSubsystem::CachesWithRunningTask' has a wrong offset!");
static_assert(offsetof(UVMergedSkeletalMeshSubsystem, DestroyedBuffersQueue) == 0x000138, "Member 'UVMergedSkeletalMeshSubsystem::DestroyedBuffersQueue' has a wrong offset!");

// Class Altar.VMessageMenuViewModel
// 0x0040 (0x0110 - 0x00D0)
class UVMessageMenuViewModel final : public UVViewModelBase
{
public:
	class FText                                   Message;                                           // 0x00D0(0x0018)(NativeAccessSpecifierPrivate)
	TArray<class FText>                           ButtonsText;                                       // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	EModalMenuLayoutType                          MenuType;                                          // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x17];                                      // 0x00F9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendClickedButton(int32 InButtonIndex);
	void SetButtonsText(const TArray<class FText>& NewButtonsText);
	void SetMenuType(EModalMenuLayoutType NewMenuType);
	void SetMessage(const class FText& NewMessage);

	const TArray<class FText> GetButtonsText() const;
	EModalMenuLayoutType GetMenuType() const;
	const class FText GetMessage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMessageMenuViewModel">();
	}
	static class UVMessageMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMessageMenuViewModel>();
	}
};
static_assert(alignof(UVMessageMenuViewModel) == 0x000008, "Wrong alignment on UVMessageMenuViewModel");
static_assert(sizeof(UVMessageMenuViewModel) == 0x000110, "Wrong size on UVMessageMenuViewModel");
static_assert(offsetof(UVMessageMenuViewModel, Message) == 0x0000D0, "Member 'UVMessageMenuViewModel::Message' has a wrong offset!");
static_assert(offsetof(UVMessageMenuViewModel, ButtonsText) == 0x0000E8, "Member 'UVMessageMenuViewModel::ButtonsText' has a wrong offset!");
static_assert(offsetof(UVMessageMenuViewModel, MenuType) == 0x0000F8, "Member 'UVMessageMenuViewModel::MenuType' has a wrong offset!");

// Class Altar.VMetaClusterSeed
// 0x0008 (0x02A0 - 0x0298)
class AVMetaClusterSeed final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMetaClusterSeed">();
	}
	static class AVMetaClusterSeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVMetaClusterSeed>();
	}
};
static_assert(alignof(AVMetaClusterSeed) == 0x000008, "Wrong alignment on AVMetaClusterSeed");
static_assert(sizeof(AVMetaClusterSeed) == 0x0002A0, "Wrong size on AVMetaClusterSeed");
static_assert(offsetof(AVMetaClusterSeed, Root) == 0x000298, "Member 'AVMetaClusterSeed::Root' has a wrong offset!");

// Class Altar.VModdableBlueprint
// 0x0000 (0x00A8 - 0x00A8)
class UVModdableBlueprint final : public UBlueprint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModdableBlueprint">();
	}
	static class UVModdableBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModdableBlueprint>();
	}
};
static_assert(alignof(UVModdableBlueprint) == 0x000008, "Wrong alignment on UVModdableBlueprint");
static_assert(sizeof(UVModdableBlueprint) == 0x0000A8, "Wrong size on UVModdableBlueprint");

// Class Altar.VModdableBlueprintInterface
// 0x0000 (0x0000 - 0x0000)
class IVModdableBlueprintInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModdableBlueprintInterface">();
	}
	static class IVModdableBlueprintInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVModdableBlueprintInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IVModdableBlueprintInterface) == 0x000001, "Wrong alignment on IVModdableBlueprintInterface");
static_assert(sizeof(IVModdableBlueprintInterface) == 0x000001, "Wrong size on IVModdableBlueprintInterface");

// Class Altar.VModernAltarMagicFilterIconTable
// 0x0050 (0x0100 - 0x00B0)
class UVModernAltarMagicFilterIconTable final : public UDataTable
{
public:
	TMap<ELegacyMagicMenuSortType, struct FModernMagicFilterTableRow> MagicFilterIconDesign;         // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernAltarMagicFilterIconTable">();
	}
	static class UVModernAltarMagicFilterIconTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernAltarMagicFilterIconTable>();
	}
};
static_assert(alignof(UVModernAltarMagicFilterIconTable) == 0x000008, "Wrong alignment on UVModernAltarMagicFilterIconTable");
static_assert(sizeof(UVModernAltarMagicFilterIconTable) == 0x000100, "Wrong size on UVModernAltarMagicFilterIconTable");
static_assert(offsetof(UVModernAltarMagicFilterIconTable, MagicFilterIconDesign) == 0x0000B0, "Member 'UVModernAltarMagicFilterIconTable::MagicFilterIconDesign' has a wrong offset!");

// Class Altar.VModernCreditsMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVModernCreditsMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernCreditsMenu">();
	}
	static class UVModernCreditsMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernCreditsMenu>();
	}
};
static_assert(alignof(UVModernCreditsMenu) == 0x000008, "Wrong alignment on UVModernCreditsMenu");
static_assert(sizeof(UVModernCreditsMenu) == 0x0004E8, "Wrong size on UVModernCreditsMenu");

// Class Altar.VModernGamepadRebindWidget
// 0x0010 (0x0628 - 0x0618)
class UVModernGamepadRebindWidget : public UVModernRebindSettingWidget
{
public:
	class UVAltarNavigableInputKeySelector*       GamepadKeySelector;                                // 0x0618(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x8];                                      // 0x0620(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGamepadKeySelectorKeyChanged();
	void OnGamepadKeySelectorKeySelected(const struct FInputChord& NewInputChord);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernGamepadRebindWidget">();
	}
	static class UVModernGamepadRebindWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernGamepadRebindWidget>();
	}
};
static_assert(alignof(UVModernGamepadRebindWidget) == 0x000008, "Wrong alignment on UVModernGamepadRebindWidget");
static_assert(sizeof(UVModernGamepadRebindWidget) == 0x000628, "Wrong size on UVModernGamepadRebindWidget");
static_assert(offsetof(UVModernGamepadRebindWidget, GamepadKeySelector) == 0x000618, "Member 'UVModernGamepadRebindWidget::GamepadKeySelector' has a wrong offset!");

// Class Altar.VModernHelpMenu
// 0x0020 (0x0510 - 0x04F0)
class UVModernHelpMenu : public UVLegacyPlayerSubMenuBase
{
public:
	TArray<class UHelpMenuListEntryData*>         CategoriesData;                                    // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UHelpMenuDetailEntryData*               CurrentData;                                       // 0x0500(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DataEntryLength;                                   // 0x0508(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50C[0x4];                                      // 0x050C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateListData(const TMap<class FString, struct FHelpEntryCategoryData>& DataPerCategory);
	void OnDataSelectionToggled();
	void OnListEntriesUpdated(const TArray<class UHelpMenuListEntryData*>& InListData);
	void OnNavigateEntry(class UHelpMenuListEntryData* Entry);
	void ProcessTutorials(const class UDataTable* Tutorials);
	bool ShowLess();
	void ToggleCategory(class UHelpMenuListEntryData* Entry);
	void ToggleData(class UHelpMenuListEntryData* Entry, class UDataTable* Tutorials);
	void UpdateListData();

	int32 GetCurrentDataAdjustedIndex() const;
	class FText GetDetailIndexText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernHelpMenu">();
	}
	static class UVModernHelpMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernHelpMenu>();
	}
};
static_assert(alignof(UVModernHelpMenu) == 0x000008, "Wrong alignment on UVModernHelpMenu");
static_assert(sizeof(UVModernHelpMenu) == 0x000510, "Wrong size on UVModernHelpMenu");
static_assert(offsetof(UVModernHelpMenu, CategoriesData) == 0x0004F0, "Member 'UVModernHelpMenu::CategoriesData' has a wrong offset!");
static_assert(offsetof(UVModernHelpMenu, CurrentData) == 0x000500, "Member 'UVModernHelpMenu::CurrentData' has a wrong offset!");
static_assert(offsetof(UVModernHelpMenu, DataEntryLength) == 0x000508, "Member 'UVModernHelpMenu::DataEntryLength' has a wrong offset!");

// Class Altar.VModernHelpMenuListEntry
// 0x0010 (0x02E0 - 0x02D0)
class UVModernHelpMenuListEntry : public UNavigationListviewEntry
{
public:
	bool                                          bIsExpanded;                                       // 0x02D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHelpMenuListEntryData*                 EntryData;                                         // 0x02D8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnExpanded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernHelpMenuListEntry">();
	}
	static class UVModernHelpMenuListEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernHelpMenuListEntry>();
	}
};
static_assert(alignof(UVModernHelpMenuListEntry) == 0x000008, "Wrong alignment on UVModernHelpMenuListEntry");
static_assert(sizeof(UVModernHelpMenuListEntry) == 0x0002E0, "Wrong size on UVModernHelpMenuListEntry");
static_assert(offsetof(UVModernHelpMenuListEntry, bIsExpanded) == 0x0002D0, "Member 'UVModernHelpMenuListEntry::bIsExpanded' has a wrong offset!");
static_assert(offsetof(UVModernHelpMenuListEntry, EntryData) == 0x0002D8, "Member 'UVModernHelpMenuListEntry::EntryData' has a wrong offset!");

// Class Altar.VModernHudMain
// 0x0000 (0x04E8 - 0x04E8)
class UVModernHudMain : public UVAltarMenu
{
public:
	void OnForcePlayerMenuPageUpdated(int32 Index_0);
	void OnHUDVisibilityChanged(EHUDVisibility Flag, bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernHudMain">();
	}
	static class UVModernHudMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernHudMain>();
	}
};
static_assert(alignof(UVModernHudMain) == 0x000008, "Wrong alignment on UVModernHudMain");
static_assert(sizeof(UVModernHudMain) == 0x0004E8, "Wrong size on UVModernHudMain");

// Class Altar.VModernHudPrimaryLayout
// 0x0000 (0x04E8 - 0x04E8)
class UVModernHudPrimaryLayout : public UVAltarMenu
{
public:
	void OnHUDGlobalVisibilityChanged(bool bVisible);
	void OnHUDVisibilityChanged(EHUDVisibility Flag, bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernHudPrimaryLayout">();
	}
	static class UVModernHudPrimaryLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernHudPrimaryLayout>();
	}
};
static_assert(alignof(UVModernHudPrimaryLayout) == 0x000008, "Wrong alignment on UVModernHudPrimaryLayout");
static_assert(sizeof(UVModernHudPrimaryLayout) == 0x0004E8, "Wrong size on UVModernHudPrimaryLayout");

// Class Altar.VModernHudReticle
// 0x00F0 (0x05B8 - 0x04C8)
class UVModernHudReticle : public UVAltarWidget
{
public:
	TSet<struct FGameplayTag>                     DefaultReticleTags;                                // 0x04C8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<struct FGameplayTag>                     RangeReticleTags;                                  // 0x0518(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<struct FGameplayTag>                     MeleeReticleTags;                                  // 0x0568(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	bool CheckForBehaviorTypeUpdate(const struct FGameplayTag& WeaponTag, class UVHUDReticleViewModel* ViewModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernHudReticle">();
	}
	static class UVModernHudReticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernHudReticle>();
	}
};
static_assert(alignof(UVModernHudReticle) == 0x000008, "Wrong alignment on UVModernHudReticle");
static_assert(sizeof(UVModernHudReticle) == 0x0005B8, "Wrong size on UVModernHudReticle");
static_assert(offsetof(UVModernHudReticle, DefaultReticleTags) == 0x0004C8, "Member 'UVModernHudReticle::DefaultReticleTags' has a wrong offset!");
static_assert(offsetof(UVModernHudReticle, RangeReticleTags) == 0x000518, "Member 'UVModernHudReticle::RangeReticleTags' has a wrong offset!");
static_assert(offsetof(UVModernHudReticle, MeleeReticleTags) == 0x000568, "Member 'UVModernHudReticle::MeleeReticleTags' has a wrong offset!");

// Class Altar.VModernIconSelectionTable
// 0x0000 (0x00B0 - 0x00B0)
class UVModernIconSelectionTable final : public UDataTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernIconSelectionTable">();
	}
	static class UVModernIconSelectionTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernIconSelectionTable>();
	}
};
static_assert(alignof(UVModernIconSelectionTable) == 0x000008, "Wrong alignment on UVModernIconSelectionTable");
static_assert(sizeof(UVModernIconSelectionTable) == 0x0000B0, "Wrong size on UVModernIconSelectionTable");

// Class Altar.VModernKeyboardRebindWidget
// 0x0018 (0x0630 - 0x0618)
class UVModernKeyboardRebindWidget : public UVModernRebindSettingWidget
{
public:
	class UVAltarNavigableInputKeySelector*       PrimaryKeyboardKeySelector;                        // 0x0618(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVAltarNavigableInputKeySelector*       SecondaryKeyboardKeySelector;                      // 0x0620(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_628[0x8];                                      // 0x0628(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPrimaryKeyboardKeySelectorKeyChanged();
	void OnPrimaryKeyboardKeySelectorKeySelected(const struct FInputChord& NewInputChord);
	void OnSecondaryKeyboardKeySelectorKeyChanged();
	void OnSecondaryKeyboardKeySelectorKeySelected(const struct FInputChord& NewInputChord);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernKeyboardRebindWidget">();
	}
	static class UVModernKeyboardRebindWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernKeyboardRebindWidget>();
	}
};
static_assert(alignof(UVModernKeyboardRebindWidget) == 0x000008, "Wrong alignment on UVModernKeyboardRebindWidget");
static_assert(sizeof(UVModernKeyboardRebindWidget) == 0x000630, "Wrong size on UVModernKeyboardRebindWidget");
static_assert(offsetof(UVModernKeyboardRebindWidget, PrimaryKeyboardKeySelector) == 0x000618, "Member 'UVModernKeyboardRebindWidget::PrimaryKeyboardKeySelector' has a wrong offset!");
static_assert(offsetof(UVModernKeyboardRebindWidget, SecondaryKeyboardKeySelector) == 0x000620, "Member 'UVModernKeyboardRebindWidget::SecondaryKeyboardKeySelector' has a wrong offset!");

// Class Altar.VStaggerStandCharacterAnimInstance
// 0x0010 (0x03C0 - 0x03B0)
class UVStaggerStandCharacterAnimInstance : public UVStaggerCharacterAnimInstance
{
public:
	struct FVStagger                              AnimSet;                                           // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStaggerStandCharacterAnimInstance">();
	}
	static class UVStaggerStandCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStaggerStandCharacterAnimInstance>();
	}
};
static_assert(alignof(UVStaggerStandCharacterAnimInstance) == 0x000010, "Wrong alignment on UVStaggerStandCharacterAnimInstance");
static_assert(sizeof(UVStaggerStandCharacterAnimInstance) == 0x0003C0, "Wrong size on UVStaggerStandCharacterAnimInstance");
static_assert(offsetof(UVStaggerStandCharacterAnimInstance, AnimSet) == 0x0003B0, "Member 'UVStaggerStandCharacterAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VModernListView
// 0x0020 (0x1010 - 0x0FF0)
class UVModernListView final : public UCommonListView
{
public:
	TMulticastInlineDelegate<void(float MinScrollbarValue, float MaxScrollbarValue, float CurrentScrollbarValue, float ThumbFractionSize)> OnListViewScrollbarChanged; // 0x0FE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF8[0x18];                                     // 0x0FF8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnListViewScrollbarChangedInternal(float MinScrollbarValue, float MaxScrollbarValue, float CurrentScrollbarValue, float ThumbFractionSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernListView">();
	}
	static class UVModernListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernListView>();
	}
};
static_assert(alignof(UVModernListView) == 0x000010, "Wrong alignment on UVModernListView");
static_assert(sizeof(UVModernListView) == 0x001010, "Wrong size on UVModernListView");
static_assert(offsetof(UVModernListView, OnListViewScrollbarChanged) == 0x000FE8, "Member 'UVModernListView::OnListViewScrollbarChanged' has a wrong offset!");

// Class Altar.VModernLockpickingMenuTumbler
// 0x0020 (0x0308 - 0x02E8)
class UVModernLockpickingMenuTumbler final : public UCommonUserWidget
{
public:
	struct FModernLockpickMenuTumblerProperties   Properties;                                        // 0x02E8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          IsSolved;                                          // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsTumbling;                                        // 0x02F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FA[0xE];                                      // 0x02FA(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AttemptSolve();
	void ForceTumblerDown();
	float GetNextAnimationTime(const float DeltaTime);
	void PlayInitialMovementEffects();
	void PlayIsSolvedEffects();
	void PlayOnFallEffects();
	void SetInitialMovement(const struct FModernLockpickMenuTumblerProperties& Value);
	void SetIsSolved(const bool Value);
	void SetIsTumbling(const bool Value);
	void UpdateAnimation(const float DeltaTime);

	const struct FModernLockpickMenuTumblerProperties GetInitialMovement() const;
	bool GetIsSolved() const;
	bool GetIsTumbling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernLockpickingMenuTumbler">();
	}
	static class UVModernLockpickingMenuTumbler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernLockpickingMenuTumbler>();
	}
};
static_assert(alignof(UVModernLockpickingMenuTumbler) == 0x000008, "Wrong alignment on UVModernLockpickingMenuTumbler");
static_assert(sizeof(UVModernLockpickingMenuTumbler) == 0x000308, "Wrong size on UVModernLockpickingMenuTumbler");
static_assert(offsetof(UVModernLockpickingMenuTumbler, Properties) == 0x0002E8, "Member 'UVModernLockpickingMenuTumbler::Properties' has a wrong offset!");
static_assert(offsetof(UVModernLockpickingMenuTumbler, IsSolved) == 0x0002F8, "Member 'UVModernLockpickingMenuTumbler::IsSolved' has a wrong offset!");
static_assert(offsetof(UVModernLockpickingMenuTumbler, IsTumbling) == 0x0002F9, "Member 'UVModernLockpickingMenuTumbler::IsTumbling' has a wrong offset!");

// Class Altar.VModernLockpickMenu
// 0x0010 (0x04F8 - 0x04E8)
class UVModernLockpickMenu final : public UVAltarMenu
{
public:
	class UCurveTable*                            DifficultyCurveTable;                              // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetTumblersToReset(int32 SecuritySkillLevel);
	void InitialiseTumblerMovement(int32 TumblerIndex, const struct FLegacyLockpickMenuTumblerDefaultProperties& TumblerDefaultProperties, const struct FLegacyLockpickMenuProperties& MenuProperties);
	void OnTumberMovementInitialised(int32 TumblerIndex, const struct FModernLockpickMenuTumblerProperties& TumbleProperties);
	void SetDifficultyCurve(ELegacyLockpickMenuDifficulty Difficulty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernLockpickMenu">();
	}
	static class UVModernLockpickMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernLockpickMenu>();
	}
};
static_assert(alignof(UVModernLockpickMenu) == 0x000008, "Wrong alignment on UVModernLockpickMenu");
static_assert(sizeof(UVModernLockpickMenu) == 0x0004F8, "Wrong size on UVModernLockpickMenu");
static_assert(offsetof(UVModernLockpickMenu, DifficultyCurveTable) == 0x0004E8, "Member 'UVModernLockpickMenu::DifficultyCurveTable' has a wrong offset!");

// Class Altar.VModernLockpickMenuPick
// 0x0038 (0x0500 - 0x04C8)
class UVModernLockpickMenuPick final : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(int32 TumblerIndex)> OnTumble;                                     // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 TumblerIndex)> OnSolve;                                      // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	int32                                         ActiveTumbler;                                     // 0x04E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviousTumbler;                                   // 0x04EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBroken;                                         // 0x04F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMovementDisabled;                               // 0x04F1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EModernLockpickMenuHandleType                 HandleType;                                        // 0x04F2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F3[0x1];                                      // 0x04F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeadZone;                                          // 0x04F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasCycled;                                        // 0x04F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F9[0x7];                                      // 0x04F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EModernLockpickMenuPickMovement GetMovementActionFromMouseMovement(const struct FPointerEvent& Input);
	void MovePick(const EModernLockpickMenuPickMovement Action);
	void NextActiveTumbler();
	void OnActiveTumblerUpdated(const int32 Value);
	void OnHandleTypeUpdated(const EModernLockpickMenuHandleType Value);
	void OnIsBrokenUpdated(const bool Value);
	void OnTumbleAction();
	void PreviousActiveTumbler();
	void SetActiveTumbler(const int32 Value);
	void SetCycledMousePosition(const struct FPointerEvent& Input);
	void TumblerUp();

	bool CanPickMove() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernLockpickMenuPick">();
	}
	static class UVModernLockpickMenuPick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernLockpickMenuPick>();
	}
};
static_assert(alignof(UVModernLockpickMenuPick) == 0x000008, "Wrong alignment on UVModernLockpickMenuPick");
static_assert(sizeof(UVModernLockpickMenuPick) == 0x000500, "Wrong size on UVModernLockpickMenuPick");
static_assert(offsetof(UVModernLockpickMenuPick, OnTumble) == 0x0004C8, "Member 'UVModernLockpickMenuPick::OnTumble' has a wrong offset!");
static_assert(offsetof(UVModernLockpickMenuPick, OnSolve) == 0x0004D8, "Member 'UVModernLockpickMenuPick::OnSolve' has a wrong offset!");
static_assert(offsetof(UVModernLockpickMenuPick, ActiveTumbler) == 0x0004E8, "Member 'UVModernLockpickMenuPick::ActiveTumbler' has a wrong offset!");
static_assert(offsetof(UVModernLockpickMenuPick, PreviousTumbler) == 0x0004EC, "Member 'UVModernLockpickMenuPick::PreviousTumbler' has a wrong offset!");
static_assert(offsetof(UVModernLockpickMenuPick, bIsBroken) == 0x0004F0, "Member 'UVModernLockpickMenuPick::bIsBroken' has a wrong offset!");
static_assert(offsetof(UVModernLockpickMenuPick, bIsMovementDisabled) == 0x0004F1, "Member 'UVModernLockpickMenuPick::bIsMovementDisabled' has a wrong offset!");
static_assert(offsetof(UVModernLockpickMenuPick, HandleType) == 0x0004F2, "Member 'UVModernLockpickMenuPick::HandleType' has a wrong offset!");
static_assert(offsetof(UVModernLockpickMenuPick, DeadZone) == 0x0004F4, "Member 'UVModernLockpickMenuPick::DeadZone' has a wrong offset!");
static_assert(offsetof(UVModernLockpickMenuPick, bHasCycled) == 0x0004F8, "Member 'UVModernLockpickMenuPick::bHasCycled' has a wrong offset!");

// Class Altar.VModernMagicFilter
// 0x00A0 (0x0568 - 0x04C8)
class UVModernMagicFilter : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(ELegacyMagicMenuSortType SortType)> OnSortTypeUpdated;             // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsReversed)> OnSortIsReversedUpdated;                        // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UVNavigableScrollBox*                   FilterIconBox;                                     // 0x04E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCommonUserWidget>          FilterIconClass;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVModernAltarMagicFilterIconTable*      IconDesignTable;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                FilterPadding;                                     // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x58];                                     // 0x0510(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateFilter(class UCommonUserWidget* Activator);
	void OnFilterIconCreated(class UCommonUserWidget* NewFilter, const struct FModernMagicFilterTableRow& FilterDesign);
	void RequestUpdateFilterWidget(class UCommonUserWidget* Filter, bool bIsDisplayed, bool bIsEnable);
	void SetActiveFilter(const ELegacyMagicMenuSortType ActiveFilterEnum);
	void SetEnabledFilters(const TArray<ELegacyMagicMenuSortType>& EnabledFilterEnums);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernMagicFilter">();
	}
	static class UVModernMagicFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernMagicFilter>();
	}
};
static_assert(alignof(UVModernMagicFilter) == 0x000008, "Wrong alignment on UVModernMagicFilter");
static_assert(sizeof(UVModernMagicFilter) == 0x000568, "Wrong size on UVModernMagicFilter");
static_assert(offsetof(UVModernMagicFilter, OnSortTypeUpdated) == 0x0004C8, "Member 'UVModernMagicFilter::OnSortTypeUpdated' has a wrong offset!");
static_assert(offsetof(UVModernMagicFilter, OnSortIsReversedUpdated) == 0x0004D8, "Member 'UVModernMagicFilter::OnSortIsReversedUpdated' has a wrong offset!");
static_assert(offsetof(UVModernMagicFilter, FilterIconBox) == 0x0004E8, "Member 'UVModernMagicFilter::FilterIconBox' has a wrong offset!");
static_assert(offsetof(UVModernMagicFilter, FilterIconClass) == 0x0004F0, "Member 'UVModernMagicFilter::FilterIconClass' has a wrong offset!");
static_assert(offsetof(UVModernMagicFilter, IconDesignTable) == 0x0004F8, "Member 'UVModernMagicFilter::IconDesignTable' has a wrong offset!");
static_assert(offsetof(UVModernMagicFilter, FilterPadding) == 0x000500, "Member 'UVModernMagicFilter::FilterPadding' has a wrong offset!");

// Class Altar.VModernOnboardingEULATable
// 0x0010 (0x00C0 - 0x00B0)
class UVModernOnboardingEULATable final : public UDataTable
{
public:
	TArray<struct FOnboardingEULATableRow>        EULAData;                                          // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernOnboardingEULATable">();
	}
	static class UVModernOnboardingEULATable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernOnboardingEULATable>();
	}
};
static_assert(alignof(UVModernOnboardingEULATable) == 0x000008, "Wrong alignment on UVModernOnboardingEULATable");
static_assert(sizeof(UVModernOnboardingEULATable) == 0x0000C0, "Wrong size on UVModernOnboardingEULATable");
static_assert(offsetof(UVModernOnboardingEULATable, EULAData) == 0x0000B0, "Member 'UVModernOnboardingEULATable::EULAData' has a wrong offset!");

// Class Altar.VModernOnboardingFlowTable
// 0x0010 (0x00C0 - 0x00B0)
class UVModernOnboardingFlowTable final : public UDataTable
{
public:
	TArray<struct FOnboardingFlowTableRow>        Flow;                                              // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernOnboardingFlowTable">();
	}
	static class UVModernOnboardingFlowTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernOnboardingFlowTable>();
	}
};
static_assert(alignof(UVModernOnboardingFlowTable) == 0x000008, "Wrong alignment on UVModernOnboardingFlowTable");
static_assert(sizeof(UVModernOnboardingFlowTable) == 0x0000C0, "Wrong size on UVModernOnboardingFlowTable");
static_assert(offsetof(UVModernOnboardingFlowTable, Flow) == 0x0000B0, "Member 'UVModernOnboardingFlowTable::Flow' has a wrong offset!");

// Class Altar.VModernOnboardingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVModernOnboardingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AcceptEULA();
	static bool IsEULAAccepted();
	static bool IsOnboardingSettingsDone();
	static bool IsOnPC();
	static void ValidateOnboardingBrighnessSettings();
	static void ValidateOnboardingGameplaySettings();
	static void ValidateOnboardingSoundSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernOnboardingFunctionLibrary">();
	}
	static class UVModernOnboardingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernOnboardingFunctionLibrary>();
	}
};
static_assert(alignof(UVModernOnboardingFunctionLibrary) == 0x000008, "Wrong alignment on UVModernOnboardingFunctionLibrary");
static_assert(sizeof(UVModernOnboardingFunctionLibrary) == 0x000028, "Wrong size on UVModernOnboardingFunctionLibrary");

// Class Altar.VModernOnboardingPage
// 0x0030 (0x04F8 - 0x04C8)
class UVModernOnboardingPage : public UVAltarWidget
{
public:
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(TScriptInterface<class IVOnboardingPageInterface> Caller)> OnEnterAnimationDelegate; // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(TScriptInterface<class IVOnboardingPageInterface> Caller)> OnExitAnimationDelegate; // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UVModernOnboardingMenu*                 OwningStateMachine;                                // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CallEnterAnimationDelegate();
	void CallExitAnimationDelegate();

	bool IsOnPC() const;
	bool IsOnPlaystation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernOnboardingPage">();
	}
	static class UVModernOnboardingPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernOnboardingPage>();
	}
};
static_assert(alignof(UVModernOnboardingPage) == 0x000008, "Wrong alignment on UVModernOnboardingPage");
static_assert(sizeof(UVModernOnboardingPage) == 0x0004F8, "Wrong size on UVModernOnboardingPage");
static_assert(offsetof(UVModernOnboardingPage, OnEnterAnimationDelegate) == 0x0004D0, "Member 'UVModernOnboardingPage::OnEnterAnimationDelegate' has a wrong offset!");
static_assert(offsetof(UVModernOnboardingPage, OnExitAnimationDelegate) == 0x0004E0, "Member 'UVModernOnboardingPage::OnExitAnimationDelegate' has a wrong offset!");
static_assert(offsetof(UVModernOnboardingPage, OwningStateMachine) == 0x0004F0, "Member 'UVModernOnboardingPage::OwningStateMachine' has a wrong offset!");

// Class Altar.VResurrectionAnimInstance
// 0x01C0 (0x0560 - 0x03A0)
class UVResurrectionAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	uint8                                         Pad_3A0[0x10];                                     // 0x03A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsHandleComponent*                PhysicsHandleComponent;                            // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BoneName;                                          // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x188];                                    // 0x03C8(0x0188)(Fixing Size After Last Property [ Dumper-7 ])
	struct FResurrectionData                      LayerData;                                         // 0x0550(0x0004)(Edit, BlueprintVisible, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_554[0xC];                                      // 0x0554(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VResurrectionAnimInstance">();
	}
	static class UVResurrectionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVResurrectionAnimInstance>();
	}
};
static_assert(alignof(UVResurrectionAnimInstance) == 0x000010, "Wrong alignment on UVResurrectionAnimInstance");
static_assert(sizeof(UVResurrectionAnimInstance) == 0x000560, "Wrong size on UVResurrectionAnimInstance");
static_assert(offsetof(UVResurrectionAnimInstance, PhysicsAsset) == 0x0003B0, "Member 'UVResurrectionAnimInstance::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(UVResurrectionAnimInstance, PhysicsHandleComponent) == 0x0003B8, "Member 'UVResurrectionAnimInstance::PhysicsHandleComponent' has a wrong offset!");
static_assert(offsetof(UVResurrectionAnimInstance, BoneName) == 0x0003C0, "Member 'UVResurrectionAnimInstance::BoneName' has a wrong offset!");
static_assert(offsetof(UVResurrectionAnimInstance, LayerData) == 0x000550, "Member 'UVResurrectionAnimInstance::LayerData' has a wrong offset!");

// Class Altar.VModernPersuasionMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVModernPersuasionMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernPersuasionMenu">();
	}
	static class UVModernPersuasionMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernPersuasionMenu>();
	}
};
static_assert(alignof(UVModernPersuasionMenu) == 0x000008, "Wrong alignment on UVModernPersuasionMenu");
static_assert(sizeof(UVModernPersuasionMenu) == 0x0004E8, "Wrong size on UVModernPersuasionMenu");

// Class Altar.VModernQuickKeysMenu
// 0x0030 (0x0518 - 0x04E8)
class UVModernQuickKeysMenu : public UVAltarMenu
{
public:
	int32                                         NumberOfQuickKeys;                                 // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MouseSelectionDeadZone;                            // 0x04F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FModernQuickKeysActionBinding>  ActionBindings;                                    // 0x0500(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_510[0x8];                                      // 0x0510(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 ComputeKeyIDOnMouseMove(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent);
	int32 ComputeKeyIDWithCenterToCursor(const struct FVector2D& CenterToCursor);
	void SetQuickKeyByIndex(int32 Index_0, class UTexture2D* Texture);
	void SetVisibilityByIndex(int32 Index_0, bool bVisibility);
	void UpdateIcons(const TArray<class UTexture2D*>& NewArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernQuickKeysMenu">();
	}
	static class UVModernQuickKeysMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernQuickKeysMenu>();
	}
};
static_assert(alignof(UVModernQuickKeysMenu) == 0x000008, "Wrong alignment on UVModernQuickKeysMenu");
static_assert(sizeof(UVModernQuickKeysMenu) == 0x000518, "Wrong size on UVModernQuickKeysMenu");
static_assert(offsetof(UVModernQuickKeysMenu, NumberOfQuickKeys) == 0x0004E8, "Member 'UVModernQuickKeysMenu::NumberOfQuickKeys' has a wrong offset!");
static_assert(offsetof(UVModernQuickKeysMenu, MouseSelectionDeadZone) == 0x0004F0, "Member 'UVModernQuickKeysMenu::MouseSelectionDeadZone' has a wrong offset!");
static_assert(offsetof(UVModernQuickKeysMenu, ActionBindings) == 0x000500, "Member 'UVModernQuickKeysMenu::ActionBindings' has a wrong offset!");

// Class Altar.VModernScrollBox
// 0x0010 (0x0D00 - 0x0CF0)
class UVModernScrollBox final : public UScrollBox
{
public:
	TMulticastInlineDelegate<void(float MinScrollbarValue, float MaxScrollbarValue, float CurrentScrollbarValue, float ThumbFractionSize)> OnScrollboxScrollbarChanged; // 0x0CF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnScrollboxScrollbarChangedInternal(float MinScrollbarValue, float MaxScrollbarValue, float CurrentScrollbarValue, float ThumbFractionSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernScrollBox">();
	}
	static class UVModernScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernScrollBox>();
	}
};
static_assert(alignof(UVModernScrollBox) == 0x000010, "Wrong alignment on UVModernScrollBox");
static_assert(sizeof(UVModernScrollBox) == 0x000D00, "Wrong size on UVModernScrollBox");
static_assert(offsetof(UVModernScrollBox, OnScrollboxScrollbarChanged) == 0x000CF0, "Member 'UVModernScrollBox::OnScrollboxScrollbarChanged' has a wrong offset!");

// Class Altar.VModernSettingCategoryTable
// 0x0010 (0x00C0 - 0x00B0)
class UVModernSettingCategoryTable final : public UDataTable
{
public:
	TArray<struct FModernSettingCategoryTableRow> Categories;                                        // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernSettingCategoryTable">();
	}
	static class UVModernSettingCategoryTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernSettingCategoryTable>();
	}
};
static_assert(alignof(UVModernSettingCategoryTable) == 0x000008, "Wrong alignment on UVModernSettingCategoryTable");
static_assert(sizeof(UVModernSettingCategoryTable) == 0x0000C0, "Wrong size on UVModernSettingCategoryTable");
static_assert(offsetof(UVModernSettingCategoryTable, Categories) == 0x0000B0, "Member 'UVModernSettingCategoryTable::Categories' has a wrong offset!");

// Class Altar.VModernSettingCategoryWidget
// 0x0028 (0x04F0 - 0x04C8)
class UVModernSettingCategoryWidget : public UVAltarWidget
{
public:
	uint8                                         Pad_4C8[0x28];                                     // 0x04C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FModernSettingCategoryTableRow GetSettingCategoryRow();
	void OnSettingCategoryChanged(const struct FModernSettingCategoryTableRow& NewSettingCategoryRow);
	void SetSettingCategoryRow(const struct FModernSettingCategoryTableRow& NewSettingCategoryRow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernSettingCategoryWidget">();
	}
	static class UVModernSettingCategoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernSettingCategoryWidget>();
	}
};
static_assert(alignof(UVModernSettingCategoryWidget) == 0x000008, "Wrong alignment on UVModernSettingCategoryWidget");
static_assert(sizeof(UVModernSettingCategoryWidget) == 0x0004F0, "Wrong size on UVModernSettingCategoryWidget");

// Class Altar.VModernSettingComboBoxItem
// 0x0018 (0x0040 - 0x0028)
class UVModernSettingComboBoxItem final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOption(const class FText& NewOption);

	const class FText GetOption() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernSettingComboBoxItem">();
	}
	static class UVModernSettingComboBoxItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernSettingComboBoxItem>();
	}
};
static_assert(alignof(UVModernSettingComboBoxItem) == 0x000008, "Wrong alignment on UVModernSettingComboBoxItem");
static_assert(sizeof(UVModernSettingComboBoxItem) == 0x000040, "Wrong size on UVModernSettingComboBoxItem");

// Class Altar.VModernSettingRebindData
// 0x0010 (0x00C0 - 0x00B0)
class UVModernSettingRebindData final : public UDataTable
{
public:
	TArray<struct FModernRebindSettingTableRow>   RebindSettings;                                    // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernSettingRebindData">();
	}
	static class UVModernSettingRebindData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernSettingRebindData>();
	}
};
static_assert(alignof(UVModernSettingRebindData) == 0x000008, "Wrong alignment on UVModernSettingRebindData");
static_assert(sizeof(UVModernSettingRebindData) == 0x0000C0, "Wrong size on UVModernSettingRebindData");
static_assert(offsetof(UVModernSettingRebindData, RebindSettings) == 0x0000B0, "Member 'UVModernSettingRebindData::RebindSettings' has a wrong offset!");

// Class Altar.VModernSettingsFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVModernSettingsFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString CreateCommand(const class FString& CommandName, const class FString& CommandValue);
	static class FString FixBooleen(const class FString& Input);
	static float GetCommandFloatValue(const class FString& CommandName);
	static int32 GetCommandIntegerValue(const class FString& CommandName);
	static class FString GetCommandValue(const class FString& CommandName);
	static bool IsPlatformValidForSetting(int32 ModernCategoryPlatormFlag);
	static bool IsRunningOnSteam();
	static bool IsRunningOnSteamDeck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernSettingsFunctionLibrary">();
	}
	static class UVModernSettingsFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernSettingsFunctionLibrary>();
	}
};
static_assert(alignof(UVModernSettingsFunctionLibrary) == 0x000008, "Wrong alignment on UVModernSettingsFunctionLibrary");
static_assert(sizeof(UVModernSettingsFunctionLibrary) == 0x000028, "Wrong size on UVModernSettingsFunctionLibrary");

// Class Altar.VModernSettingTable
// 0x0010 (0x00C0 - 0x00B0)
class UVModernSettingTable final : public UDataTable
{
public:
	TArray<struct FModernSettingTableRow>         Settings;                                          // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernSettingTable">();
	}
	static class UVModernSettingTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernSettingTable>();
	}
};
static_assert(alignof(UVModernSettingTable) == 0x000008, "Wrong alignment on UVModernSettingTable");
static_assert(sizeof(UVModernSettingTable) == 0x0000C0, "Wrong size on UVModernSettingTable");
static_assert(offsetof(UVModernSettingTable, Settings) == 0x0000B0, "Member 'UVModernSettingTable::Settings' has a wrong offset!");

// Class Altar.VWaterVolume
// 0x0000 (0x02E0 - 0x02E0)
class AVWaterVolume final : public APhysicsVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWaterVolume">();
	}
	static class AVWaterVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWaterVolume>();
	}
};
static_assert(alignof(AVWaterVolume) == 0x000008, "Wrong alignment on AVWaterVolume");
static_assert(sizeof(AVWaterVolume) == 0x0002E0, "Wrong size on AVWaterVolume");

// Class Altar.VModern_AltarMapIconDesignTable
// 0x0050 (0x0100 - 0x00B0)
class UVModern_AltarMapIconDesignTable final : public UDataTable
{
public:
	TMap<ELegacyMapMenuIcon, struct FModern_AltarMapIconDesignTableRow> MapIconDesign;               // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_AltarMapIconDesignTable">();
	}
	static class UVModern_AltarMapIconDesignTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_AltarMapIconDesignTable>();
	}
};
static_assert(alignof(UVModern_AltarMapIconDesignTable) == 0x000008, "Wrong alignment on UVModern_AltarMapIconDesignTable");
static_assert(sizeof(UVModern_AltarMapIconDesignTable) == 0x000100, "Wrong size on UVModern_AltarMapIconDesignTable");
static_assert(offsetof(UVModern_AltarMapIconDesignTable, MapIconDesign) == 0x0000B0, "Member 'UVModern_AltarMapIconDesignTable::MapIconDesign' has a wrong offset!");

// Class Altar.VModern_CharacCreationGenericColorPicker
// 0x0110 (0x05D8 - 0x04C8)
class UVModern_CharacCreationGenericColorPicker final : public UVAltarWidget
{
public:
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyRaceSexMenuTableRow             Row;                                               // 0x04D0(0x0108)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_CharacCreationGenericColorPicker">();
	}
	static class UVModern_CharacCreationGenericColorPicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_CharacCreationGenericColorPicker>();
	}
};
static_assert(alignof(UVModern_CharacCreationGenericColorPicker) == 0x000008, "Wrong alignment on UVModern_CharacCreationGenericColorPicker");
static_assert(sizeof(UVModern_CharacCreationGenericColorPicker) == 0x0005D8, "Wrong size on UVModern_CharacCreationGenericColorPicker");
static_assert(offsetof(UVModern_CharacCreationGenericColorPicker, Row) == 0x0004D0, "Member 'UVModern_CharacCreationGenericColorPicker::Row' has a wrong offset!");

// Class Altar.VModern_CharacCreationGenericSettingInterface
// 0x0000 (0x0000 - 0x0000)
class IVModern_CharacCreationGenericSettingInterface final
{
public:
	void ExecuteLastIfLastItemActionLogic();

	const struct FLegacyRaceSexMenuTableRow GetRow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_CharacCreationGenericSettingInterface">();
	}
	static class IVModern_CharacCreationGenericSettingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVModern_CharacCreationGenericSettingInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IVModern_CharacCreationGenericSettingInterface) == 0x000001, "Wrong alignment on IVModern_CharacCreationGenericSettingInterface");
static_assert(sizeof(IVModern_CharacCreationGenericSettingInterface) == 0x000001, "Wrong size on IVModern_CharacCreationGenericSettingInterface");

// Class Altar.VModern_CharacCreationGenericSlider
// 0x0110 (0x0698 - 0x0588)
class UVModern_CharacCreationGenericSlider final : public UVAltarNavigableSlider
{
public:
	uint8                                         Pad_588[0x8];                                      // 0x0588(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyRaceSexMenuTableRow             Row;                                               // 0x0590(0x0108)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_CharacCreationGenericSlider">();
	}
	static class UVModern_CharacCreationGenericSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_CharacCreationGenericSlider>();
	}
};
static_assert(alignof(UVModern_CharacCreationGenericSlider) == 0x000008, "Wrong alignment on UVModern_CharacCreationGenericSlider");
static_assert(sizeof(UVModern_CharacCreationGenericSlider) == 0x000698, "Wrong size on UVModern_CharacCreationGenericSlider");
static_assert(offsetof(UVModern_CharacCreationGenericSlider, Row) == 0x000590, "Member 'UVModern_CharacCreationGenericSlider::Row' has a wrong offset!");

// Class Altar.VModern_CharacCreationGenericTileView
// 0x0110 (0x0648 - 0x0538)
class UVModern_CharacCreationGenericTileView final : public UVAltarNavigableTileView
{
public:
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacyRaceSexMenuTableRow             Row;                                               // 0x0540(0x0108)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_CharacCreationGenericTileView">();
	}
	static class UVModern_CharacCreationGenericTileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_CharacCreationGenericTileView>();
	}
};
static_assert(alignof(UVModern_CharacCreationGenericTileView) == 0x000008, "Wrong alignment on UVModern_CharacCreationGenericTileView");
static_assert(sizeof(UVModern_CharacCreationGenericTileView) == 0x000648, "Wrong size on UVModern_CharacCreationGenericTileView");
static_assert(offsetof(UVModern_CharacCreationGenericTileView, Row) == 0x000540, "Member 'UVModern_CharacCreationGenericTileView::Row' has a wrong offset!");

// Class Altar.VModern_CharacCreationNavigableRaceScrollbar
// 0x0018 (0x0520 - 0x0508)
class UVModern_CharacCreationNavigableRaceScrollbar final : public UVAltarNavigableScrollBox
{
public:
	float                                         ScrollSpeedFactor;                                 // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TriggerTimeSpeedFactor;                            // 0x050C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x10];                                     // 0x0510(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ScrollBody(const float& ScrollDelta, const float& TriggerTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_CharacCreationNavigableRaceScrollbar">();
	}
	static class UVModern_CharacCreationNavigableRaceScrollbar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_CharacCreationNavigableRaceScrollbar>();
	}
};
static_assert(alignof(UVModern_CharacCreationNavigableRaceScrollbar) == 0x000008, "Wrong alignment on UVModern_CharacCreationNavigableRaceScrollbar");
static_assert(sizeof(UVModern_CharacCreationNavigableRaceScrollbar) == 0x000520, "Wrong size on UVModern_CharacCreationNavigableRaceScrollbar");
static_assert(offsetof(UVModern_CharacCreationNavigableRaceScrollbar, ScrollSpeedFactor) == 0x000508, "Member 'UVModern_CharacCreationNavigableRaceScrollbar::ScrollSpeedFactor' has a wrong offset!");
static_assert(offsetof(UVModern_CharacCreationNavigableRaceScrollbar, TriggerTimeSpeedFactor) == 0x00050C, "Member 'UVModern_CharacCreationNavigableRaceScrollbar::TriggerTimeSpeedFactor' has a wrong offset!");

// Class Altar.VModern_ColorPickerItem
// 0x0008 (0x0030 - 0x0028)
class UVModern_ColorPickerItem final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColorOption(const struct FColor& Value);
	void SetIsDefaultColor(const bool& Value);
	void SetIsSelected(const bool Value);

	const struct FColor GetColorOption() const;
	bool IsDefaultColor() const;
	const bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_ColorPickerItem">();
	}
	static class UVModern_ColorPickerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_ColorPickerItem>();
	}
};
static_assert(alignof(UVModern_ColorPickerItem) == 0x000008, "Wrong alignment on UVModern_ColorPickerItem");
static_assert(sizeof(UVModern_ColorPickerItem) == 0x000030, "Wrong size on UVModern_ColorPickerItem");

// Class Altar.VTutorialMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVTutorialMenu : public UVAltarMenu
{
public:
	void OnFadeEnded();
	void OnFadeStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTutorialMenu">();
	}
	static class UVTutorialMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVTutorialMenu>();
	}
};
static_assert(alignof(UVTutorialMenu) == 0x000008, "Wrong alignment on UVTutorialMenu");
static_assert(sizeof(UVTutorialMenu) == 0x0004E8, "Wrong size on UVTutorialMenu");

// Class Altar.VModern_MapIconCommonUserWidget
// 0x0040 (0x0328 - 0x02E8)
class UVModern_MapIconCommonUserWidget : public UCommonUserWidget
{
public:
	class USizeBox*                               MapIconSizeBox;                                    // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentIconSize;                                   // 0x02F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconBaseSize;                                      // 0x02F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ZoomFactorsByLevel;                                // 0x02F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StartingZoomLevelOnWorldMap;                       // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingZoomLevelOnLocalMap;                       // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingZoomFactorOnWorldMapSwitch;                // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingZoomFactorOnWorldMapSetup;                 // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingZoomFactorOnLocalMap;                      // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinIconSizeFactor;                                 // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIconSizeFactor;                                 // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIconProperties(class USizeBox* SizeBox);
	void SetIconSize(const float IconSize);
	void SetIconSizeGivenZoomFactor(const float ZoomFactor);
	void SetIconSizeGivenZoomLevel(const int32 ZoomLevel);
	void SetIconSizeSmoothlyGivenZoomLevel(const int32 ZoomLevel, const float IconSizeAlpha);
	void SetIconStartingSizeAccordingToMapType(const bool bIsWorldMap);
	void SetIconStartingSizeOnMapSetup(const bool bIsWorldMap);
	void SetIconStartingSizeOnMapSwitch(const bool bIsWorldMap);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_MapIconCommonUserWidget">();
	}
	static class UVModern_MapIconCommonUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_MapIconCommonUserWidget>();
	}
};
static_assert(alignof(UVModern_MapIconCommonUserWidget) == 0x000008, "Wrong alignment on UVModern_MapIconCommonUserWidget");
static_assert(sizeof(UVModern_MapIconCommonUserWidget) == 0x000328, "Wrong size on UVModern_MapIconCommonUserWidget");
static_assert(offsetof(UVModern_MapIconCommonUserWidget, MapIconSizeBox) == 0x0002E8, "Member 'UVModern_MapIconCommonUserWidget::MapIconSizeBox' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconCommonUserWidget, CurrentIconSize) == 0x0002F0, "Member 'UVModern_MapIconCommonUserWidget::CurrentIconSize' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconCommonUserWidget, IconBaseSize) == 0x0002F4, "Member 'UVModern_MapIconCommonUserWidget::IconBaseSize' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconCommonUserWidget, ZoomFactorsByLevel) == 0x0002F8, "Member 'UVModern_MapIconCommonUserWidget::ZoomFactorsByLevel' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconCommonUserWidget, StartingZoomLevelOnWorldMap) == 0x000308, "Member 'UVModern_MapIconCommonUserWidget::StartingZoomLevelOnWorldMap' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconCommonUserWidget, StartingZoomLevelOnLocalMap) == 0x00030C, "Member 'UVModern_MapIconCommonUserWidget::StartingZoomLevelOnLocalMap' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconCommonUserWidget, StartingZoomFactorOnWorldMapSwitch) == 0x000310, "Member 'UVModern_MapIconCommonUserWidget::StartingZoomFactorOnWorldMapSwitch' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconCommonUserWidget, StartingZoomFactorOnWorldMapSetup) == 0x000314, "Member 'UVModern_MapIconCommonUserWidget::StartingZoomFactorOnWorldMapSetup' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconCommonUserWidget, StartingZoomFactorOnLocalMap) == 0x000318, "Member 'UVModern_MapIconCommonUserWidget::StartingZoomFactorOnLocalMap' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconCommonUserWidget, MinIconSizeFactor) == 0x00031C, "Member 'UVModern_MapIconCommonUserWidget::MinIconSizeFactor' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconCommonUserWidget, MaxIconSizeFactor) == 0x000320, "Member 'UVModern_MapIconCommonUserWidget::MaxIconSizeFactor' has a wrong offset!");

// Class Altar.VModern_MapIconFilter
// 0x0130 (0x05F8 - 0x04C8)
class UVModern_MapIconFilter : public UVAltarWidget
{
public:
	class UVNavigableScrollBox*                   FilterIconBox;                                     // 0x04C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVNavigableScrollBox*                   ControlFilterBox;                                  // 0x04D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCommonUserWidget>          FilterIconClass;                                   // 0x04D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVModern_AltarMapIconDesignTable*       IconDesignTable;                                   // 0x04E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                FilterPadding;                                     // 0x04E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x100];                                    // 0x04F8(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateControlFilter(class UCommonUserWidget* Activator, bool bIsAll);
	void ActivateControlFilterFromEnum(ELegacyMapMenuIcon ActivatorEnum);
	void ActivateFilter(class UCommonUserWidget* Activator);
	void ActivateIconFilter(class UCommonUserWidget* Activator);
	void ActivateSpecificFilterFromEnum(ELegacyMapMenuIcon ActivatorEnum);
	void DesactivateFilter(class UCommonUserWidget* Activator);
	void DesactivateIconFilter(class UCommonUserWidget* Activator);
	bool IsFilterHasAtLeastOneDisplayedIcon();
	void OnFilterIconCreated(class UCommonUserWidget* NewFilter, const struct FModern_AltarMapIconDesignTableRow& FilterDesign, bool bIsControlFilter);
	void OnPostTryRegisterWidgetToFilter();
	void OnWidgetRegisterToFilter(class UCommonUserWidget* Filter, class UCommonUserWidget* NewWidgetToFilter, int32 NumberOfFilteredObjects);
	void OnWidgetUnregisterToFilter(class UCommonUserWidget* Filter, class UCommonUserWidget* RemovedWidget, int32 NumberOfFilteredObjects);
	void RequestUpdateFilteredWidget(class UCommonUserWidget* FilteredWidget, bool bCanBeDisplay);
	void RequestUpdateFilterWidget(class UCommonUserWidget* Filter, bool bIsEnable);

	class UCommonUserWidget* GetControlFilter() const;
	bool IsFilterFlagAll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_MapIconFilter">();
	}
	static class UVModern_MapIconFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_MapIconFilter>();
	}
};
static_assert(alignof(UVModern_MapIconFilter) == 0x000008, "Wrong alignment on UVModern_MapIconFilter");
static_assert(sizeof(UVModern_MapIconFilter) == 0x0005F8, "Wrong size on UVModern_MapIconFilter");
static_assert(offsetof(UVModern_MapIconFilter, FilterIconBox) == 0x0004C8, "Member 'UVModern_MapIconFilter::FilterIconBox' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconFilter, ControlFilterBox) == 0x0004D0, "Member 'UVModern_MapIconFilter::ControlFilterBox' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconFilter, FilterIconClass) == 0x0004D8, "Member 'UVModern_MapIconFilter::FilterIconClass' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconFilter, IconDesignTable) == 0x0004E0, "Member 'UVModern_MapIconFilter::IconDesignTable' has a wrong offset!");
static_assert(offsetof(UVModern_MapIconFilter, FilterPadding) == 0x0004E8, "Member 'UVModern_MapIconFilter::FilterPadding' has a wrong offset!");

// Class Altar.VModern_MapZoomSlider
// 0x0020 (0x06C0 - 0x06A0)
class UVModern_MapZoomSlider final : public UVDotedAltarNavigableSlider
{
public:
	TMulticastInlineDelegate<void(int32 Level, float sliderValue, int32 levelDelta)> OnZoomLevelReached; // 0x06A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B0[0x10];                                     // 0x06B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetLevel(int32 newLevel);

	int32 GetCurrentLevel() const;
	int32 GetMaxLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_MapZoomSlider">();
	}
	static class UVModern_MapZoomSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_MapZoomSlider>();
	}
};
static_assert(alignof(UVModern_MapZoomSlider) == 0x000010, "Wrong alignment on UVModern_MapZoomSlider");
static_assert(sizeof(UVModern_MapZoomSlider) == 0x0006C0, "Wrong size on UVModern_MapZoomSlider");
static_assert(offsetof(UVModern_MapZoomSlider, OnZoomLevelReached) == 0x0006A0, "Member 'UVModern_MapZoomSlider::OnZoomLevelReached' has a wrong offset!");

// Class Altar.VModern_MapZoomSliderSmooth
// 0x0020 (0x05A8 - 0x0588)
class UVModern_MapZoomSliderSmooth : public UVAltarNavigableSlider
{
public:
	TMulticastInlineDelegate<void(float sliderValue)> OnZoomLevelChanged;                            // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bBelongToWorldMap;                                 // 0x0598(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSliderNavigationActionDisabled;                 // 0x0599(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESliderInputType                              SliderInputType;                                   // 0x059A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59B[0x1];                                      // 0x059B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseWheelMultiplier;                              // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderArrowsMultiplier;                            // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControllerTriggersMultiplier;                      // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_MapZoomSliderSmooth">();
	}
	static class UVModern_MapZoomSliderSmooth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_MapZoomSliderSmooth>();
	}
};
static_assert(alignof(UVModern_MapZoomSliderSmooth) == 0x000008, "Wrong alignment on UVModern_MapZoomSliderSmooth");
static_assert(sizeof(UVModern_MapZoomSliderSmooth) == 0x0005A8, "Wrong size on UVModern_MapZoomSliderSmooth");
static_assert(offsetof(UVModern_MapZoomSliderSmooth, OnZoomLevelChanged) == 0x000588, "Member 'UVModern_MapZoomSliderSmooth::OnZoomLevelChanged' has a wrong offset!");
static_assert(offsetof(UVModern_MapZoomSliderSmooth, bBelongToWorldMap) == 0x000598, "Member 'UVModern_MapZoomSliderSmooth::bBelongToWorldMap' has a wrong offset!");
static_assert(offsetof(UVModern_MapZoomSliderSmooth, bIsSliderNavigationActionDisabled) == 0x000599, "Member 'UVModern_MapZoomSliderSmooth::bIsSliderNavigationActionDisabled' has a wrong offset!");
static_assert(offsetof(UVModern_MapZoomSliderSmooth, SliderInputType) == 0x00059A, "Member 'UVModern_MapZoomSliderSmooth::SliderInputType' has a wrong offset!");
static_assert(offsetof(UVModern_MapZoomSliderSmooth, MouseWheelMultiplier) == 0x00059C, "Member 'UVModern_MapZoomSliderSmooth::MouseWheelMultiplier' has a wrong offset!");
static_assert(offsetof(UVModern_MapZoomSliderSmooth, SliderArrowsMultiplier) == 0x0005A0, "Member 'UVModern_MapZoomSliderSmooth::SliderArrowsMultiplier' has a wrong offset!");
static_assert(offsetof(UVModern_MapZoomSliderSmooth, ControllerTriggersMultiplier) == 0x0005A4, "Member 'UVModern_MapZoomSliderSmooth::ControllerTriggersMultiplier' has a wrong offset!");

// Class Altar.VModern_NavigableMapWidget
// 0x02C0 (0x0788 - 0x04C8)
class UVModern_NavigableMapWidget : public UVAltarWidget
{
public:
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           MapContainer;                                      // 0x04D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVModern_MapIconFilter*                 MapIconFilter;                                     // 0x04D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                MapCursor;                                         // 0x04E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UVModern_MapIconCommonUserWidget> MapIconClass;                                // 0x04E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShiftPlayerMarkerModifier;                       // 0x04F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCtrlPlayerMarkerModifier;                        // 0x04F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAltPlayerMarkerModifier;                         // 0x04F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F3[0x1];                                      // 0x04F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavigationToMovementRatio;                         // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationToZoomRatio;                             // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PanningMaxSpeed;                                   // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePanningCurve;                                   // 0x0500(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_501[0x3];                                      // 0x0501(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseDragRigidity;                                 // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnchors                               CursorMapMovementThreshold;                        // 0x0508(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CursorRadius;                                      // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MouseCursorOffset;                                 // 0x0530(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WantedZoomLevel;                                   // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AdditionalDragOffset;                              // 0x0548(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MapZoomCurve;                                      // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            IconsZoomCurve;                                    // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            PanningCurve;                                      // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_570[0x98];                                     // 0x0570(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonUserWidget*                      HoveredMapIcon;                                    // 0x0608(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanelSlot*                       CachedMapSlot;                                     // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanelSlot*                       CachedViewSlot;                                    // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanelSlot*                       CachedCursorSlot;                                  // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonUserWidget*                      PlayerMarker;                                      // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomMinClamp;                                      // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomMaxClamp;                                      // 0x0634(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTextureRenderTarget2D>  FogOfWarRenderTarget;                              // 0x0638(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTextureRenderTarget2D>  SceneDepthRenderTarget;                            // 0x0660(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTextureRenderTarget2D>  SecondPassRenderTarget;                            // 0x0688(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTextureRenderTarget2D>  BaseColorRenderTarget;                             // 0x06B0(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterial>               FogOfWarMaterial;                                  // 0x06D8(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterial>               LocalMapMaterial;                                  // 0x0700(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               LocalMapMaterialDynamic;                           // 0x0728(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterial>               LocalMapSobelMaterial;                             // 0x0730(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_758[0x30];                                     // 0x0758(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMapZoom(float ZoomDelta);
	void ClearAllMapIcons();
	void HandleMouseMove(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent);
	void InitializeMapWidget_LocalMap(const struct FLegacyMapMenuLocalMapProperties& LocalMapData);
	void InitializeMapWidget_WorldMap(const struct FLegacyMapMenuWorldMapProperties& WorldMapData);
	class UTextureRenderTarget2D* LoadBaseColorRenderTarget();
	class UMaterial* LoadFogMaterial();
	class UTextureRenderTarget2D* LoadFogRenderTarget();
	class UMaterialInterface* LoadLocalMapMaterial();
	class UMaterial* LoadLocalMapSobelMaterial();
	class UTextureRenderTarget2D* LoadSceneDepthRenderTarget();
	class UTextureRenderTarget2D* LoadSecondPassRenderTarget();
	void MapZoomSmoothInternal(float InNewZoomValue);
	void MouseDrag(const struct FVector2D& MousePosition);
	void OnCursorHoverIcon(class UCommonUserWidget* HoveredIcon);
	void OnCursorPositionChanged(const struct FVector2D& NewPosition);
	void OnCursorUnhoverIcon(class UCommonUserWidget* UnhoveredIcon);
	void OnIconCreated(class UCommonUserWidget* NewMapIcon, const struct FLegacyMapMenuIconProperties& Data);
	void OnMapInputMethodChanged(ECommonInputType NewInputType);
	void OnMapPivotChanged(const struct FVector2D& NewPivot);
	void OnMapPositionChanged(const struct FVector2D& NewPosition);
	void OnMapSetup(const class UObject* MapBrushObject, const struct FVector2D& OriginalMapSize);
	void OnMouseDrag(const struct FVector2D& DragDelta);
	void OnPlayerMarkerRequested();
	void OnSwitchInputMode(ECommonInputType InputType);
	void OnSyncMouseWithCursorRequested();
	void OnZoomChanged(float NewZoom);
	struct FVector2D RemapCircleToSquare(const struct FVector2D& DirectionalVector);
	void RequestMapPositionUpdateWithGeometryValidation(const struct FVector2D& NewPositionVector);
	void SetCursorPosition(const struct FVector2D& NewPosition);
	void SetMapPivot(const struct FVector2D& PivotValue);
	void SetMapPivotToViewCenter();
	void SetMapPosition(const struct FVector2D& NewPositionVector);
	void SetMapZoom(float ZoomValue, bool bIsZoomingOnMouse);
	void SetMapZoomSmooth(float InNewZoomValue);
	void StartMouseDrag(const struct FVector2D& MousePosition);
	void StopMouseDrag();
	void TranslateCursor(const struct FVector2D& DirectionVector);
	void TranslateMap(const struct FVector2D& DirectionVector);
	void UnloadBaseColorRenderTarget();
	void UnloadFogMaterial();
	void UnloadFogRenderTarget();
	void UnloadLocalMapMaterial();
	void UnloadLocalMapSobelMaterial();
	void UnloadSceneDepthRenderTarget();
	void UnloadSecondPassRenderTarget();
	void UpdateIconsSizeOnMapSetup(const bool bIsWorldMap);
	void UpdateIconsSizeOnMapSwitch(const bool bIsWorldMap);
	void UpdateIconsSizeSmoothly(const bool bSmooth);
	void UpdateMapIconPosition(class UCommonUserWidget* MapIcon, const struct FVector2D& NewPosition);
	void UpdateOrCreateMapIcon(const struct FLegacyMapMenuIconProperties& IconData, const bool bIsLocalMap);
	void UpdateOrCreateMapIcons(const TArray<struct FLegacyMapMenuIconProperties>& IconsData, const bool bIsLocalMap);
	void UpdatePlayerMarkerPosition(const struct FVector2D& NewPosition);

	struct FVector2D AbsoluteSpaceToMapSpace(const struct FVector2D& AbsoluteSpace) const;
	float ClampZoomValue(float NewZoomValue) const;
	class UTextureRenderTarget2D* GetBaseColorRenderTarget() const;
	float GetCurrentZoomValue() const;
	float GetDPIScaling() const;
	class UMaterial* GetFogMaterial() const;
	class UTextureRenderTarget2D* GetFogRenderTarget() const;
	bool GetIsPaintSpaceGeometryValid() const;
	class UMaterialInterface* GetLocalMapMaterial() const;
	class UMaterial* GetLocalMapSobelMaterial() const;
	struct FVector2D GetOriginalMapSize() const;
	struct FVector2D GetPlayerPosition() const;
	struct FVector2D GetResolution() const;
	class UTextureRenderTarget2D* GetSceneDepthRenderTarget() const;
	class UTextureRenderTarget2D* GetSecondPassRenderTarget() const;
	float GetSmallestPossibleZoomValue() const;
	struct FVector2D GetViewSize() const;
	struct FVector2D GetZoomedMapSize() const;
	bool IsAskingForPlayerMarker() const;
	bool IsIconInLeftHalfOfView(const struct FVector2D& IconPosition) const;
	struct FVector3f LocalMapToOblivionWorld(const struct FVector2D& IconPosition) const;
	struct FVector2D OTAMapCoord(const struct FVector2D& OMapCoord) const;
	struct FVector2D ViewSpaceToAbsoluteSpace(const struct FVector2D& ViewSpace) const;
	struct FVector2D ViewSpaceToMapSpace(const struct FVector2D& ViewSpace) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_NavigableMapWidget">();
	}
	static class UVModern_NavigableMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_NavigableMapWidget>();
	}
};
static_assert(alignof(UVModern_NavigableMapWidget) == 0x000008, "Wrong alignment on UVModern_NavigableMapWidget");
static_assert(sizeof(UVModern_NavigableMapWidget) == 0x000788, "Wrong size on UVModern_NavigableMapWidget");
static_assert(offsetof(UVModern_NavigableMapWidget, MapContainer) == 0x0004D0, "Member 'UVModern_NavigableMapWidget::MapContainer' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, MapIconFilter) == 0x0004D8, "Member 'UVModern_NavigableMapWidget::MapIconFilter' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, MapCursor) == 0x0004E0, "Member 'UVModern_NavigableMapWidget::MapCursor' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, MapIconClass) == 0x0004E8, "Member 'UVModern_NavigableMapWidget::MapIconClass' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, IsShiftPlayerMarkerModifier) == 0x0004F0, "Member 'UVModern_NavigableMapWidget::IsShiftPlayerMarkerModifier' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, IsCtrlPlayerMarkerModifier) == 0x0004F1, "Member 'UVModern_NavigableMapWidget::IsCtrlPlayerMarkerModifier' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, IsAltPlayerMarkerModifier) == 0x0004F2, "Member 'UVModern_NavigableMapWidget::IsAltPlayerMarkerModifier' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, NavigationToMovementRatio) == 0x0004F4, "Member 'UVModern_NavigableMapWidget::NavigationToMovementRatio' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, NavigationToZoomRatio) == 0x0004F8, "Member 'UVModern_NavigableMapWidget::NavigationToZoomRatio' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, PanningMaxSpeed) == 0x0004FC, "Member 'UVModern_NavigableMapWidget::PanningMaxSpeed' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, UsePanningCurve) == 0x000500, "Member 'UVModern_NavigableMapWidget::UsePanningCurve' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, MouseDragRigidity) == 0x000504, "Member 'UVModern_NavigableMapWidget::MouseDragRigidity' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, CursorMapMovementThreshold) == 0x000508, "Member 'UVModern_NavigableMapWidget::CursorMapMovementThreshold' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, CursorRadius) == 0x000528, "Member 'UVModern_NavigableMapWidget::CursorRadius' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, MouseCursorOffset) == 0x000530, "Member 'UVModern_NavigableMapWidget::MouseCursorOffset' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, WantedZoomLevel) == 0x000540, "Member 'UVModern_NavigableMapWidget::WantedZoomLevel' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, AdditionalDragOffset) == 0x000548, "Member 'UVModern_NavigableMapWidget::AdditionalDragOffset' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, MapZoomCurve) == 0x000558, "Member 'UVModern_NavigableMapWidget::MapZoomCurve' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, IconsZoomCurve) == 0x000560, "Member 'UVModern_NavigableMapWidget::IconsZoomCurve' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, PanningCurve) == 0x000568, "Member 'UVModern_NavigableMapWidget::PanningCurve' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, HoveredMapIcon) == 0x000608, "Member 'UVModern_NavigableMapWidget::HoveredMapIcon' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, CachedMapSlot) == 0x000610, "Member 'UVModern_NavigableMapWidget::CachedMapSlot' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, CachedViewSlot) == 0x000618, "Member 'UVModern_NavigableMapWidget::CachedViewSlot' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, CachedCursorSlot) == 0x000620, "Member 'UVModern_NavigableMapWidget::CachedCursorSlot' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, PlayerMarker) == 0x000628, "Member 'UVModern_NavigableMapWidget::PlayerMarker' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, ZoomMinClamp) == 0x000630, "Member 'UVModern_NavigableMapWidget::ZoomMinClamp' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, ZoomMaxClamp) == 0x000634, "Member 'UVModern_NavigableMapWidget::ZoomMaxClamp' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, FogOfWarRenderTarget) == 0x000638, "Member 'UVModern_NavigableMapWidget::FogOfWarRenderTarget' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, SceneDepthRenderTarget) == 0x000660, "Member 'UVModern_NavigableMapWidget::SceneDepthRenderTarget' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, SecondPassRenderTarget) == 0x000688, "Member 'UVModern_NavigableMapWidget::SecondPassRenderTarget' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, BaseColorRenderTarget) == 0x0006B0, "Member 'UVModern_NavigableMapWidget::BaseColorRenderTarget' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, FogOfWarMaterial) == 0x0006D8, "Member 'UVModern_NavigableMapWidget::FogOfWarMaterial' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, LocalMapMaterial) == 0x000700, "Member 'UVModern_NavigableMapWidget::LocalMapMaterial' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, LocalMapMaterialDynamic) == 0x000728, "Member 'UVModern_NavigableMapWidget::LocalMapMaterialDynamic' has a wrong offset!");
static_assert(offsetof(UVModern_NavigableMapWidget, LocalMapSobelMaterial) == 0x000730, "Member 'UVModern_NavigableMapWidget::LocalMapSobelMaterial' has a wrong offset!");

// Class Altar.VModern_RacePortraitItem
// 0x0028 (0x0050 - 0x0028)
class UVModern_RacePortraitItem final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsSelected(const bool Value);
	void SetName(const class FString& Value);
	void SetProperties(class UTexture2D* Value);
	void SetPropertiesHover(class UTexture2D* Value);

	class FString GetName() const;
	const class UTexture2D* GetProperties() const;
	const class UTexture2D* GetPropertiesHover() const;
	const bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModern_RacePortraitItem">();
	}
	static class UVModern_RacePortraitItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModern_RacePortraitItem>();
	}
};
static_assert(alignof(UVModern_RacePortraitItem) == 0x000008, "Wrong alignment on UVModern_RacePortraitItem");
static_assert(sizeof(UVModern_RacePortraitItem) == 0x000050, "Wrong size on UVModern_RacePortraitItem");

// Class Altar.VUpperBodyModularBodyPart
// 0x0070 (0x03B0 - 0x0340)
class AVUpperBodyModularBodyPart : public AVModularBodyPartBase
{
public:
	TArray<int32>                                 MaterialSlotsHiddenInFirstPerson;                  // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UTESRace*, struct FVModularBodyPartRaceProperties> RaceSpecificProperties;            // 0x0350(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bShouldHideAmulet;                                 // 0x03A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmuletChestSnappingAlpha;                          // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmuletFemaleChestSnappingAlpha;                    // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHidePartOfGloves;                           // 0x03AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AD[0x3];                                      // 0x03AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VUpperBodyModularBodyPart">();
	}
	static class AVUpperBodyModularBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVUpperBodyModularBodyPart>();
	}
};
static_assert(alignof(AVUpperBodyModularBodyPart) == 0x000008, "Wrong alignment on AVUpperBodyModularBodyPart");
static_assert(sizeof(AVUpperBodyModularBodyPart) == 0x0003B0, "Wrong size on AVUpperBodyModularBodyPart");
static_assert(offsetof(AVUpperBodyModularBodyPart, MaterialSlotsHiddenInFirstPerson) == 0x000340, "Member 'AVUpperBodyModularBodyPart::MaterialSlotsHiddenInFirstPerson' has a wrong offset!");
static_assert(offsetof(AVUpperBodyModularBodyPart, RaceSpecificProperties) == 0x000350, "Member 'AVUpperBodyModularBodyPart::RaceSpecificProperties' has a wrong offset!");
static_assert(offsetof(AVUpperBodyModularBodyPart, bShouldHideAmulet) == 0x0003A0, "Member 'AVUpperBodyModularBodyPart::bShouldHideAmulet' has a wrong offset!");
static_assert(offsetof(AVUpperBodyModularBodyPart, AmuletChestSnappingAlpha) == 0x0003A4, "Member 'AVUpperBodyModularBodyPart::AmuletChestSnappingAlpha' has a wrong offset!");
static_assert(offsetof(AVUpperBodyModularBodyPart, AmuletFemaleChestSnappingAlpha) == 0x0003A8, "Member 'AVUpperBodyModularBodyPart::AmuletFemaleChestSnappingAlpha' has a wrong offset!");
static_assert(offsetof(AVUpperBodyModularBodyPart, bShouldHidePartOfGloves) == 0x0003AC, "Member 'AVUpperBodyModularBodyPart::bShouldHidePartOfGloves' has a wrong offset!");

// Class Altar.VLowerBodyModularBodyPart
// 0x0000 (0x0340 - 0x0340)
class AVLowerBodyModularBodyPart : public AVModularBodyPartBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLowerBodyModularBodyPart">();
	}
	static class AVLowerBodyModularBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVLowerBodyModularBodyPart>();
	}
};
static_assert(alignof(AVLowerBodyModularBodyPart) == 0x000008, "Wrong alignment on AVLowerBodyModularBodyPart");
static_assert(sizeof(AVLowerBodyModularBodyPart) == 0x000340, "Wrong size on AVLowerBodyModularBodyPart");

// Class Altar.VRingModularBodyPart
// 0x0020 (0x0360 - 0x0340)
class AVRingModularBodyPart final : public AVModularBodyPartBase
{
public:
	class FName                                   ThirdPersonRightRingSocketName;                    // 0x0340(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThirdPersonLeftRingSocketName;                     // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstPersonRightRingSocketName;                    // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstPersonLeftRingSocketName;                     // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VRingModularBodyPart">();
	}
	static class AVRingModularBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVRingModularBodyPart>();
	}
};
static_assert(alignof(AVRingModularBodyPart) == 0x000008, "Wrong alignment on AVRingModularBodyPart");
static_assert(sizeof(AVRingModularBodyPart) == 0x000360, "Wrong size on AVRingModularBodyPart");
static_assert(offsetof(AVRingModularBodyPart, ThirdPersonRightRingSocketName) == 0x000340, "Member 'AVRingModularBodyPart::ThirdPersonRightRingSocketName' has a wrong offset!");
static_assert(offsetof(AVRingModularBodyPart, ThirdPersonLeftRingSocketName) == 0x000348, "Member 'AVRingModularBodyPart::ThirdPersonLeftRingSocketName' has a wrong offset!");
static_assert(offsetof(AVRingModularBodyPart, FirstPersonRightRingSocketName) == 0x000350, "Member 'AVRingModularBodyPart::FirstPersonRightRingSocketName' has a wrong offset!");
static_assert(offsetof(AVRingModularBodyPart, FirstPersonLeftRingSocketName) == 0x000358, "Member 'AVRingModularBodyPart::FirstPersonLeftRingSocketName' has a wrong offset!");

// Class Altar.VStandSwimMultiPowerAnimInstance
// 0x0080 (0x0450 - 0x03D0)
class UVStandSwimMultiPowerAnimInstance final : public UVLRPrepareAttackAnimInstance
{
public:
	struct FStandSwimMeleeAttackMultiplePowerSingle AnimSet;                                         // 0x03D0(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStandSwimMultiPowerAnimInstance">();
	}
	static class UVStandSwimMultiPowerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStandSwimMultiPowerAnimInstance>();
	}
};
static_assert(alignof(UVStandSwimMultiPowerAnimInstance) == 0x000010, "Wrong alignment on UVStandSwimMultiPowerAnimInstance");
static_assert(sizeof(UVStandSwimMultiPowerAnimInstance) == 0x000450, "Wrong size on UVStandSwimMultiPowerAnimInstance");
static_assert(offsetof(UVStandSwimMultiPowerAnimInstance, AnimSet) == 0x0003D0, "Member 'UVStandSwimMultiPowerAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VHandsModularBodyPart
// 0x0008 (0x0348 - 0x0340)
class AVHandsModularBodyPart : public AVModularBodyPartBase
{
public:
	bool                                          bShouldHideRings;                                  // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VHandsModularBodyPart">();
	}
	static class AVHandsModularBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVHandsModularBodyPart>();
	}
};
static_assert(alignof(AVHandsModularBodyPart) == 0x000008, "Wrong alignment on AVHandsModularBodyPart");
static_assert(sizeof(AVHandsModularBodyPart) == 0x000348, "Wrong size on AVHandsModularBodyPart");
static_assert(offsetof(AVHandsModularBodyPart, bShouldHideRings) == 0x000340, "Member 'AVHandsModularBodyPart::bShouldHideRings' has a wrong offset!");

// Class Altar.VFeetModularBodyPart
// 0x0000 (0x0340 - 0x0340)
class AVFeetModularBodyPart : public AVModularBodyPartBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VFeetModularBodyPart">();
	}
	static class AVFeetModularBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVFeetModularBodyPart>();
	}
};
static_assert(alignof(AVFeetModularBodyPart) == 0x000008, "Wrong alignment on AVFeetModularBodyPart");
static_assert(sizeof(AVFeetModularBodyPart) == 0x000340, "Wrong size on AVFeetModularBodyPart");

// Class Altar.VAmuletModularBodyPart
// 0x0000 (0x0340 - 0x0340)
class AVAmuletModularBodyPart : public AVModularBodyPartBase
{
public:
	void UpdateChestSnappingAlpha(const float NewAlpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAmuletModularBodyPart">();
	}
	static class AVAmuletModularBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAmuletModularBodyPart>();
	}
};
static_assert(alignof(AVAmuletModularBodyPart) == 0x000008, "Wrong alignment on AVAmuletModularBodyPart");
static_assert(sizeof(AVAmuletModularBodyPart) == 0x000340, "Wrong size on AVAmuletModularBodyPart");

// Class Altar.VMovementSaveData
// 0x00D0 (0x0100 - 0x0030)
class UVMovementSaveData final : public UVBaseAltarSaveData
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FVVelocityAndFallTimerMovementData> VelocityAndFallTimerMovementData;        // 0x0060(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	TMap<uint32, bool>                            IsSneakingMovementData;                            // 0x00B0(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMovementSaveData">();
	}
	static class UVMovementSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVMovementSaveData>();
	}
};
static_assert(alignof(UVMovementSaveData) == 0x000008, "Wrong alignment on UVMovementSaveData");
static_assert(sizeof(UVMovementSaveData) == 0x000100, "Wrong size on UVMovementSaveData");
static_assert(offsetof(UVMovementSaveData, VelocityAndFallTimerMovementData) == 0x000060, "Member 'UVMovementSaveData::VelocityAndFallTimerMovementData' has a wrong offset!");
static_assert(offsetof(UVMovementSaveData, IsSneakingMovementData) == 0x0000B0, "Member 'UVMovementSaveData::IsSneakingMovementData' has a wrong offset!");

// Class Altar.VMusicPlayer
// 0x0050 (0x02E8 - 0x0298)
class AVMusicPlayer final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PlayMusicEvent;                                    // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          PauseMusicEvent;                                   // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          ResumeMusicEvent;                                  // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          StopMusicEvent;                                    // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x28];                                     // 0x02C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadStarted();
	void OnMusicSuccessEnded(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	void PlayMainMenuMusic();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VMusicPlayer">();
	}
	static class AVMusicPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVMusicPlayer>();
	}
};
static_assert(alignof(AVMusicPlayer) == 0x000008, "Wrong alignment on AVMusicPlayer");
static_assert(sizeof(AVMusicPlayer) == 0x0002E8, "Wrong size on AVMusicPlayer");
static_assert(offsetof(AVMusicPlayer, PlayMusicEvent) == 0x0002A0, "Member 'AVMusicPlayer::PlayMusicEvent' has a wrong offset!");
static_assert(offsetof(AVMusicPlayer, PauseMusicEvent) == 0x0002A8, "Member 'AVMusicPlayer::PauseMusicEvent' has a wrong offset!");
static_assert(offsetof(AVMusicPlayer, ResumeMusicEvent) == 0x0002B0, "Member 'AVMusicPlayer::ResumeMusicEvent' has a wrong offset!");
static_assert(offsetof(AVMusicPlayer, StopMusicEvent) == 0x0002B8, "Member 'AVMusicPlayer::StopMusicEvent' has a wrong offset!");

// Class Altar.VNavModifierComponent
// 0x0050 (0x01E0 - 0x0190)
class UVNavModifierComponent final : public UNavModifierComponent
{
public:
	TMap<class UPrimitiveComponent*, bool>        InitialCanEverAffectNavigation;                    // 0x0190(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VNavModifierComponent">();
	}
	static class UVNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVNavModifierComponent>();
	}
};
static_assert(alignof(UVNavModifierComponent) == 0x000010, "Wrong alignment on UVNavModifierComponent");
static_assert(sizeof(UVNavModifierComponent) == 0x0001E0, "Wrong size on UVNavModifierComponent");
static_assert(offsetof(UVNavModifierComponent, InitialCanEverAffectNavigation) == 0x000190, "Member 'UVNavModifierComponent::InitialCanEverAffectNavigation' has a wrong offset!");

// Class Altar.VNegotiateMenuViewModel
// 0x0048 (0x0118 - 0x00D0)
class UVNegotiateMenuViewModel final : public UVViewModelBase
{
public:
	struct FNegotiateMenuInitializationData       InitializationData;                                // 0x00D0(0x0048)(NativeAccessSpecifierPrivate)

public:
	void RegisterSendClickedCancelHandler();
	void RegisterSendConfirmHaggleHandler(int32 HagglePercentValue);

	const struct FNegotiateMenuInitializationData GetInitializationData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VNegotiateMenuViewModel">();
	}
	static class UVNegotiateMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVNegotiateMenuViewModel>();
	}
};
static_assert(alignof(UVNegotiateMenuViewModel) == 0x000008, "Wrong alignment on UVNegotiateMenuViewModel");
static_assert(sizeof(UVNegotiateMenuViewModel) == 0x000118, "Wrong size on UVNegotiateMenuViewModel");
static_assert(offsetof(UVNegotiateMenuViewModel, InitializationData) == 0x0000D0, "Member 'UVNegotiateMenuViewModel::InitializationData' has a wrong offset!");

// Class Altar.VOblivionActivableAnimInstance
// 0x0000 (0x0350 - 0x0350)
class UVOblivionActivableAnimInstance final : public UAnimInstance
{
public:
	class UVAnimationObjectPairingComponent*      LinkedAnimationObjectPairingComponent;             // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOblivionActivableAnimInstance">();
	}
	static class UVOblivionActivableAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOblivionActivableAnimInstance>();
	}
};
static_assert(alignof(UVOblivionActivableAnimInstance) == 0x000010, "Wrong alignment on UVOblivionActivableAnimInstance");
static_assert(sizeof(UVOblivionActivableAnimInstance) == 0x000350, "Wrong size on UVOblivionActivableAnimInstance");
static_assert(offsetof(UVOblivionActivableAnimInstance, LinkedAnimationObjectPairingComponent) == 0x000348, "Member 'UVOblivionActivableAnimInstance::LinkedAnimationObjectPairingComponent' has a wrong offset!");

// Class Altar.VOblivionCharacterAnimInstance
// 0x0030 (0x0380 - 0x0350)
class UVOblivionCharacterAnimInstance final : public UAnimInstance
{
public:
	float                                         AttackChainingPeriod;                              // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAnimationPairingComponent*            LinkedAnimationPairingComponent;                   // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVCharacterStatePairingComponent*       LinkedCombatPairingComponent;                      // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackwardForwardMovementAxis;                       // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeftRightMovementAxis;                             // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRunning;                                        // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCrouching;                                      // 0x0369(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOblivionCombatMoveset                        CombatMoveset;                                     // 0x036A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36B[0x1];                                      // 0x036B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChainedAttackCount;                                // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastAttack;                               // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBlocking;                                       // 0x0374(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPosePairingForced;                                // 0x0375(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_376[0xA];                                      // 0x0376(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationStateChange(const struct FOblivionSourcedCharacterAnimationState& OldState, const struct FOblivionSourcedCharacterAnimationState& NewState);
	void OnAttackStarted();
	void OnCastSpellRanged();
	void OnCastSpellSelf();
	void OnCastSpellTouch();
	void OnEquipStarted();
	void OnJumpStarted();
	void OnLanded();
	void OnUnequipStarted();
	void SetCombatMoveset(EOblivionCombatMoveset Moveset);
	void SetForcePosePairing(bool ForcePosePairing);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOblivionCharacterAnimInstance">();
	}
	static class UVOblivionCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOblivionCharacterAnimInstance>();
	}
};
static_assert(alignof(UVOblivionCharacterAnimInstance) == 0x000010, "Wrong alignment on UVOblivionCharacterAnimInstance");
static_assert(sizeof(UVOblivionCharacterAnimInstance) == 0x000380, "Wrong size on UVOblivionCharacterAnimInstance");
static_assert(offsetof(UVOblivionCharacterAnimInstance, AttackChainingPeriod) == 0x000348, "Member 'UVOblivionCharacterAnimInstance::AttackChainingPeriod' has a wrong offset!");
static_assert(offsetof(UVOblivionCharacterAnimInstance, LinkedAnimationPairingComponent) == 0x000350, "Member 'UVOblivionCharacterAnimInstance::LinkedAnimationPairingComponent' has a wrong offset!");
static_assert(offsetof(UVOblivionCharacterAnimInstance, LinkedCombatPairingComponent) == 0x000358, "Member 'UVOblivionCharacterAnimInstance::LinkedCombatPairingComponent' has a wrong offset!");
static_assert(offsetof(UVOblivionCharacterAnimInstance, BackwardForwardMovementAxis) == 0x000360, "Member 'UVOblivionCharacterAnimInstance::BackwardForwardMovementAxis' has a wrong offset!");
static_assert(offsetof(UVOblivionCharacterAnimInstance, LeftRightMovementAxis) == 0x000364, "Member 'UVOblivionCharacterAnimInstance::LeftRightMovementAxis' has a wrong offset!");
static_assert(offsetof(UVOblivionCharacterAnimInstance, bIsRunning) == 0x000368, "Member 'UVOblivionCharacterAnimInstance::bIsRunning' has a wrong offset!");
static_assert(offsetof(UVOblivionCharacterAnimInstance, bIsCrouching) == 0x000369, "Member 'UVOblivionCharacterAnimInstance::bIsCrouching' has a wrong offset!");
static_assert(offsetof(UVOblivionCharacterAnimInstance, CombatMoveset) == 0x00036A, "Member 'UVOblivionCharacterAnimInstance::CombatMoveset' has a wrong offset!");
static_assert(offsetof(UVOblivionCharacterAnimInstance, ChainedAttackCount) == 0x00036C, "Member 'UVOblivionCharacterAnimInstance::ChainedAttackCount' has a wrong offset!");
static_assert(offsetof(UVOblivionCharacterAnimInstance, TimeSinceLastAttack) == 0x000370, "Member 'UVOblivionCharacterAnimInstance::TimeSinceLastAttack' has a wrong offset!");
static_assert(offsetof(UVOblivionCharacterAnimInstance, bIsBlocking) == 0x000374, "Member 'UVOblivionCharacterAnimInstance::bIsBlocking' has a wrong offset!");
static_assert(offsetof(UVOblivionCharacterAnimInstance, bPosePairingForced) == 0x000375, "Member 'UVOblivionCharacterAnimInstance::bPosePairingForced' has a wrong offset!");

// Class Altar.VOblivionCreatureAnimInstance
// 0x0000 (0x0350 - 0x0350)
class UVOblivionCreatureAnimInstance final : public UAnimInstance
{
public:
	class UVAnimationPairingComponent*            LinkedAnimationPairingComponent;                   // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOblivionCreatureAnimInstance">();
	}
	static class UVOblivionCreatureAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOblivionCreatureAnimInstance>();
	}
};
static_assert(alignof(UVOblivionCreatureAnimInstance) == 0x000010, "Wrong alignment on UVOblivionCreatureAnimInstance");
static_assert(sizeof(UVOblivionCreatureAnimInstance) == 0x000350, "Wrong size on UVOblivionCreatureAnimInstance");
static_assert(offsetof(UVOblivionCreatureAnimInstance, LinkedAnimationPairingComponent) == 0x000348, "Member 'UVOblivionCreatureAnimInstance::LinkedAnimationPairingComponent' has a wrong offset!");

// Class Altar.VOblivionGameInstanceSubSystem
// 0x0080 (0x00B0 - 0x0030)
class UVOblivionGameInstanceSubSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AVTickSynchronizer*                     TickSynchronizer;                                  // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTESSync*                               FormSync;                                          // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ObvUIAltarTex;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ObvTexMainAltarTex;                                // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              ObvUIAltarPPMaterial;                              // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVLevelChangeData*                      LevelChangeData;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CreatureBossDataTable;                             // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             LevelCreatureBossDataTable;                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGarbageCollection();
	void WriteAltarCrashInfos();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOblivionGameInstanceSubSystem">();
	}
	static class UVOblivionGameInstanceSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOblivionGameInstanceSubSystem>();
	}
};
static_assert(alignof(UVOblivionGameInstanceSubSystem) == 0x000008, "Wrong alignment on UVOblivionGameInstanceSubSystem");
static_assert(sizeof(UVOblivionGameInstanceSubSystem) == 0x0000B0, "Wrong size on UVOblivionGameInstanceSubSystem");
static_assert(offsetof(UVOblivionGameInstanceSubSystem, TickSynchronizer) == 0x000050, "Member 'UVOblivionGameInstanceSubSystem::TickSynchronizer' has a wrong offset!");
static_assert(offsetof(UVOblivionGameInstanceSubSystem, FormSync) == 0x000058, "Member 'UVOblivionGameInstanceSubSystem::FormSync' has a wrong offset!");
static_assert(offsetof(UVOblivionGameInstanceSubSystem, ObvUIAltarTex) == 0x000060, "Member 'UVOblivionGameInstanceSubSystem::ObvUIAltarTex' has a wrong offset!");
static_assert(offsetof(UVOblivionGameInstanceSubSystem, ObvTexMainAltarTex) == 0x000068, "Member 'UVOblivionGameInstanceSubSystem::ObvTexMainAltarTex' has a wrong offset!");
static_assert(offsetof(UVOblivionGameInstanceSubSystem, ObvUIAltarPPMaterial) == 0x000070, "Member 'UVOblivionGameInstanceSubSystem::ObvUIAltarPPMaterial' has a wrong offset!");
static_assert(offsetof(UVOblivionGameInstanceSubSystem, LevelChangeData) == 0x000078, "Member 'UVOblivionGameInstanceSubSystem::LevelChangeData' has a wrong offset!");
static_assert(offsetof(UVOblivionGameInstanceSubSystem, CreatureBossDataTable) == 0x000080, "Member 'UVOblivionGameInstanceSubSystem::CreatureBossDataTable' has a wrong offset!");
static_assert(offsetof(UVOblivionGameInstanceSubSystem, LevelCreatureBossDataTable) == 0x000088, "Member 'UVOblivionGameInstanceSubSystem::LevelCreatureBossDataTable' has a wrong offset!");

// Class Altar.VOblivionGate
// 0x0018 (0x0418 - 0x0400)
class AVOblivionGate final : public AVDoor
{
public:
	float                                         MinPlayerToOblivionGateDistance;                   // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayerToOblivionGateDistance;                   // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVDynamicNavAreaRebuilderComponent*     DynamicNavAreaRebuilderComponent;                  // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDisabled();
	void OnEnabled();
	void RegisterToPlayer();
	void UnregisterFromPlayer();

	bool ShouldComputeDistanceWithPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOblivionGate">();
	}
	static class AVOblivionGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVOblivionGate>();
	}
};
static_assert(alignof(AVOblivionGate) == 0x000008, "Wrong alignment on AVOblivionGate");
static_assert(sizeof(AVOblivionGate) == 0x000418, "Wrong size on AVOblivionGate");
static_assert(offsetof(AVOblivionGate, MinPlayerToOblivionGateDistance) == 0x000400, "Member 'AVOblivionGate::MinPlayerToOblivionGateDistance' has a wrong offset!");
static_assert(offsetof(AVOblivionGate, MaxPlayerToOblivionGateDistance) == 0x000404, "Member 'AVOblivionGate::MaxPlayerToOblivionGateDistance' has a wrong offset!");
static_assert(offsetof(AVOblivionGate, DynamicNavAreaRebuilderComponent) == 0x000410, "Member 'AVOblivionGate::DynamicNavAreaRebuilderComponent' has a wrong offset!");

// Class Altar.VOblivionPlayerCharacter
// 0x02B0 (0x1290 - 0x0FE0)
class AVOblivionPlayerCharacter : public AVPairedCharacter
{
public:
	class AVInventoryPlayerCharacter*             InventoryCharacterReference;                       // 0x0FE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelekinesisDistance;                               // 0x0FE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelekinesisDuration;                               // 0x0FEC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF0[0x18];                                     // 0x0FF0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USpringArmComponent*                    CharacterCustomizationCameraSpringArm;             // 0x1008(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarSpringArmComponent*              FirstPersonCameraSpringArmComponent;               // 0x1010(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarSpringArmComponent*              ThirdPersonCameraSpringArmComponent;               // 0x1018(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraBoneName;                                    // 0x1020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UVTESObjectRefComponent* OldRef, class UVTESObjectRefComponent* NewRef)> OnCachedLastHitObjectREFComponent; // 0x1028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<EMagicSchool, class UAkAudioEvent*>      SpellCastFailedSounds;                             // 0x1038(0x0050)(Edit, BlueprintVisible, EditFixedSize, NativeAccessSpecifierPublic)
	uint8                                         Pad_1088[0x1];                                     // 0x1088(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsFacingObject;                                   // 0x1089(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108A[0x6];                                     // 0x108A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           FPSClippingFixGlobalParameters;                    // 0x1090(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         FPSClippingFixAverageFilterSize;                   // 0x1098(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1099[0x3];                                     // 0x1099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FPSClippingFixWallDetectionRadius;                 // 0x109C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FPSClippingSSSWWorldUnitScaleFacingWall;           // 0x10A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A4[0x7C];                                    // 0x10A4(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsUsingFirstPersonMesh;                           // 0x1120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1121[0x7];                                     // 0x1121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponentBudgeted*         FirstPersonSkeletalMeshComponent;                  // 0x1128(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        FirstPersonSkeletalMeshRoot;                       // 0x1130(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   FirstPersonUpperBodyChildActorComponent;           // 0x1138(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   FirstPersonHandsChildActorComponent;               // 0x1140(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   FirstPersonRightRingChildActorComponent;           // 0x1148(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   FirstPersonLeftRingChildActorComponent;            // 0x1150(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1158[0x10];                                    // 0x1158(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           AimRaycastTimerHandle;                             // 0x1168(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           PickRaycastTimerHandle;                            // 0x1170(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           CloseToOblivionGateTimerHandle;                    // 0x1178(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVGrabArmComponent*                     GrabArmComponent;                                  // 0x1180(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             LastHitResult;                                     // 0x1188(0x00E8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint32                                        FirstPersonSectionBitMask;                         // 0x1270(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerFPSMeshBeingMadeVisible;                  // 0x1274(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1275[0x1B];                                    // 0x1275(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UVTESObjectRefComponent* GetLastHitObjectRefComponent();
	void OnChangeLevel();
	void OnEndGrabAction();
	void OnEndTelekinesisAction();
	void OnEndTelekinesisPullAction();
	void OnEndTelekinesisPushAction();
	void OnEnterUnderwater();
	void OnEnterWaterSurface();
	void OnExitUnderwater();
	void OnExitWaterSurface();
	void OnGameplayCameraContextChanged(EGameplayCameraContext GameplayCameraContext);
	void OnGameplayCameraFocusOnPoint(const struct FVector& FromPosition, const struct FVector& ToPosition);
	void OnPlayFailCastSound(EMagicSchool MagicSchool);
	void OnQuiverChanged(const class AVQuiver* QuiverActor, bool bEquipping);
	bool OnStartGrabAction();
	bool OnStartTelekinesisAction();
	void OnStartTelekinesisPullAction();
	void OnStartTelekinesisPushAction();
	void OnTorchChanged(const class AActor* TorchActor, bool bEquipping);
	void RefreshFPSClippingFixFirstPersonBody(bool bShoudForceRefresh);
	void ResetInstance();
	void SetLastHitObjectRefComponent(class UVTESObjectRefComponent* Component);
	void SetUseBowAimingRotation(bool bUseBowRotation);

	bool CanTryInteract() const;
	class AVInventoryPlayerCharacter* GetInventoryPlayer() const;
	class FString GetSubLevelName() const;
	void RequestPowerAttack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOblivionPlayerCharacter">();
	}
	static class AVOblivionPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVOblivionPlayerCharacter>();
	}
};
static_assert(alignof(AVOblivionPlayerCharacter) == 0x000010, "Wrong alignment on AVOblivionPlayerCharacter");
static_assert(sizeof(AVOblivionPlayerCharacter) == 0x001290, "Wrong size on AVOblivionPlayerCharacter");
static_assert(offsetof(AVOblivionPlayerCharacter, InventoryCharacterReference) == 0x000FE0, "Member 'AVOblivionPlayerCharacter::InventoryCharacterReference' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, TelekinesisDistance) == 0x000FE8, "Member 'AVOblivionPlayerCharacter::TelekinesisDistance' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, TelekinesisDuration) == 0x000FEC, "Member 'AVOblivionPlayerCharacter::TelekinesisDuration' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, CharacterCustomizationCameraSpringArm) == 0x001008, "Member 'AVOblivionPlayerCharacter::CharacterCustomizationCameraSpringArm' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FirstPersonCameraSpringArmComponent) == 0x001010, "Member 'AVOblivionPlayerCharacter::FirstPersonCameraSpringArmComponent' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, ThirdPersonCameraSpringArmComponent) == 0x001018, "Member 'AVOblivionPlayerCharacter::ThirdPersonCameraSpringArmComponent' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, CameraBoneName) == 0x001020, "Member 'AVOblivionPlayerCharacter::CameraBoneName' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, OnCachedLastHitObjectREFComponent) == 0x001028, "Member 'AVOblivionPlayerCharacter::OnCachedLastHitObjectREFComponent' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, SpellCastFailedSounds) == 0x001038, "Member 'AVOblivionPlayerCharacter::SpellCastFailedSounds' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, bIsFacingObject) == 0x001089, "Member 'AVOblivionPlayerCharacter::bIsFacingObject' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FPSClippingFixGlobalParameters) == 0x001090, "Member 'AVOblivionPlayerCharacter::FPSClippingFixGlobalParameters' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FPSClippingFixAverageFilterSize) == 0x001098, "Member 'AVOblivionPlayerCharacter::FPSClippingFixAverageFilterSize' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FPSClippingFixWallDetectionRadius) == 0x00109C, "Member 'AVOblivionPlayerCharacter::FPSClippingFixWallDetectionRadius' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FPSClippingSSSWWorldUnitScaleFacingWall) == 0x0010A0, "Member 'AVOblivionPlayerCharacter::FPSClippingSSSWWorldUnitScaleFacingWall' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, bIsUsingFirstPersonMesh) == 0x001120, "Member 'AVOblivionPlayerCharacter::bIsUsingFirstPersonMesh' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FirstPersonSkeletalMeshComponent) == 0x001128, "Member 'AVOblivionPlayerCharacter::FirstPersonSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FirstPersonSkeletalMeshRoot) == 0x001130, "Member 'AVOblivionPlayerCharacter::FirstPersonSkeletalMeshRoot' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FirstPersonUpperBodyChildActorComponent) == 0x001138, "Member 'AVOblivionPlayerCharacter::FirstPersonUpperBodyChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FirstPersonHandsChildActorComponent) == 0x001140, "Member 'AVOblivionPlayerCharacter::FirstPersonHandsChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FirstPersonRightRingChildActorComponent) == 0x001148, "Member 'AVOblivionPlayerCharacter::FirstPersonRightRingChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FirstPersonLeftRingChildActorComponent) == 0x001150, "Member 'AVOblivionPlayerCharacter::FirstPersonLeftRingChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, AimRaycastTimerHandle) == 0x001168, "Member 'AVOblivionPlayerCharacter::AimRaycastTimerHandle' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, PickRaycastTimerHandle) == 0x001170, "Member 'AVOblivionPlayerCharacter::PickRaycastTimerHandle' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, CloseToOblivionGateTimerHandle) == 0x001178, "Member 'AVOblivionPlayerCharacter::CloseToOblivionGateTimerHandle' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, GrabArmComponent) == 0x001180, "Member 'AVOblivionPlayerCharacter::GrabArmComponent' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, LastHitResult) == 0x001188, "Member 'AVOblivionPlayerCharacter::LastHitResult' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, FirstPersonSectionBitMask) == 0x001270, "Member 'AVOblivionPlayerCharacter::FirstPersonSectionBitMask' has a wrong offset!");
static_assert(offsetof(AVOblivionPlayerCharacter, bIsPlayerFPSMeshBeingMadeVisible) == 0x001274, "Member 'AVOblivionPlayerCharacter::bIsPlayerFPSMeshBeingMadeVisible' has a wrong offset!");

// Class Altar.VOblivionPosePairingAnimInstance
// 0x0000 (0x0350 - 0x0350)
class UVOblivionPosePairingAnimInstance final : public UAnimInstance
{
public:
	class UVAnimationObjectPairingComponent*      LinkedAnimationObjectPairingComponent;             // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOblivionPosePairingAnimInstance">();
	}
	static class UVOblivionPosePairingAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOblivionPosePairingAnimInstance>();
	}
};
static_assert(alignof(UVOblivionPosePairingAnimInstance) == 0x000010, "Wrong alignment on UVOblivionPosePairingAnimInstance");
static_assert(sizeof(UVOblivionPosePairingAnimInstance) == 0x000350, "Wrong size on UVOblivionPosePairingAnimInstance");
static_assert(offsetof(UVOblivionPosePairingAnimInstance, LinkedAnimationObjectPairingComponent) == 0x000348, "Member 'UVOblivionPosePairingAnimInstance::LinkedAnimationObjectPairingComponent' has a wrong offset!");

// Class Altar.VOblivionRuntimeSettings
// 0x0F78 (0x0FA0 - 0x0028)
class UVOblivionRuntimeSettings final : public UObject
{
public:
	struct FDirectoryPath                         OblivionCustomRootDataFolder;                      // 0x0028(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDirectoryPath                         OblivionCustomRootDataFolderEditor;                // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDirectoryPath                         OblivionCustomRootDataFolderXSX;                   // 0x0048(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDirectoryPath                         OblivionCustomRootDataFolderPS5;                   // 0x0058(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 StatusEffectComponentClass;                        // 0x0068(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStatusEffectVfxInInventory;                     // 0x0070(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   BloodVFXBlueprintClass;                            // 0x0078(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DeathVFXBlueprintClass;                            // 0x00A0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SparkOnBlockWeaponSocket;                          // 0x00C8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SparkOnBlockShieldSocket;                          // 0x00D0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableReversePairingExperimentalMap;              // 0x00D8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DefaultCharacterPhysicsAsset;                      // 0x00E0(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPhysicsDebugTraceRadiusRange;               // 0x0100(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PhysicsDebugPanelWidgetClass;                      // 0x0108(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PhysicsDebugPanelDrawSize;                         // 0x0130(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PhysicsDebugPanelScale;                            // 0x0140(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsDebugPanelArcAngle;                         // 0x0158(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsDebugPanelDistanceFromGround;               // 0x015C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsDebugPanelDistanceFromPlayer;               // 0x0160(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsDebugPanelMessageDuration;                  // 0x0164(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 PhysicsDebugPanelMessageColor;                     // 0x0168(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        PhysicsDebugPanelMaterial;                         // 0x0170(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PhysicsDebugTargetOverlayMaterial;                 // 0x0190(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SimulatingDefaultPhysicalMaterial;                 // 0x01B0(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseUnrealProjectilePhysics;                       // 0x01D0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArrowGravityScale;                                 // 0x01D4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowWaterDragFactor;                              // 0x01D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ArrowBoxesRotationEuler;                           // 0x01E0(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArrowHitBoxPosition;                               // 0x01F8(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowDurationAfterCollideForPlayer;                // 0x0210(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowDurationAfterCollideForPawns;                 // 0x0214(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowDurationAfterCollideForEnv;                   // 0x0218(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushedPawnReferenceMass;                           // 0x021C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushingGeometryCollectionReferenceMass;            // 0x0220(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMovePushForce;                                 // 0x0224(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIToPlayerPushForceMult;                           // 0x0228(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIInCombatToPlayerPushForceMult;                   // 0x022C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerToAIPushForceMult;                           // 0x0230(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingPushForceMultiplier;                        // 0x0234(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePawnPhysicsInteractionSubsystem;               // 0x0238(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ImpactSystemDataTable;                             // 0x0240(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalEnvironmentImpactHitForceMultiplier;         // 0x0260(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpellEnvironmentExplosionRadius;                   // 0x0264(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpellEnvironmentExplosionForceMultiplier;          // 0x0268(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SFXSystemDataTable;                                // 0x0270(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LevelWeatherTextureDataTable;                      // 0x0290(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalCollisionSoundCooldown;                    // 0x02B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalCollisionSoundMinVelocityThreshold;        // 0x02B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalCollisionSoundMaxVelocityThreshold;        // 0x02B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnteringSplashSoundMinVelocityThreshold;           // 0x02BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnteringSplashSoundMinDistanceBodyRatio;           // 0x02C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterFollowerInnerRadius;                          // 0x02C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterSoundFollowerOuterRadius;                     // 0x02C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        WeaponSneakDamageMultiplierDataTable;              // 0x02D0(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EffectChameleon;                                   // 0x02F0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EffectInvisibility;                                // 0x0318(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EffectNightEye;                                    // 0x0340(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EffectDarkness;                                    // 0x0368(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EffectLight;                                       // 0x0390(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EffectClairvoyanceBP;                              // 0x03B8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowClairvoyanceDebugPoints;                      // 0x03E0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MaxDistanceBetweenClairvoyancePoints;              // 0x03E8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ClairvoyanceMaxRange;                              // 0x03F0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ClairvoyanceSearchRadius;                          // 0x03F8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ClairvoyanceDefaultDistance;                       // 0x0400(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ClairvoyanceFirstPointDistance;                    // 0x0408(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClairvoyanceNodeName;                              // 0x0410(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultStateMachineClass;                          // 0x0418(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AttackSpeedDependentAnimTags;                      // 0x0440(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultCharacterBehaviorMap;                       // 0x0460(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultCreatureBehaviorMap;                        // 0x0488(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultPawnBehaviorMap;                            // 0x04B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlaceholderMeleeWeaponClass;                       // 0x04D8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlaceholderOneHandedSwordClass;                    // 0x0500(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlaceholderBowClass;                               // 0x0528(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlaceholderStaffClass;                             // 0x0550(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlaceholderShieldClass;                            // 0x0578(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TorchClass;                                        // 0x05A0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultEquippedQuiverClass;                        // 0x05C8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultDroppedAmmoClass;                           // 0x05F0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultFiredAmmoClass;                             // 0x0618(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVCharacterPhenotypePreset> DefaultPhenotypePreset;                         // 0x0640(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           PlaceholderFullBody;                               // 0x0668(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CharacterGenericClass;                             // 0x0690(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   InventoryPlayerClass;                              // 0x06B8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimBlueprint>          CharacterAnimationBlueprint;                       // 0x06E0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimBlueprint>          FirstPersonCharacterAnimationBlueprint;            // 0x0708(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DefaultFacialAnimation;                            // 0x0730(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimBlueprint>          HairAnimationBlueprint;                            // 0x0750(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HelmetPlaceholder;                                 // 0x0778(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AmuletPlaceholder;                                 // 0x07A0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RingPlaceholder;                                   // 0x07C8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   UpperBodyPlaceholder;                              // 0x07F0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HandsPlaceholder;                                  // 0x0818(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   LowerBodyPlaceholder;                              // 0x0840(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FeetPlaceholder;                                   // 0x0868(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             DefaultDirectionalSpeedCurve;                      // 0x0890(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             DefaultRotationSpeedCurve;                         // 0x08B8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterLocomotionDebugArrowLength;               // 0x08E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterLocomotionDebugArrowHeadSize;             // 0x08E4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterLocomotionDebugArrowThickness;            // 0x08E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8EC[0x4];                                      // 0x08EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NiagaraUserVariableIdentifier;                     // 0x08F0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AIControllerClass;                                 // 0x0900(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AIDebugWidgetBlueprint;                            // 0x0928(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AIProcedureDebugWidgetBlueprint;                   // 0x0950(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTESForm>>        LandmarkStaticForms;                               // 0x0978(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector                                LandmarkMetaClusterProjectionExtent;               // 0x0988(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EntityDetailsDebugWidgetBlueprint;                 // 0x09A0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultPropSocket;                                 // 0x09C8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultBookBlueprintClass;                         // 0x09D0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CraftedPotionClass;                                // 0x09F8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CraftedPoisonClass;                                // 0x0A20(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CreatureBossDataTable;                             // 0x0A48(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LevelCreatureBossDataTable;                        // 0x0A68(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CorpseDefaultAnimPoseDatatable;                    // 0x0A88(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CorpseDefaultPhysicPoseDatatable;                  // 0x0AA8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              DefaultCameraSettingsTable;                        // 0x0AC8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ArmsRotationDependentAnimTags;                     // 0x0AF0(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         MaxBlendTime;                                      // 0x0B10(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B14[0x4];                                      // 0x0B14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             CameraBlendLocationCurve;                          // 0x0B18(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             ConvertPlayerSensitivityCurve;                     // 0x0B40(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVCameraShake>                  CameraShakeThirdPersonHorse;                       // 0x0B68(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FVCameraShake>                  CameraShakeFirstPerson;                            // 0x0B78(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FVCameraShake>                  CameraShakeThirdPerson;                            // 0x0B88(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         FirstPersonViewSensitivity;                        // 0x0B98(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonViewSensitivity;                        // 0x0B9C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             StickSmoothingCurve;                               // 0x0BA0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstPersonCameraHorizontalSensitivityScale;       // 0x0BC8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonCameraHorizontalSensitivityScale;       // 0x0BCC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstPersonCameraVerticalSensitivityScale;         // 0x0BD0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonCameraVerticalSensitivityScale;         // 0x0BD4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimSlowdownEntityMinRange;                         // 0x0BD8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BDC[0x4];                                      // 0x0BDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AimSlowdownPlayerStateList;                        // 0x0BE0(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         AimSlowdownTraceStartRadius;                       // 0x0C00(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimSlowdownTraceEndRadius;                         // 0x0C04(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             AimSlowdownEntityCurve;                            // 0x0C08(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             AimSlowdownItemCurve;                              // 0x0C30(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimSlowdownDistMin;                                // 0x0C58(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimSlowdownDistMax;                                // 0x0C5C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimSlowdownAddedDistBetweenSpheres;                // 0x0C60(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimSlowdownSmoothingIntensity;                     // 0x0C64(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultMeleeHitboxExtent;                          // 0x0C68(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InputActionTagToRemoveOnUISwitch;                  // 0x0C80(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         DismountMinimalHeightDistance;                     // 0x0CA0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHorseAutoAlignCameraEnabled;                    // 0x0CA4(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA5[0x3];                                      // 0x0CA5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagsAllowingHorseFirstPerson;                      // 0x0CA8(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsThatShouldIgnoreInputs;                        // 0x0CC8(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEnvQuery>               SummonLocationEnvironmentQuery;                    // 0x0CE8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PawnSpawnLocationOffset;                           // 0x0D10(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVAltarCompressionMethod                      CompressionMethod;                                 // 0x0D28(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Version;                                           // 0x0D2C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ThumbnailResolution;                               // 0x0D30(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfAutoSaves;                                 // 0x0D40(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePlayerFacialCustomisationSave;              // 0x0D44(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D45[0x3];                                      // 0x0D45(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BowAimingVectorLength;                             // 0x0D48(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4C[0x4];                                      // 0x0D4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      MissingPrePlacedActorMaterial;                     // 0x0D50(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStringTable>            CellToMapPathStringTable;                          // 0x0D78(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHitReactDebug;                                // 0x0DA0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHitReactDirectionFromAnimation;                // 0x0DA1(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA2[0x6];                                      // 0x0DA2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AltarPrePlacedGuidToCellAsyncFlowHashDataTable;    // 0x0DA8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AltarSEWorldPrePlacedGuidToCellAsyncFlowHashDataTable; // 0x0DC8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AltarTamrielPrePlacedNotSpatiallyLoadedDataTable;  // 0x0DE8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AltarSEWorldPrePlacedNotSpatiallyLoadedDataTable;  // 0x0E08(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPhysicalMaterial>       WaterPhysicalMaterial;                             // 0x0E28(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPhysicalMaterial>       LavaPhysicalMaterial;                              // 0x0E50(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TrailVFXBlueprintClass;                            // 0x0E78(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVSkillLevel                                  TrailVFX_NeededLevelForSkillBladeNormal;           // 0x0EA0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVSkillLevel                                  TrailVFX_NeededLevelForSkillBluntNormal;           // 0x0EA1(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVSkillLevel                                  TrailVFX_NeededLevelForSkillHandToHandNormal;      // 0x0EA2(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVSkillLevel                                  TrailVFX_NeededLevelForSkillBladePower;            // 0x0EA3(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVSkillLevel                                  TrailVFX_NeededLevelForSkillBluntPower;            // 0x0EA4(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVSkillLevel                                  TrailVFX_NeededLevelForSkillHandToHandPower;       // 0x0EA5(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA6[0x2];                                      // 0x0EA6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           NoLumenWaterReflectionMapsXSS;                     // 0x0EA8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FName>                           FixDialogueFaceShadowsMapList;                     // 0x0EB8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           BehaviorMapsToPreload;                             // 0x0EC8(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	double                                        MaxLedgeHeight;                                    // 0x0ED8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxLedgeHeightIncrement;                           // 0x0EE0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxLedgeLength;                                    // 0x0EE8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxLedgeCrossingSpeed;                             // 0x0EF0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<TSoftClassPtr<class UClass>>             IgnoreMaxLedgeHeightNavAreas;                      // 0x0EF8(0x0050)(Edit, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WaterNavAreaClass;                                 // 0x0F48(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ShallowWaterNavAreaClass;                          // 0x0F70(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrashDataUpdatesPerSecond;                         // 0x0F98(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9C[0x4];                                      // 0x0F9C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOblivionRuntimeSettings">();
	}
	static class UVOblivionRuntimeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOblivionRuntimeSettings>();
	}
};
static_assert(alignof(UVOblivionRuntimeSettings) == 0x000008, "Wrong alignment on UVOblivionRuntimeSettings");
static_assert(sizeof(UVOblivionRuntimeSettings) == 0x000FA0, "Wrong size on UVOblivionRuntimeSettings");
static_assert(offsetof(UVOblivionRuntimeSettings, OblivionCustomRootDataFolder) == 0x000028, "Member 'UVOblivionRuntimeSettings::OblivionCustomRootDataFolder' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, OblivionCustomRootDataFolderEditor) == 0x000038, "Member 'UVOblivionRuntimeSettings::OblivionCustomRootDataFolderEditor' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, OblivionCustomRootDataFolderXSX) == 0x000048, "Member 'UVOblivionRuntimeSettings::OblivionCustomRootDataFolderXSX' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, OblivionCustomRootDataFolderPS5) == 0x000058, "Member 'UVOblivionRuntimeSettings::OblivionCustomRootDataFolderPS5' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, StatusEffectComponentClass) == 0x000068, "Member 'UVOblivionRuntimeSettings::StatusEffectComponentClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, bIsStatusEffectVfxInInventory) == 0x000070, "Member 'UVOblivionRuntimeSettings::bIsStatusEffectVfxInInventory' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, BloodVFXBlueprintClass) == 0x000078, "Member 'UVOblivionRuntimeSettings::BloodVFXBlueprintClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DeathVFXBlueprintClass) == 0x0000A0, "Member 'UVOblivionRuntimeSettings::DeathVFXBlueprintClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, SparkOnBlockWeaponSocket) == 0x0000C8, "Member 'UVOblivionRuntimeSettings::SparkOnBlockWeaponSocket' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, SparkOnBlockShieldSocket) == 0x0000D0, "Member 'UVOblivionRuntimeSettings::SparkOnBlockShieldSocket' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, bEnableReversePairingExperimentalMap) == 0x0000D8, "Member 'UVOblivionRuntimeSettings::bEnableReversePairingExperimentalMap' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultCharacterPhysicsAsset) == 0x0000E0, "Member 'UVOblivionRuntimeSettings::DefaultCharacterPhysicsAsset' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultPhysicsDebugTraceRadiusRange) == 0x000100, "Member 'UVOblivionRuntimeSettings::DefaultPhysicsDebugTraceRadiusRange' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicsDebugPanelWidgetClass) == 0x000108, "Member 'UVOblivionRuntimeSettings::PhysicsDebugPanelWidgetClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicsDebugPanelDrawSize) == 0x000130, "Member 'UVOblivionRuntimeSettings::PhysicsDebugPanelDrawSize' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicsDebugPanelScale) == 0x000140, "Member 'UVOblivionRuntimeSettings::PhysicsDebugPanelScale' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicsDebugPanelArcAngle) == 0x000158, "Member 'UVOblivionRuntimeSettings::PhysicsDebugPanelArcAngle' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicsDebugPanelDistanceFromGround) == 0x00015C, "Member 'UVOblivionRuntimeSettings::PhysicsDebugPanelDistanceFromGround' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicsDebugPanelDistanceFromPlayer) == 0x000160, "Member 'UVOblivionRuntimeSettings::PhysicsDebugPanelDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicsDebugPanelMessageDuration) == 0x000164, "Member 'UVOblivionRuntimeSettings::PhysicsDebugPanelMessageDuration' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicsDebugPanelMessageColor) == 0x000168, "Member 'UVOblivionRuntimeSettings::PhysicsDebugPanelMessageColor' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicsDebugPanelMaterial) == 0x000170, "Member 'UVOblivionRuntimeSettings::PhysicsDebugPanelMaterial' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicsDebugTargetOverlayMaterial) == 0x000190, "Member 'UVOblivionRuntimeSettings::PhysicsDebugTargetOverlayMaterial' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, SimulatingDefaultPhysicalMaterial) == 0x0001B0, "Member 'UVOblivionRuntimeSettings::SimulatingDefaultPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, bUseUnrealProjectilePhysics) == 0x0001D0, "Member 'UVOblivionRuntimeSettings::bUseUnrealProjectilePhysics' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ArrowGravityScale) == 0x0001D4, "Member 'UVOblivionRuntimeSettings::ArrowGravityScale' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ArrowWaterDragFactor) == 0x0001D8, "Member 'UVOblivionRuntimeSettings::ArrowWaterDragFactor' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ArrowBoxesRotationEuler) == 0x0001E0, "Member 'UVOblivionRuntimeSettings::ArrowBoxesRotationEuler' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ArrowHitBoxPosition) == 0x0001F8, "Member 'UVOblivionRuntimeSettings::ArrowHitBoxPosition' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ArrowDurationAfterCollideForPlayer) == 0x000210, "Member 'UVOblivionRuntimeSettings::ArrowDurationAfterCollideForPlayer' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ArrowDurationAfterCollideForPawns) == 0x000214, "Member 'UVOblivionRuntimeSettings::ArrowDurationAfterCollideForPawns' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ArrowDurationAfterCollideForEnv) == 0x000218, "Member 'UVOblivionRuntimeSettings::ArrowDurationAfterCollideForEnv' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PushedPawnReferenceMass) == 0x00021C, "Member 'UVOblivionRuntimeSettings::PushedPawnReferenceMass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PushingGeometryCollectionReferenceMass) == 0x000220, "Member 'UVOblivionRuntimeSettings::PushingGeometryCollectionReferenceMass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, BaseMovePushForce) == 0x000224, "Member 'UVOblivionRuntimeSettings::BaseMovePushForce' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AIToPlayerPushForceMult) == 0x000228, "Member 'UVOblivionRuntimeSettings::AIToPlayerPushForceMult' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AIInCombatToPlayerPushForceMult) == 0x00022C, "Member 'UVOblivionRuntimeSettings::AIInCombatToPlayerPushForceMult' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PlayerToAIPushForceMult) == 0x000230, "Member 'UVOblivionRuntimeSettings::PlayerToAIPushForceMult' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, FallingPushForceMultiplier) == 0x000234, "Member 'UVOblivionRuntimeSettings::FallingPushForceMultiplier' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, bUsePawnPhysicsInteractionSubsystem) == 0x000238, "Member 'UVOblivionRuntimeSettings::bUsePawnPhysicsInteractionSubsystem' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ImpactSystemDataTable) == 0x000240, "Member 'UVOblivionRuntimeSettings::ImpactSystemDataTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, GlobalEnvironmentImpactHitForceMultiplier) == 0x000260, "Member 'UVOblivionRuntimeSettings::GlobalEnvironmentImpactHitForceMultiplier' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, SpellEnvironmentExplosionRadius) == 0x000264, "Member 'UVOblivionRuntimeSettings::SpellEnvironmentExplosionRadius' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, SpellEnvironmentExplosionForceMultiplier) == 0x000268, "Member 'UVOblivionRuntimeSettings::SpellEnvironmentExplosionForceMultiplier' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, SFXSystemDataTable) == 0x000270, "Member 'UVOblivionRuntimeSettings::SFXSystemDataTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, LevelWeatherTextureDataTable) == 0x000290, "Member 'UVOblivionRuntimeSettings::LevelWeatherTextureDataTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicalCollisionSoundCooldown) == 0x0002B0, "Member 'UVOblivionRuntimeSettings::PhysicalCollisionSoundCooldown' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicalCollisionSoundMinVelocityThreshold) == 0x0002B4, "Member 'UVOblivionRuntimeSettings::PhysicalCollisionSoundMinVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PhysicalCollisionSoundMaxVelocityThreshold) == 0x0002B8, "Member 'UVOblivionRuntimeSettings::PhysicalCollisionSoundMaxVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, EnteringSplashSoundMinVelocityThreshold) == 0x0002BC, "Member 'UVOblivionRuntimeSettings::EnteringSplashSoundMinVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, EnteringSplashSoundMinDistanceBodyRatio) == 0x0002C0, "Member 'UVOblivionRuntimeSettings::EnteringSplashSoundMinDistanceBodyRatio' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, WaterFollowerInnerRadius) == 0x0002C4, "Member 'UVOblivionRuntimeSettings::WaterFollowerInnerRadius' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, WaterSoundFollowerOuterRadius) == 0x0002C8, "Member 'UVOblivionRuntimeSettings::WaterSoundFollowerOuterRadius' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, WeaponSneakDamageMultiplierDataTable) == 0x0002D0, "Member 'UVOblivionRuntimeSettings::WeaponSneakDamageMultiplierDataTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, EffectChameleon) == 0x0002F0, "Member 'UVOblivionRuntimeSettings::EffectChameleon' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, EffectInvisibility) == 0x000318, "Member 'UVOblivionRuntimeSettings::EffectInvisibility' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, EffectNightEye) == 0x000340, "Member 'UVOblivionRuntimeSettings::EffectNightEye' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, EffectDarkness) == 0x000368, "Member 'UVOblivionRuntimeSettings::EffectDarkness' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, EffectLight) == 0x000390, "Member 'UVOblivionRuntimeSettings::EffectLight' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, EffectClairvoyanceBP) == 0x0003B8, "Member 'UVOblivionRuntimeSettings::EffectClairvoyanceBP' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, bShowClairvoyanceDebugPoints) == 0x0003E0, "Member 'UVOblivionRuntimeSettings::bShowClairvoyanceDebugPoints' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, MaxDistanceBetweenClairvoyancePoints) == 0x0003E8, "Member 'UVOblivionRuntimeSettings::MaxDistanceBetweenClairvoyancePoints' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ClairvoyanceMaxRange) == 0x0003F0, "Member 'UVOblivionRuntimeSettings::ClairvoyanceMaxRange' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ClairvoyanceSearchRadius) == 0x0003F8, "Member 'UVOblivionRuntimeSettings::ClairvoyanceSearchRadius' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ClairvoyanceDefaultDistance) == 0x000400, "Member 'UVOblivionRuntimeSettings::ClairvoyanceDefaultDistance' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ClairvoyanceFirstPointDistance) == 0x000408, "Member 'UVOblivionRuntimeSettings::ClairvoyanceFirstPointDistance' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ClairvoyanceNodeName) == 0x000410, "Member 'UVOblivionRuntimeSettings::ClairvoyanceNodeName' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultStateMachineClass) == 0x000418, "Member 'UVOblivionRuntimeSettings::DefaultStateMachineClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AttackSpeedDependentAnimTags) == 0x000440, "Member 'UVOblivionRuntimeSettings::AttackSpeedDependentAnimTags' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultCharacterBehaviorMap) == 0x000460, "Member 'UVOblivionRuntimeSettings::DefaultCharacterBehaviorMap' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultCreatureBehaviorMap) == 0x000488, "Member 'UVOblivionRuntimeSettings::DefaultCreatureBehaviorMap' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultPawnBehaviorMap) == 0x0004B0, "Member 'UVOblivionRuntimeSettings::DefaultPawnBehaviorMap' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PlaceholderMeleeWeaponClass) == 0x0004D8, "Member 'UVOblivionRuntimeSettings::PlaceholderMeleeWeaponClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PlaceholderOneHandedSwordClass) == 0x000500, "Member 'UVOblivionRuntimeSettings::PlaceholderOneHandedSwordClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PlaceholderBowClass) == 0x000528, "Member 'UVOblivionRuntimeSettings::PlaceholderBowClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PlaceholderStaffClass) == 0x000550, "Member 'UVOblivionRuntimeSettings::PlaceholderStaffClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PlaceholderShieldClass) == 0x000578, "Member 'UVOblivionRuntimeSettings::PlaceholderShieldClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, TorchClass) == 0x0005A0, "Member 'UVOblivionRuntimeSettings::TorchClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultEquippedQuiverClass) == 0x0005C8, "Member 'UVOblivionRuntimeSettings::DefaultEquippedQuiverClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultDroppedAmmoClass) == 0x0005F0, "Member 'UVOblivionRuntimeSettings::DefaultDroppedAmmoClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultFiredAmmoClass) == 0x000618, "Member 'UVOblivionRuntimeSettings::DefaultFiredAmmoClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultPhenotypePreset) == 0x000640, "Member 'UVOblivionRuntimeSettings::DefaultPhenotypePreset' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PlaceholderFullBody) == 0x000668, "Member 'UVOblivionRuntimeSettings::PlaceholderFullBody' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CharacterGenericClass) == 0x000690, "Member 'UVOblivionRuntimeSettings::CharacterGenericClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, InventoryPlayerClass) == 0x0006B8, "Member 'UVOblivionRuntimeSettings::InventoryPlayerClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CharacterAnimationBlueprint) == 0x0006E0, "Member 'UVOblivionRuntimeSettings::CharacterAnimationBlueprint' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, FirstPersonCharacterAnimationBlueprint) == 0x000708, "Member 'UVOblivionRuntimeSettings::FirstPersonCharacterAnimationBlueprint' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultFacialAnimation) == 0x000730, "Member 'UVOblivionRuntimeSettings::DefaultFacialAnimation' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, HairAnimationBlueprint) == 0x000750, "Member 'UVOblivionRuntimeSettings::HairAnimationBlueprint' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, HelmetPlaceholder) == 0x000778, "Member 'UVOblivionRuntimeSettings::HelmetPlaceholder' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AmuletPlaceholder) == 0x0007A0, "Member 'UVOblivionRuntimeSettings::AmuletPlaceholder' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, RingPlaceholder) == 0x0007C8, "Member 'UVOblivionRuntimeSettings::RingPlaceholder' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, UpperBodyPlaceholder) == 0x0007F0, "Member 'UVOblivionRuntimeSettings::UpperBodyPlaceholder' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, HandsPlaceholder) == 0x000818, "Member 'UVOblivionRuntimeSettings::HandsPlaceholder' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, LowerBodyPlaceholder) == 0x000840, "Member 'UVOblivionRuntimeSettings::LowerBodyPlaceholder' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, FeetPlaceholder) == 0x000868, "Member 'UVOblivionRuntimeSettings::FeetPlaceholder' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultDirectionalSpeedCurve) == 0x000890, "Member 'UVOblivionRuntimeSettings::DefaultDirectionalSpeedCurve' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultRotationSpeedCurve) == 0x0008B8, "Member 'UVOblivionRuntimeSettings::DefaultRotationSpeedCurve' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CharacterLocomotionDebugArrowLength) == 0x0008E0, "Member 'UVOblivionRuntimeSettings::CharacterLocomotionDebugArrowLength' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CharacterLocomotionDebugArrowHeadSize) == 0x0008E4, "Member 'UVOblivionRuntimeSettings::CharacterLocomotionDebugArrowHeadSize' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CharacterLocomotionDebugArrowThickness) == 0x0008E8, "Member 'UVOblivionRuntimeSettings::CharacterLocomotionDebugArrowThickness' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, NiagaraUserVariableIdentifier) == 0x0008F0, "Member 'UVOblivionRuntimeSettings::NiagaraUserVariableIdentifier' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AIControllerClass) == 0x000900, "Member 'UVOblivionRuntimeSettings::AIControllerClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AIDebugWidgetBlueprint) == 0x000928, "Member 'UVOblivionRuntimeSettings::AIDebugWidgetBlueprint' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AIProcedureDebugWidgetBlueprint) == 0x000950, "Member 'UVOblivionRuntimeSettings::AIProcedureDebugWidgetBlueprint' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, LandmarkStaticForms) == 0x000978, "Member 'UVOblivionRuntimeSettings::LandmarkStaticForms' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, LandmarkMetaClusterProjectionExtent) == 0x000988, "Member 'UVOblivionRuntimeSettings::LandmarkMetaClusterProjectionExtent' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, EntityDetailsDebugWidgetBlueprint) == 0x0009A0, "Member 'UVOblivionRuntimeSettings::EntityDetailsDebugWidgetBlueprint' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultPropSocket) == 0x0009C8, "Member 'UVOblivionRuntimeSettings::DefaultPropSocket' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultBookBlueprintClass) == 0x0009D0, "Member 'UVOblivionRuntimeSettings::DefaultBookBlueprintClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CraftedPotionClass) == 0x0009F8, "Member 'UVOblivionRuntimeSettings::CraftedPotionClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CraftedPoisonClass) == 0x000A20, "Member 'UVOblivionRuntimeSettings::CraftedPoisonClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CreatureBossDataTable) == 0x000A48, "Member 'UVOblivionRuntimeSettings::CreatureBossDataTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, LevelCreatureBossDataTable) == 0x000A68, "Member 'UVOblivionRuntimeSettings::LevelCreatureBossDataTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CorpseDefaultAnimPoseDatatable) == 0x000A88, "Member 'UVOblivionRuntimeSettings::CorpseDefaultAnimPoseDatatable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CorpseDefaultPhysicPoseDatatable) == 0x000AA8, "Member 'UVOblivionRuntimeSettings::CorpseDefaultPhysicPoseDatatable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultCameraSettingsTable) == 0x000AC8, "Member 'UVOblivionRuntimeSettings::DefaultCameraSettingsTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ArmsRotationDependentAnimTags) == 0x000AF0, "Member 'UVOblivionRuntimeSettings::ArmsRotationDependentAnimTags' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, MaxBlendTime) == 0x000B10, "Member 'UVOblivionRuntimeSettings::MaxBlendTime' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CameraBlendLocationCurve) == 0x000B18, "Member 'UVOblivionRuntimeSettings::CameraBlendLocationCurve' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ConvertPlayerSensitivityCurve) == 0x000B40, "Member 'UVOblivionRuntimeSettings::ConvertPlayerSensitivityCurve' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CameraShakeThirdPersonHorse) == 0x000B68, "Member 'UVOblivionRuntimeSettings::CameraShakeThirdPersonHorse' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CameraShakeFirstPerson) == 0x000B78, "Member 'UVOblivionRuntimeSettings::CameraShakeFirstPerson' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CameraShakeThirdPerson) == 0x000B88, "Member 'UVOblivionRuntimeSettings::CameraShakeThirdPerson' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, FirstPersonViewSensitivity) == 0x000B98, "Member 'UVOblivionRuntimeSettings::FirstPersonViewSensitivity' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ThirdPersonViewSensitivity) == 0x000B9C, "Member 'UVOblivionRuntimeSettings::ThirdPersonViewSensitivity' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, StickSmoothingCurve) == 0x000BA0, "Member 'UVOblivionRuntimeSettings::StickSmoothingCurve' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, FirstPersonCameraHorizontalSensitivityScale) == 0x000BC8, "Member 'UVOblivionRuntimeSettings::FirstPersonCameraHorizontalSensitivityScale' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ThirdPersonCameraHorizontalSensitivityScale) == 0x000BCC, "Member 'UVOblivionRuntimeSettings::ThirdPersonCameraHorizontalSensitivityScale' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, FirstPersonCameraVerticalSensitivityScale) == 0x000BD0, "Member 'UVOblivionRuntimeSettings::FirstPersonCameraVerticalSensitivityScale' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ThirdPersonCameraVerticalSensitivityScale) == 0x000BD4, "Member 'UVOblivionRuntimeSettings::ThirdPersonCameraVerticalSensitivityScale' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AimSlowdownEntityMinRange) == 0x000BD8, "Member 'UVOblivionRuntimeSettings::AimSlowdownEntityMinRange' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AimSlowdownPlayerStateList) == 0x000BE0, "Member 'UVOblivionRuntimeSettings::AimSlowdownPlayerStateList' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AimSlowdownTraceStartRadius) == 0x000C00, "Member 'UVOblivionRuntimeSettings::AimSlowdownTraceStartRadius' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AimSlowdownTraceEndRadius) == 0x000C04, "Member 'UVOblivionRuntimeSettings::AimSlowdownTraceEndRadius' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AimSlowdownEntityCurve) == 0x000C08, "Member 'UVOblivionRuntimeSettings::AimSlowdownEntityCurve' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AimSlowdownItemCurve) == 0x000C30, "Member 'UVOblivionRuntimeSettings::AimSlowdownItemCurve' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AimSlowdownDistMin) == 0x000C58, "Member 'UVOblivionRuntimeSettings::AimSlowdownDistMin' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AimSlowdownDistMax) == 0x000C5C, "Member 'UVOblivionRuntimeSettings::AimSlowdownDistMax' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AimSlowdownAddedDistBetweenSpheres) == 0x000C60, "Member 'UVOblivionRuntimeSettings::AimSlowdownAddedDistBetweenSpheres' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AimSlowdownSmoothingIntensity) == 0x000C64, "Member 'UVOblivionRuntimeSettings::AimSlowdownSmoothingIntensity' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DefaultMeleeHitboxExtent) == 0x000C68, "Member 'UVOblivionRuntimeSettings::DefaultMeleeHitboxExtent' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, InputActionTagToRemoveOnUISwitch) == 0x000C80, "Member 'UVOblivionRuntimeSettings::InputActionTagToRemoveOnUISwitch' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, DismountMinimalHeightDistance) == 0x000CA0, "Member 'UVOblivionRuntimeSettings::DismountMinimalHeightDistance' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, bIsHorseAutoAlignCameraEnabled) == 0x000CA4, "Member 'UVOblivionRuntimeSettings::bIsHorseAutoAlignCameraEnabled' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, TagsAllowingHorseFirstPerson) == 0x000CA8, "Member 'UVOblivionRuntimeSettings::TagsAllowingHorseFirstPerson' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, TagsThatShouldIgnoreInputs) == 0x000CC8, "Member 'UVOblivionRuntimeSettings::TagsThatShouldIgnoreInputs' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, SummonLocationEnvironmentQuery) == 0x000CE8, "Member 'UVOblivionRuntimeSettings::SummonLocationEnvironmentQuery' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, PawnSpawnLocationOffset) == 0x000D10, "Member 'UVOblivionRuntimeSettings::PawnSpawnLocationOffset' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CompressionMethod) == 0x000D28, "Member 'UVOblivionRuntimeSettings::CompressionMethod' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, Version) == 0x000D2C, "Member 'UVOblivionRuntimeSettings::Version' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ThumbnailResolution) == 0x000D30, "Member 'UVOblivionRuntimeSettings::ThumbnailResolution' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, NumberOfAutoSaves) == 0x000D40, "Member 'UVOblivionRuntimeSettings::NumberOfAutoSaves' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, bEnablePlayerFacialCustomisationSave) == 0x000D44, "Member 'UVOblivionRuntimeSettings::bEnablePlayerFacialCustomisationSave' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, BowAimingVectorLength) == 0x000D48, "Member 'UVOblivionRuntimeSettings::BowAimingVectorLength' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, MissingPrePlacedActorMaterial) == 0x000D50, "Member 'UVOblivionRuntimeSettings::MissingPrePlacedActorMaterial' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CellToMapPathStringTable) == 0x000D78, "Member 'UVOblivionRuntimeSettings::CellToMapPathStringTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, bShowHitReactDebug) == 0x000DA0, "Member 'UVOblivionRuntimeSettings::bShowHitReactDebug' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, bUseHitReactDirectionFromAnimation) == 0x000DA1, "Member 'UVOblivionRuntimeSettings::bUseHitReactDirectionFromAnimation' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AltarPrePlacedGuidToCellAsyncFlowHashDataTable) == 0x000DA8, "Member 'UVOblivionRuntimeSettings::AltarPrePlacedGuidToCellAsyncFlowHashDataTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AltarSEWorldPrePlacedGuidToCellAsyncFlowHashDataTable) == 0x000DC8, "Member 'UVOblivionRuntimeSettings::AltarSEWorldPrePlacedGuidToCellAsyncFlowHashDataTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AltarTamrielPrePlacedNotSpatiallyLoadedDataTable) == 0x000DE8, "Member 'UVOblivionRuntimeSettings::AltarTamrielPrePlacedNotSpatiallyLoadedDataTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, AltarSEWorldPrePlacedNotSpatiallyLoadedDataTable) == 0x000E08, "Member 'UVOblivionRuntimeSettings::AltarSEWorldPrePlacedNotSpatiallyLoadedDataTable' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, WaterPhysicalMaterial) == 0x000E28, "Member 'UVOblivionRuntimeSettings::WaterPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, LavaPhysicalMaterial) == 0x000E50, "Member 'UVOblivionRuntimeSettings::LavaPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, TrailVFXBlueprintClass) == 0x000E78, "Member 'UVOblivionRuntimeSettings::TrailVFXBlueprintClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, TrailVFX_NeededLevelForSkillBladeNormal) == 0x000EA0, "Member 'UVOblivionRuntimeSettings::TrailVFX_NeededLevelForSkillBladeNormal' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, TrailVFX_NeededLevelForSkillBluntNormal) == 0x000EA1, "Member 'UVOblivionRuntimeSettings::TrailVFX_NeededLevelForSkillBluntNormal' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, TrailVFX_NeededLevelForSkillHandToHandNormal) == 0x000EA2, "Member 'UVOblivionRuntimeSettings::TrailVFX_NeededLevelForSkillHandToHandNormal' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, TrailVFX_NeededLevelForSkillBladePower) == 0x000EA3, "Member 'UVOblivionRuntimeSettings::TrailVFX_NeededLevelForSkillBladePower' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, TrailVFX_NeededLevelForSkillBluntPower) == 0x000EA4, "Member 'UVOblivionRuntimeSettings::TrailVFX_NeededLevelForSkillBluntPower' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, TrailVFX_NeededLevelForSkillHandToHandPower) == 0x000EA5, "Member 'UVOblivionRuntimeSettings::TrailVFX_NeededLevelForSkillHandToHandPower' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, NoLumenWaterReflectionMapsXSS) == 0x000EA8, "Member 'UVOblivionRuntimeSettings::NoLumenWaterReflectionMapsXSS' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, FixDialogueFaceShadowsMapList) == 0x000EB8, "Member 'UVOblivionRuntimeSettings::FixDialogueFaceShadowsMapList' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, BehaviorMapsToPreload) == 0x000EC8, "Member 'UVOblivionRuntimeSettings::BehaviorMapsToPreload' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, MaxLedgeHeight) == 0x000ED8, "Member 'UVOblivionRuntimeSettings::MaxLedgeHeight' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, MaxLedgeHeightIncrement) == 0x000EE0, "Member 'UVOblivionRuntimeSettings::MaxLedgeHeightIncrement' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, MaxLedgeLength) == 0x000EE8, "Member 'UVOblivionRuntimeSettings::MaxLedgeLength' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, MaxLedgeCrossingSpeed) == 0x000EF0, "Member 'UVOblivionRuntimeSettings::MaxLedgeCrossingSpeed' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, IgnoreMaxLedgeHeightNavAreas) == 0x000EF8, "Member 'UVOblivionRuntimeSettings::IgnoreMaxLedgeHeightNavAreas' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, WaterNavAreaClass) == 0x000F48, "Member 'UVOblivionRuntimeSettings::WaterNavAreaClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, ShallowWaterNavAreaClass) == 0x000F70, "Member 'UVOblivionRuntimeSettings::ShallowWaterNavAreaClass' has a wrong offset!");
static_assert(offsetof(UVOblivionRuntimeSettings, CrashDataUpdatesPerSecond) == 0x000F98, "Member 'UVOblivionRuntimeSettings::CrashDataUpdatesPerSecond' has a wrong offset!");

// Class Altar.VOctopedBodyAnimInstance
// 0x0070 (0x0420 - 0x03B0)
class UVOctopedBodyAnimInstance final : public UVLowerUpperBodyAnimInstance
{
public:
	float                                         MovingSpeedThreshold;                              // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCreatureOctopedBoneAnimationData      LayeredBoneSettings;                               // 0x03AC(0x006C)(Edit, BlueprintVisible, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOctopedBodyAnimInstance">();
	}
	static class UVOctopedBodyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOctopedBodyAnimInstance>();
	}
};
static_assert(alignof(UVOctopedBodyAnimInstance) == 0x000010, "Wrong alignment on UVOctopedBodyAnimInstance");
static_assert(sizeof(UVOctopedBodyAnimInstance) == 0x000420, "Wrong size on UVOctopedBodyAnimInstance");
static_assert(offsetof(UVOctopedBodyAnimInstance, MovingSpeedThreshold) == 0x0003A8, "Member 'UVOctopedBodyAnimInstance::MovingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UVOctopedBodyAnimInstance, LayeredBoneSettings) == 0x0003AC, "Member 'UVOctopedBodyAnimInstance::LayeredBoneSettings' has a wrong offset!");

// Class Altar.VOnboardingPageInterface
// 0x0000 (0x0000 - 0x0000)
class IVOnboardingPageInterface final
{
public:
	void Clean();
	void LaunchEnterAnimation();
	void LaunchExitAnimation();
	void OnEnd();
	void OnEnter();
	void OnExit(bool Forward);
	void OnStart();

	bool CanBeSkiped() const;
	bool CanEnter() const;
	bool CanExit() const;
	bool DoesNeedEnterAnimation() const;
	bool DoesNeedExitAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOnboardingPageInterface">();
	}
	static class IVOnboardingPageInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVOnboardingPageInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IVOnboardingPageInterface) == 0x000001, "Wrong alignment on IVOnboardingPageInterface");
static_assert(sizeof(IVOnboardingPageInterface) == 0x000001, "Wrong size on IVOnboardingPageInterface");

// Class Altar.VOriginalImageTile
// 0x0240 (0x0500 - 0x02C0)
class UVOriginalImageTile : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(class UUserWidget* Target, const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)> OnHoveredDelegate; // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UUserWidget* Target, const struct FPointerEvent& InMouseEvent)> OnUnhoveredDelegate; // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UUserWidget* Target, const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)> OnMouseButtonDownDelegate; // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UUserWidget* Target, const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)> OnMouseButtonUpDelegate; // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UUserWidget* Target, const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)> OnMouseMoveDelegate; // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bFixPowerOfTwoOffsets;                             // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OriginalImageSize;                                 // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0330(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bDoesHandledMouseEvent;                            // 0x0400(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0xFF];                                     // 0x0401(0x00FF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetCeilPowerOfTwo(int32 Value);
	static struct FVector2D GetFixedOffsetPowerOfTwo(const struct FImageCorrectionData& Data);

	void OnBrushUpdated(const struct FSlateBrush& Value);
	void OnCorrectionDataUpdated(const struct FImageCorrectionData& Value);
	void OnFixPowerOfTwoOffsetsUpdated(bool Value);
	void OnOriginalImageSizeUpdated(const struct FVector2D& Value);
	void OnSynchronizeProperties();
	void SetBrush(const struct FSlateBrush& Value);
	void SetCorrectionData(const struct FImageCorrectionData& Value);
	void SetFixPowerOfTwoOffsets(bool Value);
	void SetOriginalImageSize(const struct FVector2D& Value);

	const struct FImageCorrectionData GetCorrectionData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOriginalImageTile">();
	}
	static class UVOriginalImageTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOriginalImageTile>();
	}
};
static_assert(alignof(UVOriginalImageTile) == 0x000010, "Wrong alignment on UVOriginalImageTile");
static_assert(sizeof(UVOriginalImageTile) == 0x000500, "Wrong size on UVOriginalImageTile");
static_assert(offsetof(UVOriginalImageTile, OnHoveredDelegate) == 0x0002C0, "Member 'UVOriginalImageTile::OnHoveredDelegate' has a wrong offset!");
static_assert(offsetof(UVOriginalImageTile, OnUnhoveredDelegate) == 0x0002D0, "Member 'UVOriginalImageTile::OnUnhoveredDelegate' has a wrong offset!");
static_assert(offsetof(UVOriginalImageTile, OnMouseButtonDownDelegate) == 0x0002E0, "Member 'UVOriginalImageTile::OnMouseButtonDownDelegate' has a wrong offset!");
static_assert(offsetof(UVOriginalImageTile, OnMouseButtonUpDelegate) == 0x0002F0, "Member 'UVOriginalImageTile::OnMouseButtonUpDelegate' has a wrong offset!");
static_assert(offsetof(UVOriginalImageTile, OnMouseMoveDelegate) == 0x000300, "Member 'UVOriginalImageTile::OnMouseMoveDelegate' has a wrong offset!");
static_assert(offsetof(UVOriginalImageTile, bFixPowerOfTwoOffsets) == 0x000310, "Member 'UVOriginalImageTile::bFixPowerOfTwoOffsets' has a wrong offset!");
static_assert(offsetof(UVOriginalImageTile, OriginalImageSize) == 0x000318, "Member 'UVOriginalImageTile::OriginalImageSize' has a wrong offset!");
static_assert(offsetof(UVOriginalImageTile, Brush) == 0x000330, "Member 'UVOriginalImageTile::Brush' has a wrong offset!");
static_assert(offsetof(UVOriginalImageTile, bDoesHandledMouseEvent) == 0x000400, "Member 'UVOriginalImageTile::bDoesHandledMouseEvent' has a wrong offset!");

// Class Altar.VOriginalLevelUpMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVOriginalLevelUpMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOriginalLevelUpMenu">();
	}
	static class UVOriginalLevelUpMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOriginalLevelUpMenu>();
	}
};
static_assert(alignof(UVOriginalLevelUpMenu) == 0x000008, "Wrong alignment on UVOriginalLevelUpMenu");
static_assert(sizeof(UVOriginalLevelUpMenu) == 0x0004E8, "Wrong size on UVOriginalLevelUpMenu");

// Class Altar.VOriginalVideoMenu
// 0x0000 (0x04E8 - 0x04E8)
class UVOriginalVideoMenu final : public UVAltarMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOriginalVideoMenu">();
	}
	static class UVOriginalVideoMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOriginalVideoMenu>();
	}
};
static_assert(alignof(UVOriginalVideoMenu) == 0x000008, "Wrong alignment on UVOriginalVideoMenu");
static_assert(sizeof(UVOriginalVideoMenu) == 0x0004E8, "Wrong size on UVOriginalVideoMenu");

// Class Altar.VOriginal_FilterBackgroundTable
// 0x0050 (0x0100 - 0x00B0)
class UVOriginal_FilterBackgroundTable final : public UDataTable
{
public:
	TMap<EOriginalInventoryFilterBackgrounds, struct FOriginal_InventoryFilterBackgroundTableRow> InventoryFilterBackgroundsMap; // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOriginal_FilterBackgroundTable">();
	}
	static class UVOriginal_FilterBackgroundTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOriginal_FilterBackgroundTable>();
	}
};
static_assert(alignof(UVOriginal_FilterBackgroundTable) == 0x000008, "Wrong alignment on UVOriginal_FilterBackgroundTable");
static_assert(sizeof(UVOriginal_FilterBackgroundTable) == 0x000100, "Wrong size on UVOriginal_FilterBackgroundTable");
static_assert(offsetof(UVOriginal_FilterBackgroundTable, InventoryFilterBackgroundsMap) == 0x0000B0, "Member 'UVOriginal_FilterBackgroundTable::InventoryFilterBackgroundsMap' has a wrong offset!");

// Class Altar.VOriginal_InventoryFilter
// 0x00A0 (0x0568 - 0x04C8)
class UVOriginal_InventoryFilter : public UVAltarWidget
{
public:
	TMulticastInlineDelegate<void(EOriginalInventoryMenuSortType SortType)> OnSortTypeUpdated;       // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsReversed)> OnSortIsReversedUpdated;                        // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UVNavigableScrollBox*                   FilterIconBox;                                     // 0x04E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCommonUserWidget>          FilterIconClass;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVOriginal_AltarInventoryFilterIconTable* IconDesignTable;                                 // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                FilterPadding;                                     // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x58];                                     // 0x0510(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateFilter(class UCommonUserWidget* Activator);
	void OnFilterIconCreated(class UCommonUserWidget* NewFilter, const struct FOriginal_InventoryFilterTableRow& FilterDesign);
	void RequestUpdateFilterWidget(class UCommonUserWidget* Filter, bool bIsDisplayed, bool bIsEnable);
	void SetActiveFilter(EOriginalInventoryMenuSortType ActiveFilterEnum);
	void SetEnabledFilters(const TArray<EOriginalInventoryMenuSortType>& EnabledFilterEnums);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOriginal_InventoryFilter">();
	}
	static class UVOriginal_InventoryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOriginal_InventoryFilter>();
	}
};
static_assert(alignof(UVOriginal_InventoryFilter) == 0x000008, "Wrong alignment on UVOriginal_InventoryFilter");
static_assert(sizeof(UVOriginal_InventoryFilter) == 0x000568, "Wrong size on UVOriginal_InventoryFilter");
static_assert(offsetof(UVOriginal_InventoryFilter, OnSortTypeUpdated) == 0x0004C8, "Member 'UVOriginal_InventoryFilter::OnSortTypeUpdated' has a wrong offset!");
static_assert(offsetof(UVOriginal_InventoryFilter, OnSortIsReversedUpdated) == 0x0004D8, "Member 'UVOriginal_InventoryFilter::OnSortIsReversedUpdated' has a wrong offset!");
static_assert(offsetof(UVOriginal_InventoryFilter, FilterIconBox) == 0x0004E8, "Member 'UVOriginal_InventoryFilter::FilterIconBox' has a wrong offset!");
static_assert(offsetof(UVOriginal_InventoryFilter, FilterIconClass) == 0x0004F0, "Member 'UVOriginal_InventoryFilter::FilterIconClass' has a wrong offset!");
static_assert(offsetof(UVOriginal_InventoryFilter, IconDesignTable) == 0x0004F8, "Member 'UVOriginal_InventoryFilter::IconDesignTable' has a wrong offset!");
static_assert(offsetof(UVOriginal_InventoryFilter, FilterPadding) == 0x000500, "Member 'UVOriginal_InventoryFilter::FilterPadding' has a wrong offset!");

// Class Altar.VPairedAssetsLoadingSettings
// 0x0038 (0x0060 - 0x0028)
class UVPairedAssetsLoadingSettings final : public UObject
{
public:
	bool                                          bEnableAllSyncMapFormsPreloadingAtGameStartup;     // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCachingOfBlueprintClasses;                  // 0x0029(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NPCPreloadingDistanceMax;                          // 0x002C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCPreloadingDistanceMedium;                       // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCPreloadingDistanceCritical;                     // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTotalNumberOfCachedAssets;                      // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumberOfHeavyWeightCachedAssets;                // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumberOfMediumWeightCachedAssets;               // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinNumberOfGarbagedAssets;                         // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeavyWeightCachedAssetsGarbageRatio;               // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MediumWeightCachedAssetsGarbageRatio;              // 0x004C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultCacheEntryLifetime;                         // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShortCacheEntryLifetime;                           // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongCacheEntryLifetime;                            // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CacheCleanupUpdateFrequency;                       // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPairedAssetsLoadingSettings">();
	}
	static class UVPairedAssetsLoadingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPairedAssetsLoadingSettings>();
	}
};
static_assert(alignof(UVPairedAssetsLoadingSettings) == 0x000008, "Wrong alignment on UVPairedAssetsLoadingSettings");
static_assert(sizeof(UVPairedAssetsLoadingSettings) == 0x000060, "Wrong size on UVPairedAssetsLoadingSettings");
static_assert(offsetof(UVPairedAssetsLoadingSettings, bEnableAllSyncMapFormsPreloadingAtGameStartup) == 0x000028, "Member 'UVPairedAssetsLoadingSettings::bEnableAllSyncMapFormsPreloadingAtGameStartup' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, bEnableCachingOfBlueprintClasses) == 0x000029, "Member 'UVPairedAssetsLoadingSettings::bEnableCachingOfBlueprintClasses' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, NPCPreloadingDistanceMax) == 0x00002C, "Member 'UVPairedAssetsLoadingSettings::NPCPreloadingDistanceMax' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, NPCPreloadingDistanceMedium) == 0x000030, "Member 'UVPairedAssetsLoadingSettings::NPCPreloadingDistanceMedium' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, NPCPreloadingDistanceCritical) == 0x000034, "Member 'UVPairedAssetsLoadingSettings::NPCPreloadingDistanceCritical' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, MaxTotalNumberOfCachedAssets) == 0x000038, "Member 'UVPairedAssetsLoadingSettings::MaxTotalNumberOfCachedAssets' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, MaxNumberOfHeavyWeightCachedAssets) == 0x00003C, "Member 'UVPairedAssetsLoadingSettings::MaxNumberOfHeavyWeightCachedAssets' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, MaxNumberOfMediumWeightCachedAssets) == 0x000040, "Member 'UVPairedAssetsLoadingSettings::MaxNumberOfMediumWeightCachedAssets' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, MinNumberOfGarbagedAssets) == 0x000044, "Member 'UVPairedAssetsLoadingSettings::MinNumberOfGarbagedAssets' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, HeavyWeightCachedAssetsGarbageRatio) == 0x000048, "Member 'UVPairedAssetsLoadingSettings::HeavyWeightCachedAssetsGarbageRatio' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, MediumWeightCachedAssetsGarbageRatio) == 0x00004C, "Member 'UVPairedAssetsLoadingSettings::MediumWeightCachedAssetsGarbageRatio' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, DefaultCacheEntryLifetime) == 0x000050, "Member 'UVPairedAssetsLoadingSettings::DefaultCacheEntryLifetime' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, ShortCacheEntryLifetime) == 0x000054, "Member 'UVPairedAssetsLoadingSettings::ShortCacheEntryLifetime' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, LongCacheEntryLifetime) == 0x000058, "Member 'UVPairedAssetsLoadingSettings::LongCacheEntryLifetime' has a wrong offset!");
static_assert(offsetof(UVPairedAssetsLoadingSettings, CacheCleanupUpdateFrequency) == 0x00005C, "Member 'UVPairedAssetsLoadingSettings::CacheCleanupUpdateFrequency' has a wrong offset!");

// Class Altar.VPairedAssetsLoadingSubsystem
// 0x0328 (0x0358 - 0x0030)
class UVPairedAssetsLoadingSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x328];                                     // 0x0030(0x0328)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int64 RegisterPreloadRequestFromForm(const class UTESForm* InPairedActorForm, EVPreloadPriority InPriority, const int64 InOwnerInstanceFormID);
	int64 RegisterPreloadRequestFromFormID(const int64 InPairedActorFormID, EVPreloadPriority InPriority, const int64 InOwnerInstanceFormID);
	bool UnregisterPreloadRequestFromForm(const class UTESForm* InPairedActorForm, const int64 InOwnerInstanceFormID);
	bool UnregisterPreloadRequestFromFormID(const int64 InPairedActorFormID, const int64 InOwnerInstanceFormID);
	bool UnregisterPreloadRequestFromRequestID(const int64 InPreloadRequestID, const int64 InOwnerInstanceFormID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPairedAssetsLoadingSubsystem">();
	}
	static class UVPairedAssetsLoadingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPairedAssetsLoadingSubsystem>();
	}
};
static_assert(alignof(UVPairedAssetsLoadingSubsystem) == 0x000008, "Wrong alignment on UVPairedAssetsLoadingSubsystem");
static_assert(sizeof(UVPairedAssetsLoadingSubsystem) == 0x000358, "Wrong size on UVPairedAssetsLoadingSubsystem");

// Class Altar.VStatusEffectOnPawn
// 0x0040 (0x0068 - 0x0028)
class UVStatusEffectOnPawn final : public UObject
{
public:
	class UTESEffectShader*                       StatusEffectForm;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVStatusEffectVFXBlueprint*             StatusEffectVFXBlueprint;                          // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   StatusEffectColors;                                // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           MeshIgnoreList;                                    // 0x0048(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         StatusEffectValue;                                 // 0x0058(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExcessInstancesCount;                              // 0x005C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bIsPresentOnWeapons;                               // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueModifierEffectIndex;                          // 0x0064(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStatusEffectOnPawn">();
	}
	static class UVStatusEffectOnPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStatusEffectOnPawn>();
	}
};
static_assert(alignof(UVStatusEffectOnPawn) == 0x000008, "Wrong alignment on UVStatusEffectOnPawn");
static_assert(sizeof(UVStatusEffectOnPawn) == 0x000068, "Wrong size on UVStatusEffectOnPawn");
static_assert(offsetof(UVStatusEffectOnPawn, StatusEffectForm) == 0x000028, "Member 'UVStatusEffectOnPawn::StatusEffectForm' has a wrong offset!");
static_assert(offsetof(UVStatusEffectOnPawn, StatusEffectVFXBlueprint) == 0x000030, "Member 'UVStatusEffectOnPawn::StatusEffectVFXBlueprint' has a wrong offset!");
static_assert(offsetof(UVStatusEffectOnPawn, StatusEffectColors) == 0x000038, "Member 'UVStatusEffectOnPawn::StatusEffectColors' has a wrong offset!");
static_assert(offsetof(UVStatusEffectOnPawn, MeshIgnoreList) == 0x000048, "Member 'UVStatusEffectOnPawn::MeshIgnoreList' has a wrong offset!");
static_assert(offsetof(UVStatusEffectOnPawn, StatusEffectValue) == 0x000058, "Member 'UVStatusEffectOnPawn::StatusEffectValue' has a wrong offset!");
static_assert(offsetof(UVStatusEffectOnPawn, ExcessInstancesCount) == 0x00005C, "Member 'UVStatusEffectOnPawn::ExcessInstancesCount' has a wrong offset!");
static_assert(offsetof(UVStatusEffectOnPawn, bIsPresentOnWeapons) == 0x000060, "Member 'UVStatusEffectOnPawn::bIsPresentOnWeapons' has a wrong offset!");
static_assert(offsetof(UVStatusEffectOnPawn, ValueModifierEffectIndex) == 0x000064, "Member 'UVStatusEffectOnPawn::ValueModifierEffectIndex' has a wrong offset!");

// Class Altar.AnimNotifyActionEventInfo
// 0x00B8 (0x00E0 - 0x0028)
class UAnimNotifyActionEventInfo final : public UObject
{
public:
	struct FAnimNotifyEvent                       AnimNotifyEvent;                                   // 0x0028(0x00B8)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	float GetNotifyDuration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyActionEventInfo">();
	}
	static class UAnimNotifyActionEventInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyActionEventInfo>();
	}
};
static_assert(alignof(UAnimNotifyActionEventInfo) == 0x000008, "Wrong alignment on UAnimNotifyActionEventInfo");
static_assert(sizeof(UAnimNotifyActionEventInfo) == 0x0000E0, "Wrong size on UAnimNotifyActionEventInfo");
static_assert(offsetof(UAnimNotifyActionEventInfo, AnimNotifyEvent) == 0x000028, "Member 'UAnimNotifyActionEventInfo::AnimNotifyEvent' has a wrong offset!");

// Class Altar.VPawnAnimatedAction
// 0x0048 (0x0070 - 0x0028)
class UVPawnAnimatedAction final : public UObject
{
public:
	struct FGameplayTag                           ActionTypeTag;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimationIndex;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionFinished;                                   // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        StartTime;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocksMovement;                                    // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawRotationSpeedMultiplier;                        // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsCancelled)> OnEnded;                                       // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const class UAnimNotifyActionEventInfo* EventSource)> OnEvent; // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPawnAnimatedAction">();
	}
	static class UVPawnAnimatedAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPawnAnimatedAction>();
	}
};
static_assert(alignof(UVPawnAnimatedAction) == 0x000008, "Wrong alignment on UVPawnAnimatedAction");
static_assert(sizeof(UVPawnAnimatedAction) == 0x000070, "Wrong size on UVPawnAnimatedAction");
static_assert(offsetof(UVPawnAnimatedAction, ActionTypeTag) == 0x000028, "Member 'UVPawnAnimatedAction::ActionTypeTag' has a wrong offset!");
static_assert(offsetof(UVPawnAnimatedAction, Duration) == 0x000030, "Member 'UVPawnAnimatedAction::Duration' has a wrong offset!");
static_assert(offsetof(UVPawnAnimatedAction, AnimationIndex) == 0x000034, "Member 'UVPawnAnimatedAction::AnimationIndex' has a wrong offset!");
static_assert(offsetof(UVPawnAnimatedAction, bActionFinished) == 0x000038, "Member 'UVPawnAnimatedAction::bActionFinished' has a wrong offset!");
static_assert(offsetof(UVPawnAnimatedAction, Lifetime) == 0x00003C, "Member 'UVPawnAnimatedAction::Lifetime' has a wrong offset!");
static_assert(offsetof(UVPawnAnimatedAction, StartTime) == 0x000040, "Member 'UVPawnAnimatedAction::StartTime' has a wrong offset!");
static_assert(offsetof(UVPawnAnimatedAction, bLocksMovement) == 0x000048, "Member 'UVPawnAnimatedAction::bLocksMovement' has a wrong offset!");
static_assert(offsetof(UVPawnAnimatedAction, YawRotationSpeedMultiplier) == 0x00004C, "Member 'UVPawnAnimatedAction::YawRotationSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UVPawnAnimatedAction, OnEnded) == 0x000050, "Member 'UVPawnAnimatedAction::OnEnded' has a wrong offset!");
static_assert(offsetof(UVPawnAnimatedAction, OnEvent) == 0x000060, "Member 'UVPawnAnimatedAction::OnEvent' has a wrong offset!");

// Class Altar.VSpellCastSingleAnimInstance
// 0x0040 (0x03E0 - 0x03A0)
class UVSpellCastSingleAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	struct FSpellCastSingleAnimSet                AnimSet;                                           // 0x03A0(0x0038)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCastSelfLeftEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCastSelfRightEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCastTargeRightEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCastTargetLeftEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCastTouchLeftEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnCastTouchRightEnter(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSpellCastSingleAnimInstance">();
	}
	static class UVSpellCastSingleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSpellCastSingleAnimInstance>();
	}
};
static_assert(alignof(UVSpellCastSingleAnimInstance) == 0x000010, "Wrong alignment on UVSpellCastSingleAnimInstance");
static_assert(sizeof(UVSpellCastSingleAnimInstance) == 0x0003E0, "Wrong size on UVSpellCastSingleAnimInstance");
static_assert(offsetof(UVSpellCastSingleAnimInstance, AnimSet) == 0x0003A0, "Member 'UVSpellCastSingleAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VAIProcedureExecution_DoNothing
// 0x0000 (0x0040 - 0x0040)
class UVAIProcedureExecution_DoNothing final : public UVAIProcedureExecution_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAIProcedureExecution_DoNothing">();
	}
	static class UVAIProcedureExecution_DoNothing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAIProcedureExecution_DoNothing>();
	}
};
static_assert(alignof(UVAIProcedureExecution_DoNothing) == 0x000008, "Wrong alignment on UVAIProcedureExecution_DoNothing");
static_assert(sizeof(UVAIProcedureExecution_DoNothing) == 0x000040, "Wrong size on UVAIProcedureExecution_DoNothing");

// Class Altar.VAltarAIBlackboard
// 0x0050 (0x0078 - 0x0028)
class UVAltarAIBlackboard final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearValue(const struct FGameplayTag& Tag);
	void SetScalarValue(const struct FGameplayTag& Tag, float Value);

	bool HasValue(const struct FGameplayTag& Tag) const;
	float ReadScalarValue(const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarAIBlackboard">();
	}
	static class UVAltarAIBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarAIBlackboard>();
	}
};
static_assert(alignof(UVAltarAIBlackboard) == 0x000008, "Wrong alignment on UVAltarAIBlackboard");
static_assert(sizeof(UVAltarAIBlackboard) == 0x000078, "Wrong size on UVAltarAIBlackboard");

// Class Altar.VPairedPawnAIController
// 0x0220 (0x05E0 - 0x03C0)
class AVPairedPawnAIController : public AAIController
{
public:
	uint8                                         Pad_3C0[0x18];                                     // 0x03C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInDebugMode;                                      // 0x03D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCombatDebugMode;                                // 0x03D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DA[0x6];                                      // 0x03DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVOblivionAIPackageData                CurrentPackage;                                    // 0x03E0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EVOblivionAIProcedureType                     CurrentProcedureType;                              // 0x0448(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x27];                                     // 0x0449(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class AVPairedPawn*                           ControlledPairedPawn;                              // 0x0470(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAltarPathFollowingComponent*          AltarPathFollowingComponent;                       // 0x0478(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVSteeringBehaviorsComponent*           SteeringBehaviorsComponent;                        // 0x0480(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     CannotSwimFilterClass;                             // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     CanOnlySwimFilterClass;                            // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FollowPlayerCharacterFilterClass;                  // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A0[0x20];                                     // 0x04A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MovementActorTarget;                               // 0x04C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C8[0xC];                                      // 0x04C8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UVTESObjectRefComponent> DynamicTargetRefComponent;                         // 0x04D4(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UVTESObjectRefComponent> GenericLocationRefComponent;                       // 0x04DC(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAIProcedureExecution_Base*            CurrentProcedureExecution;                         // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAIPackageExecutionOverride*           CurrentPackageExecutionOverride;                   // 0x04F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVAIControllerCombatData               CombatData;                                        // 0x04F8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReachabilityUpdateFrequency;                       // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ReachabilityUpdateTimerHandle;                     // 0x0558(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_560[0xC];                                      // 0x0560(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementRestrictionUpdateFrequency;                // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           MovementRestrictionUpdateTimerHandle;              // 0x0570(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_578[0x20];                                     // 0x0578(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           MovementStoppedTimerHandle;                        // 0x0598(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 TrackedTargets[0x5];                               // 0x05A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x4];                                      // 0x05C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWantsToRun;                                       // 0x05CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWantsToSneak;                                     // 0x05CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5CE[0x2];                                      // 0x05CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AVPairedPawn*                           CurrentDestinationPawn;                            // 0x05D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateCombatDebugMode();
	void ActivateDebugMode();
	void DeactivateCombatDebugMode();
	void DeactivateDebugMode();
	void OnControlledPawnWeaponChanged(const class AVWeapon* NewWeaponForm);
	void OnDebugModeActivated();
	void OnDebugModeDeactivated();
	void OnProcedureInterrupted();
	void OnProcedureStarted();
	void UpdateCombatDebugDisplay();

	float ComputePackageRadius(int32 RadiusTypeIndex) const;
	class AActor* GetDynamicTargetActor() const;
	bool HasDynamicTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPairedPawnAIController">();
	}
	static class AVPairedPawnAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPairedPawnAIController>();
	}
};
static_assert(alignof(AVPairedPawnAIController) == 0x000008, "Wrong alignment on AVPairedPawnAIController");
static_assert(sizeof(AVPairedPawnAIController) == 0x0005E0, "Wrong size on AVPairedPawnAIController");
static_assert(offsetof(AVPairedPawnAIController, bInDebugMode) == 0x0003D8, "Member 'AVPairedPawnAIController::bInDebugMode' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, bInCombatDebugMode) == 0x0003D9, "Member 'AVPairedPawnAIController::bInCombatDebugMode' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, CurrentPackage) == 0x0003E0, "Member 'AVPairedPawnAIController::CurrentPackage' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, CurrentProcedureType) == 0x000448, "Member 'AVPairedPawnAIController::CurrentProcedureType' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, ControlledPairedPawn) == 0x000470, "Member 'AVPairedPawnAIController::ControlledPairedPawn' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, AltarPathFollowingComponent) == 0x000478, "Member 'AVPairedPawnAIController::AltarPathFollowingComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, SteeringBehaviorsComponent) == 0x000480, "Member 'AVPairedPawnAIController::SteeringBehaviorsComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, CannotSwimFilterClass) == 0x000488, "Member 'AVPairedPawnAIController::CannotSwimFilterClass' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, CanOnlySwimFilterClass) == 0x000490, "Member 'AVPairedPawnAIController::CanOnlySwimFilterClass' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, FollowPlayerCharacterFilterClass) == 0x000498, "Member 'AVPairedPawnAIController::FollowPlayerCharacterFilterClass' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, MovementActorTarget) == 0x0004C0, "Member 'AVPairedPawnAIController::MovementActorTarget' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, DynamicTargetRefComponent) == 0x0004D4, "Member 'AVPairedPawnAIController::DynamicTargetRefComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, GenericLocationRefComponent) == 0x0004DC, "Member 'AVPairedPawnAIController::GenericLocationRefComponent' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, CurrentProcedureExecution) == 0x0004E8, "Member 'AVPairedPawnAIController::CurrentProcedureExecution' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, CurrentPackageExecutionOverride) == 0x0004F0, "Member 'AVPairedPawnAIController::CurrentPackageExecutionOverride' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, CombatData) == 0x0004F8, "Member 'AVPairedPawnAIController::CombatData' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, ReachabilityUpdateFrequency) == 0x000550, "Member 'AVPairedPawnAIController::ReachabilityUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, ReachabilityUpdateTimerHandle) == 0x000558, "Member 'AVPairedPawnAIController::ReachabilityUpdateTimerHandle' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, MovementRestrictionUpdateFrequency) == 0x00056C, "Member 'AVPairedPawnAIController::MovementRestrictionUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, MovementRestrictionUpdateTimerHandle) == 0x000570, "Member 'AVPairedPawnAIController::MovementRestrictionUpdateTimerHandle' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, MovementStoppedTimerHandle) == 0x000598, "Member 'AVPairedPawnAIController::MovementStoppedTimerHandle' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, TrackedTargets) == 0x0005A0, "Member 'AVPairedPawnAIController::TrackedTargets' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, bWantsToRun) == 0x0005CC, "Member 'AVPairedPawnAIController::bWantsToRun' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, bWantsToSneak) == 0x0005CD, "Member 'AVPairedPawnAIController::bWantsToSneak' has a wrong offset!");
static_assert(offsetof(AVPairedPawnAIController, CurrentDestinationPawn) == 0x0005D0, "Member 'AVPairedPawnAIController::CurrentDestinationPawn' has a wrong offset!");

// Class Altar.VPairedPawnStateMachineComponent
// 0x0008 (0x0180 - 0x0178)
class UVPairedPawnStateMachineComponent final : public UVStateMachineComponent
{
public:
	class UDataTable*                             ActionStatePresetsDataTable;                       // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FString GetActionState() const;
	float GetActionStateDuration() const;
	struct FGameplayTag GetActionStateTag() const;
	struct FGameplayTag GetLocomotionStateTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPairedPawnStateMachineComponent">();
	}
	static class UVPairedPawnStateMachineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPairedPawnStateMachineComponent>();
	}
};
static_assert(alignof(UVPairedPawnStateMachineComponent) == 0x000008, "Wrong alignment on UVPairedPawnStateMachineComponent");
static_assert(sizeof(UVPairedPawnStateMachineComponent) == 0x000180, "Wrong size on UVPairedPawnStateMachineComponent");
static_assert(offsetof(UVPairedPawnStateMachineComponent, ActionStatePresetsDataTable) == 0x000178, "Member 'UVPairedPawnStateMachineComponent::ActionStatePresetsDataTable' has a wrong offset!");

// Class Altar.VParticleEffectPairingComponent
// 0x0060 (0x0118 - 0x00B8)
class UVParticleEffectPairingComponent final : public UVActorPairingComponent
{
public:
	TMap<class FString, TSoftObjectPtr<class UNiagaraSystem>> VisualEffects;                         // 0x00B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoesAutoplay;                                     // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBeDestroyed;                                   // 0x0111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPendingForDestruction;                          // 0x0112(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_113[0x5];                                      // 0x0113(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachVFX(const class FString& VisualEffectKey, class UNiagaraSystem* VisualEffect);
	void InitializeComponent();
	void OrderActorDestruction(bool bDoesStopEmitting);
	void SetAutoplay(bool bInDoesAutoplay);
	void SetCanBeDestroyed(bool bInCanBeDestroyed);
	void SetCanBeDestroyedToTrue();
	void StopVFX(bool bDoesStopImmediately);
	void TriggerVFX(const class FString& SequenceName);
	void TryToDestroyActor();

	class UNiagaraComponent* GetNiagaraComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VParticleEffectPairingComponent">();
	}
	static class UVParticleEffectPairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVParticleEffectPairingComponent>();
	}
};
static_assert(alignof(UVParticleEffectPairingComponent) == 0x000008, "Wrong alignment on UVParticleEffectPairingComponent");
static_assert(sizeof(UVParticleEffectPairingComponent) == 0x000118, "Wrong size on UVParticleEffectPairingComponent");
static_assert(offsetof(UVParticleEffectPairingComponent, VisualEffects) == 0x0000B8, "Member 'UVParticleEffectPairingComponent::VisualEffects' has a wrong offset!");
static_assert(offsetof(UVParticleEffectPairingComponent, NiagaraComponent) == 0x000108, "Member 'UVParticleEffectPairingComponent::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(UVParticleEffectPairingComponent, bDoesAutoplay) == 0x000110, "Member 'UVParticleEffectPairingComponent::bDoesAutoplay' has a wrong offset!");
static_assert(offsetof(UVParticleEffectPairingComponent, bCanBeDestroyed) == 0x000111, "Member 'UVParticleEffectPairingComponent::bCanBeDestroyed' has a wrong offset!");
static_assert(offsetof(UVParticleEffectPairingComponent, bIsPendingForDestruction) == 0x000112, "Member 'UVParticleEffectPairingComponent::bIsPendingForDestruction' has a wrong offset!");

// Class Altar.VPatrolDoorNavLinkProxy
// 0x0020 (0x0358 - 0x0338)
class AVPatrolDoorNavLinkProxy final : public AVDoorNavLinkProxy
{
public:
	uint8                                         Pad_338[0x18];                                     // 0x0338(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AVPatrolDoorNavLinkProxy*               PairedNavLink;                                     // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPatrolDoorNavLinkProxy">();
	}
	static class AVPatrolDoorNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPatrolDoorNavLinkProxy>();
	}
};
static_assert(alignof(AVPatrolDoorNavLinkProxy) == 0x000008, "Wrong alignment on AVPatrolDoorNavLinkProxy");
static_assert(sizeof(AVPatrolDoorNavLinkProxy) == 0x000358, "Wrong size on AVPatrolDoorNavLinkProxy");
static_assert(offsetof(AVPatrolDoorNavLinkProxy, PairedNavLink) == 0x000350, "Member 'AVPatrolDoorNavLinkProxy::PairedNavLink' has a wrong offset!");

// Class Altar.VPawnPhysicsInteractionSubsystem
// 0x0010 (0x0050 - 0x0040)
class UVPawnPhysicsInteractionSubsystem final : public UTickableWorldSubsystem
{
public:
	TArray<struct FVPawnPhysicsInteractionData>   OngoingInteractions;                               // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPawnPhysicsInteractionSubsystem">();
	}
	static class UVPawnPhysicsInteractionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPawnPhysicsInteractionSubsystem>();
	}
};
static_assert(alignof(UVPawnPhysicsInteractionSubsystem) == 0x000008, "Wrong alignment on UVPawnPhysicsInteractionSubsystem");
static_assert(sizeof(UVPawnPhysicsInteractionSubsystem) == 0x000050, "Wrong size on UVPawnPhysicsInteractionSubsystem");
static_assert(offsetof(UVPawnPhysicsInteractionSubsystem, OngoingInteractions) == 0x000040, "Member 'UVPawnPhysicsInteractionSubsystem::OngoingInteractions' has a wrong offset!");

// Class Altar.VPawnSparkVFXBlueprint
// 0x0000 (0x02A0 - 0x02A0)
class AVPawnSparkVFXBlueprint final : public AVVFXBlueprint
{
public:
	void OnStartPlay(bool bIsBlocked, float Damages, const class AActor* Target, const class AActor* Attacker, bool bDoesBeginInFirstPerson, EVHitSourceType HitSourceType, EVHitSourceMaterial HitSourceMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPawnSparkVFXBlueprint">();
	}
	static class AVPawnSparkVFXBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPawnSparkVFXBlueprint>();
	}
};
static_assert(alignof(AVPawnSparkVFXBlueprint) == 0x000008, "Wrong alignment on AVPawnSparkVFXBlueprint");
static_assert(sizeof(AVPawnSparkVFXBlueprint) == 0x0002A0, "Wrong size on AVPawnSparkVFXBlueprint");

// Class Altar.VPhysicalAnimationComponent
// 0x0000 (0x00E0 - 0x00E0)
class UVPhysicalAnimationComponent final : public UPhysicalAnimationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPhysicalAnimationComponent">();
	}
	static class UVPhysicalAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPhysicalAnimationComponent>();
	}
};
static_assert(alignof(UVPhysicalAnimationComponent) == 0x000008, "Wrong alignment on UVPhysicalAnimationComponent");
static_assert(sizeof(UVPhysicalAnimationComponent) == 0x0000E0, "Wrong size on UVPhysicalAnimationComponent");

// Class Altar.VPhysicsControllable
// 0x0000 (0x0000 - 0x0000)
class IVPhysicsControllable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPhysicsControllable">();
	}
	static class IVPhysicsControllable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVPhysicsControllable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IVPhysicsControllable) == 0x000001, "Wrong alignment on IVPhysicsControllable");
static_assert(sizeof(IVPhysicsControllable) == 0x000001, "Wrong size on IVPhysicsControllable");

// Class Altar.VControllableEntry
// 0x0008 (0x0030 - 0x0028)
class UVControllableEntry final : public UObject
{
public:
	class FName                                   LabelName;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VControllableEntry">();
	}
	static class UVControllableEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVControllableEntry>();
	}
};
static_assert(alignof(UVControllableEntry) == 0x000008, "Wrong alignment on UVControllableEntry");
static_assert(sizeof(UVControllableEntry) == 0x000030, "Wrong size on UVControllableEntry");
static_assert(offsetof(UVControllableEntry, LabelName) == 0x000028, "Member 'UVControllableEntry::LabelName' has a wrong offset!");

// Class Altar.VPhysicsControllableWidget
// 0x0018 (0x02D8 - 0x02C0)
class UVPhysicsControllableWidget : public UUserWidget
{
public:
	TArray<struct FVPhysicsControllableDebugData> StoredDebugData;                                   // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         DisplayedDataIndex;                                // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateDisplayedData(const struct FVPhysicsControllableDebugData& ControllableDebugData, int32 DataIndex);
	void UpdateEntries(const TArray<class UVControllableEntry*>& ControllableEntries);

	class FString GetCurrentMapName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPhysicsControllableWidget">();
	}
	static class UVPhysicsControllableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPhysicsControllableWidget>();
	}
};
static_assert(alignof(UVPhysicsControllableWidget) == 0x000008, "Wrong alignment on UVPhysicsControllableWidget");
static_assert(sizeof(UVPhysicsControllableWidget) == 0x0002D8, "Wrong size on UVPhysicsControllableWidget");
static_assert(offsetof(UVPhysicsControllableWidget, StoredDebugData) == 0x0002C0, "Member 'UVPhysicsControllableWidget::StoredDebugData' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllableWidget, DisplayedDataIndex) == 0x0002D0, "Member 'UVPhysicsControllableWidget::DisplayedDataIndex' has a wrong offset!");

// Class Altar.VPhysicsControllerComponent
// 0x0340 (0x0558 - 0x0218)
class UVPhysicsControllerComponent final : public UVBuoyancyComponent
{
public:
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          GlobalImpactEvent;                                 // 0x0220(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVPhysicsSettingsAuthorityFlags        PhysicsSettingsAuthorityFlags;                     // 0x0228(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsUsingCustomPhysicsControlSettings;              // 0x022C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVPhysicsControlSettings               PhysicsControlSettingsOverride;                    // 0x0230(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FComponentReference>            PhysicallySimulatedComponentReferencesOverride;    // 0x0250(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FComponentReference>            PoseableComponentReferencesOverride;               // 0x0260(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   CustomConstraintProfile;                           // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVConstrainingMode                            CustomConstrainingMode;                            // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomLockParentName;                              // 0x027C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CustomLockLeavesNames;                             // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x50];                                     // 0x0298(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AWaterBody>              InteractingWaterBody;                              // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterLevel;                                        // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x24];                                     // 0x02F4(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          DebugBoxComponent;                                 // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0xB0];                                     // 0x0320(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class USkeletalMeshComponent>, struct FVPhysicsAssetPose> StoredPhysicsAssetPoses; // 0x03D0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class UPrimitiveComponent>, struct FTransform> StoredWorldTransforms;        // 0x0420(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAreCodeDrivenPhysicsSettingsAllowed;              // 0x0480(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_481[0x77];                                     // 0x0481(0x0077)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsOwnerGrabbed;                                   // 0x04F8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOwnerDisabled;                                  // 0x04F9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOwnerSimulatingPhysics;                         // 0x04FA(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVConstrainingMode                            SimulationConstrainingMode;                        // 0x04FB(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4FC[0x4];                                      // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class UPrimitiveComponent>, struct FVAttachComponentData> AttachComponentDataMap; // 0x0500(0x0050)(Edit, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_550[0x8];                                      // 0x0550(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeDampingValues(float DampingValuesMultiplier);
	void ClearWaterBodyInfo(class AActor* OverlappedActor, class AActor* OtherActor);
	void HandleCollisionSoundOnBeginOverlap(class UPrimitiveComponent* SourceComp, class AActor* TargetActor, class UPrimitiveComponent* TargetComp, int32 UnusedOtherBox, bool UnusedSweep, const struct FHitResult& EmptyHitResult);
	void HandleCollisionSoundOnHit(class UPrimitiveComponent* SourceComp, class AActor* TargetActor, class UPrimitiveComponent* TargetComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void InitializePontoons();
	void OnComponentPhysicsStateChanged(class UPrimitiveComponent* Component, EComponentPhysicsStateChange State);
	void RetrieveWaterBodyInfo(class AActor* OverlappedActor, class AActor* OtherActor);
	void TryOwnerPerformSnapToEnvironment(class UPrimitiveComponent* Component, EComponentPhysicsStateChange StateChange);

	TArray<class UPrimitiveComponent*> FindWaterInteractiveComponents() const;
	bool IsOwnerDisabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPhysicsControllerComponent">();
	}
	static class UVPhysicsControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPhysicsControllerComponent>();
	}
};
static_assert(alignof(UVPhysicsControllerComponent) == 0x000008, "Wrong alignment on UVPhysicsControllerComponent");
static_assert(sizeof(UVPhysicsControllerComponent) == 0x000558, "Wrong size on UVPhysicsControllerComponent");
static_assert(offsetof(UVPhysicsControllerComponent, GlobalImpactEvent) == 0x000220, "Member 'UVPhysicsControllerComponent::GlobalImpactEvent' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, PhysicsSettingsAuthorityFlags) == 0x000228, "Member 'UVPhysicsControllerComponent::PhysicsSettingsAuthorityFlags' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, bIsUsingCustomPhysicsControlSettings) == 0x00022C, "Member 'UVPhysicsControllerComponent::bIsUsingCustomPhysicsControlSettings' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, PhysicsControlSettingsOverride) == 0x000230, "Member 'UVPhysicsControllerComponent::PhysicsControlSettingsOverride' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, PhysicallySimulatedComponentReferencesOverride) == 0x000250, "Member 'UVPhysicsControllerComponent::PhysicallySimulatedComponentReferencesOverride' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, PoseableComponentReferencesOverride) == 0x000260, "Member 'UVPhysicsControllerComponent::PoseableComponentReferencesOverride' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, CustomConstraintProfile) == 0x000270, "Member 'UVPhysicsControllerComponent::CustomConstraintProfile' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, CustomConstrainingMode) == 0x000278, "Member 'UVPhysicsControllerComponent::CustomConstrainingMode' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, CustomLockParentName) == 0x00027C, "Member 'UVPhysicsControllerComponent::CustomLockParentName' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, CustomLockLeavesNames) == 0x000288, "Member 'UVPhysicsControllerComponent::CustomLockLeavesNames' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, InteractingWaterBody) == 0x0002E8, "Member 'UVPhysicsControllerComponent::InteractingWaterBody' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, WaterLevel) == 0x0002F0, "Member 'UVPhysicsControllerComponent::WaterLevel' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, DebugBoxComponent) == 0x000318, "Member 'UVPhysicsControllerComponent::DebugBoxComponent' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, StoredPhysicsAssetPoses) == 0x0003D0, "Member 'UVPhysicsControllerComponent::StoredPhysicsAssetPoses' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, StoredWorldTransforms) == 0x000420, "Member 'UVPhysicsControllerComponent::StoredWorldTransforms' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, bAreCodeDrivenPhysicsSettingsAllowed) == 0x000480, "Member 'UVPhysicsControllerComponent::bAreCodeDrivenPhysicsSettingsAllowed' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, bIsOwnerGrabbed) == 0x0004F8, "Member 'UVPhysicsControllerComponent::bIsOwnerGrabbed' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, bIsOwnerDisabled) == 0x0004F9, "Member 'UVPhysicsControllerComponent::bIsOwnerDisabled' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, bIsOwnerSimulatingPhysics) == 0x0004FA, "Member 'UVPhysicsControllerComponent::bIsOwnerSimulatingPhysics' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, SimulationConstrainingMode) == 0x0004FB, "Member 'UVPhysicsControllerComponent::SimulationConstrainingMode' has a wrong offset!");
static_assert(offsetof(UVPhysicsControllerComponent, AttachComponentDataMap) == 0x000500, "Member 'UVPhysicsControllerComponent::AttachComponentDataMap' has a wrong offset!");

// Class Altar.VPhysicsDebugPanel
// 0x0018 (0x02B0 - 0x0298)
class AVPhysicsDebugPanel final : public AActor
{
public:
	class USceneComponent*                        AnchorComponent;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetComponent*                       WidgetComponent;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        TargetArrowComponent;                              // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPhysicsDebugPanel">();
	}
	static class AVPhysicsDebugPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPhysicsDebugPanel>();
	}
};
static_assert(alignof(AVPhysicsDebugPanel) == 0x000008, "Wrong alignment on AVPhysicsDebugPanel");
static_assert(sizeof(AVPhysicsDebugPanel) == 0x0002B0, "Wrong size on AVPhysicsDebugPanel");
static_assert(offsetof(AVPhysicsDebugPanel, AnchorComponent) == 0x000298, "Member 'AVPhysicsDebugPanel::AnchorComponent' has a wrong offset!");
static_assert(offsetof(AVPhysicsDebugPanel, WidgetComponent) == 0x0002A0, "Member 'AVPhysicsDebugPanel::WidgetComponent' has a wrong offset!");
static_assert(offsetof(AVPhysicsDebugPanel, TargetArrowComponent) == 0x0002A8, "Member 'AVPhysicsDebugPanel::TargetArrowComponent' has a wrong offset!");

// Class Altar.VPhysicsSaveData
// 0x0080 (0x00B0 - 0x0030)
class UVPhysicsSaveData final : public UVBaseAltarSaveData
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FVPhysicsControllableState> PhysicsControllablesStates;                      // 0x0060(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPhysicsSaveData">();
	}
	static class UVPhysicsSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPhysicsSaveData>();
	}
};
static_assert(alignof(UVPhysicsSaveData) == 0x000008, "Wrong alignment on UVPhysicsSaveData");
static_assert(sizeof(UVPhysicsSaveData) == 0x0000B0, "Wrong size on UVPhysicsSaveData");
static_assert(offsetof(UVPhysicsSaveData, PhysicsControllablesStates) == 0x000060, "Member 'UVPhysicsSaveData::PhysicsControllablesStates' has a wrong offset!");

// Class Altar.VPhysicsUtilities
// 0x0000 (0x0028 - 0x0028)
class UVPhysicsUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyEquippedProfile(class AActor* EquippedActor, const class FString& CollisionLockKey);
	static void ApplyGhostProfiles(class APawn* Pawn);
	static void ApplyGrabbedProfile(class AActor* GrabbedActor, const class FString& CollisionLockKey);
	static void ApplyIgnoreCameraProfiles(class AActor* Actor, const class FString& CollisionLockKey);
	static void ApplyInvisibilityProfiles(class APawn* Pawn);
	static void ApplyNoCollisionProfile(class AActor* Actor, const class FString& CollisionLockKey);
	static void ApplyPawnDockingOnHorseProfile(class APawn* aPawn, const class FString& CollisionLockKey);
	static void ApplyPawnDockingProfile(class APawn* aPawn, const class FString& CollisionLockKey);
	static void ApplyWaterWalkingProfile(class AActor* Actor, const class FString& CollisionLockKey);
	static void CheckIsCollisionProfileNotAnonymous(const class UPrimitiveComponent* PrimitiveComponent);
	static void ClearAllCollisionTags(const class AActor* Actor);
	static bool FindDefaultCanEverAffectNavigation(const class AActor* Actor);
	static class FName FindDefaultCollisionProfileName(const class AActor* Actor);
	static bool FindNavigableTeleportSpot(const class APawn* Pawn, const struct FRotator& TeleportRotation, struct FVector& TeleportLocation);
	static bool IsCollisionProfileCodeDrivable(const class FName& Name_0);
	static bool IsCollisionProfileNameValid(const class FName& Name_0);
	static bool IsCollisionProfilePurelyCodeDriven(const class UPrimitiveComponent* PrimitiveComponent);
	static bool IsUsingTemporaryProfile(class AActor* Actor);
	static void RemoveGhostProfiles(class APawn* Pawn);
	static void RemoveInvisibilityProfiles(class APawn* Pawn);
	static void ResetAllOriginalProfilesToDefault(const class AActor* Actor);
	static void RestoreOriginalProfile(class AActor* Actor, const class FString& CollisionLockKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPhysicsUtilities">();
	}
	static class UVPhysicsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPhysicsUtilities>();
	}
};
static_assert(alignof(UVPhysicsUtilities) == 0x000008, "Wrong alignment on UVPhysicsUtilities");
static_assert(sizeof(UVPhysicsUtilities) == 0x000028, "Wrong size on UVPhysicsUtilities");

// Class Altar.VPlayerMenuViewModel
// 0x0048 (0x0118 - 0x00D0)
class UVPlayerMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnSettingsMenuOpen;                                // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSettingsMenuClose;                               // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnForceFooterUpdate;                               // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnForceFogUpdate;                                  // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	ELegacyPlayerMenuPage                         MenuPage;                                          // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x1];                                      // 0x0111(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsVisible;                                        // 0x0112(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsQuickKeysVisible;                               // 0x0113(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterChangeMenuHandler(ELegacyPlayerMenuPage NewPage);
	void RegisterCloseMenuFromSaveMenuHandler();
	void RegisterCloseMenuHandler();
	void RegisterClosePauseMenuHandler();
	void RegisterOpenPauseMenuHandler();
	void SetCurrentPage(ELegacyPlayerMenuPage NewPage);
	void SetQuickKeysVisibility(bool bNewVisibility);
	void SetVisibility(bool bNewVisibility);

	ELegacyPlayerMenuPage GetCurrentPage() const;
	bool IsQuickKeysVisible() const;
	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPlayerMenuViewModel">();
	}
	static class UVPlayerMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPlayerMenuViewModel>();
	}
};
static_assert(alignof(UVPlayerMenuViewModel) == 0x000008, "Wrong alignment on UVPlayerMenuViewModel");
static_assert(sizeof(UVPlayerMenuViewModel) == 0x000118, "Wrong size on UVPlayerMenuViewModel");
static_assert(offsetof(UVPlayerMenuViewModel, OnSettingsMenuOpen) == 0x0000D0, "Member 'UVPlayerMenuViewModel::OnSettingsMenuOpen' has a wrong offset!");
static_assert(offsetof(UVPlayerMenuViewModel, OnSettingsMenuClose) == 0x0000E0, "Member 'UVPlayerMenuViewModel::OnSettingsMenuClose' has a wrong offset!");
static_assert(offsetof(UVPlayerMenuViewModel, OnForceFooterUpdate) == 0x0000F0, "Member 'UVPlayerMenuViewModel::OnForceFooterUpdate' has a wrong offset!");
static_assert(offsetof(UVPlayerMenuViewModel, OnForceFogUpdate) == 0x000100, "Member 'UVPlayerMenuViewModel::OnForceFogUpdate' has a wrong offset!");
static_assert(offsetof(UVPlayerMenuViewModel, MenuPage) == 0x000110, "Member 'UVPlayerMenuViewModel::MenuPage' has a wrong offset!");
static_assert(offsetof(UVPlayerMenuViewModel, bIsVisible) == 0x000112, "Member 'UVPlayerMenuViewModel::bIsVisible' has a wrong offset!");
static_assert(offsetof(UVPlayerMenuViewModel, bIsQuickKeysVisible) == 0x000113, "Member 'UVPlayerMenuViewModel::bIsQuickKeysVisible' has a wrong offset!");

// Class Altar.VPowerSingleAttackAnimInstance
// 0x0030 (0x03F0 - 0x03C0)
class UVPowerSingleAttackAnimInstance final : public UVLeftRightAttackAnimInstance
{
public:
	struct FMeleeAttackPowerSingle                AnimSet;                                           // 0x03B8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPowerSingleAttackAnimInstance">();
	}
	static class UVPowerSingleAttackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPowerSingleAttackAnimInstance>();
	}
};
static_assert(alignof(UVPowerSingleAttackAnimInstance) == 0x000010, "Wrong alignment on UVPowerSingleAttackAnimInstance");
static_assert(sizeof(UVPowerSingleAttackAnimInstance) == 0x0003F0, "Wrong size on UVPowerSingleAttackAnimInstance");
static_assert(offsetof(UVPowerSingleAttackAnimInstance, AnimSet) == 0x0003B8, "Member 'UVPowerSingleAttackAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VPreviewDefaultLocationRotation
// 0x0000 (0x00B0 - 0x00B0)
class UVPreviewDefaultLocationRotation final : public UDataTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPreviewDefaultLocationRotation">();
	}
	static class UVPreviewDefaultLocationRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVPreviewDefaultLocationRotation>();
	}
};
static_assert(alignof(UVPreviewDefaultLocationRotation) == 0x000008, "Wrong alignment on UVPreviewDefaultLocationRotation");
static_assert(sizeof(UVPreviewDefaultLocationRotation) == 0x0000B0, "Wrong size on UVPreviewDefaultLocationRotation");

// Class Altar.VPropItem
// 0x0008 (0x02A0 - 0x0298)
class AVPropItem final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VPropItem">();
	}
	static class AVPropItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVPropItem>();
	}
};
static_assert(alignof(AVPropItem) == 0x000008, "Wrong alignment on AVPropItem");
static_assert(sizeof(AVPropItem) == 0x0002A0, "Wrong size on AVPropItem");

// Class Altar.VQuantityMenuViewModel
// 0x0018 (0x00E8 - 0x00D0)
class UVQuantityMenuViewModel final : public UVViewModelBase
{
public:
	float                                         SelectedValue;                                     // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLegacyScrollbarValueProperties        ScrollbarProperties;                               // 0x00D4(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSendClickedOnCancel();
	void RegisterSendClickedOnOkay(float Value);
	void SetScrollbarProperties(const struct FLegacyScrollbarValueProperties& NewScrollbarProperties);
	void SetSelectedValue(float NewSelectedValue);

	struct FLegacyScrollbarValueProperties GetScrollbarProperties() const;
	float GetSelectedValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VQuantityMenuViewModel">();
	}
	static class UVQuantityMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVQuantityMenuViewModel>();
	}
};
static_assert(alignof(UVQuantityMenuViewModel) == 0x000008, "Wrong alignment on UVQuantityMenuViewModel");
static_assert(sizeof(UVQuantityMenuViewModel) == 0x0000E8, "Wrong size on UVQuantityMenuViewModel");
static_assert(offsetof(UVQuantityMenuViewModel, SelectedValue) == 0x0000D0, "Member 'UVQuantityMenuViewModel::SelectedValue' has a wrong offset!");
static_assert(offsetof(UVQuantityMenuViewModel, ScrollbarProperties) == 0x0000D4, "Member 'UVQuantityMenuViewModel::ScrollbarProperties' has a wrong offset!");

// Class Altar.VQuickKeysMenuViewModel
// 0x0030 (0x0100 - 0x00D0)
class UVQuickKeysMenuViewModel final : public UVViewModelBase
{
public:
	int32                                         KeyIndex;                                          // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     Icons;                                             // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FText                                   Message;                                           // 0x00E8(0x0018)(NativeAccessSpecifierPrivate)

public:
	void RegisterSendClose();
	void RegisterSendForceMouseInputByAltar(bool bNewForceMouseInputByAltar);
	void RegisterSendOpen();
	void RegisterSendSelectedQuickKey(int32 KeyID);
	void SetIcons(const TArray<class UTexture2D*>& NewIcons);
	void SetKeyIndex(int32 NewKeyIndex);
	void SetMessage(const class FText& NewMessage);

	const TArray<class UTexture2D*> GetIcons() const;
	int32 GetKeyIndex() const;
	const class FText GetMessage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VQuickKeysMenuViewModel">();
	}
	static class UVQuickKeysMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVQuickKeysMenuViewModel>();
	}
};
static_assert(alignof(UVQuickKeysMenuViewModel) == 0x000008, "Wrong alignment on UVQuickKeysMenuViewModel");
static_assert(sizeof(UVQuickKeysMenuViewModel) == 0x000100, "Wrong size on UVQuickKeysMenuViewModel");
static_assert(offsetof(UVQuickKeysMenuViewModel, KeyIndex) == 0x0000D0, "Member 'UVQuickKeysMenuViewModel::KeyIndex' has a wrong offset!");
static_assert(offsetof(UVQuickKeysMenuViewModel, Icons) == 0x0000D8, "Member 'UVQuickKeysMenuViewModel::Icons' has a wrong offset!");
static_assert(offsetof(UVQuickKeysMenuViewModel, Message) == 0x0000E8, "Member 'UVQuickKeysMenuViewModel::Message' has a wrong offset!");

// Class Altar.VModernStatsDataItem
// 0x0038 (0x0060 - 0x0028)
class UVModernStatsDataItem final : public UObject
{
public:
	class FText                                   Name_0;                                            // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture*                               RowIcon;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TileIcon;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatGroupType                                Type;                                              // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultValue;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBaseValues(EStatGroupType InType, const class FText& InName, float InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VModernStatsDataItem">();
	}
	static class UVModernStatsDataItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVModernStatsDataItem>();
	}
};
static_assert(alignof(UVModernStatsDataItem) == 0x000008, "Wrong alignment on UVModernStatsDataItem");
static_assert(sizeof(UVModernStatsDataItem) == 0x000060, "Wrong size on UVModernStatsDataItem");
static_assert(offsetof(UVModernStatsDataItem, Name_0) == 0x000028, "Member 'UVModernStatsDataItem::Name_0' has a wrong offset!");
static_assert(offsetof(UVModernStatsDataItem, RowIcon) == 0x000040, "Member 'UVModernStatsDataItem::RowIcon' has a wrong offset!");
static_assert(offsetof(UVModernStatsDataItem, TileIcon) == 0x000048, "Member 'UVModernStatsDataItem::TileIcon' has a wrong offset!");
static_assert(offsetof(UVModernStatsDataItem, Value) == 0x000050, "Member 'UVModernStatsDataItem::Value' has a wrong offset!");
static_assert(offsetof(UVModernStatsDataItem, Type) == 0x000054, "Member 'UVModernStatsDataItem::Type' has a wrong offset!");
static_assert(offsetof(UVModernStatsDataItem, DefaultValue) == 0x000058, "Member 'UVModernStatsDataItem::DefaultValue' has a wrong offset!");

// Class Altar.VTorchCharacterAnimInstance
// 0x0050 (0x04B0 - 0x0460)
class UVTorchCharacterAnimInstance : public UVLocomotionCharacterAnimInstance
{
public:
	struct FTorchAnimationData                    AnimSet;                                           // 0x0460(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsHoldingTorch;                                   // 0x04A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseStandingTorchPose;                             // 0x04A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwitchToHandPose;                                 // 0x04A2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A3[0xD];                                      // 0x04A3(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupTorchLayer(const struct FTorchAnimationData& InAnimSet);

	bool CanDisableTorchPose() const;
	bool CanEnableTorchPose() const;
	bool IsBlocking() const;
	bool IsSneaking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTorchCharacterAnimInstance">();
	}
	static class UVTorchCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVTorchCharacterAnimInstance>();
	}
};
static_assert(alignof(UVTorchCharacterAnimInstance) == 0x000010, "Wrong alignment on UVTorchCharacterAnimInstance");
static_assert(sizeof(UVTorchCharacterAnimInstance) == 0x0004B0, "Wrong size on UVTorchCharacterAnimInstance");
static_assert(offsetof(UVTorchCharacterAnimInstance, AnimSet) == 0x000460, "Member 'UVTorchCharacterAnimInstance::AnimSet' has a wrong offset!");
static_assert(offsetof(UVTorchCharacterAnimInstance, bIsHoldingTorch) == 0x0004A0, "Member 'UVTorchCharacterAnimInstance::bIsHoldingTorch' has a wrong offset!");
static_assert(offsetof(UVTorchCharacterAnimInstance, bUseStandingTorchPose) == 0x0004A1, "Member 'UVTorchCharacterAnimInstance::bUseStandingTorchPose' has a wrong offset!");
static_assert(offsetof(UVTorchCharacterAnimInstance, bSwitchToHandPose) == 0x0004A2, "Member 'UVTorchCharacterAnimInstance::bSwitchToHandPose' has a wrong offset!");

// Class Altar.VRaceSexMenuViewModel
// 0x0498 (0x0568 - 0x00D0)
class UVRaceSexMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void(bool bShouldShow, class UUserWidget* Caller, const struct FModernRaceSexMenuColorProperties& Properties)> OnColorPickerChangedDelegate; // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FPlayerNamePair& NamePair)> OnNameSetDelegate;        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnResetRequestedDelegate;                          // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MaxNameLength;                                     // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVPhenotypeCustomizationSession*        PlayerCustomizationSession;                        // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELegacyRaceSexMenuPage                        CurrentPage;                                       // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentArchetype;                                  // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentSex;                                        // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FModernRaceSexMenuArchetypeProperties> ArchetypesProperties;                       // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FString                                 CurrentRace;                                       // 0x0130(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   RaceDescription;                                   // 0x0140(0x0018)(NativeAccessSpecifierPrivate)
	class FText                                   CurrentName;                                       // 0x0158(0x0018)(NativeAccessSpecifierPrivate)
	struct FPlayerNamePair                        PlayerNameLocalizationPair;                        // 0x0170(0x0028)(NativeAccessSpecifierPrivate)
	class UVActorValuesPairingComponent*          CurrentActorStats;                                 // 0x0198(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   CurrentHairName;                                   // 0x01A0(0x0018)(NativeAccessSpecifierPrivate)
	struct FRaceSexMenuPhenotypeData              PhenotypeData;                                     // 0x01B8(0x0100)(NativeAccessSpecifierPrivate)
	struct FRaceSexMenuPhenotypeData              SyncedPhenotypeData;                               // 0x02B8(0x0100)(NativeAccessSpecifierPrivate)
	TArray<struct FLegacyRaceSexMenuTableRow>     CommonCharacterModifications;                      // 0x03B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FLegacyRaceSexMenuRaceProperties> RaceModificationProperties;                      // 0x03C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FVRaceDataRows>    RaceRowDataMap;                                    // 0x03D8(0x0050)(NativeAccessSpecifierPrivate)
	TArray<ELegacyRaceSexMenuPage>                PageHistory;                                       // 0x0428(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTESRace*>                       RacesPtrArray;                                     // 0x0438(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x120];                                    // 0x0448(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseMenu(EVFadeTransitionType Type);
	int32 GetCurrentHairIndex(bool bHardReset);
	void OnResetRefreshEnd();
	struct FLegacyRaceSexMenuButtonProperties ParseButtonProperties(const struct FLegacyRaceSexMenuButtonProperties& TableProperties);
	struct FLegacyRaceSexMenuToggleProperties ParseToggleProperties(const struct FLegacyRaceSexMenuToggleProperties& TableProperties);
	void Random();
	void RegisterSendDoneButtonHandler();
	void RequestColorPicker(bool bShouldShow, class UUserWidget* Caller, const struct FModernRaceSexMenuColorProperties& Properties);
	void Reset();
	void ReturnToPreviousPage();
	void SetActorStats(class UVActorValuesPairingComponent* NewCurrentActorStats);
	void SetActorStatsWrapper();
	void SetArchetypesProperties(const TArray<struct FModernRaceSexMenuArchetypeProperties>& NewArchetypesProperties);
	void SetCurrentArchetype(const int32& NewArchetype);
	void SetCurrentHairName(const class FText& NewName);
	void SetCurrentName(const class FText& NewName);
	void SetCurrentPage(ELegacyRaceSexMenuPage NewCurrentPage);
	void SetCurrentRace(const class FString& NewRace);
	void SetCurrentRaceWithForceUpdate(const class FString& NewRace);
	void SetCurrentSex(const int32& NewSex);
	void SetPhenotypeData(const struct FRaceSexMenuPhenotypeData& NewPhenotypeData);
	void SetPlayerNameLocalizationPair(const struct FPlayerNamePair& NewNamePair);
	void SetRaceDescription(const class FText& NewRaceDescription);
	void SetSave();
	void SilentSetCurrentRace(const class FString& NewRace);
	void SyncCharacterWithModel();
	void UpdateArchetype(int32 ArchetypeIndex);
	void UpdateColorTarget(const class FName& ValueType, const struct FColor& TargetValue, bool bUpdateCharacter);
	void UpdateCustomisationTarget(const struct FLegacyRaceSexMenuToggleProperties& Property, int32 OptionIndex, bool bUpdateCharacter);
	void UpdateEyeColor(class UMaterialInterface* EyeMaterial, int32 CustomisationIndex, bool bUpdateCharacter);
	void UpdateHair(const class UVCharacterHairPieceBase* HairPiece, int32 CustomisationIndex, bool bUpdateCharacter);
	void UpdateMorphTarget(class FName TargetName, float TargetValue, bool bUpdateCharacter);
	void UpdatePhenotypeValue(const class FName& ValueType, float Value, bool bUpdateCharacter);
	void UpdateRaceSexArchetype(const class FText& NewRaceDescription, int32 RaceIndex, int32 SexIndex, int32 ArchetypeIndex, class UTESRace* TESRacePtr, bool bUpdateCharacter);
	void UpdateWidgetPhenotypeData(bool bHardReset);

	const class UVActorValuesPairingComponent* GetActorStats() const;
	const TArray<struct FLegacyRaceSexMenuRaceProperties> GetAllRaceModificationProperties() const;
	const TArray<struct FModernRaceSexMenuArchetypeProperties> GetArchetypesProperties() const;
	const TArray<struct FLegacyRaceSexMenuTableRow> GetCommonCharacterModifications() const;
	int32 GetCurrentArchetype() const;
	const class FText GetCurrentHairName() const;
	const class FText GetCurrentName() const;
	ELegacyRaceSexMenuPage GetCurrentPage() const;
	class FString GetCurrentRace() const;
	int32 GetCurrentSex() const;
	TMap<class FName, class FText> GetPagesOfCategory(const EModernRaceSexPage& CurrentPageToAnalyse) const;
	const struct FRaceSexMenuPhenotypeData GetPhenotypeData() const;
	const struct FPlayerNamePair GetPlayerNameLocalizationPair() const;
	const class FText GetRaceDescription() const;
	int32 GetRaceId(const class FString& RaceName) const;
	TArray<struct FLegacyRaceSexMenuTableRow> GetRaceModificationItemsProperties(const class FString& RaceName) const;
	const struct FLegacyRaceSexMenuRaceProperties GetRaceModificationProperties(const class FString& RaceName) const;
	const TArray<struct FLegacyRaceSexMenuTableRow> GetRaceTableRows(const class FString& RaceName) const;
	const struct FLegacyRaceSexMenuTableRow GetSliderTableRowDataFromCommon(const class FName& MorphTarget) const;
	const struct FRaceSexMenuPhenotypeData GetSyncedPhenotypeData() const;
	const struct FLegacyRaceSexMenuTableRow GetToggleTableRowDataFromCommon(ELegacyRaceSexMenuToggleType Type) const;
	bool IsGenericPageScrollboxValid(const class FName& CategoryKey, class UScrollBox* ScrollBox) const;
	void RequestQuitDialog() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VRaceSexMenuViewModel">();
	}
	static class UVRaceSexMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVRaceSexMenuViewModel>();
	}
};
static_assert(alignof(UVRaceSexMenuViewModel) == 0x000008, "Wrong alignment on UVRaceSexMenuViewModel");
static_assert(sizeof(UVRaceSexMenuViewModel) == 0x000568, "Wrong size on UVRaceSexMenuViewModel");
static_assert(offsetof(UVRaceSexMenuViewModel, OnColorPickerChangedDelegate) == 0x0000D0, "Member 'UVRaceSexMenuViewModel::OnColorPickerChangedDelegate' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, OnNameSetDelegate) == 0x0000E0, "Member 'UVRaceSexMenuViewModel::OnNameSetDelegate' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, OnResetRequestedDelegate) == 0x0000F0, "Member 'UVRaceSexMenuViewModel::OnResetRequestedDelegate' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, MaxNameLength) == 0x000100, "Member 'UVRaceSexMenuViewModel::MaxNameLength' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, PlayerCustomizationSession) == 0x000108, "Member 'UVRaceSexMenuViewModel::PlayerCustomizationSession' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, CurrentPage) == 0x000110, "Member 'UVRaceSexMenuViewModel::CurrentPage' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, CurrentArchetype) == 0x000114, "Member 'UVRaceSexMenuViewModel::CurrentArchetype' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, CurrentSex) == 0x000118, "Member 'UVRaceSexMenuViewModel::CurrentSex' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, ArchetypesProperties) == 0x000120, "Member 'UVRaceSexMenuViewModel::ArchetypesProperties' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, CurrentRace) == 0x000130, "Member 'UVRaceSexMenuViewModel::CurrentRace' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, RaceDescription) == 0x000140, "Member 'UVRaceSexMenuViewModel::RaceDescription' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, CurrentName) == 0x000158, "Member 'UVRaceSexMenuViewModel::CurrentName' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, PlayerNameLocalizationPair) == 0x000170, "Member 'UVRaceSexMenuViewModel::PlayerNameLocalizationPair' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, CurrentActorStats) == 0x000198, "Member 'UVRaceSexMenuViewModel::CurrentActorStats' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, CurrentHairName) == 0x0001A0, "Member 'UVRaceSexMenuViewModel::CurrentHairName' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, PhenotypeData) == 0x0001B8, "Member 'UVRaceSexMenuViewModel::PhenotypeData' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, SyncedPhenotypeData) == 0x0002B8, "Member 'UVRaceSexMenuViewModel::SyncedPhenotypeData' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, CommonCharacterModifications) == 0x0003B8, "Member 'UVRaceSexMenuViewModel::CommonCharacterModifications' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, RaceModificationProperties) == 0x0003C8, "Member 'UVRaceSexMenuViewModel::RaceModificationProperties' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, RaceRowDataMap) == 0x0003D8, "Member 'UVRaceSexMenuViewModel::RaceRowDataMap' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, PageHistory) == 0x000428, "Member 'UVRaceSexMenuViewModel::PageHistory' has a wrong offset!");
static_assert(offsetof(UVRaceSexMenuViewModel, RacesPtrArray) == 0x000438, "Member 'UVRaceSexMenuViewModel::RacesPtrArray' has a wrong offset!");

// Class Altar.VRaceSexSave
// 0x0008 (0x0040 - 0x0038)
class UVRaceSexSave final : public UVBaseUIGameSaveData
{
public:
	int32                                         CurrentArchetype;                                  // 0x0038(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VRaceSexSave">();
	}
	static class UVRaceSexSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVRaceSexSave>();
	}
};
static_assert(alignof(UVRaceSexSave) == 0x000008, "Wrong alignment on UVRaceSexSave");
static_assert(sizeof(UVRaceSexSave) == 0x000040, "Wrong size on UVRaceSexSave");
static_assert(offsetof(UVRaceSexSave, CurrentArchetype) == 0x000038, "Member 'UVRaceSexSave::CurrentArchetype' has a wrong offset!");

// Class Altar.VRadialMenu
// 0x0008 (0x04D0 - 0x04C8)
class UVRadialMenu final : public UVAltarWidget
{
public:
	class UWidget*                                CenterWidget;                                      // 0x04C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetMouseCursorAngle() const;
	float GetMouseCursorDistance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VRadialMenu">();
	}
	static class UVRadialMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVRadialMenu>();
	}
};
static_assert(alignof(UVRadialMenu) == 0x000008, "Wrong alignment on UVRadialMenu");
static_assert(sizeof(UVRadialMenu) == 0x0004D0, "Wrong size on UVRadialMenu");
static_assert(offsetof(UVRadialMenu, CenterWidget) == 0x0004C8, "Member 'UVRadialMenu::CenterWidget' has a wrong offset!");

// Class Altar.VRebindGlobalSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class UVRebindGlobalSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnRequestWidgetRefresh;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UVModernRebindSettingWidget* ChangedRebind)> OnRebindChangedDelegete; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UVNavigableInputKeySelector* Target, bool NewState)> OnSelectorListenStateChangedDelegate; // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bListenState)> OnBroadcastListenChangedDelegate;              // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x70];                                      // 0x0070(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyRebindHasBeenChanged(bool bListenState);
	void RegisterKeySelector(class UVAltarNavigableInputKeySelector* Selector);
	void RegisterListeningWidget(class UVModernRebindSettingWidget* RebindWidget, class UVNavigableInputKeySelector* Target);
	void RegisterRebindWidget(class UVModernRebindSettingWidget* OwnerItem, EVModernRebindType Type, const struct FModernRebindData& RebindData, const struct FModernPairedRebindData& PairedRebindData);
	void RequestBroadcastOnSettingsChanged(class UVModernRebindSettingWidget* ChangedRebind);
	void RequestWidgetsRefresh();
	void StopAllSelectorListenning(const class UVAltarNavigableInputKeySelector* Exeption);
	void UnregisterKeySelector(class UVAltarNavigableInputKeySelector* Selector);
	void UnregisterListeningWidget(class UVModernRebindSettingWidget* RebindWidget, class UVNavigableInputKeySelector* Target);
	void UnregisterRebindWidget(class UVModernRebindSettingWidget* OwnerItem);

	bool DoesHaveAEmptyPrimaryBinding() const;
	bool DoesHaveAEmptyPrimaryBindingForType(EVModernRebindType ComparedType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VRebindGlobalSubsystem">();
	}
	static class UVRebindGlobalSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVRebindGlobalSubsystem>();
	}
};
static_assert(alignof(UVRebindGlobalSubsystem) == 0x000008, "Wrong alignment on UVRebindGlobalSubsystem");
static_assert(sizeof(UVRebindGlobalSubsystem) == 0x0000E0, "Wrong size on UVRebindGlobalSubsystem");
static_assert(offsetof(UVRebindGlobalSubsystem, OnRequestWidgetRefresh) == 0x000030, "Member 'UVRebindGlobalSubsystem::OnRequestWidgetRefresh' has a wrong offset!");
static_assert(offsetof(UVRebindGlobalSubsystem, OnRebindChangedDelegete) == 0x000040, "Member 'UVRebindGlobalSubsystem::OnRebindChangedDelegete' has a wrong offset!");
static_assert(offsetof(UVRebindGlobalSubsystem, OnSelectorListenStateChangedDelegate) == 0x000050, "Member 'UVRebindGlobalSubsystem::OnSelectorListenStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(UVRebindGlobalSubsystem, OnBroadcastListenChangedDelegate) == 0x000060, "Member 'UVRebindGlobalSubsystem::OnBroadcastListenChangedDelegate' has a wrong offset!");

// Class Altar.VLegacyRechargeMenuItem
// 0x0040 (0x0068 - 0x0028)
class UVLegacyRechargeMenuItem final : public UObject
{
public:
	struct FLegacyRechargeMenuItemProperties      Properties;                                        // 0x0028(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void SetProperties(const struct FLegacyRechargeMenuItemProperties& Value);

	int32 GetIndex() const;
	const struct FLegacyRechargeMenuItemProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyRechargeMenuItem">();
	}
	static class UVLegacyRechargeMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyRechargeMenuItem>();
	}
};
static_assert(alignof(UVLegacyRechargeMenuItem) == 0x000008, "Wrong alignment on UVLegacyRechargeMenuItem");
static_assert(sizeof(UVLegacyRechargeMenuItem) == 0x000068, "Wrong size on UVLegacyRechargeMenuItem");
static_assert(offsetof(UVLegacyRechargeMenuItem, Properties) == 0x000028, "Member 'UVLegacyRechargeMenuItem::Properties' has a wrong offset!");

// Class Altar.VRechargeMenuViewModel
// 0x00F8 (0x01C8 - 0x00D0)
class UVRechargeMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnSucessRechargeSoundTrigger;                      // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSucessRechargeMerchantSoundTrigger;              // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSucessRechargeAllSoundTrigger;                   // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<struct FLegacyRechargeMenuItemProperties> Items;                                          // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FLegacyRechargeMenuGoldProperties      RechargeMenuGoldProperties;                        // 0x0110(0x0028)(NativeAccessSpecifierPrivate)
	struct FLegacyRechargeMenuSoulProperties      RechargeMenuSoulProperties;                        // 0x0138(0x0040)(NativeAccessSpecifierPrivate)
	ELegacyRechargeMenuPage                       RechargeMenuPage;                                  // 0x0178(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOriginalInventoryMenuSortType                SortType;                                          // 0x0179(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOpenedFromQuickWheel;                           // 0x017A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17B[0x5];                                      // 0x017B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSortReversed;                                   // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModernRechargeMenuCharacterData       PlayerData;                                        // 0x0188(0x0020)(NativeAccessSpecifierPrivate)
	struct FModernRechargeMenuCharacterData       MerchantData;                                      // 0x01A8(0x0020)(NativeAccessSpecifierPrivate)

public:
	void RegisterSendClickedExit();
	void RegisterSendClickedItem(int32 Index_0);
	void RegisterSendClickedRechargeAll();
	void RegisterSendHoveredItem(int32 Index_0);
	void SetIsOpenedFromQuickWheel(bool bNewIsOpenedFromQuickWheel);
	void SetIsSortReversed(bool bNewIsSortReversed);
	void SetItems(const TArray<struct FLegacyRechargeMenuItemProperties>& NewItems);
	void SetMerchantData(const struct FModernRechargeMenuCharacterData& NewMerchantData);
	void SetMerchantGold(int32 NewMerchantGold);
	void SetPlayerData(const struct FModernRechargeMenuCharacterData& NewPlayerData);
	void SetPlayerGold(int32 NewPlayerGold);
	void SetRechargeMenuGoldProperties(const struct FLegacyRechargeMenuGoldProperties& NewValue);
	void SetRechargeMenuPage(const ELegacyRechargeMenuPage& NewValue);
	void SetRechargeMenuSoulProperties(const struct FLegacyRechargeMenuSoulProperties& NewValue);
	void SetSortType(const EOriginalInventoryMenuSortType& NewSortType);

	const TArray<struct FLegacyRechargeMenuItemProperties> GetItems() const;
	struct FModernRechargeMenuCharacterData GetMerchantData() const;
	struct FModernRechargeMenuCharacterData GetPlayerData() const;
	const struct FLegacyRechargeMenuGoldProperties GetRechargeMenuGoldProperties() const;
	const ELegacyRechargeMenuPage GetRechargeMenuPage() const;
	const struct FLegacyRechargeMenuSoulProperties GetRechargeMenuSoulProperties() const;
	EOriginalInventoryMenuSortType GetSortType() const;
	bool IsOpenedFromQuickWheel() const;
	bool IsSortReversed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VRechargeMenuViewModel">();
	}
	static class UVRechargeMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVRechargeMenuViewModel>();
	}
};
static_assert(alignof(UVRechargeMenuViewModel) == 0x000008, "Wrong alignment on UVRechargeMenuViewModel");
static_assert(sizeof(UVRechargeMenuViewModel) == 0x0001C8, "Wrong size on UVRechargeMenuViewModel");
static_assert(offsetof(UVRechargeMenuViewModel, OnSucessRechargeSoundTrigger) == 0x0000D0, "Member 'UVRechargeMenuViewModel::OnSucessRechargeSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVRechargeMenuViewModel, OnSucessRechargeMerchantSoundTrigger) == 0x0000E0, "Member 'UVRechargeMenuViewModel::OnSucessRechargeMerchantSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVRechargeMenuViewModel, OnSucessRechargeAllSoundTrigger) == 0x0000F0, "Member 'UVRechargeMenuViewModel::OnSucessRechargeAllSoundTrigger' has a wrong offset!");
static_assert(offsetof(UVRechargeMenuViewModel, Items) == 0x000100, "Member 'UVRechargeMenuViewModel::Items' has a wrong offset!");
static_assert(offsetof(UVRechargeMenuViewModel, RechargeMenuGoldProperties) == 0x000110, "Member 'UVRechargeMenuViewModel::RechargeMenuGoldProperties' has a wrong offset!");
static_assert(offsetof(UVRechargeMenuViewModel, RechargeMenuSoulProperties) == 0x000138, "Member 'UVRechargeMenuViewModel::RechargeMenuSoulProperties' has a wrong offset!");
static_assert(offsetof(UVRechargeMenuViewModel, RechargeMenuPage) == 0x000178, "Member 'UVRechargeMenuViewModel::RechargeMenuPage' has a wrong offset!");
static_assert(offsetof(UVRechargeMenuViewModel, SortType) == 0x000179, "Member 'UVRechargeMenuViewModel::SortType' has a wrong offset!");
static_assert(offsetof(UVRechargeMenuViewModel, bIsOpenedFromQuickWheel) == 0x00017A, "Member 'UVRechargeMenuViewModel::bIsOpenedFromQuickWheel' has a wrong offset!");
static_assert(offsetof(UVRechargeMenuViewModel, bIsSortReversed) == 0x000180, "Member 'UVRechargeMenuViewModel::bIsSortReversed' has a wrong offset!");
static_assert(offsetof(UVRechargeMenuViewModel, PlayerData) == 0x000188, "Member 'UVRechargeMenuViewModel::PlayerData' has a wrong offset!");
static_assert(offsetof(UVRechargeMenuViewModel, MerchantData) == 0x0001A8, "Member 'UVRechargeMenuViewModel::MerchantData' has a wrong offset!");

// Class Altar.VRecoilCharacterAnimInstance
// 0x0010 (0x03B0 - 0x03A0)
#pragma pack(push, 0x1)
class alignas(0x10) UVRecoilCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	class UAnimMontage*                           RecoilMontage;                                     // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VRecoilCharacterAnimInstance">();
	}
	static class UVRecoilCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVRecoilCharacterAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVRecoilCharacterAnimInstance) == 0x000010, "Wrong alignment on UVRecoilCharacterAnimInstance");
static_assert(sizeof(UVRecoilCharacterAnimInstance) == 0x0003B0, "Wrong size on UVRecoilCharacterAnimInstance");
static_assert(offsetof(UVRecoilCharacterAnimInstance, RecoilMontage) == 0x0003A0, "Member 'UVRecoilCharacterAnimInstance::RecoilMontage' has a wrong offset!");

// Class Altar.VRecoilMultipleCharacterAnimInstance
// 0x0010 (0x03C0 - 0x03B0)
class UVRecoilMultipleCharacterAnimInstance : public UVRecoilCharacterAnimInstance
{
public:
	struct FVRecoilMultiple                       AnimSet;                                           // 0x03A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VRecoilMultipleCharacterAnimInstance">();
	}
	static class UVRecoilMultipleCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVRecoilMultipleCharacterAnimInstance>();
	}
};
static_assert(alignof(UVRecoilMultipleCharacterAnimInstance) == 0x000010, "Wrong alignment on UVRecoilMultipleCharacterAnimInstance");
static_assert(sizeof(UVRecoilMultipleCharacterAnimInstance) == 0x0003C0, "Wrong size on UVRecoilMultipleCharacterAnimInstance");
static_assert(offsetof(UVRecoilMultipleCharacterAnimInstance, AnimSet) == 0x0003A8, "Member 'UVRecoilMultipleCharacterAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VRecoilSingleCharacterAnimInstance
// 0x0010 (0x03C0 - 0x03B0)
class UVRecoilSingleCharacterAnimInstance final : public UVRecoilCharacterAnimInstance
{
public:
	struct FVRecoil                               AnimSet;                                           // 0x03A8(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VRecoilSingleCharacterAnimInstance">();
	}
	static class UVRecoilSingleCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVRecoilSingleCharacterAnimInstance>();
	}
};
static_assert(alignof(UVRecoilSingleCharacterAnimInstance) == 0x000010, "Wrong alignment on UVRecoilSingleCharacterAnimInstance");
static_assert(sizeof(UVRecoilSingleCharacterAnimInstance) == 0x0003C0, "Wrong size on UVRecoilSingleCharacterAnimInstance");
static_assert(offsetof(UVRecoilSingleCharacterAnimInstance, AnimSet) == 0x0003A8, "Member 'UVRecoilSingleCharacterAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VRecoilStandSwimCharacterAnimInstance
// 0x0040 (0x03F0 - 0x03B0)
class UVRecoilStandSwimCharacterAnimInstance final : public UVRecoilCharacterAnimInstance
{
public:
	class UAnimMontage*                           LandRecoilMontage;                                 // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           SwimRecoilMontage;                                 // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          LandIdleBlend;                                     // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          SwimIdleBlend;                                     // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          IdleBlend;                                         // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVStandSwimRecoil                      AnimSet;                                           // 0x03D0(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VRecoilStandSwimCharacterAnimInstance">();
	}
	static class UVRecoilStandSwimCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVRecoilStandSwimCharacterAnimInstance>();
	}
};
static_assert(alignof(UVRecoilStandSwimCharacterAnimInstance) == 0x000010, "Wrong alignment on UVRecoilStandSwimCharacterAnimInstance");
static_assert(sizeof(UVRecoilStandSwimCharacterAnimInstance) == 0x0003F0, "Wrong size on UVRecoilStandSwimCharacterAnimInstance");
static_assert(offsetof(UVRecoilStandSwimCharacterAnimInstance, LandRecoilMontage) == 0x0003A8, "Member 'UVRecoilStandSwimCharacterAnimInstance::LandRecoilMontage' has a wrong offset!");
static_assert(offsetof(UVRecoilStandSwimCharacterAnimInstance, SwimRecoilMontage) == 0x0003B0, "Member 'UVRecoilStandSwimCharacterAnimInstance::SwimRecoilMontage' has a wrong offset!");
static_assert(offsetof(UVRecoilStandSwimCharacterAnimInstance, LandIdleBlend) == 0x0003B8, "Member 'UVRecoilStandSwimCharacterAnimInstance::LandIdleBlend' has a wrong offset!");
static_assert(offsetof(UVRecoilStandSwimCharacterAnimInstance, SwimIdleBlend) == 0x0003C0, "Member 'UVRecoilStandSwimCharacterAnimInstance::SwimIdleBlend' has a wrong offset!");
static_assert(offsetof(UVRecoilStandSwimCharacterAnimInstance, IdleBlend) == 0x0003C8, "Member 'UVRecoilStandSwimCharacterAnimInstance::IdleBlend' has a wrong offset!");
static_assert(offsetof(UVRecoilStandSwimCharacterAnimInstance, AnimSet) == 0x0003D0, "Member 'UVRecoilStandSwimCharacterAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VLegacyRepairMenuItem
// 0x0048 (0x0070 - 0x0028)
class UVLegacyRepairMenuItem final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const struct FLegacyRepairItemProperties& Value);

	int32 GetIndex() const;
	const struct FLegacyRepairItemProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacyRepairMenuItem">();
	}
	static class UVLegacyRepairMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacyRepairMenuItem>();
	}
};
static_assert(alignof(UVLegacyRepairMenuItem) == 0x000008, "Wrong alignment on UVLegacyRepairMenuItem");
static_assert(sizeof(UVLegacyRepairMenuItem) == 0x000070, "Wrong size on UVLegacyRepairMenuItem");

// Class Altar.VSpecialIdleLayerAnimInstance
// 0x0050 (0x03F0 - 0x03A0)
class UVSpecialIdleLayerAnimInstance final : public UVLayerCharacterAnimInstance
{
public:
	struct FVSpecialAndDynamicIdle                SpecialAndDynamicIdleSettings;                     // 0x03A0(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          IsPlayingSpecialIdle;                              // 0x03AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInDynamicIdle;                                   // 0x03AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WasInSpecialIdle;                                  // 0x03AE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDynamicIdleChanged;                              // 0x03AF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DynamicIdleBlendTime;                              // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SpecialIdleSequence;                               // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      OldSpecialIdleSequence;                            // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           SpecialIdleMontage;                                // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      DynamicIdleSequence;                               // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      OldDynamicIdleSequence;                            // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageSlotName;                                   // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ShouldStopSpecialIdle();
	void StartSpecialIdle();
	void StopSpecialIdle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSpecialIdleLayerAnimInstance">();
	}
	static class UVSpecialIdleLayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSpecialIdleLayerAnimInstance>();
	}
};
static_assert(alignof(UVSpecialIdleLayerAnimInstance) == 0x000010, "Wrong alignment on UVSpecialIdleLayerAnimInstance");
static_assert(sizeof(UVSpecialIdleLayerAnimInstance) == 0x0003F0, "Wrong size on UVSpecialIdleLayerAnimInstance");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, SpecialAndDynamicIdleSettings) == 0x0003A0, "Member 'UVSpecialIdleLayerAnimInstance::SpecialAndDynamicIdleSettings' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, IsPlayingSpecialIdle) == 0x0003AC, "Member 'UVSpecialIdleLayerAnimInstance::IsPlayingSpecialIdle' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, IsInDynamicIdle) == 0x0003AD, "Member 'UVSpecialIdleLayerAnimInstance::IsInDynamicIdle' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, WasInSpecialIdle) == 0x0003AE, "Member 'UVSpecialIdleLayerAnimInstance::WasInSpecialIdle' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, IsDynamicIdleChanged) == 0x0003AF, "Member 'UVSpecialIdleLayerAnimInstance::IsDynamicIdleChanged' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, DynamicIdleBlendTime) == 0x0003B0, "Member 'UVSpecialIdleLayerAnimInstance::DynamicIdleBlendTime' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, SpecialIdleSequence) == 0x0003B8, "Member 'UVSpecialIdleLayerAnimInstance::SpecialIdleSequence' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, OldSpecialIdleSequence) == 0x0003C0, "Member 'UVSpecialIdleLayerAnimInstance::OldSpecialIdleSequence' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, SpecialIdleMontage) == 0x0003C8, "Member 'UVSpecialIdleLayerAnimInstance::SpecialIdleMontage' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, DynamicIdleSequence) == 0x0003D0, "Member 'UVSpecialIdleLayerAnimInstance::DynamicIdleSequence' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, OldDynamicIdleSequence) == 0x0003D8, "Member 'UVSpecialIdleLayerAnimInstance::OldDynamicIdleSequence' has a wrong offset!");
static_assert(offsetof(UVSpecialIdleLayerAnimInstance, MontageSlotName) == 0x0003E0, "Member 'UVSpecialIdleLayerAnimInstance::MontageSlotName' has a wrong offset!");

// Class Altar.VLegacySpellMakingItem
// 0x0030 (0x0058 - 0x0028)
class UVLegacySpellMakingItem final : public UObject
{
public:
	struct FLegacyEffectsItemProperties           Properties;                                        // 0x0028(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)

public:
	void SetProperties(const struct FLegacyEffectsItemProperties& Value);

	const int32 GetIndex() const;
	const struct FLegacyEffectsItemProperties GetProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VLegacySpellMakingItem">();
	}
	static class UVLegacySpellMakingItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVLegacySpellMakingItem>();
	}
};
static_assert(alignof(UVLegacySpellMakingItem) == 0x000008, "Wrong alignment on UVLegacySpellMakingItem");
static_assert(sizeof(UVLegacySpellMakingItem) == 0x000058, "Wrong size on UVLegacySpellMakingItem");
static_assert(offsetof(UVLegacySpellMakingItem, Properties) == 0x000028, "Member 'UVLegacySpellMakingItem::Properties' has a wrong offset!");

// Class Altar.VSpellPurchaseMenuViewModel
// 0x0050 (0x0120 - 0x00D0)
class UVSpellPurchaseMenuViewModel final : public UVViewModelBase
{
public:
	TArray<struct FLegacySpellPurchaseMenuItemProperties> SpellList;                                 // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FText                                   PlayerName;                                        // 0x00E0(0x0018)(NativeAccessSpecifierPrivate)
	int32                                         PlayerMoney;                                       // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELegacySpellPurchaseMenuSortType              SortType;                                          // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsSortReversed;                                    // 0x00FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacySpellPurchaseMenuNPCData        NpcData;                                           // 0x0100(0x0020)(NativeAccessSpecifierPrivate)

public:
	void RegisterSendCloseButtonClicked();
	void RegisterSendHaggleButtonClicked();
	void RegisterSendItemHoverHandler(int32 InButtonIndex);
	void RegisterSendSpellItemClicked(int32 InButtonIndex);
	void SetIsSortReversed(const bool Value);
	void SetNpcData(const struct FLegacySpellPurchaseMenuNPCData& NewNPCData);
	void SetPlayerMoney(int32 NewPlayerMoney);
	void SetPlayerName(const class FText& NewPlayerName);
	void SetSortType(const ELegacySpellPurchaseMenuSortType Value);

	bool GetIsSortReversed() const;
	const struct FLegacySpellPurchaseMenuNPCData GetNpcData() const;
	int32 GetPlayerMoney() const;
	const class FText GetPlayerName() const;
	ELegacySpellPurchaseMenuSortType GetSortType() const;
	const TArray<struct FLegacySpellPurchaseMenuItemProperties> GetSpellList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSpellPurchaseMenuViewModel">();
	}
	static class UVSpellPurchaseMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSpellPurchaseMenuViewModel>();
	}
};
static_assert(alignof(UVSpellPurchaseMenuViewModel) == 0x000008, "Wrong alignment on UVSpellPurchaseMenuViewModel");
static_assert(sizeof(UVSpellPurchaseMenuViewModel) == 0x000120, "Wrong size on UVSpellPurchaseMenuViewModel");
static_assert(offsetof(UVSpellPurchaseMenuViewModel, SpellList) == 0x0000D0, "Member 'UVSpellPurchaseMenuViewModel::SpellList' has a wrong offset!");
static_assert(offsetof(UVSpellPurchaseMenuViewModel, PlayerName) == 0x0000E0, "Member 'UVSpellPurchaseMenuViewModel::PlayerName' has a wrong offset!");
static_assert(offsetof(UVSpellPurchaseMenuViewModel, PlayerMoney) == 0x0000F8, "Member 'UVSpellPurchaseMenuViewModel::PlayerMoney' has a wrong offset!");
static_assert(offsetof(UVSpellPurchaseMenuViewModel, SortType) == 0x0000FC, "Member 'UVSpellPurchaseMenuViewModel::SortType' has a wrong offset!");
static_assert(offsetof(UVSpellPurchaseMenuViewModel, IsSortReversed) == 0x0000FD, "Member 'UVSpellPurchaseMenuViewModel::IsSortReversed' has a wrong offset!");
static_assert(offsetof(UVSpellPurchaseMenuViewModel, NpcData) == 0x000100, "Member 'UVSpellPurchaseMenuViewModel::NpcData' has a wrong offset!");

// Class Altar.VStaggerSwimCharacterAnimInstance
// 0x0020 (0x03D0 - 0x03B0)
class UVStaggerSwimCharacterAnimInstance : public UVStaggerCharacterAnimInstance
{
public:
	class UAnimMontage*                           LandStaggerMontage;                                // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           SwimStaggerMontage;                                // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVStaggerSwim                          AnimSet;                                           // 0x03C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VStaggerSwimCharacterAnimInstance">();
	}
	static class UVStaggerSwimCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVStaggerSwimCharacterAnimInstance>();
	}
};
static_assert(alignof(UVStaggerSwimCharacterAnimInstance) == 0x000010, "Wrong alignment on UVStaggerSwimCharacterAnimInstance");
static_assert(sizeof(UVStaggerSwimCharacterAnimInstance) == 0x0003D0, "Wrong size on UVStaggerSwimCharacterAnimInstance");
static_assert(offsetof(UVStaggerSwimCharacterAnimInstance, LandStaggerMontage) == 0x0003B0, "Member 'UVStaggerSwimCharacterAnimInstance::LandStaggerMontage' has a wrong offset!");
static_assert(offsetof(UVStaggerSwimCharacterAnimInstance, SwimStaggerMontage) == 0x0003B8, "Member 'UVStaggerSwimCharacterAnimInstance::SwimStaggerMontage' has a wrong offset!");
static_assert(offsetof(UVStaggerSwimCharacterAnimInstance, AnimSet) == 0x0003C0, "Member 'UVStaggerSwimCharacterAnimInstance::AnimSet' has a wrong offset!");

// Class Altar.VSteeringBehaviorsComponent
// 0x0000 (0x03F0 - 0x03F0)
class UVSteeringBehaviorsComponent final : public USteeringBehaviorsComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VSteeringBehaviorsComponent">();
	}
	static class UVSteeringBehaviorsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVSteeringBehaviorsComponent>();
	}
};
static_assert(alignof(UVSteeringBehaviorsComponent) == 0x000008, "Wrong alignment on UVSteeringBehaviorsComponent");
static_assert(sizeof(UVSteeringBehaviorsComponent) == 0x0003F0, "Wrong size on UVSteeringBehaviorsComponent");

// Class Altar.VThumbstickSensitivityModifier
// 0x0000 (0x0028 - 0x0028)
class UVThumbstickSensitivityModifier final : public UInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VThumbstickSensitivityModifier">();
	}
	static class UVThumbstickSensitivityModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVThumbstickSensitivityModifier>();
	}
};
static_assert(alignof(UVThumbstickSensitivityModifier) == 0x000008, "Wrong alignment on UVThumbstickSensitivityModifier");
static_assert(sizeof(UVThumbstickSensitivityModifier) == 0x000028, "Wrong size on UVThumbstickSensitivityModifier");

// Class Altar.VTrainingMenuViewModel
// 0x00F0 (0x01C0 - 0x00D0)
class UVTrainingMenuViewModel final : public UVViewModelBase
{
public:
	struct FModernSkillProgression                SkillProgression;                                  // 0x00D0(0x0028)(NativeAccessSpecifierPublic)
	struct FLegacyTrainMenuProperties             Properties;                                        // 0x00F8(0x00C8)(NativeAccessSpecifierPrivate)

public:
	void RegisterSendCloseButtonClicked();
	void RegisterSendTrainButtonClicked();
	void SetProperties(const struct FLegacyTrainMenuProperties& NewProperties);

	struct FLegacyTrainMenuProperties GetProperties() const;
	const struct FModernSkillProgression GetSkillProgression() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTrainingMenuViewModel">();
	}
	static class UVTrainingMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVTrainingMenuViewModel>();
	}
};
static_assert(alignof(UVTrainingMenuViewModel) == 0x000008, "Wrong alignment on UVTrainingMenuViewModel");
static_assert(sizeof(UVTrainingMenuViewModel) == 0x0001C0, "Wrong size on UVTrainingMenuViewModel");
static_assert(offsetof(UVTrainingMenuViewModel, SkillProgression) == 0x0000D0, "Member 'UVTrainingMenuViewModel::SkillProgression' has a wrong offset!");
static_assert(offsetof(UVTrainingMenuViewModel, Properties) == 0x0000F8, "Member 'UVTrainingMenuViewModel::Properties' has a wrong offset!");

// Class Altar.VTransformPairingComponent
// 0x0078 (0x0130 - 0x00B8)
class UVTransformPairingComponent final : public UVActorPairingComponent
{
public:
	bool                                          bSnapOwnerToLatestTransform;                       // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReversePairedSocketName;                           // 0x00BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x6C];                                      // 0x00C4(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTransform GetLatestPairedTransform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTransformPairingComponent">();
	}
	static class UVTransformPairingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVTransformPairingComponent>();
	}
};
static_assert(alignof(UVTransformPairingComponent) == 0x000008, "Wrong alignment on UVTransformPairingComponent");
static_assert(sizeof(UVTransformPairingComponent) == 0x000130, "Wrong size on UVTransformPairingComponent");
static_assert(offsetof(UVTransformPairingComponent, bSnapOwnerToLatestTransform) == 0x0000B8, "Member 'UVTransformPairingComponent::bSnapOwnerToLatestTransform' has a wrong offset!");
static_assert(offsetof(UVTransformPairingComponent, ReversePairedSocketName) == 0x0000BC, "Member 'UVTransformPairingComponent::ReversePairedSocketName' has a wrong offset!");

// Class Altar.VTurnInPlaceCharacterAnimInstance
// 0x0100 (0x04A0 - 0x03A0)
class UVTurnInPlaceCharacterAnimInstance : public UVLayerCharacterAnimInstance
{
public:
	class UCharacterMovementComponent*            CharacterMoveComp;                                 // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLayerActive;                                    // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x03A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AA[0xA];                                      // 0x03AA(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SneakingTag;                                       // 0x03B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           BowDrawTag;                                        // 0x03BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnPlayRate;                                      // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RootYawOffset;                                     // 0x03C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnAngle;                                         // 0x03CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVTurnInPlace                          TurnInPlaceSettings;                               // 0x03E0(0x0028)(BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVHumanoidLowerAndUpperBodySetup       TurnInPlaceBlendSettings;                          // 0x0408(0x0038)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   RootYawRotationCurve;                              // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UpperBodyBone;                                     // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTurnAngle;                                      // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSneaking;                                       // 0x0454(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTurning;                                        // 0x0455(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAiming;                                         // 0x0456(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartTurn;                                        // 0x0457(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReadyForNextTurn;                                 // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            AimBlendSpace;                                     // 0x0460(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               AimOffset;                                         // 0x0468(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanAimOffset;                                     // 0x0480(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_481[0x3];                                      // 0x0481(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawAimOffset;                                      // 0x0484(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchAimOffset;                                    // 0x0488(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48C[0x14];                                     // 0x048C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void IsOnHorse();
	void OnIdleStateEntry(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void OnStartTurnTransitionStateEntry(const struct FAnimUpdateContext& Context, const struct FAnimNodeReference& Node);
	void SafeUpdatePawnStates();
	void SafeUpdateTurnValues();
	void TriggerLastTurn();
	void TriggerStartTurn();
	void TriggerTurnInPlace(float InTurnAngle);
	void UpdateAimingOffset();
	void UpdateAnimStatus();
	void UpdateOffsets();
	bool UpdateTurnSystem();

	float GetActorOffset() const;
	float GetAnimRotationRatio() const;
	float GetAnimYawRotation() const;
	bool GetInterruptionState() const;
	float GetRootOffset() const;
	bool GetStopState() const;
	float GetTurningYawAimOffset() const;
	bool HasPawnHasTag(const struct FGameplayTag& Tag) const;
	bool IsTurnTooSmall(float Angle) const;
	bool NeedsTurnInPlace() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTurnInPlaceCharacterAnimInstance">();
	}
	static class UVTurnInPlaceCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVTurnInPlaceCharacterAnimInstance>();
	}
};
static_assert(alignof(UVTurnInPlaceCharacterAnimInstance) == 0x000010, "Wrong alignment on UVTurnInPlaceCharacterAnimInstance");
static_assert(sizeof(UVTurnInPlaceCharacterAnimInstance) == 0x0004A0, "Wrong size on UVTurnInPlaceCharacterAnimInstance");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, CharacterMoveComp) == 0x0003A0, "Member 'UVTurnInPlaceCharacterAnimInstance::CharacterMoveComp' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, bIsLayerActive) == 0x0003A8, "Member 'UVTurnInPlaceCharacterAnimInstance::bIsLayerActive' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, bEnabled) == 0x0003A9, "Member 'UVTurnInPlaceCharacterAnimInstance::bEnabled' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, SneakingTag) == 0x0003B4, "Member 'UVTurnInPlaceCharacterAnimInstance::SneakingTag' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, BowDrawTag) == 0x0003BC, "Member 'UVTurnInPlaceCharacterAnimInstance::BowDrawTag' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, TurnPlayRate) == 0x0003C4, "Member 'UVTurnInPlaceCharacterAnimInstance::TurnPlayRate' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, RootYawOffset) == 0x0003C8, "Member 'UVTurnInPlaceCharacterAnimInstance::RootYawOffset' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, TurnAngle) == 0x0003CC, "Member 'UVTurnInPlaceCharacterAnimInstance::TurnAngle' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, TurnInPlaceSettings) == 0x0003E0, "Member 'UVTurnInPlaceCharacterAnimInstance::TurnInPlaceSettings' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, TurnInPlaceBlendSettings) == 0x000408, "Member 'UVTurnInPlaceCharacterAnimInstance::TurnInPlaceBlendSettings' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, RootYawRotationCurve) == 0x000440, "Member 'UVTurnInPlaceCharacterAnimInstance::RootYawRotationCurve' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, UpperBodyBone) == 0x000448, "Member 'UVTurnInPlaceCharacterAnimInstance::UpperBodyBone' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, MinTurnAngle) == 0x000450, "Member 'UVTurnInPlaceCharacterAnimInstance::MinTurnAngle' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, bIsSneaking) == 0x000454, "Member 'UVTurnInPlaceCharacterAnimInstance::bIsSneaking' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, bIsTurning) == 0x000455, "Member 'UVTurnInPlaceCharacterAnimInstance::bIsTurning' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, bIsAiming) == 0x000456, "Member 'UVTurnInPlaceCharacterAnimInstance::bIsAiming' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, bStartTurn) == 0x000457, "Member 'UVTurnInPlaceCharacterAnimInstance::bStartTurn' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, bReadyForNextTurn) == 0x000458, "Member 'UVTurnInPlaceCharacterAnimInstance::bReadyForNextTurn' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, AimBlendSpace) == 0x000460, "Member 'UVTurnInPlaceCharacterAnimInstance::AimBlendSpace' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, AimOffset) == 0x000468, "Member 'UVTurnInPlaceCharacterAnimInstance::AimOffset' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, bCanAimOffset) == 0x000480, "Member 'UVTurnInPlaceCharacterAnimInstance::bCanAimOffset' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, YawAimOffset) == 0x000484, "Member 'UVTurnInPlaceCharacterAnimInstance::YawAimOffset' has a wrong offset!");
static_assert(offsetof(UVTurnInPlaceCharacterAnimInstance, PitchAimOffset) == 0x000488, "Member 'UVTurnInPlaceCharacterAnimInstance::PitchAimOffset' has a wrong offset!");

// Class Altar.VTutorialMenuViewModel
// 0x0070 (0x0140 - 0x00D0)
class alignas(0x10) UVTutorialMenuViewModel final : public UVViewModelBase
{
public:
	TMulticastInlineDelegate<void()>              OnClearTutorialDataDelegate;                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x60];                                      // 0x00E0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	struct FModernTutorialQueueProperties Dequeue();
	void Enqueue(const struct FModernTutorialQueueProperties& NewProperties);

	bool IsEmpty() const;
	bool ThisIsForPluginCompliance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VTutorialMenuViewModel">();
	}
	static class UVTutorialMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVTutorialMenuViewModel>();
	}
};
static_assert(alignof(UVTutorialMenuViewModel) == 0x000010, "Wrong alignment on UVTutorialMenuViewModel");
static_assert(sizeof(UVTutorialMenuViewModel) == 0x000140, "Wrong size on UVTutorialMenuViewModel");
static_assert(offsetof(UVTutorialMenuViewModel, OnClearTutorialDataDelegate) == 0x0000D0, "Member 'UVTutorialMenuViewModel::OnClearTutorialDataDelegate' has a wrong offset!");

// Class Altar.VUISaveSystem
// 0x0050 (0x0080 - 0x0030)
class UVUISaveSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VUISaveSystem">();
	}
	static class UVUISaveSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVUISaveSystem>();
	}
};
static_assert(alignof(UVUISaveSystem) == 0x000008, "Wrong alignment on UVUISaveSystem");
static_assert(sizeof(UVUISaveSystem) == 0x000080, "Wrong size on UVUISaveSystem");

// Class Altar.VUsablePropItem
// 0x0000 (0x0000 - 0x0000)
class IVUsablePropItem final
{
public:
	void OnAttachedToPawnAsProp(class AVPairedPawn* PawnUsingThisItem);

	class FName GetAttachSocketName(class AVPairedPawn* PawnUsingThisItem) const;
	struct FTransform GetOffsetWhenUsedAsProp(class AVPairedPawn* PawnUsingThisItem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VUsablePropItem">();
	}
	static class IVUsablePropItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVUsablePropItem>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IVUsablePropItem) == 0x000001, "Wrong alignment on IVUsablePropItem");
static_assert(sizeof(IVUsablePropItem) == 0x000001, "Wrong size on IVUsablePropItem");

// Class Altar.VVideoMenuViewModel
// 0x0000 (0x00D0 - 0x00D0)
class UVVideoMenuViewModel final : public UVViewModelBase
{
public:
	void RegisterSendClickedButton(ELegacyVideoMenuIDs InButtonIndex);

	bool ThisIsForPluginCompliance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VVideoMenuViewModel">();
	}
	static class UVVideoMenuViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVVideoMenuViewModel>();
	}
};
static_assert(alignof(UVVideoMenuViewModel) == 0x000008, "Wrong alignment on UVVideoMenuViewModel");
static_assert(sizeof(UVVideoMenuViewModel) == 0x0000D0, "Wrong size on UVVideoMenuViewModel");

// Class Altar.VViewModelBase_Deprecated
// 0x0020 (0x0048 - 0x0028)
class UVViewModelBase_Deprecated final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterDelegates();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VViewModelBase_Deprecated">();
	}
	static class UVViewModelBase_Deprecated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVViewModelBase_Deprecated>();
	}
};
static_assert(alignof(UVViewModelBase_Deprecated) == 0x000008, "Wrong alignment on UVViewModelBase_Deprecated");
static_assert(sizeof(UVViewModelBase_Deprecated) == 0x000048, "Wrong size on UVViewModelBase_Deprecated");

// Class Altar.VWeapon_Blunt
// 0x0000 (0x03A0 - 0x03A0)
class AVWeapon_Blunt : public AVWeapon_Melee
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWeapon_Blunt">();
	}
	static class AVWeapon_Blunt* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWeapon_Blunt>();
	}
};
static_assert(alignof(AVWeapon_Blunt) == 0x000008, "Wrong alignment on AVWeapon_Blunt");
static_assert(sizeof(AVWeapon_Blunt) == 0x0003A0, "Wrong size on AVWeapon_Blunt");

// Class Altar.VWeapon_BladeWithScabbard
// 0x0008 (0x03A8 - 0x03A0)
class AVWeapon_BladeWithScabbard : public AVWeapon_Blade
{
public:
	class UStaticMeshComponent*                   ScabbardMeshComponent;                             // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWeapon_BladeWithScabbard">();
	}
	static class AVWeapon_BladeWithScabbard* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWeapon_BladeWithScabbard>();
	}
};
static_assert(alignof(AVWeapon_BladeWithScabbard) == 0x000008, "Wrong alignment on AVWeapon_BladeWithScabbard");
static_assert(sizeof(AVWeapon_BladeWithScabbard) == 0x0003A8, "Wrong size on AVWeapon_BladeWithScabbard");
static_assert(offsetof(AVWeapon_BladeWithScabbard, ScabbardMeshComponent) == 0x0003A0, "Member 'AVWeapon_BladeWithScabbard::ScabbardMeshComponent' has a wrong offset!");

// Class Altar.VWeapon_Bow
// 0x0008 (0x0398 - 0x0390)
class AVWeapon_Bow : public AVWeapon
{
public:
	class USkeletalMeshComponent*                 MainSkeletalMeshComponent;                         // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnDraw();
	void OnShoot();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWeapon_Bow">();
	}
	static class AVWeapon_Bow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWeapon_Bow>();
	}
};
static_assert(alignof(AVWeapon_Bow) == 0x000008, "Wrong alignment on AVWeapon_Bow");
static_assert(sizeof(AVWeapon_Bow) == 0x000398, "Wrong size on AVWeapon_Bow");
static_assert(offsetof(AVWeapon_Bow, MainSkeletalMeshComponent) == 0x000390, "Member 'AVWeapon_Bow::MainSkeletalMeshComponent' has a wrong offset!");

// Class Altar.VShield
// 0x0008 (0x0398 - 0x0390)
class AVShield : public AVWeapon
{
public:
	class UStaticMeshComponent*                   MainStaticMeshComponent;                           // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VShield">();
	}
	static class AVShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVShield>();
	}
};
static_assert(alignof(AVShield) == 0x000008, "Wrong alignment on AVShield");
static_assert(sizeof(AVShield) == 0x000398, "Wrong size on AVShield");
static_assert(offsetof(AVShield, MainStaticMeshComponent) == 0x000390, "Member 'AVShield::MainStaticMeshComponent' has a wrong offset!");

// Class Altar.VQuiver
// 0x0028 (0x03B8 - 0x0390)
class AVQuiver : public AVWeapon
{
public:
	class UStaticMeshComponent*                   MainStaticMeshComponent;                           // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           ArrowMeshComponents;                               // 0x0398(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ArrowMesh;                                         // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArrowCount;                                        // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnArrowCountChange(int32 NewCount);

	int32 GetArrowCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VQuiver">();
	}
	static class AVQuiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVQuiver>();
	}
};
static_assert(alignof(AVQuiver) == 0x000008, "Wrong alignment on AVQuiver");
static_assert(sizeof(AVQuiver) == 0x0003B8, "Wrong size on AVQuiver");
static_assert(offsetof(AVQuiver, MainStaticMeshComponent) == 0x000390, "Member 'AVQuiver::MainStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVQuiver, ArrowMeshComponents) == 0x000398, "Member 'AVQuiver::ArrowMeshComponents' has a wrong offset!");
static_assert(offsetof(AVQuiver, ArrowMesh) == 0x0003A8, "Member 'AVQuiver::ArrowMesh' has a wrong offset!");
static_assert(offsetof(AVQuiver, ArrowCount) == 0x0003B0, "Member 'AVQuiver::ArrowCount' has a wrong offset!");

// Class Altar.VWeatherAudioPlayer
// 0x00F0 (0x0388 - 0x0298)
class AVWeatherAudioPlayer final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeatherSlice                          OblivionStormSlice;                                // 0x02A0(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FWeatherSlice                          RainCitySlice;                                     // 0x02B8(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FWeatherSlice                          RainFoliageSlice;                                  // 0x02D0(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FWeatherSlice                          RainOpenSlice;                                     // 0x02E8(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FWeatherSlice                          SnowSlice;                                         // 0x0300(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FWeatherSlice                          ThunderstormSlice;                                 // 0x0318(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FWeatherSlice                          WindFoliageSlice;                                  // 0x0330(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FWeatherSlice                          WindOpenSlice;                                     // 0x0348(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              WeatherTextureUpdatedEvent;                        // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x18];                                     // 0x0370(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOblivionStormIntensity(float Intensity);
	void SetRainIntensity(float Intensity);
	void SetSnowIntensity(float Intensity);
	void SetThunderstormIntensity(float Intensity);
	void SetWindIntensity(float Intensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWeatherAudioPlayer">();
	}
	static class AVWeatherAudioPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWeatherAudioPlayer>();
	}
};
static_assert(alignof(AVWeatherAudioPlayer) == 0x000008, "Wrong alignment on AVWeatherAudioPlayer");
static_assert(sizeof(AVWeatherAudioPlayer) == 0x000388, "Wrong size on AVWeatherAudioPlayer");
static_assert(offsetof(AVWeatherAudioPlayer, OblivionStormSlice) == 0x0002A0, "Member 'AVWeatherAudioPlayer::OblivionStormSlice' has a wrong offset!");
static_assert(offsetof(AVWeatherAudioPlayer, RainCitySlice) == 0x0002B8, "Member 'AVWeatherAudioPlayer::RainCitySlice' has a wrong offset!");
static_assert(offsetof(AVWeatherAudioPlayer, RainFoliageSlice) == 0x0002D0, "Member 'AVWeatherAudioPlayer::RainFoliageSlice' has a wrong offset!");
static_assert(offsetof(AVWeatherAudioPlayer, RainOpenSlice) == 0x0002E8, "Member 'AVWeatherAudioPlayer::RainOpenSlice' has a wrong offset!");
static_assert(offsetof(AVWeatherAudioPlayer, SnowSlice) == 0x000300, "Member 'AVWeatherAudioPlayer::SnowSlice' has a wrong offset!");
static_assert(offsetof(AVWeatherAudioPlayer, ThunderstormSlice) == 0x000318, "Member 'AVWeatherAudioPlayer::ThunderstormSlice' has a wrong offset!");
static_assert(offsetof(AVWeatherAudioPlayer, WindFoliageSlice) == 0x000330, "Member 'AVWeatherAudioPlayer::WindFoliageSlice' has a wrong offset!");
static_assert(offsetof(AVWeatherAudioPlayer, WindOpenSlice) == 0x000348, "Member 'AVWeatherAudioPlayer::WindOpenSlice' has a wrong offset!");
static_assert(offsetof(AVWeatherAudioPlayer, WeatherTextureUpdatedEvent) == 0x000360, "Member 'AVWeatherAudioPlayer::WeatherTextureUpdatedEvent' has a wrong offset!");

// Class Altar.VWeatherTextureBox
// 0x0008 (0x02A8 - 0x02A0)
class AVWeatherTextureBox final : public AVAudioTriggerBox
{
public:
	EVWeatherTexture                              WeatherTextureInside;                              // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWeatherTextureBox">();
	}
	static class AVWeatherTextureBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVWeatherTextureBox>();
	}
};
static_assert(alignof(AVWeatherTextureBox) == 0x000008, "Wrong alignment on AVWeatherTextureBox");
static_assert(sizeof(AVWeatherTextureBox) == 0x0002A8, "Wrong size on AVWeatherTextureBox");
static_assert(offsetof(AVWeatherTextureBox, WeatherTextureInside) == 0x0002A0, "Member 'AVWeatherTextureBox::WeatherTextureInside' has a wrong offset!");

// Class Altar.VWorldPartitionRuntimeCell
// 0x0008 (0x0098 - 0x0090)
class UVWorldPartitionRuntimeCell final : public UWorldPartitionRuntimeLevelStreamingCell
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWorldPartitionRuntimeCell">();
	}
	static class UVWorldPartitionRuntimeCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVWorldPartitionRuntimeCell>();
	}
};
static_assert(alignof(UVWorldPartitionRuntimeCell) == 0x000008, "Wrong alignment on UVWorldPartitionRuntimeCell");
static_assert(sizeof(UVWorldPartitionRuntimeCell) == 0x000098, "Wrong size on UVWorldPartitionRuntimeCell");

// Class Altar.VWorldPartitionStreamingPolicy
// 0x0000 (0x02F8 - 0x02F8)
class UVWorldPartitionStreamingPolicy final : public UWorldPartitionLevelStreamingPolicy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VWorldPartitionStreamingPolicy">();
	}
	static class UVWorldPartitionStreamingPolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVWorldPartitionStreamingPolicy>();
	}
};
static_assert(alignof(UVWorldPartitionStreamingPolicy) == 0x000008, "Wrong alignment on UVWorldPartitionStreamingPolicy");
static_assert(sizeof(UVWorldPartitionStreamingPolicy) == 0x0002F8, "Wrong size on UVWorldPartitionStreamingPolicy");

// Class Altar.VAltarStateConditionCheckGameplayTags
// 0x0020 (0x0058 - 0x0038)
class UVAltarStateConditionCheckGameplayTags : public UVAltarStateConditionBase
{
public:
	struct FGameplayTagContainer                  GameplayTagsToCheck;                               // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAltarStateConditionCheckGameplayTags">();
	}
	static class UVAltarStateConditionCheckGameplayTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAltarStateConditionCheckGameplayTags>();
	}
};
static_assert(alignof(UVAltarStateConditionCheckGameplayTags) == 0x000008, "Wrong alignment on UVAltarStateConditionCheckGameplayTags");
static_assert(sizeof(UVAltarStateConditionCheckGameplayTags) == 0x000058, "Wrong size on UVAltarStateConditionCheckGameplayTags");
static_assert(offsetof(UVAltarStateConditionCheckGameplayTags, GameplayTagsToCheck) == 0x000038, "Member 'UVAltarStateConditionCheckGameplayTags::GameplayTagsToCheck' has a wrong offset!");

}

