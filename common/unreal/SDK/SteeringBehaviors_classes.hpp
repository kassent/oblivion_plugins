#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SteeringBehaviors

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SteeringBehaviors_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"


namespace SDK
{

// Class SteeringBehaviors.MoveRequestDestinationSpatialIndexSubsystem
// 0x0258 (0x0288 - 0x0030)
class UMoveRequestDestinationSpatialIndexSubsystem final : public UWorldSubsystem
{
public:
	TMap<int32, struct FMoveRequestDestinationData> OctreeIdMoveRequestDestinations;                 // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x208];                                     // 0x0080(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FAIRequestID GetCurrentMoveRequestId(const class AAIController* AIController);

	void OnControllerEndPlay(const class AActor* Actor, const EEndPlayReason EndPlayReason);
	void RegisterMoveRequestDestination(const class AAIController* AIController, const struct FAIRequestID& MoveRequestId);

	void GetMoveRequestDestinationsInRadius(const struct FVector& SphereCenter, const double SphereRadius, TArray<struct FMoveRequestDestinationData>& MoveRequestDestinations) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveRequestDestinationSpatialIndexSubsystem">();
	}
	static class UMoveRequestDestinationSpatialIndexSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveRequestDestinationSpatialIndexSubsystem>();
	}
};
static_assert(alignof(UMoveRequestDestinationSpatialIndexSubsystem) == 0x000008, "Wrong alignment on UMoveRequestDestinationSpatialIndexSubsystem");
static_assert(sizeof(UMoveRequestDestinationSpatialIndexSubsystem) == 0x000288, "Wrong size on UMoveRequestDestinationSpatialIndexSubsystem");
static_assert(offsetof(UMoveRequestDestinationSpatialIndexSubsystem, OctreeIdMoveRequestDestinations) == 0x000030, "Member 'UMoveRequestDestinationSpatialIndexSubsystem::OctreeIdMoveRequestDestinations' has a wrong offset!");

// Class SteeringBehaviors.SteeringBehavior
// 0x0008 (0x0030 - 0x0028)
class USteeringBehavior : public UObject
{
public:
	struct FSteeringBehaviorContextConfiguration  ContextConfiguration;                              // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USteeringBehaviorsComponent* GetSteeringBehaviorsComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehavior">();
	}
	static class USteeringBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehavior>();
	}
};
static_assert(alignof(USteeringBehavior) == 0x000008, "Wrong alignment on USteeringBehavior");
static_assert(sizeof(USteeringBehavior) == 0x000030, "Wrong size on USteeringBehavior");
static_assert(offsetof(USteeringBehavior, ContextConfiguration) == 0x000028, "Member 'USteeringBehavior::ContextConfiguration' has a wrong offset!");
static_assert(offsetof(USteeringBehavior, bEnabled) == 0x00002C, "Member 'USteeringBehavior::bEnabled' has a wrong offset!");

// Class SteeringBehaviors.SteeringBehavior_NavMeshAvoidance
// 0x0040 (0x0070 - 0x0030)
class USteeringBehavior_NavMeshAvoidance final : public USteeringBehavior
{
public:
	double                                        DetectionCollisionTime;                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            DistanceToDangerCurve;                             // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARecastNavMesh*                         NavigationData;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehavior_NavMeshAvoidance">();
	}
	static class USteeringBehavior_NavMeshAvoidance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehavior_NavMeshAvoidance>();
	}
};
static_assert(alignof(USteeringBehavior_NavMeshAvoidance) == 0x000008, "Wrong alignment on USteeringBehavior_NavMeshAvoidance");
static_assert(sizeof(USteeringBehavior_NavMeshAvoidance) == 0x000070, "Wrong size on USteeringBehavior_NavMeshAvoidance");
static_assert(offsetof(USteeringBehavior_NavMeshAvoidance, DetectionCollisionTime) == 0x000030, "Member 'USteeringBehavior_NavMeshAvoidance::DetectionCollisionTime' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavMeshAvoidance, DistanceToDangerCurve) == 0x000038, "Member 'USteeringBehavior_NavMeshAvoidance::DistanceToDangerCurve' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavMeshAvoidance, CharacterMovementComponent) == 0x000040, "Member 'USteeringBehavior_NavMeshAvoidance::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavMeshAvoidance, NavigationData) == 0x000048, "Member 'USteeringBehavior_NavMeshAvoidance::NavigationData' has a wrong offset!");

// Class SteeringBehaviors.PawnSpatialIndexSubsystem
// 0x0248 (0x0288 - 0x0040)
class UPawnSpatialIndexSubsystem final : public UTickableWorldSubsystem
{
public:
	TArray<TSubclassOf<class APawn>>              IndexedPawnClasses;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<int32, class APawn*>                     OctreeIdPawns;                                     // 0x0050(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x1E8];                                     // 0x00A0(0x01E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPawn(const class APawn* Pawn);
	void OnActorEndPlay(const class AActor* Actor, const EEndPlayReason EndPlayReason);
	void OnActorSpawned(const class AActor* ActorSpawned);
	void RemovePawn(const class APawn* Pawn);
	void UpdatePawnLocation(const class APawn* Pawn);

	void BlueprintGetPawnsInRadius(const struct FVector& SphereCenter, const double SphereRadius, TArray<class APawn*>& OutPawns) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnSpatialIndexSubsystem">();
	}
	static class UPawnSpatialIndexSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnSpatialIndexSubsystem>();
	}
};
static_assert(alignof(UPawnSpatialIndexSubsystem) == 0x000008, "Wrong alignment on UPawnSpatialIndexSubsystem");
static_assert(sizeof(UPawnSpatialIndexSubsystem) == 0x000288, "Wrong size on UPawnSpatialIndexSubsystem");
static_assert(offsetof(UPawnSpatialIndexSubsystem, IndexedPawnClasses) == 0x000040, "Member 'UPawnSpatialIndexSubsystem::IndexedPawnClasses' has a wrong offset!");
static_assert(offsetof(UPawnSpatialIndexSubsystem, OctreeIdPawns) == 0x000050, "Member 'UPawnSpatialIndexSubsystem::OctreeIdPawns' has a wrong offset!");

// Class SteeringBehaviors.SteeringBehaviorsAIController
// 0x0010 (0x03D0 - 0x03C0)
class ASteeringBehaviorsAIController final : public AAIController
{
public:
	double                                        OffsetPathFromCornersDistance;                     // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USteeringBehaviorsComponent*            SteeringBehaviorsComponent;                        // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehaviorsAIController">();
	}
	static class ASteeringBehaviorsAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASteeringBehaviorsAIController>();
	}
};
static_assert(alignof(ASteeringBehaviorsAIController) == 0x000008, "Wrong alignment on ASteeringBehaviorsAIController");
static_assert(sizeof(ASteeringBehaviorsAIController) == 0x0003D0, "Wrong size on ASteeringBehaviorsAIController");
static_assert(offsetof(ASteeringBehaviorsAIController, OffsetPathFromCornersDistance) == 0x0003C0, "Member 'ASteeringBehaviorsAIController::OffsetPathFromCornersDistance' has a wrong offset!");
static_assert(offsetof(ASteeringBehaviorsAIController, SteeringBehaviorsComponent) == 0x0003C8, "Member 'ASteeringBehaviorsAIController::SteeringBehaviorsComponent' has a wrong offset!");

// Class SteeringBehaviors.SteeringBehaviorsBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class USteeringBehaviorsBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FVector> BuildParallelPath(const TArray<struct FVector>& Path, const double Offset2D, const double LayerHeight);
	static void DrawDebugPolyline(const class UObject* WorldContextObject, const TArray<struct FVector>& Polyline, const struct FLinearColor& PolylineColor, const float Duration, const float Thickness);
	static double GetParallelPathMaxOffset2D(const TArray<struct FVector>& Path, const bool bLeftSide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehaviorsBlueprintFunctionLibrary">();
	}
	static class USteeringBehaviorsBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehaviorsBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(USteeringBehaviorsBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on USteeringBehaviorsBlueprintFunctionLibrary");
static_assert(sizeof(USteeringBehaviorsBlueprintFunctionLibrary) == 0x000028, "Wrong size on USteeringBehaviorsBlueprintFunctionLibrary");

// Class SteeringBehaviors.SteeringBehaviorsComponent
// 0x0350 (0x03F0 - 0x00A0)
class USteeringBehaviorsComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USteeringBehavior*                      StaticObstacleAvoidanceBehavior;                   // 0x00A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USteeringBehavior*                      DynamicObstacleAvoidanceBehavior;                  // 0x00B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USteeringBehavior*>              DefaultSteeringBehaviors;                          // 0x00B8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         SteeringBehaviorSize;                              // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DangerScoreMultiplier;                             // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxSpeedNormalizedScoreMultiplier;                 // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        VelocityBiasMultiplier;                            // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        VelocityBiasMinSpeedNormalized;                    // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        VelocityBiasAngleTolerance;                        // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ETeamAttitude>                         TeamAttitudesToAvoid;                              // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	double                                        SteerInterpolationTime;                            // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        DeactivateSteeringInterpolationDistance;           // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        AvoidanceTemporaryIgnoredDuration;                 // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMultithreadedTick;                                // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplySteeringAutomatically;                       // 0x0121(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_122[0x6];                                      // 0x0122(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MoveFocusRotationInterpolationSpeed;               // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDynamicAvoidanceDeactivationFallback;          // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DynamicAvoidanceDeactivationFallbackTimeThreshold; // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        DynamicAvoidanceDeactivationFallbackDistanceThreshold; // 0x0140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        DynamicAvoidanceDeactivationFallbackLocationSampleRate; // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        DynamicAvoidanceDeactivationFallbackDuration;      // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSteeringBehaviorData>          SteeringBehaviors;                                 // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bSteeringBehaviorsRelevant;                        // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIController*                          AIController;                                      // 0x0170(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  Pawn;                                              // 0x0178(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPawnMovementComponent*                 MovementComponent;                                 // 0x0180(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           AvoidanceIgnoredActors;                            // 0x0188(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FAvoidanceTemporaryIgnoredActor> AvoidanceTemporaryIgnoredActors;                  // 0x01D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x208];                                    // 0x01E8(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSteeringBehavior(const class USteeringBehavior* SteeringBehavior);
	class USteeringBehavior* AddSteeringBehaviorByClass(const TSubclassOf<class USteeringBehavior> SteeringBehaviorClass);
	void OnAvoidanceIgnoredActorEndPlay(const class AActor* Actor, const EEndPlayReason EndPlayReason);
	void OnPossessedPawnChanged(const class APawn* OldPawn, const class APawn* NewPawn);
	void RemoveSteeringBehavior(const class USteeringBehavior* SteeringBehavior);
	bool RemoveSteeringBehaviorByClass(const TSubclassOf<class USteeringBehavior> SteeringBehaviorClass);
	void SetAvoidanceIgnoredActor(const class AActor* Actor, const bool bAvoidanceIgnored);
	void SetDynamicAvoidanceEnabled(const bool bEnabled);
	void SetStaticAvoidanceEnabled(const bool bEnabled);
	void SetSteeringBehaviorSize(const int32 NewSteeringBehaviorSize);

	class USteeringBehavior* FindSteeringBehaviorByClass(const TSubclassOf<class USteeringBehavior> SteeringBehaviorClass) const;
	struct FVector GetMoveFocus() const;
	struct FVector GetRequestedVelocity() const;
	bool IsActorIgnoredForAvoidance(const class AActor* Actor, const bool bAgentDeltaHeightIgnored, const bool bIncludeTemporaryIgnoredActors) const;
	bool IsDynamicAvoidanceEnabled() const;
	bool IsStaticAvoidanceEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehaviorsComponent">();
	}
	static class USteeringBehaviorsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehaviorsComponent>();
	}
};
static_assert(alignof(USteeringBehaviorsComponent) == 0x000008, "Wrong alignment on USteeringBehaviorsComponent");
static_assert(sizeof(USteeringBehaviorsComponent) == 0x0003F0, "Wrong size on USteeringBehaviorsComponent");
static_assert(offsetof(USteeringBehaviorsComponent, StaticObstacleAvoidanceBehavior) == 0x0000A8, "Member 'USteeringBehaviorsComponent::StaticObstacleAvoidanceBehavior' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, DynamicObstacleAvoidanceBehavior) == 0x0000B0, "Member 'USteeringBehaviorsComponent::DynamicObstacleAvoidanceBehavior' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, DefaultSteeringBehaviors) == 0x0000B8, "Member 'USteeringBehaviorsComponent::DefaultSteeringBehaviors' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, SteeringBehaviorSize) == 0x0000C8, "Member 'USteeringBehaviorsComponent::SteeringBehaviorSize' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, DangerScoreMultiplier) == 0x0000D0, "Member 'USteeringBehaviorsComponent::DangerScoreMultiplier' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, MaxSpeedNormalizedScoreMultiplier) == 0x0000D8, "Member 'USteeringBehaviorsComponent::MaxSpeedNormalizedScoreMultiplier' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, VelocityBiasMultiplier) == 0x0000E0, "Member 'USteeringBehaviorsComponent::VelocityBiasMultiplier' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, VelocityBiasMinSpeedNormalized) == 0x0000E8, "Member 'USteeringBehaviorsComponent::VelocityBiasMinSpeedNormalized' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, VelocityBiasAngleTolerance) == 0x0000F0, "Member 'USteeringBehaviorsComponent::VelocityBiasAngleTolerance' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, TeamAttitudesToAvoid) == 0x0000F8, "Member 'USteeringBehaviorsComponent::TeamAttitudesToAvoid' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, SteerInterpolationTime) == 0x000108, "Member 'USteeringBehaviorsComponent::SteerInterpolationTime' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, DeactivateSteeringInterpolationDistance) == 0x000110, "Member 'USteeringBehaviorsComponent::DeactivateSteeringInterpolationDistance' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, AvoidanceTemporaryIgnoredDuration) == 0x000118, "Member 'USteeringBehaviorsComponent::AvoidanceTemporaryIgnoredDuration' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, bMultithreadedTick) == 0x000120, "Member 'USteeringBehaviorsComponent::bMultithreadedTick' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, bApplySteeringAutomatically) == 0x000121, "Member 'USteeringBehaviorsComponent::bApplySteeringAutomatically' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, MoveFocusRotationInterpolationSpeed) == 0x000128, "Member 'USteeringBehaviorsComponent::MoveFocusRotationInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, bUseDynamicAvoidanceDeactivationFallback) == 0x000130, "Member 'USteeringBehaviorsComponent::bUseDynamicAvoidanceDeactivationFallback' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, DynamicAvoidanceDeactivationFallbackTimeThreshold) == 0x000138, "Member 'USteeringBehaviorsComponent::DynamicAvoidanceDeactivationFallbackTimeThreshold' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, DynamicAvoidanceDeactivationFallbackDistanceThreshold) == 0x000140, "Member 'USteeringBehaviorsComponent::DynamicAvoidanceDeactivationFallbackDistanceThreshold' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, DynamicAvoidanceDeactivationFallbackLocationSampleRate) == 0x000148, "Member 'USteeringBehaviorsComponent::DynamicAvoidanceDeactivationFallbackLocationSampleRate' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, DynamicAvoidanceDeactivationFallbackDuration) == 0x000150, "Member 'USteeringBehaviorsComponent::DynamicAvoidanceDeactivationFallbackDuration' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, SteeringBehaviors) == 0x000158, "Member 'USteeringBehaviorsComponent::SteeringBehaviors' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, bSteeringBehaviorsRelevant) == 0x000168, "Member 'USteeringBehaviorsComponent::bSteeringBehaviorsRelevant' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, AIController) == 0x000170, "Member 'USteeringBehaviorsComponent::AIController' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, Pawn) == 0x000178, "Member 'USteeringBehaviorsComponent::Pawn' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, MovementComponent) == 0x000180, "Member 'USteeringBehaviorsComponent::MovementComponent' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, AvoidanceIgnoredActors) == 0x000188, "Member 'USteeringBehaviorsComponent::AvoidanceIgnoredActors' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsComponent, AvoidanceTemporaryIgnoredActors) == 0x0001D8, "Member 'USteeringBehaviorsComponent::AvoidanceTemporaryIgnoredActors' has a wrong offset!");

// Class SteeringBehaviors.SteeringBehaviorsComponentDeactivationTrigger
// 0x0000 (0x02A0 - 0x02A0)
class ASteeringBehaviorsComponentDeactivationTrigger final : public ATriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehaviorsComponentDeactivationTrigger">();
	}
	static class ASteeringBehaviorsComponentDeactivationTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASteeringBehaviorsComponentDeactivationTrigger>();
	}
};
static_assert(alignof(ASteeringBehaviorsComponentDeactivationTrigger) == 0x000008, "Wrong alignment on ASteeringBehaviorsComponentDeactivationTrigger");
static_assert(sizeof(ASteeringBehaviorsComponentDeactivationTrigger) == 0x0002A0, "Wrong size on ASteeringBehaviorsComponentDeactivationTrigger");

// Class SteeringBehaviors.SteeringBehaviorsPathFollowingComponent
// 0x0018 (0x02E0 - 0x02C8)
class USteeringBehaviorsPathFollowingComponent : public UPathFollowingComponent
{
public:
	bool                                          bCanRepathAutomatically;                           // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RepathRaycastCooldownTime;                         // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USteeringBehaviorsComponent*            SteeringBehaviorsComponent;                        // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehaviorsPathFollowingComponent">();
	}
	static class USteeringBehaviorsPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehaviorsPathFollowingComponent>();
	}
};
static_assert(alignof(USteeringBehaviorsPathFollowingComponent) == 0x000008, "Wrong alignment on USteeringBehaviorsPathFollowingComponent");
static_assert(sizeof(USteeringBehaviorsPathFollowingComponent) == 0x0002E0, "Wrong size on USteeringBehaviorsPathFollowingComponent");
static_assert(offsetof(USteeringBehaviorsPathFollowingComponent, bCanRepathAutomatically) == 0x0002C8, "Member 'USteeringBehaviorsPathFollowingComponent::bCanRepathAutomatically' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsPathFollowingComponent, RepathRaycastCooldownTime) == 0x0002CC, "Member 'USteeringBehaviorsPathFollowingComponent::RepathRaycastCooldownTime' has a wrong offset!");
static_assert(offsetof(USteeringBehaviorsPathFollowingComponent, SteeringBehaviorsComponent) == 0x0002D0, "Member 'USteeringBehaviorsPathFollowingComponent::SteeringBehaviorsComponent' has a wrong offset!");

// Class SteeringBehaviors.SteeringBehavior_Direction
// 0x0020 (0x0050 - 0x0030)
class USteeringBehavior_Direction final : public USteeringBehavior
{
public:
	double                                        MaxInterest;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        MinInterest;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDirection(const struct FVector& NewDirection);

	struct FVector GetDirection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehavior_Direction">();
	}
	static class USteeringBehavior_Direction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehavior_Direction>();
	}
};
static_assert(alignof(USteeringBehavior_Direction) == 0x000008, "Wrong alignment on USteeringBehavior_Direction");
static_assert(sizeof(USteeringBehavior_Direction) == 0x000050, "Wrong size on USteeringBehavior_Direction");
static_assert(offsetof(USteeringBehavior_Direction, MaxInterest) == 0x000030, "Member 'USteeringBehavior_Direction::MaxInterest' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_Direction, MinInterest) == 0x000038, "Member 'USteeringBehavior_Direction::MinInterest' has a wrong offset!");

// Class SteeringBehaviors.SteeringBehavior_DropOffLedge
// 0x0138 (0x0168 - 0x0030)
class USteeringBehavior_DropOffLedge : public USteeringBehavior
{
public:
	double                                        MinLedgeHeight;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxLedgeHeight;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxLedgeHeightIncrement;                           // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxLedgeLength;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxPathSegmentDistance;                            // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxLedgeCrossingSpeed;                             // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxLedgeCrossingDuration;                          // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<TSoftClassPtr<class UClass>>             IgnoreMaxLedgeHeightNavAreas;                      // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   LedgeObstacleDetectionCollisionProfile;            // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARecastNavMesh*                         NavigationData;                                    // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0xA0];                                      // 0x00C8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehavior_DropOffLedge">();
	}
	static class USteeringBehavior_DropOffLedge* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehavior_DropOffLedge>();
	}
};
static_assert(alignof(USteeringBehavior_DropOffLedge) == 0x000008, "Wrong alignment on USteeringBehavior_DropOffLedge");
static_assert(sizeof(USteeringBehavior_DropOffLedge) == 0x000168, "Wrong size on USteeringBehavior_DropOffLedge");
static_assert(offsetof(USteeringBehavior_DropOffLedge, MinLedgeHeight) == 0x000030, "Member 'USteeringBehavior_DropOffLedge::MinLedgeHeight' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_DropOffLedge, MaxLedgeHeight) == 0x000038, "Member 'USteeringBehavior_DropOffLedge::MaxLedgeHeight' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_DropOffLedge, MaxLedgeHeightIncrement) == 0x000040, "Member 'USteeringBehavior_DropOffLedge::MaxLedgeHeightIncrement' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_DropOffLedge, MaxLedgeLength) == 0x000048, "Member 'USteeringBehavior_DropOffLedge::MaxLedgeLength' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_DropOffLedge, MaxPathSegmentDistance) == 0x000050, "Member 'USteeringBehavior_DropOffLedge::MaxPathSegmentDistance' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_DropOffLedge, MaxLedgeCrossingSpeed) == 0x000058, "Member 'USteeringBehavior_DropOffLedge::MaxLedgeCrossingSpeed' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_DropOffLedge, MaxLedgeCrossingDuration) == 0x000060, "Member 'USteeringBehavior_DropOffLedge::MaxLedgeCrossingDuration' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_DropOffLedge, IgnoreMaxLedgeHeightNavAreas) == 0x000068, "Member 'USteeringBehavior_DropOffLedge::IgnoreMaxLedgeHeightNavAreas' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_DropOffLedge, LedgeObstacleDetectionCollisionProfile) == 0x0000B8, "Member 'USteeringBehavior_DropOffLedge::LedgeObstacleDetectionCollisionProfile' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_DropOffLedge, NavigationData) == 0x0000C0, "Member 'USteeringBehavior_DropOffLedge::NavigationData' has a wrong offset!");

// Class SteeringBehaviors.SteeringBehavior_MoveRequestDestinationAvoidance
// 0x00D0 (0x0100 - 0x0030)
class USteeringBehavior_MoveRequestDestinationAvoidance final : public USteeringBehavior
{
public:
	double                                        QueryRadius;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        SpacingDistance;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MinInterest;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxInterest;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMoveRequestDestinationSpatialIndexSubsystem* MoveRequestDestinationSpatialIndexSubsystem; // 0x0050(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class APawn*>                            IgnoredPawns;                                      // 0x0068(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIgnoredActorEndPlay(const class AActor* Actor, const EEndPlayReason EndPlayReason);
	void SetPawnIgnored(const class APawn* Pawn, const bool bIgnored);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehavior_MoveRequestDestinationAvoidance">();
	}
	static class USteeringBehavior_MoveRequestDestinationAvoidance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehavior_MoveRequestDestinationAvoidance>();
	}
};
static_assert(alignof(USteeringBehavior_MoveRequestDestinationAvoidance) == 0x000008, "Wrong alignment on USteeringBehavior_MoveRequestDestinationAvoidance");
static_assert(sizeof(USteeringBehavior_MoveRequestDestinationAvoidance) == 0x000100, "Wrong size on USteeringBehavior_MoveRequestDestinationAvoidance");
static_assert(offsetof(USteeringBehavior_MoveRequestDestinationAvoidance, QueryRadius) == 0x000030, "Member 'USteeringBehavior_MoveRequestDestinationAvoidance::QueryRadius' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_MoveRequestDestinationAvoidance, SpacingDistance) == 0x000038, "Member 'USteeringBehavior_MoveRequestDestinationAvoidance::SpacingDistance' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_MoveRequestDestinationAvoidance, MinInterest) == 0x000040, "Member 'USteeringBehavior_MoveRequestDestinationAvoidance::MinInterest' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_MoveRequestDestinationAvoidance, MaxInterest) == 0x000048, "Member 'USteeringBehavior_MoveRequestDestinationAvoidance::MaxInterest' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_MoveRequestDestinationAvoidance, MoveRequestDestinationSpatialIndexSubsystem) == 0x000050, "Member 'USteeringBehavior_MoveRequestDestinationAvoidance::MoveRequestDestinationSpatialIndexSubsystem' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_MoveRequestDestinationAvoidance, IgnoredPawns) == 0x000068, "Member 'USteeringBehavior_MoveRequestDestinationAvoidance::IgnoredPawns' has a wrong offset!");

// Class SteeringBehaviors.SteeringBehavior_NavAgentAvoidance
// 0x0080 (0x00B0 - 0x0030)
class USteeringBehavior_NavAgentAvoidance final : public USteeringBehavior
{
public:
	double                                        DetectionDistance;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            DistanceToDangerCurve;                             // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            DistanceToDangerGreaterAvoidanceWeightCurve;       // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        IgnorePawnDotProductThreshold;                     // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        SpacingDistance;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        MinSpeedNormalized;                                // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        MinCollisionTime;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBrake;                                         // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         RepulsionDistanceInterval;                         // 0x006C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatInterval                         RepulsionInterestInterval;                         // 0x0074(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPawnSpatialIndexSubsystem*             PawnSpatialIndexSubsystem;                         // 0x0080(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x0088(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class APawn*>                          PawnsDetected;                                     // 0x0090(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehavior_NavAgentAvoidance">();
	}
	static class USteeringBehavior_NavAgentAvoidance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehavior_NavAgentAvoidance>();
	}
};
static_assert(alignof(USteeringBehavior_NavAgentAvoidance) == 0x000008, "Wrong alignment on USteeringBehavior_NavAgentAvoidance");
static_assert(sizeof(USteeringBehavior_NavAgentAvoidance) == 0x0000B0, "Wrong size on USteeringBehavior_NavAgentAvoidance");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, DetectionDistance) == 0x000030, "Member 'USteeringBehavior_NavAgentAvoidance::DetectionDistance' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, DistanceToDangerCurve) == 0x000038, "Member 'USteeringBehavior_NavAgentAvoidance::DistanceToDangerCurve' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, DistanceToDangerGreaterAvoidanceWeightCurve) == 0x000040, "Member 'USteeringBehavior_NavAgentAvoidance::DistanceToDangerGreaterAvoidanceWeightCurve' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, IgnorePawnDotProductThreshold) == 0x000048, "Member 'USteeringBehavior_NavAgentAvoidance::IgnorePawnDotProductThreshold' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, SpacingDistance) == 0x000050, "Member 'USteeringBehavior_NavAgentAvoidance::SpacingDistance' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, MinSpeedNormalized) == 0x000058, "Member 'USteeringBehavior_NavAgentAvoidance::MinSpeedNormalized' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, MinCollisionTime) == 0x000060, "Member 'USteeringBehavior_NavAgentAvoidance::MinCollisionTime' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, bCanBrake) == 0x000068, "Member 'USteeringBehavior_NavAgentAvoidance::bCanBrake' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, RepulsionDistanceInterval) == 0x00006C, "Member 'USteeringBehavior_NavAgentAvoidance::RepulsionDistanceInterval' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, RepulsionInterestInterval) == 0x000074, "Member 'USteeringBehavior_NavAgentAvoidance::RepulsionInterestInterval' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, PawnSpatialIndexSubsystem) == 0x000080, "Member 'USteeringBehavior_NavAgentAvoidance::PawnSpatialIndexSubsystem' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, CharacterMovementComponent) == 0x000088, "Member 'USteeringBehavior_NavAgentAvoidance::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_NavAgentAvoidance, PawnsDetected) == 0x000090, "Member 'USteeringBehavior_NavAgentAvoidance::PawnsDetected' has a wrong offset!");

// Class SteeringBehaviors.SteeringBehavior_PathFollowingComponent
// 0x0198 (0x01C8 - 0x0030)
class USteeringBehavior_PathFollowingComponent final : public USteeringBehavior
{
public:
	double                                        MinInterest;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        DefaultLookAheadDistance;                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxLookAheadLocationCount;                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        LookAheadMaxTrajectoryAngle;                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        FurthestLookAheadLocationInterest;                 // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopAtDestination;                                // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalculateTurnRate;                                // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        AvoidanceDetectionDistance;                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        AvoidanceTimeDifferentVelocities;                  // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        AvoidanceTimeSimilarVelocities;                    // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAvoidanceIgnoreBlockingPawns;                     // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanGiveWay;                                       // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        GiveWayDuration;                                   // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        GiveWayPathLength2D;                               // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        StopGiveWayPathLength2D;                           // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        BacktrackPathLength2D;                             // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSkipPathSegmentAreaConfiguration> SkipPathSegmentAreaConfigurations;              // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCharacterMovementComponent*            CharacterMovementComponent;                        // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UPathFollowingComponent> PathFollowingComponent;                            // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPawnSpatialIndexSubsystem*             PawnSpatialIndexSubsystem;                         // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class APawn*>                          PawnsDetected;                                     // 0x00C8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FPawnAvoidanceBox>              PawnAvoidanceBoxes;                                // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class APawn*, struct FPawnAvoidancePersistence> PawnsAvoidancePersistence;                  // 0x00E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x90];                                     // 0x0138(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringBehavior_PathFollowingComponent">();
	}
	static class USteeringBehavior_PathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringBehavior_PathFollowingComponent>();
	}
};
static_assert(alignof(USteeringBehavior_PathFollowingComponent) == 0x000008, "Wrong alignment on USteeringBehavior_PathFollowingComponent");
static_assert(sizeof(USteeringBehavior_PathFollowingComponent) == 0x0001C8, "Wrong size on USteeringBehavior_PathFollowingComponent");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, MinInterest) == 0x000030, "Member 'USteeringBehavior_PathFollowingComponent::MinInterest' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, DefaultLookAheadDistance) == 0x000038, "Member 'USteeringBehavior_PathFollowingComponent::DefaultLookAheadDistance' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, MaxLookAheadLocationCount) == 0x000040, "Member 'USteeringBehavior_PathFollowingComponent::MaxLookAheadLocationCount' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, LookAheadMaxTrajectoryAngle) == 0x000048, "Member 'USteeringBehavior_PathFollowingComponent::LookAheadMaxTrajectoryAngle' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, FurthestLookAheadLocationInterest) == 0x000050, "Member 'USteeringBehavior_PathFollowingComponent::FurthestLookAheadLocationInterest' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, bStopAtDestination) == 0x000058, "Member 'USteeringBehavior_PathFollowingComponent::bStopAtDestination' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, bCalculateTurnRate) == 0x000059, "Member 'USteeringBehavior_PathFollowingComponent::bCalculateTurnRate' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, AvoidanceDetectionDistance) == 0x000060, "Member 'USteeringBehavior_PathFollowingComponent::AvoidanceDetectionDistance' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, AvoidanceTimeDifferentVelocities) == 0x000068, "Member 'USteeringBehavior_PathFollowingComponent::AvoidanceTimeDifferentVelocities' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, AvoidanceTimeSimilarVelocities) == 0x000070, "Member 'USteeringBehavior_PathFollowingComponent::AvoidanceTimeSimilarVelocities' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, bAvoidanceIgnoreBlockingPawns) == 0x000078, "Member 'USteeringBehavior_PathFollowingComponent::bAvoidanceIgnoreBlockingPawns' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, bCanGiveWay) == 0x000079, "Member 'USteeringBehavior_PathFollowingComponent::bCanGiveWay' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, GiveWayDuration) == 0x000080, "Member 'USteeringBehavior_PathFollowingComponent::GiveWayDuration' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, GiveWayPathLength2D) == 0x000088, "Member 'USteeringBehavior_PathFollowingComponent::GiveWayPathLength2D' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, StopGiveWayPathLength2D) == 0x000090, "Member 'USteeringBehavior_PathFollowingComponent::StopGiveWayPathLength2D' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, BacktrackPathLength2D) == 0x000098, "Member 'USteeringBehavior_PathFollowingComponent::BacktrackPathLength2D' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, SkipPathSegmentAreaConfigurations) == 0x0000A0, "Member 'USteeringBehavior_PathFollowingComponent::SkipPathSegmentAreaConfigurations' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, CharacterMovementComponent) == 0x0000B0, "Member 'USteeringBehavior_PathFollowingComponent::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, PathFollowingComponent) == 0x0000B8, "Member 'USteeringBehavior_PathFollowingComponent::PathFollowingComponent' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, PawnSpatialIndexSubsystem) == 0x0000C0, "Member 'USteeringBehavior_PathFollowingComponent::PawnSpatialIndexSubsystem' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, PawnsDetected) == 0x0000C8, "Member 'USteeringBehavior_PathFollowingComponent::PawnsDetected' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, PawnAvoidanceBoxes) == 0x0000D8, "Member 'USteeringBehavior_PathFollowingComponent::PawnAvoidanceBoxes' has a wrong offset!");
static_assert(offsetof(USteeringBehavior_PathFollowingComponent, PawnsAvoidancePersistence) == 0x0000E8, "Member 'USteeringBehavior_PathFollowingComponent::PawnsAvoidancePersistence' has a wrong offset!");

}

